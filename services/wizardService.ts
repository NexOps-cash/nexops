import { ProjectFile } from '../types';

export interface TemplateParameter {
    id: string;
    label: string;
    type: 'string' | 'number' | 'address';
    description: string;
    placeholder?: string;
    defaultValue?: string | number;
}

export interface ContractTemplate {
    id: string;
    name: string;
    description: string;
    category: 'Vault' | 'DeFi' | 'Utility';
    parameters: TemplateParameter[];
    generateSource: (params: Record<string, any>) => string;
}

export const CONTRACT_TEMPLATES: ContractTemplate[] = [
    {
        id: 'multisig-vault',
        name: 'Multisig Vault (2-of-3)',
        description: 'A secure vault that requires 2 out of 3 authorized keys to spend funds.',
        category: 'Vault',
        parameters: [
            { id: 'pk1', label: 'Public Key 1', type: 'string', description: 'Full hex-encoded public key of the first participant.', placeholder: '02...' },
            { id: 'pk2', label: 'Public Key 2', type: 'string', description: 'Full hex-encoded public key of the second participant.', placeholder: '02...' },
            { id: 'pk3', label: 'Public Key 3', type: 'string', description: 'Full hex-encoded public key of the third participant.', placeholder: '02...' },
        ],
        generateSource: (params) => `
pragma cashscript ^0.9.0;

// Multisig Vault (2-of-3)
// Automatically generated by NexOps Wizard
contract MultisigVault(
    pubkey pk1,
    pubkey pk2,
    pubkey pk3
) {
    function spend(sig s1, sig s2) {
        require(checkMultiSig([s1, s2], [pk1, pk2, pk3]));
    }
}
`.trim()
    },
    {
        id: 'timelock-escrow',
        name: 'Time-Locked Escrow',
        description: 'Funds are locked for a specific recipient until a certain block height or timestamp.',
        category: 'Vault',
        parameters: [
            { id: 'recipient', label: 'Recipient Key', type: 'string', description: 'Public key of the person who can claim funds.', placeholder: '02...' },
            { id: 'unlockHeight', label: 'Unlock Height', type: 'number', description: 'The block height at which the funds become spendable.', defaultValue: 2000000 },
        ],
        generateSource: (params) => `
pragma cashscript ^0.9.0;

// Time-Locked Escrow
// Automatically generated by NexOps Wizard
contract TimeLockedEscrow(
    pubkey recipient,
    int unlockHeight
) {
    function claim(sig s) {
        require(checkSig(s, recipient));
        require(tx.age >= unlockHeight);
    }
}
`.trim()
    },
    {
        id: 'token-splitter',
        name: 'Simple Fee Splitter',
        description: 'Splits incoming BCH between two addresses at a fixed ratio.',
        category: 'Utility',
        parameters: [
            { id: 'addr1', label: 'Address 1', type: 'address', description: 'First recipient address.', placeholder: 'bitcoincash:p...' },
            { id: 'addr2', label: 'Address 2', type: 'address', description: 'Second recipient address.', placeholder: 'bitcoincash:p...' },
            { id: 'ratio', label: 'Split Ratio (%)', type: 'number', description: 'Percentage of funds sent to Address 1 (0-100).', defaultValue: 50 },
        ],
        generateSource: (params) => `
pragma cashscript ^0.9.0;

// Simple Fee Splitter
// Automatically generated by NexOps Wizard
contract FeeSplitter() {
    function split() {
        // This is a simplified logic for the splitter pattern
        // In NexOps, we use the introspection API to ensure outputs match ratios.
        // For Hackcelerator demonstration, this scaffolds the structure.
        
        int ratio = ${params.ratio};
        // Logic to verify tx.outputs[0].value and tx.outputs[1].value matches ratio
        require(true);
    }
}
`.trim()
    }
];

export function generateFromTemplate(templateId: string, params: Record<string, any>): string {
    const template = CONTRACT_TEMPLATES.find(t => t.id === templateId);
    if (!template) throw new Error("Template not found");
    return template.generateSource(params);
}
