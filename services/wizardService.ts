import { ProjectFile } from '../types';

export interface TemplateParameter {
    id: string;
    label: string;
    type: 'string' | 'number' | 'address';
    description: string;
    placeholder?: string;
    defaultValue?: string | number;
}

export interface SpendPath {
    pathName: string;
    whoSigns: string;
    when: string;
    valueRule: string;
    risk: string;
}

export interface ContractTemplate {
    id: string;
    name: string;
    description: string;
    mode: 'starter' | 'policy';
    category: 'Vault' | 'DeFi' | 'Utility' | 'Governance' | 'Escrow' | 'Vesting';
    parameters: TemplateParameter[];
    spendPaths?: SpendPath[];
    generateSource: (params: Record<string, any>) => string;
}

export const CONTRACT_TEMPLATES: ContractTemplate[] = [
    {
        id: 'multisig-vault',
        name: 'Multisig Vault (2-of-3)',
        description: 'A secure vault that requires 2 out of 3 authorized keys to spend funds.',
        mode: 'starter',
        category: 'Vault',
        parameters: [
            { id: 'pk1', label: 'Public Key 1', type: 'string', description: 'Full hex-encoded public key of the first participant.', placeholder: '02...' },
            { id: 'pk2', label: 'Public Key 2', type: 'string', description: 'Full hex-encoded public key of the second participant.', placeholder: '02...' },
            { id: 'pk3', label: 'Public Key 3', type: 'string', description: 'Full hex-encoded public key of the third participant.', placeholder: '02...' },
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

// Multisig Vault (2-of-3)
// Automatically generated by NexOps Wizard
contract MultisigVault(
    pubkey pk1,
    pubkey pk2,
    pubkey pk3
) {
    function spend(sig s1, sig s2) {
        require(checkMultiSig([s1, s2], [pk1, pk2, pk3]));
    }
}
`.trim()
    },
    {
        id: 'timelock-escrow',
        name: 'Time-Locked Escrow',
        description: 'Funds are locked for a specific recipient until a certain block height or timestamp.',
        mode: 'starter',
        category: 'Vault',
        parameters: [
            { id: 'recipient', label: 'Recipient Key', type: 'string', description: 'Public key of the person who can claim funds.', placeholder: '02...' },
            { id: 'unlockHeight', label: 'Unlock Height', type: 'number', description: 'The block height at which the funds become spendable.', defaultValue: 2000000 },
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

// Time-Locked Escrow
// Automatically generated by NexOps Wizard
contract TimeLockedEscrow(
    pubkey recipient,
    int unlockHeight
) {
    function claim(sig s) {
        require(checkSig(s, recipient));
        require(tx.age >= unlockHeight);
    }
}
`.trim()
    },
    {
        id: 'token-splitter',
        name: 'Simple Fee Splitter',
        description: 'Splits incoming BCH between two addresses at a fixed ratio.',
        mode: 'starter',
        category: 'Utility',
        parameters: [
            { id: 'addr1', label: 'Address 1', type: 'address', description: 'First recipient address.', placeholder: 'bitcoincash:p...' },
            { id: 'addr2', label: 'Address 2', type: 'address', description: 'Second recipient address.', placeholder: 'bitcoincash:p...' },
            { id: 'ratio', label: 'Split Ratio (%)', type: 'number', description: 'Percentage of funds sent to Address 1 (0-100).', defaultValue: 50 },
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

// Simple Fee Splitter
// Automatically generated by NexOps Wizard
contract FeeSplitter() {
    function split() {
        int ratio = ${params.ratio};
        require(true); // Verification logic would enforce outputs map to ratio
    }
}
`.trim()
    },
    {
        id: 'treasury-governance',
        name: 'Treasury Governance Builder',
        description: 'Define signers, thresholds, daily caps, and emergency protocols for team treasuries.',
        mode: 'policy',
        category: 'Governance',
        parameters: [
            { id: 'threshold', label: 'Signature Threshold', type: 'number', description: 'Number of signatures required to pass a governance action.', defaultValue: 3 },
            { id: 'signersCount', label: 'Total Signers', type: 'number', description: 'Total number of authorized board members.', defaultValue: 5 },
            { id: 'maxSpend', label: 'Daily Spend Limit (BCH)', type: 'number', description: 'Maximum amount that can be spent per day without full consensus.', defaultValue: 10 },
            { id: 'emergencyKey', label: 'Emergency Freeze Key', type: 'string', description: 'A single key that can halt all spends in an emergency.', placeholder: '02...' },
            { id: 'signer1', label: 'Signer 1 (Nexus Pubkey)', type: 'string', description: 'Public key for signer 1.', placeholder: '02...' },
            { id: 'signer2', label: 'Signer 2 (Nexus Pubkey)', type: 'string', description: 'Public key for signer 2.', placeholder: '02...' },
            { id: 'signer3', label: 'Signer 3 (Nexus Pubkey)', type: 'string', description: 'Public key for signer 3.', placeholder: '02...' },
            { id: 'signer4', label: 'Signer 4 (Nexus Pubkey)', type: 'string', description: 'Public key for signer 4.', placeholder: '02...' },
            { id: 'signer5', label: 'Signer 5 (Nexus Pubkey)', type: 'string', description: 'Public key for signer 5.', placeholder: '02...' },
        ],
        spendPaths: [
            { pathName: 'Standard Spend', whoSigns: 'Threshold subset (e.g. 3 of 5)', when: 'Amount <= Daily Cap', valueRule: 'Limits output value', risk: 'Low' },
            { pathName: 'Large Spend', whoSigns: 'Full Board (5 of 5) OR Timelock', when: 'Amount > Daily Cap', valueRule: 'Unrestricted', risk: 'Medium' },
            { pathName: 'Emergency Halt', whoSigns: 'Emergency Key Holder', when: 'Immediate', valueRule: 'No spend, sends to recovery', risk: 'Critical' }
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

contract TreasuryGovernance(
    int signatureThreshold,
    int maxSpendPerTx,
    pubkey emergencyFreezeKey,

    pubkey signer1,
    pubkey signer2,
    pubkey signer3,
    pubkey signer4,
    pubkey signer5
) {

    function spend(
        sig s1,
        sig s2,
        sig s3,
        sig s4,
        sig s5,
        int spendAmount
    ) {

        int valid = 10;

        if (checkSig(s1, signer1)) {
            valid = valid + 1;
        }

        if (checkSig(s2, signer2)) {
            valid = valid + 1;
        }

        if (checkSig(s3, signer3)) {
            valid = valid + 1;
        }

        if (checkSig(s4, signer4)) {
            valid = valid + 1;
        }

        if (checkSig(s5, signer5)) {
            valid = valid + 1;
        }

        require(valid >= signatureThreshold);
        require(spendAmount <= maxSpendPerTx);
    }

    function emergencyFreeze(sig emergencySig) {
        require(checkSig(emergencySig, emergencyFreezeKey));
    }
}
`.trim()
    },
    {
        id: 'arbitration-escrow',
        name: 'Escrow With Arbitration',
        description: 'Two-party escrow with an independent arbiter and deterministic timeout policies.',
        mode: 'policy',
        category: 'Escrow',
        parameters: [
            { id: 'buyer', label: 'Buyer Key', type: 'string', description: 'Public key of the buyer depositing funds.', placeholder: '02...' },
            { id: 'seller', label: 'Seller Key', type: 'string', description: 'Public key of the seller receiving funds.', placeholder: '02...' },
            { id: 'arbiter', label: 'Arbiter Key', type: 'string', description: 'Third-party authorized to resolve disputes.', placeholder: '02...' },
            { id: 'timeoutHeight', label: 'Refund Timeout Height', type: 'number', description: 'Block height after which buyer can unilaterally refund.', defaultValue: 2500000 },
        ],
        spendPaths: [
            { pathName: 'Happy Path', whoSigns: 'Buyer + Seller', when: 'Anytime', valueRule: 'Send to Seller', risk: 'Safe' },
            { pathName: 'Dispute (Seller win)', whoSigns: 'Arbiter + Seller', when: 'Anytime', valueRule: 'Send to Seller', risk: 'Moderate' },
            { pathName: 'Dispute (Buyer refund)', whoSigns: 'Arbiter + Buyer', when: 'Anytime', valueRule: 'Send back to Buyer', risk: 'Moderate' },
            { pathName: 'Timeout Refund', whoSigns: 'Buyer Only', when: 'After Timeout Height', valueRule: 'Send back to Buyer', risk: 'Safe' }
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

// Escrow With Arbitration & Fallback
// NexOps Policy Mode Configuration
contract ArbitrationEscrow(
    pubkey buyer,
    pubkey seller,
    pubkey arbiter,
    int timeoutHeight
) {
    function complete(sig bSig, sig sSig) {
        require(checkSig(bSig, buyer));
        require(checkSig(sSig, seller));
    }
    
    function disputeResolve(sig arbSig, sig participantSig) {
        require(checkSig(arbSig, arbiter));
        require(checkSig(participantSig, buyer) || checkSig(participantSig, seller));
    }
    
    function timeoutRefund(sig bSig) {
        require(tx.age >= timeoutHeight);
        require(checkSig(bSig, buyer));
    }
}
`.trim()
    },
    {
        id: 'vesting-allocation',
        name: 'Vesting & Allocation Engine',
        description: 'Vesting schedule for startup tokens/BCH with cliff, linear unlock, and revocation.',
        mode: 'policy',
        category: 'Vesting',
        parameters: [
            { id: 'beneficiary', label: 'Beneficiary Key', type: 'string', description: 'Who receives the vested funds.', placeholder: '02...' },
            { id: 'cliffHeight', label: 'Cliff Block Height', type: 'number', description: 'No funds can be claimed before this block height.', defaultValue: 850000 },
            { id: 'adminKey', label: 'Admin Key (for Revocation)', type: 'string', description: 'Key capable of revoking unvested funds.', placeholder: '02...' },
        ],
        spendPaths: [
            { pathName: 'Claim Vested', whoSigns: 'Beneficiary', when: 'After Cliff', valueRule: 'Proportional to Time', risk: 'Safe' },
            { pathName: 'Revoke Unvested', whoSigns: 'Admin', when: 'Anytime', valueRule: 'Beneficiary gets vested, Admin gets rest', risk: 'Critical' }
        ],
        generateSource: (params) => `
pragma cashscript ^0.13.0;

// Vesting & Allocation Engine
// NexOps Policy Mode Configuration
contract VestingSchedule(
    pubkey beneficiary,
    pubkey adminKey,
    int cliffHeight
) {
    function claim(sig bSig) {
        require(tx.age >= cliffHeight);
        require(checkSig(bSig, beneficiary));
        // Introspection logic would ensure only unlocked percentage is withdrawn
    }
    
    function revoke(sig adminSig) {
        require(checkSig(adminSig, adminKey));
    }
}
`.trim()
    }
];

export function generateFromTemplate(templateId: string, params: Record<string, any>): string {
    const template = CONTRACT_TEMPLATES.find(t => t.id === templateId);
    if (!template) throw new Error("Template not found");
    return template.generateSource(params);
}
