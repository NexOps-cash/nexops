[
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-0",
    "content": "# CashScript Core Reference\n\n**Single authoritative reference for CashScript development on Bitcoin Cash.**\n\n---\n\n## 1. UTXO Mental Model (READ THIS FIRST)\n\n### This is NOT Ethereum\n\nBitcoin Cash uses an Unspent Transaction Output (UTXO) model. A CashScript contract doesn't \"do\" anything - it only **validates** whether a proposed transaction meets its rules.\n\n| Aspect | UTXO (CashScript/BCH) | Account (EVM/Solidity) |\n|--------|----------------------|------------------------|\n| **State** | No global state, independent atomic UTXOs | Global state tree, persistent storage |\n| **Execution** | Transaction-level validation, stateless scripts | Contract-level execution, stateful |\n| **Concurrency** | Parallel spending of different UTXOs | Sequential (nonce-based) |\n| **Persistence** | UTXO chains, NFT commitments (40 bytes, 128 in May 2026) | Storage slots, mappings, state variables |\n| **Transaction** | Multiple inputs → Multiple outputs | Single sender → Single recipient |\n| **Gas/Fees** | Fee based on tx size (bytes) | Computational steps (opcode-based) |\n| **Introspection** | Full tx visibility (`tx.inputs[]`, `tx.outputs[]`) | Limited (`msg.sender`, `msg.value`) |\n| **Reentrancy** | N/A (atomic transactions) | Vulnerable (requires guards) |\n| **Tokens** | Native CashTokens (FT/NFT) | ERC-20/721 contract standards |\n| **Inter-Contract** | Via multi-input transactions | `call`, `delegatecall`, `staticcall` |\n| **Signatures** | Explicit `checkSig(sig, pk)` | Implicit `msg.sender` recovery |",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "introspection",
      "bytes",
      "CashScript Core Reference",
      "1. UTXO Mental Model (READ THIS FIRST)",
      "This is NOT Ethereum"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-1",
    "content": "### The Core Question\n\nFor every contract, ask: **\"What transformation of UTXOs does this contract permit?\"**\n\nNot \"what does this contract do\" but \"what does this contract ALLOW to happen to itself?\"\n\n### State Lives in UTXOs\n\n```\nUTXO → consumed & recreated → state carried in new UTXO\n```\n- **Mutable NFT commitment** = where state lives (40 bytes, 128 in May 2026)\n- **Contract recreation** = how state persists\n- **NFT capability** = authority identifier\n\n### Mental Model: UTXO State Continuity\n\n```\nEVM: storage.balance += amount (in-place state update)\n\nCashScript:\n1. Consume UTXO with current balance (input)\n2. Validate input has expected balance state: require(tx.inputs[0].nftCommitment == oldState)\n3. Create new UTXO with updated balance (output)\n4. Enforce balance conservation: sum(inputs) == sum(outputs) + fee\n5. Set new state: require(tx.outputs[0].nftCommitment == newState)\n```\n\n---\n\n## 2. Type System",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "The Core Question",
      "State Lives in UTXOs",
      "Mental Model: UTXO State Continuity",
      "2. Type System"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-2",
    "content": "## 2. Type System\n\n| Type | Size | Operations | Methods | Conversions |\n|------|------|-----------|---------|-------------|\n| `bool` | 1 bit | `! && \\|\\| == !=` | - | - |\n| `int` | Variable | `+ - * / % < <= > >= == !=` | - | `bytes(int)` `bytesN(int)` |\n| `string` | Variable | `+ == !=` | `.length` `.reverse()` `.split(i)` `.slice(s,e)` | `bytes(string)` |\n| `bytes` | Variable | `+ == != & \\| ^` | `.length` `.reverse()` `.split(i)` `.slice(s,e)` | - |\n| `bytesN` | N bytes (1-64) | Same as bytes | Same as bytes | `bytesN(any)` |\n| `pubkey` | 33 bytes | `== !=` | - | Auto to bytes |\n| `sig` | ~65 bytes | `== !=` | - | Auto to bytes |\n| `datasig` | ~64 bytes | `== !=` | - | Auto to bytes |\n\n**Common bytesN**: `bytes1` (byte), `bytes4` (prefix), `bytes20` (hash160), `bytes32` (sha256), `bytes64` (signature)\n\n### Script Number Encoding\n\nBCH Script uses sign-magnitude encoding: the MSB of the last byte indicates sign, values are little-endian, and minimal encoding is required (no unnecessary leading zeros).\n\n**Maximum positive values by byte size:**\n- `bytes1`: 127 (2^7 - 1)\n- `bytes2`: 32,767 (2^15 - 1)\n- `bytes4`: 2,147,483,647 (2^31 - 1)\n- `bytes8`: 9,223,372,036,854,775,807 (2^63 - 1)\n\n**Why MSB matters**: The sign bit occupies the MSB of the final byte. If you use the full byte range, values with a set MSB are interpreted as negative.\n\n**Post-May 2025**: BigInt support enables arbitrary precision up to 10,000 bytes (matching stack element limit). The encoding rules remain the same.",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "bytes",
      "int",
      "string",
      "bool",
      "2. Type System",
      "Script Number Encoding"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-3",
    "content": "### Type Casting Limit\n\nOnly `bytes1` through `bytes8` can be cast to `int`. Larger bounded bytes types cause a compile error:\n\n```cashscript\n// OK\nbytes8 amount = bytes8(commitment.slice(0, 8));\nrequire(int(amount) > 0);\n\n// COMPILE ERROR\nbytes16 liquidity = bytes16(commitment.slice(0, 16));\nrequire(int(liquidity) > 0);  // ❌ \"Type 'bytes16' is not castable to type 'int'\"\n```\n\n### Operators\n\n| Category | Operators | Valid Types | Notes |\n|----------|-----------|-------------|-------|\n| Arithmetic | `+ - * / %` | `int` | Integer only, div/0 fails |\n| Comparison | `< <= > >= == !=` | `int` `bool` `bytes` `string` | - |\n| Logical | `! && \\|\\|` | `bool` | **NO short-circuit** (all operands evaluated) |\n| Bitwise | `& \\| ^` | `bytes` only | NOT supported on int. No shift or invert |\n| Concatenation | `+` | `string` `bytes` | - |\n| Unary | `+ - !` | `int` `bool` | - |\n\n### Units\n\n| BCH Units | Value | Time Units | Value |\n|-----------|-------|------------|-------|\n| `sats` | 1 | `seconds` | 1 |\n| `finney` | 100,000 | `minutes` | 60 |\n| `bits` | 100 | `hours` | 3,600 |\n| `bitcoin` | 100,000,000 | `days` | 86,400 |\n| - | - | `weeks` | 604,800 |\n\n---\n\n## 3. Global Variables & Introspection",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "introspection",
      "bytes",
      "int",
      "string",
      "bool",
      "Type Casting Limit",
      "Operators",
      "Units",
      "3. Global Variables & Introspection"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-4",
    "content": "## 3. Global Variables & Introspection\n\n### Transaction Properties\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `tx.time` | `int` | Absolute time lock (nLocktime). <500M=block height, ≥500M=Unix timestamp |\n| `tx.version` | `int` | Transaction version |\n| `tx.locktime` | `int` | Transaction locktime value |\n| `tx.inputs` | `Input[]` | Transaction inputs array |\n| `tx.outputs` | `Output[]` | Transaction outputs array |\n\n### Input Properties\n\n```cashscript\ntx.inputs[i].value                    // int: BCH amount in satoshis\ntx.inputs[i].lockingBytecode          // bytes: Input scriptPubKey\ntx.inputs[i].unlockingBytecode        // bytes: Input scriptSig\ntx.inputs[i].outpointTransactionHash  // bytes32: UTXO source tx hash\ntx.inputs[i].outpointIndex            // int: UTXO source output index\ntx.inputs[i].sequenceNumber           // int: nSequence value\ntx.inputs[i].tokenCategory            // bytes: 32-byte ID + optional capability\ntx.inputs[i].nftCommitment            // bytes: NFT data (40 bytes, 128 in May 2026)\ntx.inputs[i].tokenAmount              // int: Fungible token amount\n```\n\n### Output Properties\n\n```cashscript\ntx.outputs[i].value            // int: BCH amount in satoshis\ntx.outputs[i].lockingBytecode  // bytes: Output script bytecode\ntx.outputs[i].tokenCategory    // bytes: 32-byte ID + optional capability\ntx.outputs[i].nftCommitment    // bytes: NFT data (40 bytes, 128 in May 2026)\ntx.outputs[i].tokenAmount      // int: Fungible token amount\n```",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "transaction",
      "introspection",
      "bytes",
      "int",
      "3. Global Variables & Introspection",
      "Transaction Properties",
      "Input Properties",
      "Output Properties"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-5",
    "content": "**Note**: Outputs do NOT have `outpointTransactionHash`, `outpointIndex`, `unlockingBytecode`, `sequenceNumber`.\n\n### Contract Context\n\n```cashscript\nthis.activeInputIndex   // int: Current input being evaluated\nthis.activeBytecode     // bytes: Current input's locking bytecode\nthis.age                // int: Relative UTXO age in blocks (SDK limitation)\n```\n\n### Locking Bytecode Constructors\n\n```cashscript\nnew LockingBytecodeP2PKH(bytes20 pkHash)       // Pay to public key hash\nnew LockingBytecodeP2SH20(bytes20 scriptHash)  // Pay to script hash (20-byte, legacy)\nnew LockingBytecodeP2SH32(bytes32 scriptHash)  // Pay to script hash (32-byte, default)\nnew LockingBytecodeNullData(bytes[] chunks)    // OP_RETURN data output\n```\n\n---\n\n## 4. Built-in Functions",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "int",
      "Contract Context",
      "Locking Bytecode Constructors",
      "4. Built-in Functions"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-6",
    "content": "## 4. Built-in Functions\n\n| Function | Signature | Returns | Notes |\n|----------|-----------|---------|-------|\n| `abs` | `(int)` | `int` | Absolute value |\n| `min` | `(int, int)` | `int` | Minimum of two |\n| `max` | `(int, int)` | `int` | Maximum of two |\n| `within` | `(int x, int lower, int upper)` | `bool` | `x >= lower && x < upper` (upper exclusive) |\n| `sha256` | `(any)` | `bytes32` | SHA-256 hash |\n| `sha1` | `(any)` | `bytes20` | SHA-1 hash |\n| `ripemd160` | `(any)` | `bytes20` | RIPEMD-160 hash |\n| `hash160` | `(any)` | `bytes20` | SHA-256 then RIPEMD-160 |\n| `hash256` | `(any)` | `bytes32` | Double SHA-256 |\n| `checkSig` | `(sig, pubkey)` | `bool` | Transaction signature. NULLFAIL: invalid=fail, `0x`=false |\n| `checkMultiSig` | `([sig, ...], [pubkey, ...])` | `bool` | Multi-sig. NOT in TypeScript SDK |\n| `checkDataSig` | `(datasig, bytes, pubkey)` | `bool` | Data signature. NULLFAIL applies |\n| `bytes` | `(any)` | `bytes` | Type conversion |\n| `bytesN` | `(any)` | `bytesN` | Fixed-length conversion (pads/truncates) |\n\n---\n\n## 5. CashTokens Essentials",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "function",
      "transaction",
      "bytes",
      "int",
      "bool",
      "4. Built-in Functions",
      "5. CashTokens Essentials"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-7",
    "content": "## 5. CashTokens Essentials\n\n### Token Category (Identity)\n\nEvery CashToken belongs to a **token category** identified by a 32-byte category ID.\n\n```cashscript\nbytes32 tokenCategory = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n```\n\n### Token Types\n\n**Fungible Tokens (FT)**: Divisible tokens with amounts, represented by `tokenAmount` property.\n\n**Non-Fungible Tokens (NFT)**: Unique tokens with capabilities and commitments.\n\n### NFT Capabilities (The 33rd Byte)\n\n`tokenCategory` is 33 bytes: 32-byte categoryId + 1-byte capability flag.\n\n| Capability | Byte | Description |\n|------------|------|-------------|\n| Immutable | `0x` (absent) | Cannot modify NFT commitment when spent |\n| Mutable | `0x01` | Can modify commitment, downgrade to immutable |\n| Minting | `0x02` | Can create unlimited NFTs, downgrade to mutable/immutable |\n\n### Token Category Arithmetic\n\n```cashscript\nbytes32 systemTokenId = 0x1234...;\n\n// Validate minting NFT\nrequire(tx.inputs[0].tokenCategory == systemTokenId + 0x02);\n\n// Validate mutable NFT\nrequire(tx.inputs[1].tokenCategory == systemTokenId + 0x01);\n\n// Validate immutable NFT (no suffix)\nrequire(tx.inputs[2].tokenCategory == systemTokenId);\n\n// Extract category and capability\nbytes category, bytes capability = tx.inputs[0].tokenCategory.split(32);\nrequire(capability == 0x02); // Must be minting\n```\n\n### Token Properties Check\n\n```cashscript\n// Check if output has tokens\nbool hasTokens = tx.outputs[0].tokenCategory != 0x;\n\n// Prevent tokens on output (pure BCH)\nrequire(tx.outputs[N].tokenCategory == 0x);\n```",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "bool",
      "5. CashTokens Essentials",
      "Token Category (Identity)",
      "Token Types",
      "NFT Capabilities (The 33rd Byte)",
      "Token Category Arithmetic",
      "Token Properties Check"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-8",
    "content": "### Token Constraints\n\n- One NFT per output maximum\n- All tokens in output must share same category\n- Fungible token amount: 1 to 9,223,372,036,854,775,807 (64-bit)\n- NFT commitment: max 40 bytes (128 in May 2026)\n- Category byte order: unreversed (OP_HASH256 format)\n\n---\n\n## 6. SDK Quick Start",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "bytes",
      "Token Constraints",
      "6. SDK Quick Start"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-9",
    "content": "## 6. SDK Quick Start\n\n### Installation\n\n```bash\nnpm install cashscript\nnpm install -g cashc  # Compiler (optional)\n```\n\n### Contract Instantiation\n\n```javascript\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\nimport { compileFile } from 'cashc';\n\n// Compile contract\nconst artifact = compileFile('contract.cash');\n\n// Create provider\nconst provider = new ElectrumNetworkProvider('mainnet');  // or 'chipnet'\n\n// Create contract instance\nconst ownerPubkey = Buffer.from('03...', 'hex');\nconst contract = new Contract(artifact, [ownerPubkey], { provider });\n\nconsole.log('Address:', contract.address);\nconsole.log('Balance:', await contract.getBalance());\n```\n\n### Transaction Building\n\n```javascript\nimport { SignatureTemplate } from 'cashscript';\n\nconst sigTemplate = new SignatureTemplate(privateKey);\n\n// Simple spend\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to('bitcoincash:qr...', 1000n)\n    .send();\n\n// With CashTokens\nconst txDetails = await contract.functions\n    .transfer(sigTemplate)\n    .to({\n        to: 'bitcoincash:qr...',\n        amount: 1000n,\n        token: {\n            category: '1234...abcdef',\n            amount: 100n  // Fungible tokens\n        }\n    })\n    .send();\n\n// With NFT\nconst txDetails = await contract.functions\n    .mintNFT(sigTemplate)\n    .to({\n        to: 'bitcoincash:qr...',\n        amount: 1000n,\n        token: {\n            category: '1234...abcdef',\n            nft: {\n                capability: 'mutable',  // 'none', 'mutable', 'minting'\n                commitment: Buffer.from('data-here')\n            }\n        }\n    })\n    .send();\n```",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "6. SDK Quick Start",
      "Installation",
      "Contract Instantiation",
      "Transaction Building"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-10",
    "content": "### Address Types\n\n```javascript\nconst options = {\n    provider: provider,\n    addressType: 'p2sh32'  // default, more secure\n    // or 'p2sh20' (legacy) or 'p2s' (direct script, more efficient)\n};\n```\n\n---\n\n## 7. Byte Extraction: split() vs slice()",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "Address Types",
      "7. Byte Extraction: split() vs slice()"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-11",
    "content": "## 7. Byte Extraction: split() vs slice()\n\n| Method | Signature | Returns | Use Case |\n|--------|-----------|---------|----------|\n| `split(index)` | `.split(i)` | `(bytes, bytes)` tuple | Head/tail separation |\n| `slice(start, end)` | `.slice(s, e)` | `bytes` | Extract from middle |\n\n### When to Use Which\n\n**split()** - Best for extracting from START or END, or sequential destructuring:\n```cashscript\n// First 20 bytes\nbytes20 ownerPkh = bytes20(commitment.split(20)[0]);\n\n// Last 4 bytes (of 40-byte commitment)\nbytes4 suffix = bytes4(commitment.split(36)[1]);\n\n// Sequential destructuring\nbytes20 owner, bytes rest = commitment.split(20);\nbytes8 balance, bytes rest2 = rest.split(8);\n```\n\n**slice()** - Best for extracting from the MIDDLE:\n```cashscript\n// Bytes 64-71 from commitment\nbytes8 reserveBytes = bytes8(commitment.slice(64, 72));\nint reserve = int(reserveBytes);\n```\n\n### Common Extraction Patterns\n\n```\nCommitment: [field0(20) | field1(8) | field2(32) | field3(4)] = 64 bytes\n\nField 0 (offset 0, size 20):   bytes20(commitment.split(20)[0])\nField 1 (offset 20, size 8):   bytes8(commitment.slice(20, 28))\nField 2 (offset 28, size 32):  bytes32(commitment.slice(28, 60))\nField 3 (offset 60, size 4):   bytes4(commitment.split(60)[1])\n```\n\n---\n\n## 8. NFT Commitment Data Storage",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "int",
      "7. Byte Extraction: split() vs slice()",
      "When to Use Which",
      "Common Extraction Patterns",
      "8. NFT Commitment Data Storage"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-12",
    "content": "## 8. NFT Commitment Data Storage\n\n### Production Pattern: Structured Commitment\n\n```cashscript\n// Layout: userPkh(20) + reserved(18) + lockBlocks(2) = 40 bytes total\n\n// WRITE: Pack into commitment\nrequire(tx.outputs[0].nftCommitment == userPkh + bytes18(0) + bytes2(lockBlocks));\n\n// READ: Unpack from commitment\nbytes20 storedPkh = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\nbytes2 stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\nint blocks = int(stakeBlocks);\n```\n\n### Partial Commitment Updates\n\n```cashscript\n// Update only last N bytes\nbytes restCommitment = tx.inputs[0].nftCommitment.split(31)[0];\nint newPledgeID = int(pledgeID) + 1;\nrequire(tx.outputs[0].nftCommitment == restCommitment + bytes4(newPledgeID) + campaignID);\n\n// Update only first N bytes\nbytes existingTail = tx.inputs[0].nftCommitment.split(2)[1];\nrequire(tx.outputs[0].nftCommitment == bytes2(newFee) + existingTail);\n```\n\n### Common Layouts (40 bytes)\n\n```\n[pubkeyhash(20) + fee(2) + adminPkh(18)]                    // Admin contract\n[pubkeyhash(20) + reserved(18) + blocks(2)]                 // Time-locked\n[pledgeAmt(6) + padding(21) + endBlock(4) + id(4) + campaignID(5)]  // Receipt NFT\n```\n\n---\n\n## 9. Common Patterns",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "int",
      "8. NFT Commitment Data Storage",
      "Production Pattern: Structured Commitment",
      "Partial Commitment Updates",
      "Common Layouts (40 bytes)",
      "9. Common Patterns"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-13",
    "content": "## 9. Common Patterns\n\n### Self-Replicating Covenant\n\n```cashscript\nfunction process() {\n    // Limit outputs (CRITICAL - prevent minting attacks)\n    require(tx.outputs.length <= 5);\n\n    // Self-replicate: all 5 properties\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n    require(tx.outputs[0].nftCommitment == newCommitment);  // State can change\n}\n```\n\n### UTXO-Based Authorization (No Signature)\n\n```cashscript\nfunction userAction(bytes20 userPkh) {\n    // User proves ownership by spending their UTXO\n    require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(userPkh));\n}\n```\n\n### Time-Locked Release\n\n```cashscript\nfunction unlock() {\n    require(tx.time >= lockTime);      // Absolute: ALWAYS use >=\n    require(this.age >= requiredAge);  // Relative: blocks only\n}\n```\n\n### Input Position Validation\n\n```cashscript\nfunction myOperation() {\n    // ALWAYS validate your own position\n    require(this.activeInputIndex == 2);\n\n    // Validate other contracts at expected positions\n    require(tx.inputs[0].tokenCategory == oracleCategory + 0x01);\n    require(tx.inputs[1].tokenCategory == mainCategory + 0x01);\n}\n```\n\n### Fee Accounting\n\n```cashscript\n// Minimum dust amounts\nrequire(tx.outputs[0].value == 1000);  // Safe dust for token UTXO\n\n// Explicit fee subtraction\nrequire(tx.outputs[0].value == tx.inputs[0].value - 3000);  // fee + dust\n\n// Fee collection into contract\nbytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\nrequire(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\n```",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int",
      "9. Common Patterns",
      "Self-Replicating Covenant",
      "UTXO-Based Authorization (No Signature)",
      "Time-Locked Release",
      "Input Position Validation",
      "Fee Accounting"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-14",
    "content": "---\n\n## 10. Solidity → CashScript Mapping\n\n| Solidity | CashScript | Notes |\n|----------|-----------|-------|\n| `constructor(address _owner)` | `contract MyContract(pubkey owner)` | Immutable per UTXO |\n| `uint256 balance;` | NFT commitment | State in 40-byte commitment |\n| `mapping(address => uint)` | N/A | No O(1) lookups |\n| `require(condition, \"msg\")` | `require(condition);` | No error messages |\n| `msg.sender` | `checkSig(sig, pubkey)` | Explicit signature verification |\n| `msg.value` | `tx.inputs[this.activeInputIndex].value` | Sum inputs, validate outputs |\n| `transfer(recipient, amount)` | `require(tx.outputs[0].value >= amount)` | Covenant-based |\n| `emit Event(data)` | N/A | Transaction IS the event |\n| `for(uint i=0; i<n; i++)` | `do { i=i+1; } while(i<n)` | Beta in v0.13.0 |\n| `x++`, `x += 1` | `x = x + 1;` | No compound assignment |\n| `import` | N/A | Single file contracts |\n| `interface/library` | N/A | No code reuse mechanisms |\n| `enum` | `int PENDING = 0;` | Use int constants |\n| `struct` | bytes + `.split()` | Pack into bytes |\n\n---\n\n## 11. Critical Gotchas",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "bytes",
      "int",
      "10. Solidity → CashScript Mapping",
      "11. Critical Gotchas"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-15",
    "content": "## 11. Critical Gotchas\n\n### No Short-Circuit Evaluation\n```cashscript\n// ❌ DANGEROUS - both sides always evaluated\narray.length > 0 && array[0] == value\n\n// ✅ SAFE - separate statements\nrequire(array.length > 0);\nrequire(array[0] == value);\n```\n\n### Time Comparison\n```cashscript\n// ❌ WRONG\nrequire(tx.time > lockTime);\n\n// ✅ CORRECT - ALWAYS use >=\nrequire(tx.time >= lockTime);\n```\n\n### No Compound Assignment\n```cashscript\n// ❌ NOT SUPPORTED\nx++; x += 1; x -= 1;\n\n// ✅ CORRECT\nx = x + 1;\n```\n\n### Bitwise on bytes Only\n```cashscript\n// ❌ COMPILE ERROR - bitwise on int\nint flags = 0x05;\nrequire((flags & 0x01) == 0x01);\n\n// ✅ CORRECT - use bytes\nbytes1 flags = 0x05;\nrequire((flags & 0x01) == 0x01);\n```\n\n### Array Bounds\n```cashscript\n// ❌ DANGEROUS - no automatic bounds checking\ntx.outputs[5].value\n\n// ✅ SAFE - always validate first\nrequire(tx.outputs.length > 5);\nrequire(tx.outputs[5].value >= amount);\n```\n\n---\n\n## 12. VM Limits (Current)",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "int",
      "11. Critical Gotchas",
      "No Short-Circuit Evaluation",
      "Time Comparison",
      "No Compound Assignment",
      "Bitwise on bytes Only",
      "Array Bounds",
      "12. VM Limits (Current)"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-16",
    "content": "## 12. VM Limits (Current)\n\n**May 2025 Active:**\n- Stack element limit: 10,000 bytes (was 520 bytes)\n- 201-opcode limit: REMOVED, replaced by operation cost system\n- Operation cost budget: (41 + unlocking_bytecode_length) × 800\n- BigInt support: enabled for large number arithmetic\n\n**May 2026 Upgrade:**\n- NFT commitment: 128 bytes (currently 40 bytes)\n- P2S (Pay to Script) becomes standard\n- 10,000 bytes unlocking bytecode limit\n\n---\n\n## 13. Contract Template",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "12. VM Limits (Current)",
      "13. Contract Template"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-17",
    "content": "## 13. Contract Template\n\n```cashscript\npragma cashscript ^0.13.0;\n\n/*  --- ContractName Mutable NFT State ---\n    bytes20 userPkh = 0x...\n    bytes2 lockBlocks = 0x0000\n*/\n\ncontract ContractName(bytes32 tokenCategory) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Brief description of what this function does.\n    //\n    //inputs:\n    //  0   masterNFT                 [NFT]       (from this contract)\n    //  1   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   masterNFT                 [NFT]       (to this contract)\n    //  1   result                    [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function operate(bytes20 userPkh) {\n        // 1. Validate position\n        require(this.activeInputIndex == 0);\n\n        // 2. Limit outputs (CRITICAL)\n        require(tx.outputs.length <= 3);\n\n        // 3. Authenticate\n        require(tx.inputs[0].tokenCategory == tokenCategory + 0x01);\n        require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(userPkh));\n\n        // 4. Business logic\n        bytes commitment = tx.inputs[0].nftCommitment;\n        // ... process ...\n\n        // 5. Self-replicate (5-point covenant)\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].value == 1000);\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n        require(tx.outputs[0].nftCommitment == newCommitment);\n    }\n}\n```",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "13. Contract Template"
    ]
  },
  {
    "id": "Knowledge-Base-V2/CORE_REFERENCE.md-18",
    "content": "---\n\n## Quick Reference Links\n\n- **Security & Architecture**: See `SECURITY_ARCHITECTURE.md`\n- **FAQ & Troubleshooting**: See `FAQ_DISTILLED.md`\n- **CashScript Docs**: https://cashscript.org/docs/\n- **CashTokens Spec**: https://cashtokens.org/docs/spec/",
    "source": "Knowledge-Base-V2/CORE_REFERENCE.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "Quick Reference Links"
    ]
  },
  {
    "id": "language/language-reference.md-0",
    "content": "# CashScript Language Reference\n\n## TYPE SYSTEM\n\n| Type | Operations | Methods | Conversions | Size | Constraints |\n|------|-----------|---------|-------------|------|-------------|\n| `bool` | `! && || == !=` | - | - | 1 bit | - |\n| `int` | `+ - * / % < <= > >= == !=` | - | `bytes(int)` `bytesN(int)` | Variable | Integer-only, div/0 fails, underscores OK: `1_000_000`, scientific: `1e6` |\n| `string` | `+ == !=` | `.length` `.reverse()` `.split(i)` `.slice(start,end)` | `bytes(string)` | Variable | UTF-8 encoded |\n| `bytes` | `+ == != & | ^` | `.length` `.reverse()` `.split(i)` `.slice(start,end)` | Variable | Hex: `0x1234abcd` |\n| `bytesN` | Same as bytes | Same as bytes | `bytesN(any)` | N bytes (1-64) | Fixed length, N=1-64, `byte` alias for `bytes1` |\n| `pubkey` | `== !=` | - | Auto to bytes | 33 bytes | Bitcoin public key |\n| `sig` | `== !=` | - | Auto to bytes | ~65 bytes | Transaction signature |\n| `datasig` | `== !=` | - | Auto to bytes | ~64 bytes | Data signature |\n\n**Common bytesN**: `bytes1` (byte), `bytes4` (prefix), `bytes20` (hash160), `bytes32` (sha256), `bytes64` (signature)\n\n### CRITICAL: Script Number Minimal Encoding\n\n**BCH Script requires minimal encoding for integers**. The most significant bit (MSB) of the last byte indicates sign. Production contracts must validate upper bounds:\n\n```cashscript\n// PATTERN: Validate values don't exceed bytesN capacity (minus MSB)\nrequire(pledgeAmount <= 140737488355327);  // Max bytes6: 2^47 - 1 (MSB reserved)\nrequire(newPledgeID != 2147483647);        // Max bytes4: 2^31 - 1 (MSB reserved)\nrequire(campaignID != 0xFFFFFFFFFF);       // Sentinel value check (bytes5)\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "transaction",
      "bytes",
      "int",
      "string",
      "bool",
      "CashScript Language Reference",
      "TYPE SYSTEM",
      "CRITICAL: Script Number Minimal Encoding"
    ]
  },
  {
    "id": "language/language-reference.md-1",
    "content": "**Maximum values by byte size (CRITICAL - MSB constraint):**\n- `bytes1`: 127 (2^7 - 1)\n- `bytes2`: 32,767 (2^15 - 1)\n- `bytes4`: 2,147,483,647 (2^31 - 1)\n- `bytes5`: 549,755,813,887 (2^39 - 1)\n- `bytes6`: 140,737,488,355,327 (2^47 - 1)\n- `bytes8`: 9,223,372,036,854,775,807 (2^63 - 1)\n\n**Why MSB matters**: In Script Number encoding, the MSB indicates sign. If you use the full byte range, you risk creating values that get interpreted as negative. Always subtract 1 bit from max capacity.\n\n### CRITICAL: int Type Casting Limit\n\nOnly `bytes1` through `bytes8` can be cast to `int`. Larger bounded bytes types cause a compile error:\n\n| Type | Cast to int | Error |\n|------|-------------|-------|\n| `bytes1-bytes8` | ✅ `int(value)` | - |\n| `bytes9-bytes64` | ❌ | \"Type 'bytesN' is not castable to type 'int'\" |\n\n```cashscript\n// OK - bytes8 or smaller\nbytes8 amount = bytes8(commitment.slice(0, 8));\nrequire(int(amount) > 0);\n\n// COMPILE ERROR - bytes16 cannot cast to int\nbytes16 liquidity = bytes16(commitment.slice(0, 16));\nrequire(int(liquidity) > 0);  // ❌ Error!\n```\n\n**Auto-increment pattern with overflow check:**\n```cashscript\nbytes4 currentID = bytes4(tx.inputs[0].nftCommitment.split(4)[0]);\nint newID = int(currentID) + 1;\nrequire(newID != 2147483647);  // Check BEFORE using new value\nrequire(tx.outputs[0].nftCommitment == bytes4(newID) + restOfCommitment);\n```\n\n## FUNCTION REFERENCE",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "function",
      "bytes",
      "int",
      "CRITICAL: int Type Casting Limit",
      "FUNCTION REFERENCE"
    ]
  },
  {
    "id": "language/language-reference.md-2",
    "content": "## FUNCTION REFERENCE\n\n| Function | Signature | Returns | Notes |\n|----------|-----------|---------|-------|\n| `abs` | `(int)` | `int` | Absolute value |\n| `min` | `(int, int)` | `int` | Minimum of two |\n| `max` | `(int, int)` | `int` | Maximum of two |\n| `within` | `(int x, int lower, int upper)` | `bool` | `x >= lower && x < upper` (upper exclusive) |\n| `sha256` | `(any)` | `bytes32` | SHA-256 hash |\n| `sha1` | `(any)` | `bytes20` | SHA-1 hash |\n| `ripemd160` | `(any)` | `bytes20` | RIPEMD-160 hash |\n| `hash160` | `(any)` | `bytes20` | SHA-256 then RIPEMD-160 |\n| `hash256` | `(any)` | `bytes32` | Double SHA-256 |\n| `checkSig` | `(sig, pubkey)` | `bool` | Transaction signature. NULLFAIL: invalid=fail, `0x`=false |\n| `checkMultiSig` | `([sig, ...], [pubkey, ...])` | `bool` | Multi-sig. INLINE arrays only: `checkMultisig([s1,s2], [pk1,pk2,pk3])`. NOT in TypeScript SDK |\n| `checkDataSig` | `(datasig, bytes, pubkey)` | `bool` | Data signature. NULLFAIL applies |\n| `bytes` | `(any)` | `bytes` | Type conversion |\n| `bytesN` | `(any)` | `bytesN` | Fixed-length conversion (pads/truncates) |\n\n## GLOBAL VARIABLES",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "function",
      "transaction",
      "bytes",
      "int",
      "bool",
      "FUNCTION REFERENCE",
      "GLOBAL VARIABLES"
    ]
  },
  {
    "id": "language/language-reference.md-3",
    "content": "## GLOBAL VARIABLES\n\n| Variable | Type | Description | Constraint |\n|----------|------|-------------|------------|\n| `tx.time` | `int` | Absolute time lock (nLocktime) | <500M=block height, ≥500M=Unix timestamp. Use: `require(tx.time >= expr)` |\n| `this.age` | `int` | Relative UTXO age (nSequence) | Blocks only (SDK limitation). Use: `require(this.age >= expr)` |\n| `tx.version` | `int` | Transaction version | Typically 2 |\n| `tx.locktime` | `int` | Transaction locktime | 0 or timestamp/block |\n| `tx.inputs` | `Input[]` | Transaction inputs array | Check `.length` before access |\n| `tx.outputs` | `Output[]` | Transaction outputs array | Check `.length` before access |\n| `tx.inputs[i].value` | `int` | Input satoshi amount | Bounds: `i < tx.inputs.length` |\n| `tx.inputs[i].lockingBytecode` | `bytes` | Input scriptPubKey | - |\n| `tx.inputs[i].unlockingBytecode` | `bytes` | Input scriptSig | - |\n| `tx.inputs[i].outpointTransactionHash` | `bytes32` | UTXO source tx hash | - |\n| `tx.inputs[i].outpointIndex` | `int` | UTXO source output index | - |\n| `tx.inputs[i].sequenceNumber` | `int` | nSequence value | Relative timelock in v2 tx only |\n| `tx.inputs[i].tokenCategory` | `bytes` | Input token category | 32-byte ID + optional capability (0x01=mutable, 0x02=minting) |\n| `tx.inputs[i].nftCommitment` | `bytes` | Input NFT commitment | CashTokens, max 40 bytes (128 in May 2026) |\n| `tx.inputs[i].tokenAmount` | `int` | Input fungible tokens | CashTokens, max 64-bit |\n| `tx.outputs[i].value` | `int` | Output satoshi amount | Bounds: `i < tx.outputs.length` |",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "transaction",
      "bytes",
      "int",
      "GLOBAL VARIABLES"
    ]
  },
  {
    "id": "language/language-reference.md-4",
    "content": "| `tx.outputs[i].lockingBytecode` | `bytes` | Output script bytecode | - |\n| `tx.outputs[i].tokenCategory` | `bytes` | Output token category | 32-byte ID + optional capability (0x01=mutable, 0x02=minting) |\n| `tx.outputs[i].nftCommitment` | `bytes` | Output NFT commitment | CashTokens, max 40 bytes (128 in May 2026) |\n| `tx.outputs[i].tokenAmount` | `int` | Output fungible tokens | CashTokens |\n| `this.activeInputIndex` | `int` | Current input being evaluated | - |\n\n**CRITICAL: tx.outputs vs tx.inputs property differences**:\n- `tx.outputs[i]` does NOT have: `outpointTransactionHash`, `outpointIndex`, `unlockingBytecode`, `sequenceNumber`\n- These properties only exist on `tx.inputs[i]` (they describe where the UTXO came from)\n- `tx.outputs[i]` only describes what's being created: `value`, `lockingBytecode`, `tokenCategory`, `nftCommitment`, `tokenAmount`\n| `this.activeBytecode` | `bytes` | Current input's locking bytecode | For covenants |\n\n**Locking Bytecode Constructors**:\n- `new LockingBytecodeP2PKH(bytes20 pkHash)` - Pay to public key hash\n- `new LockingBytecodeP2SH20(bytes20 scriptHash)` - Pay to script hash (20-byte)\n- `new LockingBytecodeP2SH32(bytes32 scriptHash)` - Pay to script hash (32-byte)\n- `new LockingBytecodeNullData(bytes[] chunks)` - OP_RETURN data output\n\n### CRITICAL: P2SH32 Address Type (HARDCODED CONTRACT ADDRESSES)\n\nWhen storing contract addresses for **cross-contract validation** (multi-contract systems), ALWAYS use `bytes32` type. This is a CRITICAL rule:",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int",
      "CRITICAL: P2SH32 Address Type (HARDCODED CONTRACT ADDRESSES)"
    ]
  },
  {
    "id": "language/language-reference.md-5",
    "content": "```cashscript\n// ✓ CORRECT - bytes32 type for P2SH32 addresses\nbytes32 votingBoothAddress = 0x1234567890123456789012345678901234567890123456789012345678901234;\nrequire(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(votingBoothAddress));\n\n// ✗ WRONG - bytes type will cause compilation error!\nbytes votingBoothAddress = 0x1234567890123456789012345678901234567890123456789012345678901234;\nrequire(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(votingBoothAddress));\n// Error: Found parameters (bytes) where (bytes32) expected\n\n// ✗ WRONG - operations that lose type precision!\nbytes someData = 0x00...;  // 33 bytes total\nbytes32 addressHash = someData.split(1)[1];  // Results in bytes31, NOT bytes32!\nrequire(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(addressHash));\n// Error: Type 'bytes31' can not be assigned to variable of type 'bytes32'\n\n// ✓ CORRECT - explicit bytes32 cast or direct literal\nbytes32 addressHash = bytes32(someData.split(1)[1]);  // Explicit cast to bytes32\n// OR better: use direct literal assignment\nbytes32 votingBoothHash = 0x1234...;  // Hardcode the address directly\n\n// ✓ CORRECT - bytes20 type for P2PKH addresses\nbytes20 chairpersonPkh = 0x1234567890123456789012345678901234567890;\nrequire(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(chairpersonPkh));\n```\n\n**Why this matters**: Multi-contract systems (like BCHess, CashStarter, voting systems) embed other contract addresses for validation. Using the wrong type (`bytes` instead of `bytes32`) causes a type mismatch error that will fail compilation.",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "p2pkh",
      "bytes"
    ]
  },
  {
    "id": "language/language-reference.md-6",
    "content": "**Production pattern** (from BCHess/CashStarter):\n```cashscript\n// In contracts that reference other contracts by address:\ncontract BallotInitializer(bytes20 chairpersonPkh) {\n    function initialize(...) {\n        // Hardcoded contract address (deployed first)\n        bytes32 votingBoothHash = 0xabc...;  // Must be bytes32!\n        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(votingBoothHash));\n    }\n}\n```\n\n**CashToken Capabilities**:\n- **Immutable** (no capability byte): Cannot modify NFT commitment when spent\n- **Mutable** (0x01): Can create ONE replacement NFT per spending, can downgrade to immutable\n- **Minting** (0x02): Can create unlimited NFTs, can downgrade to mutable or immutable\n\n**Token Constraints**:\n- One NFT per output maximum\n- All tokens in output must share same category\n- Fungible token amount: 1 to 9,223,372,036,854,775,807 (64-bit)\n- tokenCategory returns `0x` when no tokens present\n- Category byte order: unreversed (OP_HASH256 format, NOT wallet/explorer format)\n\n**Token Exclusion (Security Pattern)**:\nTo prevent ANY tokens on an output, require empty tokenCategory:\n```cashscript\nrequire(tx.outputs[N].tokenCategory == 0x);  // No tokens allowed - pure BCH only\n```\nCritical when minting NFTs exist - without this check, minting capability allows creating tokens on ANY output. Use on change outputs and any output that should be pure BCH.\n\n## NFT COMMITMENT DATA STORAGE",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "NFT COMMITMENT DATA STORAGE"
    ]
  },
  {
    "id": "language/language-reference.md-7",
    "content": "## NFT COMMITMENT DATA STORAGE\n\n**CRITICAL**: BCH has no global state. Store data in NFT commitments (local transferrable state).\n\n**Size limits**:\n- 40 bytes (current)\n- 128 bytes (May 2026 upgrade)\n\n**Pattern**: Contract introspects input commitment, enforces output commitment with updated state.\n```cashscript\ncontract StatefulContract(bytes32 stateTokenCategory) {\n    function updateState(sig ownerSig, bytes newState) {\n        require(checkSig(ownerSig, owner));\n        // Read current state from input NFT commitment\n        require(tx.inputs[0].tokenCategory == stateTokenCategory);\n        bytes currentState = tx.inputs[0].nftCommitment;\n        // Enforce updated state in output NFT commitment\n        require(tx.outputs[0].tokenCategory == stateTokenCategory);\n        require(tx.outputs[0].nftCommitment == newState);\n    }\n}\n```\n\n**Key concepts**:\n- **Local transferrable state**: NFT commitments persist across transactions\n- **Local transferrable functions**: Store function logic in 128-byte commitments (post-May 2026)\n- **NOT OP_RETURN**: OP_RETURN is provably unspendable (funds burned), not for storage\n\n## OP_RETURN OUTPUTS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "NFT COMMITMENT DATA STORAGE",
      "OP_RETURN OUTPUTS"
    ]
  },
  {
    "id": "language/language-reference.md-8",
    "content": "## OP_RETURN OUTPUTS\n\n**CRITICAL**: In UTXO model, the transaction itself IS the observable event. UTXO consumption/creation is inherently visible on-chain - no separate event emission needed.\n\n**OP_RETURN purpose**: Optional off-chain metadata broadcasting (NOT \"Solidity events\")\n**Size limit**: 223 bytes total per transaction\n**Spendability**: Provably unspendable (funds BURNED)\n\n**When to use OP_RETURN**:\n- App-specific metadata for off-chain indexers (Chronik, Chaingraph)\n- Protocol-specific data (e.g., social apps, token metadata)\n- NOT for state change notifications (UTXO changes are already observable)\n- NOT for data storage (use NFT commitments)\n\n```cashscript\n// Optional: Add metadata for indexers\nrequire(tx.outputs[1].lockingBytecode == new LockingBytecodeNullData([appData]));\n```\n\n**Solidity events vs BCH UTXO model**:\n- Solidity `emit Transfer(from, to, amount)` → logs state change explicitly\n- BCH: The UTXO with updated NFT commitment IS the state change - no explicit event needed\n- Transaction structure itself communicates what happened\n\n## STATE VARIABLES (Solidity → CashScript)",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "transaction",
      "bytes",
      "OP_RETURN OUTPUTS",
      "STATE VARIABLES (Solidity → CashScript)"
    ]
  },
  {
    "id": "language/language-reference.md-9",
    "content": "## STATE VARIABLES (Solidity → CashScript)\n\n**CRITICAL**: BCH is UTXO-based (stateless), NOT account-based like Ethereum.\n\n**Solidity updatable state → CashScript covenant pattern**:\n```solidity\n// Solidity (account model - state persists)\nstring public message;\nfunction update(string newMessage) { message = newMessage; }\n```\n→\n```cashscript\n// CashScript (UTXO model - enforce recreation)\ncontract Message(bytes message) {\n    function update(bytes newMessage, sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        // Enforce output creates NEW contract instance\n        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH32(hash256(/* new contract with newMessage */)));\n        require(tx.outputs[0].value >= tx.inputs[this.activeInputIndex].value - 1000);\n    }\n}\n```\n\n**Key differences**:\n- Constructor params = \"state\" (immutable per UTXO)\n- \"Update\" = spend old UTXO, create new UTXO with new constructor params\n- Covenant enforces output constraints (new contract instance, preserve value)\n- Read functions unnecessary (inspect constructor params off-chain)\n\n## STRUCTURED COMMITMENT PACKING",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "string",
      "STATE VARIABLES (Solidity → CashScript)",
      "STRUCTURED COMMITMENT PACKING"
    ]
  },
  {
    "id": "language/language-reference.md-10",
    "content": "## STRUCTURED COMMITMENT PACKING\n\n**NFT commitments (40 bytes current, 128 in May 2026) require careful layout planning**. Production contracts pack multiple values with explicit byte positions:\n\n```cashscript\n// PRODUCTION PATTERN: Pack multiple values into commitment (40 bytes current)\n// Layout: userPkh(20) + reserved(18) + lockBlocks(2) = 40 bytes total\nbytes20 userPkh = 0xaabbccdd...;  // 20 bytes\nint lockBlocks = 1000;             // Will become 2 bytes\n\n// WRITE: Pack into commitment\nrequire(tx.outputs[0].nftCommitment == userPkh + bytes18(0) + bytes2(lockBlocks));\n\n// READ: Unpack from commitment\nbytes20 storedPkh = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\nbytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);  // Skip 38, take last 2\nint blocks = int(stakeBlocks);\n```\n\n### CRITICAL: Chained Split Operations and Tuple Destructuring\n\n**Production contracts use chained splits for complex layouts:**\n\n```cashscript\n// PATTERN: Extract multiple values from middle of commitment\n// Layout: [other(31) + pledgeID(4) + campaignID(5)] = 40 bytes\n\n// Chained split: skip 31 bytes, then split remaining 9 bytes at position 4\nbytes4 pledgeID, bytes5 campaignID = tx.inputs[0].nftCommitment.split(31)[1].split(4);\n\n// Another example: extract middle field\n// Layout: [prefix(26) + endBlock(4) + suffix(10)]\nbytes4 endBlock = tx.inputs[0].nftCommitment.split(26)[1].split(4)[0];  // Skip 26, take next 4\n```\n\n**Tuple destructuring syntax (CRITICAL - often overlooked):**",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "int",
      "STRUCTURED COMMITMENT PACKING",
      "CRITICAL: Chained Split Operations and Tuple Destructuring"
    ]
  },
  {
    "id": "language/language-reference.md-11",
    "content": "```cashscript\n// SINGLE split returns TWO parts - assign both at once\nbytes left, bytes right = someBytes.split(10);  // Generic\nbytes4 id, bytes5 rest = data.split(4);         // Typed destructuring\nbytes20 addr, bytes remaining = commitment.split(20);  // Common pattern\n```\n\n### Partial Commitment Preservation\n\n**Modify specific bytes while keeping rest intact:**\n```cashscript\n// PATTERN: Update only the last N bytes of commitment\nbytes restCommitment = tx.inputs[0].nftCommitment.split(31)[0];  // Keep first 31 bytes\nint newPledgeID = int(pledgeID) + 1;\nrequire(tx.outputs[0].nftCommitment == restCommitment + bytes4(newPledgeID) + campaignID);\n\n// PATTERN: Update only the first N bytes\nbytes existingTail = tx.inputs[0].nftCommitment.split(2)[1];  // Keep last 38 bytes\nrequire(tx.outputs[0].nftCommitment == bytes2(newFee) + existingTail);\n```\n\n**Common layouts (40 bytes current, 128 in May 2026)**:\n```\n[pubkeyhash(20) + fee(2) + adminPkh(18)]                    // Admin contract\n[pubkeyhash(20) + reserved(18) + blocks(2)]                 // Time-locked\n[pledgeAmt(6) + padding(21) + endBlock(4) + id(4) + campaignID(5)]  // Receipt NFT\n[prefix(31) + pledgeID(4) + campaignID(5)]                  // Campaign state\n```\n\n**Byte-size reference**:\n- `bytes2` = 0-65535 (sufficient for block counts, small fees)\n- `bytes4` = 0-4,294,967,295 (timestamps, larger values)\n- `bytes5` = 0-1,099,511,627,775 (5-byte IDs, up to ~1 trillion)\n- `bytes6` = 0-281,474,976,710,655 (6-byte amounts)\n- `bytes8` = int max range (Script Number limit)",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "int",
      "Partial Commitment Preservation"
    ]
  },
  {
    "id": "language/language-reference.md-12",
    "content": "- `bytes20` = pubkeyhash (P2PKH address)\n- `bytes32` = token category ID, hashes\n\n**CRITICAL**: Plan your commitment layout BEFORE writing code. Changing layout breaks existing UTXOs.\n\n### slice() vs split() - Byte Extraction Guide\n\nCashScript provides TWO methods for byte extraction:\n\n| Method | Signature | Returns | Use Case |\n|--------|-----------|---------|----------|\n| `split(index)` | `.split(i)` | `(bytes, bytes)` tuple | Head/tail separation |\n| `slice(start, end)` | `.slice(s, e)` | `bytes` | Extract from middle |\n\n**CRITICAL: When to use which:**\n- **split()** - Best for extracting from START or END, or sequential destructuring\n- **slice()** - Best for extracting bytes from the MIDDLE of a commitment\n\n```cashscript\n// WRONG: Chained splits produce wrong sizes!\n// To extract 8 bytes at offset 64:\nint reserve = int(commitment.split(72)[0].split(8)[1]);\n// split(72)[0] → bytes72 (first 72 bytes)\n// .split(8)[1] → bytes64 (72-8=64 bytes!), NOT bytes8!\n// ERROR: \"Type 'bytes64' is not castable to type 'int'\"\n\n// CORRECT: Use slice() for middle extraction\nbytes8 reserveBytes = bytes8(commitment.slice(64, 72));  // bytes 64-71\nint reserve = int(reserveBytes);\n\n// CORRECT: Use split() for head extraction\nbytes20 ownerPkh = bytes20(commitment.split(20)[0]);  // first 20 bytes\n\n// CORRECT: Use split() for tail extraction (40-byte commitment)\nbytes4 suffix = bytes4(commitment.split(36)[1]);  // last 4 bytes\n\n// CORRECT: Sequential destructuring with split()\nbytes20 owner, bytes rest = commitment.split(20);\nbytes8 balance, bytes rest2 = rest.split(8);\nbytes4 timestamp = bytes4(rest2.split(4)[0]);\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "p2pkh",
      "bytes",
      "int",
      "slice() vs split() - Byte Extraction Guide"
    ]
  },
  {
    "id": "language/language-reference.md-13",
    "content": "**Common extraction patterns by position:**\n```\nCommitment: [field0(20) | field1(8) | field2(32) | field3(4)] = 64 bytes\n\nField 0 (offset 0, size 20):   bytes20(commitment.split(20)[0])\nField 1 (offset 20, size 8):   bytes8(commitment.slice(20, 28))\nField 2 (offset 28, size 32):  bytes32(commitment.slice(28, 60))\nField 3 (offset 60, size 4):   bytes4(commitment.split(60)[1])\n```\n\n## DUST AND FEE ACCOUNTING",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "DUST AND FEE ACCOUNTING"
    ]
  },
  {
    "id": "language/language-reference.md-14",
    "content": "## DUST AND FEE ACCOUNTING\n\n**BCH requires explicit fee management**. Unlike EVM gas abstraction, you must account for every satoshi:\n\n```cashscript\n// CRITICAL: Minimum dust amounts\nrequire(tx.outputs[0].value == 1000);  // Minimum dust for token UTXO (546 technically, 1000 safe)\nrequire(amount >= 5000);               // Ensure enough for future fees\n\n// PATTERN: Explicit fee subtraction\nrequire(tx.outputs[0].value == tx.inputs[0].value - 3000);  // 3000 = miner fee + 2x dust UTXOs\n\n// PATTERN: Fee collection into contract\nbytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\nrequire(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\n\n// PATTERN: Withdraw accumulated fees\nrequire(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\n```\n\n**Production fee constants**:\n- **546 sats** - Absolute minimum dust (rarely used)\n- **1000 sats** - Safe dust for token UTXOs\n- **1000-2000 sats** - Typical miner fee per KB\n- **5000+ sats** - Minimum lock amounts (covers future unlock fees)\n\n**Key insight**: Every output costs ~34 bytes (8 value + 26 script). Fee = tx_size * rate. Plan outputs carefully.\n\n## INTER-CONTRACT TRUST MODEL",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "int",
      "DUST AND FEE ACCOUNTING",
      "INTER-CONTRACT TRUST MODEL"
    ]
  },
  {
    "id": "language/language-reference.md-15",
    "content": "## INTER-CONTRACT TRUST MODEL\n\n**CashScript contracts can interact securely via shared token categories**. This enables composable DeFi protocols:\n\n```cashscript\n// CONTRACT A: Primary contract (e.g., CashStarter)\ncontract PrimaryContract() {\n    function doSomething() {\n        require(this.activeInputIndex == 0);  // This is input 0\n        // ... primary logic\n    }\n\n    // Allow external contracts to interact\n    function externalFunction() {\n        require(this.activeInputIndex == 1);  // This contract is input 1\n        // Trust verified by input 0 having minting NFT from shared category\n        bytes masterCategory = 0x64c9ea104e07d9099bc3cdcb2a0035286773790c40dbcb0ae67068b1b8453748;\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x02);  // Other contract has minting NFT\n    }\n}\n\n// CONTRACT B: Extension contract (deployed alongside)\ncontract ExtensionContract() {\n    function extendedLogic() {\n        require(this.activeInputIndex == 0);  // This is input 0\n        bytes masterCategory = 0x64c9ea104e07d9099bc3cdcb2a0035286773790c40dbcb0ae67068b1b8453748;\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x02);  // Has minting NFT\n        require(tx.inputs[1].tokenCategory == masterCategory + 0x02);  // Primary also has minting NFT\n        // Now both contracts trust each other\n    }\n}\n```\n\n**Trust mechanism**:\n1. Deploy contracts together, share same minting NFTs\n2. Minting NFTs (0x02 capability) should NEVER exist outside trusted contracts",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "INTER-CONTRACT TRUST MODEL"
    ]
  },
  {
    "id": "language/language-reference.md-16",
    "content": "3. Contract verifies other input has minting NFT = trusted partner\n4. `this.activeInputIndex` determines which contract executes\n\n**Use cases**:\n- Plugin/extension architecture\n- Protocol upgrades without migration\n- Cross-contract composability\n- Shared state management\n\n**CRITICAL**: This pattern requires careful deployment. Minting NFTs are the \"keys to the kingdom\". Never let them escape to untrusted addresses.\n\n## IMPLICIT NFT BURNING",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "IMPLICIT NFT BURNING"
    ]
  },
  {
    "id": "language/language-reference.md-17",
    "content": "## IMPLICIT NFT BURNING\n\n**NFTs are burned by NOT including them in transaction outputs**. This is a fundamental UTXO pattern:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Stop a campaign after deadline. Burns campaign NFT if no pledges.\n//\n//inputs:\n//  0   helperMasterNFT           [NFT]       (from Stop contract)\n//  1   campaignNFT               [NFT]       (from Main contract)\n//  2   creatorBCH                [BCH]       (from campaign creator)\n//outputs:\n//  0   helperMasterNFT           [NFT]       (to Stop contract)\n//  1   campaignNFT {if pledges}  [NFT]       (to Main contract)\n//  ?   creatorBCH                [BCH]       (to campaign creator)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction stop() {\n    require(this.activeInputIndex == 0);\n    require(tx.inputs.length == 2);\n\n    // Recreate masterNFT (input 0)\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // ... other validations\n\n    if (tx.inputs[1].value == 1000) {  // No pledges made\n        require(tx.outputs.length == 1);  // ONLY masterNFT recreated\n        // Campaign NFT (input 1) is IMPLICITLY BURNED - not in any output!\n    } else {\n        // Recreate campaign NFT with modified state\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n        // ...\n    }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "IMPLICIT NFT BURNING"
    ]
  },
  {
    "id": "language/language-reference.md-18",
    "content": "**Key insight**: In UTXO model, anything not explicitly recreated is destroyed. Use output count to control burn behavior.\n\n## NFT CAPABILITY AS STATE MACHINE\n\n**Token capabilities encode contract state, not just permissions**:\n\n```\nMINTING (0x02)     →    MUTABLE (0x01)      →    IMMUTABLE (0x)\nActive state            Stopped state            Final state\nCan modify freely       Can modify once more     Proof/receipt only\n\nExamples:\n- Active campaign       - Cancelled campaign     - Receipt NFT\n- Master controller     - Restricted campaign    - Proof of pledge\n```\n\n**State transition pattern:**\n```cashscript\n// Downgrade from minting to mutable (stop/cancel campaign)\nrequire(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory.split(32)[0] + 0x01);\n\n// Downgrade from minting to immutable (create receipt)\nrequire(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);  // No capability byte\n\n// Verify state\nbytes category, bytes capability = tx.inputs[1].tokenCategory.split(32);\nrequire(capability == 0x02);  // Must be minting (active)\nrequire(capability != 0x);     // Must NOT be immutable (receipt)\n```\n\n**State machine benefits**:\n- Capability = State indicator visible to all contracts\n- Irreversible state transitions (can't upgrade capability)\n- Receipt NFTs are permanent proof of action\n\n## RECEIPT NFT PATTERN",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "NFT CAPABILITY AS STATE MACHINE",
      "RECEIPT NFT PATTERN"
    ]
  },
  {
    "id": "language/language-reference.md-19",
    "content": "## RECEIPT NFT PATTERN\n\n**Immutable NFTs serve as cryptographic receipts/proofs**:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Accept a pledge from a backer. Issues an immutable receipt NFT as proof.\n//\n//inputs:\n//  0   masterNFT                 [NFT]       (from Manager contract)\n//  1   backerBCH                 [BCH]       (from backer)\n//  2   campaignNFT               [NFT]       (from Main contract)\n//outputs:\n//  0   masterNFT                 [NFT]       (to Manager contract)\n//  1   pledgeReceipt             [NFT]       (to backer)\n//  2   campaignNFT               [NFT]       (to Main contract)\n//  3   change {optional}         [BCH]       (to backer)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction pledge(int pledgeAmount) {\n    // ... validation ...\n\n    // Create IMMUTABLE receipt NFT (proof of pledge)\n    require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);  // No capability\n    require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);  // To user\n    require(tx.outputs[1].value == 1000);  // Dust\n    require(tx.outputs[1].tokenAmount == 0);  // No fungible tokens\n\n    // Receipt contains proof data\n    require(tx.outputs[1].nftCommitment ==\n        bytes6(pledgeAmount) +      // What was pledged\n        bytes21(0) +                // Padding\n        endBlock +                  // Campaign deadline\n        bytes4(pledgeID) +          // Unique pledge ID\n        campaignID                  // Which campaign\n    );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Refund a backer after campaign failure. Validates receipt NFT authenticity.\n//\n//inputs:\n//  0   helperMasterNFT           [NFT]       (from Refund contract)\n//  1   campaignNFT               [NFT]       (from Main contract)\n//  2   pledgeReceipt             [NFT]       (from backer)\n//  3   backerBCH                 [BCH]       (from backer)\n//outputs:\n//  0   helperMasterNFT           [NFT]       (to Refund contract)\n//  1   campaignNFT               [NFT]       (to Main contract)\n//  2   refundPayment             [BCH]       (to backer)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction refund() {\n    bytes category2, bytes capability2 = tx.inputs[2].tokenCategory.split(32);\n    require(category2 == masterCategory);  // Same token family\n    require(capability2 == 0x);             // MUST be immutable (receipt)\n\n    bytes campaignID = tx.inputs[1].nftCommitment.split(35)[1];\n    bytes refundID = tx.inputs[2].nftCommitment.split(35)[1];\n    require(campaignID == refundID);  // Receipt matches campaign\n\n    int pledgeAmount = int(tx.inputs[2].nftCommitment.split(6)[0]);\n    // Process refund based on receipt...\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "RECEIPT NFT PATTERN"
    ]
  },
  {
    "id": "language/language-reference.md-20",
    "content": "**Use cases**: Pledge receipts, voting proofs, subscription tickets, access tokens\n\n## VALUE-BASED STATE DETECTION\n\n**Satoshi amount can indicate contract state**:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Cancel a campaign before deadline. Behavior depends on whether pledges exist.\n//\n//inputs:\n//  0   helperMasterNFT           [NFT]       (from Cancel contract)\n//  1   campaignNFT               [NFT]       (from Main contract)\n//  2   creatorBCH                [BCH]       (from campaign creator)\n//outputs:\n//  0   helperMasterNFT           [NFT]       (to Cancel contract)\n//  1   campaignNFT {if pledges}  [NFT]       (to Main contract)\n//  1   creatorBCH                [BCH]       (to campaign creator)\n//  2   creatorBCH {if pledges}   [BCH]       (to campaign creator)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction cancel() {\n    // Initial campaign has exactly 1000 sats (dust for existence)\n    // After pledges, value increases\n\n    if (tx.inputs[1].value == 1000) {  // No pledges = initial state\n        // Burn campaign, refund user\n        require(tx.outputs.length == 2);\n        require(tx.outputs[1].value == tx.inputs[2].value);\n\n    } else {  // Has pledges = modified state\n        // Preserve campaign with downgraded capability\n        require(tx.outputs[1].value == tx.inputs[1].value - 1000);\n        require(tx.outputs[2].value == tx.inputs[2].value);\n    }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "VALUE-BASED STATE DETECTION"
    ]
  },
  {
    "id": "language/language-reference.md-21",
    "content": "**Patterns**:\n- `value == 1000`: Initial/empty state (dust only)\n- `value > initial`: Modified state (has accumulated funds)\n- `value <= pledgeAmount`: Last pledge (will empty contract)\n\n**Key insight**: BCH value is part of contract state. Design initial values to be identifiable.\n\n## SERVICE PROVIDER FEE PATTERNS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "SERVICE PROVIDER FEE PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-22",
    "content": "## SERVICE PROVIDER FEE PATTERNS\n\n**Built-in protocol monetization for frontends**:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Initialize a new campaign with optional service provider fee.\n//\n//inputs:\n//  0   masterNFT                 [NFT]       (from Manager contract)\n//  1   creatorBCH                [BCH]       (from campaign creator)\n//outputs:\n//  0   masterNFT                 [NFT]       (to Manager contract)\n//  1   campaignNFT               [NFT]       (to Main contract)\n//  2   serviceFee {optional}     [BCH]       (to service provider)\n//  ?   change {optional}         [BCH]       (to campaign creator)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction initialize(bytes20 servicePKH, int serviceFee) {\n    require(serviceFee <= 1000000);  // Max 0.01 BCH absolute cap\n    require(tx.outputs[2].lockingBytecode == new LockingBytecodeP2PKH(servicePKH));\n    require(tx.outputs[2].value == serviceFee);\n    require(tx.outputs[2].tokenCategory == 0x);  // Pure BCH\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Claim successful campaign funds with capped service provider fee.\n//\n//inputs:\n//  0   helperMasterNFT           [NFT]       (from Claim contract)\n//  1   campaignNFT               [NFT]       (from Main contract)\n//  2   creatorBCH                [BCH]       (from campaign creator)\n//outputs:\n//  0   helperMasterNFT           [NFT]       (to Claim contract)\n//  1   campaignFunds             [BCH]       (to campaign creator)\n//  2   serviceFee                [BCH]       (to service provider)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction claim(bytes20 servicePKH, int serviceFee) {\n    // Integer percentage: value * numerator / denominator\n    require(serviceFee <= tx.inputs[1].value * 50 / 1000);  // Max 5% of campaign\n\n    require(tx.outputs[2].lockingBytecode == new LockingBytecodeP2PKH(servicePKH));\n    require(tx.outputs[2].value == serviceFee);\n    require(tx.outputs[2].tokenCategory == 0x);\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "SERVICE PROVIDER FEE PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-23",
    "content": "**Percentage math patterns**:\n- `value * 50 / 1000` = 5%\n- `value * 10 / 1000` = 1%\n- `value * 1 / 100` = 1%\n- `value / 100` = 1% (simplest)\n\n**Benefits**: Incentivizes frontend development, decentralizes service provision\n\n## MULTI-CONTRACT DEPLOYMENT PATTERNS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "MULTI-CONTRACT DEPLOYMENT PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-24",
    "content": "## MULTI-CONTRACT DEPLOYMENT PATTERNS\n\n**Complex protocols require coordinated contract deployment**:\n\n```cashscript\n// CONTRACT 1: Manager (creates campaigns)\ncontract Manager() {\n    function initialize() {\n        // Hardcode target contract address at compile time\n        require(tx.outputs[1].lockingBytecode ==\n            new LockingBytecodeP2SH32(0xe3cab0f5a4aa3b8898d4708dbfa3b4126a723d5d982ac4c2691e33841fa8371f));\n    }\n}\n\n// CONTRACT 2: Main (holds campaigns)\ncontract Main() {\n    function externalFunction() {\n        require(this.activeInputIndex == 1);  // I am input 1\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x02);  // Trust input 0\n    }\n}\n\n// CONTRACT 3-N: Helpers (cancel, claim, refund, stop)\ncontract Helper() {\n    function action() {\n        // Each helper has its OWN masterNFT\n        require(tx.inputs[0].nftCommitment.split(35)[1] == 0xFFFFFFFFFF);  // Sentinel ID\n        // Main contract NFT is input 1\n        require(tx.inputs[1].tokenCategory == masterCategory + 0x02);\n    }\n}\n```\n\n**Distributed masterNFT pattern**:\n- Each contract in system gets ONE masterNFT with sentinel ID (0xFFFFFFFFFF)\n- MasterNFTs stay in their respective contracts forever\n- Contracts identify each other by shared token category\n- Sentinel value distinguishes master from data NFTs\n\n**Deployment checklist**:\n1. Deploy all contracts (get P2SH32 addresses)\n2. Hardcode addresses in source where needed\n3. Recompile with addresses\n4. Create token category (genesis transaction)",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "MULTI-CONTRACT DEPLOYMENT PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-25",
    "content": "5. Mint masterNFTs for each contract\n6. Send masterNFTs to their contracts\n\n**CRITICAL**: Contracts are immutable after deployment. All inter-contract addresses must be correct at compile time.\n\n## PERMISSIONLESS (CONSTRAINT-ONLY) CONTRACTS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "PERMISSIONLESS (CONSTRAINT-ONLY) CONTRACTS"
    ]
  },
  {
    "id": "language/language-reference.md-26",
    "content": "## PERMISSIONLESS (CONSTRAINT-ONLY) CONTRACTS\n\n**Some protocols require NO authorization at all**. Anyone can execute if they construct valid transactions:\n\n```cashscript\n// BCHess: ZERO signatures, ZERO authorization checks\ncontract King() {  // Empty constructor\n    function move() {\n        // No checkSig, no UTXO ownership check\n        // Pure constraint validation only\n\n        int turnCounter = int(tx.inputs[2].nftCommitment);\n        int colorTurn = turnCounter % 2;  // Whose turn is it?\n\n        // Verify source piece belongs to current team\n        byte sourceTeam = tx.inputs[3].nftCommitment.split(6)[1].split(1)[0];\n        require(int(sourceTeam) == colorTurn);\n\n        // Validate movement rules (king moves 1 square any direction)\n        require(abs(deltaX) <= 1 && abs(deltaY) <= 1);\n        require(deltaX != 0 || deltaY != 0);  // Must actually move\n    }\n}\n```\n\n**When to use permissionless contracts:**\n- Games (chess, checkers) - state determines valid moves\n- Public goods - anyone can contribute/participate\n- Open protocols - no gatekeeping required\n- Deterministic state machines - rules enforce validity\n\n**Key insight**: Authorization via constraints, not signatures. If transaction structure is valid, the action is valid.\n\n## STATELESS LOGIC CONTRACTS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "PERMISSIONLESS (CONSTRAINT-ONLY) CONTRACTS",
      "STATELESS LOGIC CONTRACTS"
    ]
  },
  {
    "id": "language/language-reference.md-27",
    "content": "## STATELESS LOGIC CONTRACTS\n\n**Separate validation logic from state management**. Logic contracts have NO constructor parameters:\n\n```cashscript\n// STATE CONTRACT: Holds and manages data\ncontract ChessMaster(bytes squareCategory, bytes pieceCategory) {\n    function move() {\n        // Validate state transitions\n        int turnCounter = int(tx.inputs[2].nftCommitment);\n        int newTurnCounter = turnCounter + 1;\n        require(tx.outputs[2].nftCommitment == bytes8(newTurnCounter));\n    }\n}\n\n// LOGIC CONTRACT: Pure validation rules (NO constructor params)\ncontract Pawn() {  // Empty!\n    function move() {\n        // ONLY validates movement rules\n        byte piece = tx.inputs[3].nftCommitment.split(7)[1].split(1)[0];\n        require(piece == 0x01);  // Must be pawn\n\n        // Forward movement validation\n        require(deltaX == 0 && deltaY == 1);  // One square forward\n    }\n}\n```\n\n**Benefits:**\n- **Modularity**: Add new piece types without changing state contract\n- **Reusability**: Same logic contract used across multiple games\n- **Testability**: Logic isolated from state management\n- **Upgradability**: Deploy new logic contract, same state\n\n**Pattern**: State contracts embed category IDs. Logic contracts are pure validators.\n\n## UTXO ORDERING AS DATA STRUCTURE",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "STATELESS LOGIC CONTRACTS",
      "UTXO ORDERING AS DATA STRUCTURE"
    ]
  },
  {
    "id": "language/language-reference.md-28",
    "content": "## UTXO ORDERING AS DATA STRUCTURE\n\n**Input position in transaction encodes information**. Sequential UTXOs represent paths or sequences:\n\n```cashscript\n// BCHess: Rook movement path validation\n// Inputs represent: source -> empty squares -> destination\n\nfunction checkEmpty() {\n    // Get previous square coordinates\n    byte prevX = tx.inputs[this.activeInputIndex - 1].nftCommitment.split(4)[1].split(1)[0];\n    byte prevY = tx.inputs[this.activeInputIndex - 1].nftCommitment.split(5)[1].split(1)[0];\n\n    // Get current square coordinates\n    byte thisX = tx.inputs[this.activeInputIndex].nftCommitment.split(4)[1].split(1)[0];\n    byte thisY = tx.inputs[this.activeInputIndex].nftCommitment.split(5)[1].split(1)[0];\n\n    // Get next square coordinates\n    byte nextX = tx.inputs[this.activeInputIndex + 1].nftCommitment.split(4)[1].split(1)[0];\n    byte nextY = tx.inputs[this.activeInputIndex + 1].nftCommitment.split(5)[1].split(1)[0];\n\n    // Verify stepping pattern (must maintain direction)\n    int stepToPrevX = int(thisX) - int(prevX);\n    int stepToNextX = int(nextX) - int(thisX);\n    require(stepToPrevX == stepToNextX);  // Same direction\n\n    // Verify this square is empty\n    byte currentTeam = tx.inputs[this.activeInputIndex].nftCommitment.split(6)[1].split(1)[0];\n    require(currentTeam == 0x02);  // Empty square\n}\n```\n\n**Use cases:**\n- Path validation (chess pieces moving through squares)\n- Sequential approval chains\n- Multi-step processes\n- Graph traversal validation\n\n**Critical pattern**: `tx.inputs[this.activeInputIndex ± 1]` accesses neighboring inputs.",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "function",
      "transaction",
      "int",
      "UTXO ORDERING AS DATA STRUCTURE"
    ]
  },
  {
    "id": "language/language-reference.md-29",
    "content": "## DISTRIBUTED STATE ACROSS MULTIPLE UTXOs\n\n**Complex state split across many NFTs**. BCHess uses 64 UTXOs for chess board:\n\n```cashscript\n// Each square NFT commitment (8 bytes):\n// [startingTeam(1) + startingPiece(1) + x(1) + y(1) + currentTeam(1) + currentPiece(1)]\n\n// Square 0,0 (white rook): 0x00040000 + 0x0004 (white, rook at start; white, rook now)\n// Square 3,4 (empty):      0x02000304 + 0x0200 (empty at start; empty now)\n\nfunction reset() {\n    // After king capture, reset ALL 64 squares in one transaction\n    require(tx.inputs.length == 66);   // ChessMaster + user + 64 squares\n    require(tx.outputs.length == 66);\n\n    // Each square resets to starting configuration\n    bytes teamPiece, bytes xy = tx.inputs[this.activeInputIndex].nftCommitment.split(2);\n    require(tx.outputs[this.activeInputIndex].nftCommitment == teamPiece + xy + teamPiece);\n}\n```\n\n**Immutable + Mutable in one NFT:**\n```\nBytes 0-3: Immutable (starting position, coordinates)\nBytes 4-5: Mutable (current state)\n```\nImmutable fields enable reset to known good state.\n\n**Benefits:**\n- Parallel state updates (all squares in one tx)\n- Granular state tracking\n- Reset via immutable field copying\n- Distributed validation load\n\n## CONSTRUCTOR PARAMETERS AS TRUST ANCHORS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "function",
      "transaction",
      "bytes",
      "DISTRIBUTED STATE ACROSS MULTIPLE UTXOs",
      "CONSTRUCTOR PARAMETERS AS TRUST ANCHORS"
    ]
  },
  {
    "id": "language/language-reference.md-30",
    "content": "## CONSTRUCTOR PARAMETERS AS TRUST ANCHORS\n\n**Embed token category IDs at compile time** for cross-contract validation:\n\n```cashscript\ncontract Squares(\n    bytes chessMasterCategory01,  // Category ID embedded at deployment\n    bytes squareCategory01,\n    bytes pieceCategory00\n) {\n    function move() {\n        // Validate other contracts by embedded category IDs\n        require(tx.inputs[1].tokenCategory == pieceCategory00);          // Piece logic\n        require(tx.inputs[2].tokenCategory == chessMasterCategory01);   // Game master\n        require(tx.inputs[3].tokenCategory == squareCategory01);        // Source square\n\n        // Multiple validation layers via constructor params\n        bytes srcCategory = tx.inputs[3].tokenCategory.split(32)[0];\n        require(srcCategory == squareCategory01.split(32)[0]);\n    }\n}\n```\n\n**Trust anchor flow:**\n1. Deploy all contracts (get addresses)\n2. Create token categories (genesis txs)\n3. Recompile contracts with category IDs in constructors\n4. Deploy with embedded trust anchors\n5. Contracts validate each other by hardcoded categories\n\n**Key insight**: Constructor parameters are compile-time constants that enable trustless cross-contract validation.\n\n## VARIABLE-LENGTH INPUT PATTERNS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "CONSTRUCTOR PARAMETERS AS TRUST ANCHORS",
      "VARIABLE-LENGTH INPUT PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-31",
    "content": "## VARIABLE-LENGTH INPUT PATTERNS\n\n**Dynamic input counts for arbitrary-length operations**:\n\n```cashscript\nfunction move() {\n    // Minimum inputs: user + piece + master + source + destination\n    require(tx.inputs.length >= 5);\n\n    // Can have more for longer paths (rook, bishop, queen)\n    // Each additional input is an empty square along the path\n\n    // Process all inputs between source and destination\n    int i = 4;  // Start after source square\n    do {\n        // Validate each intermediate square is empty\n        byte team = tx.inputs[i].nftCommitment.split(6)[1].split(1)[0];\n        require(team == 0x02);  // Empty\n        i = i + 1;\n    } while (i < tx.inputs.length - 1);  // Stop before destination\n\n    // Last input is always destination\n    bytes destCommitment = tx.inputs[tx.inputs.length - 1].nftCommitment;\n}\n```\n\n**Patterns:**\n- `tx.inputs.length` for conditional logic\n- `tx.inputs[tx.inputs.length - 1]` for last input\n- Loop through variable number of inputs\n- Different path lengths for different operations\n\n**Use cases:**\n- Movement paths of varying length\n- Multi-signature with variable signers\n- Batch operations\n- Chain validation with arbitrary depth\n\n## FUNCTION VISIBILITY & AUTHORIZATION",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "function",
      "bytes",
      "int",
      "VARIABLE-LENGTH INPUT PATTERNS",
      "FUNCTION VISIBILITY & AUTHORIZATION"
    ]
  },
  {
    "id": "language/language-reference.md-32",
    "content": "## FUNCTION VISIBILITY & AUTHORIZATION\n\n**CRITICAL**: CashScript has NO visibility modifiers (public/private/internal/external).\n\n**All functions are callable by anyone** who can construct a valid transaction. Access control must be explicit via `require` statements.\n\n| Solidity | CashScript | Notes |\n|----------|-----------|-------|\n| `public` | All functions | No keyword - all functions exposed |\n| `private` | Authorization pattern | Gate with signature OR UTXO ownership check |\n| `internal` | N/A | No contract inheritance in CashScript |\n| `external` | All functions | All functions externally callable |\n| `view/pure` | N/A | All validation on-chain, no read-only functions |\n\n### Authorization Pattern 1: Signature-Based (Explicit)\n```cashscript\ncontract SignatureAuth(pubkey ownerPk) {\n    function ownerOnly(sig s) {\n        require(checkSig(s, ownerPk));  // Must prove key ownership\n        // ... restricted logic\n    }\n}\n```\n**Use when**: Known fixed set of authorized keys (admin, oracle)\n\n### Authorization Pattern 2: UTXO-Based (Implicit) - PRODUCTION PREFERRED\n```cashscript\ncontract UTXOAuth() {\n    function userAction(bytes20 userPkh) {\n        // NO signature check needed!\n        // User proves ownership by spending their UTXO\n        require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(userPkh));\n        // ... action authorized by UTXO ownership\n    }\n}\n```\n**Use when**: Any user can participate, authorization via UTXO spending\n\n### Authorization Pattern 3: Commitment-Stored Admin",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "FUNCTION VISIBILITY & AUTHORIZATION",
      "Authorization Pattern 1: Signature-Based (Explicit)",
      "Authorization Pattern 2: UTXO-Based (Implicit) - PRODUCTION PREFERRED",
      "Authorization Pattern 3: Commitment-Stored Admin"
    ]
  },
  {
    "id": "language/language-reference.md-33",
    "content": "```cashscript\ncontract CommitmentAuth() {\n    function adminOnly() {\n        // Admin pubkeyhash stored in NFT commitment\n        bytes20 adminPkh = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\n        bytes adminBytecode = new LockingBytecodeP2PKH(adminPkh);\n        require(tx.inputs[1].lockingBytecode == adminBytecode);  // Admin must provide input\n    }\n}\n```\n**Use when**: Admin changeable, stored in contract state\n\n### Critical: `this.activeInputIndex` Validation\n```cashscript\nfunction anyFunction() {\n    // ALWAYS validate which input executes the contract\n    require(this.activeInputIndex == 0);  // Contract must be input 0\n    require(tx.inputs.length == 2);        // Exact input count\n    // ... rest of logic\n}\n```\n**Why critical**: Multi-input transactions can have different contracts executing. This ensures your contract code runs as expected input position.\n\n**Key insight**: UTXO-based authorization is more flexible and gas-efficient than signature-based. User proves they control funds by spending them.\n\n## OPERATORS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "Critical: `this.activeInputIndex` Validation",
      "OPERATORS"
    ]
  },
  {
    "id": "language/language-reference.md-34",
    "content": "## OPERATORS\n\n| Category | Operators | Valid Types | Notes |\n|----------|-----------|-------------|-------|\n| Arithmetic | `+ - * / %` | `int` | Integer only, div/0 fails |\n| Comparison | `< <= > >= == !=` | `int` `bool` `bytes` `string` | - |\n| Logical | `! && ||` | `bool` | NO short-circuit (all operands evaluated) |\n| Bitwise | `& | ^` | `bytes` only | AND, OR, XOR only. NOT supported on int. No shift or invert |\n| Concatenation | `+` | `string` `bytes` | - |\n| Unary | `+ - !` | `int` `bool` | - |\n\n## UNITS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "bytes",
      "int",
      "string",
      "bool",
      "OPERATORS",
      "UNITS"
    ]
  },
  {
    "id": "language/language-reference.md-35",
    "content": "## UNITS\n\n| BCH Units | Value | Time Units | Value |\n|-----------|-------|------------|-------|\n| `sats` | 1 | `seconds` | 1 |\n| `finney` | 100,000 | `minutes` | 60 |\n| `bits` | 100 | `hours` | 3,600 |\n| `bitcoin` | 100,000,000 | `days` | 86,400 |\n| - | - | `weeks` | 604,800 |\n\n## SYNTAX PATTERNS",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "UNITS",
      "SYNTAX PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-36",
    "content": "## SYNTAX PATTERNS\n\n### Contract Structure\n```cashscript\npragma cashscript ^0.13.0;\n\ncontract MyContract(params) {\n    function spend() { /* ... */ }\n}\n```\n**Pragma**: Specifies compiler version. Uses SemVer (e.g., `^0.13.0`, `>= 0.7.0 < 0.9.3`)\n\n### Type Conversions\n```cashscript\nint i = 42;\nbytes b = bytes(i);              // Explicit conversion\nbytes4 b4 = bytes4(i);           // Fixed-length (pads/truncates)\n\npubkey pk = 0x03...;\nbytes pkBytes = pk;              // Implicit conversion (specialized types)\n\nstring s = \"Hello\";\nbytes sBytes = bytes(s);         // UTF-8 encoding\n```\n\n### Collections\n```cashscript\n// Arrays (limited, mainly for checkMultiSig)\nsig[] sigs = [sig1, sig2];\npubkey[] pks = [pk1, pk2, pk3];\nrequire(checkMultiSig(sigs, pks));\n\n// Tuples (from split operations)\nbytes part1, bytes part2 = data.split(5);\nstring s1, string s2 = text.split(10);\n```\n\n### Control Flow: Loops\n```cashscript\n// do-while loop (CashScript 0.13.0+)\nint inputIndex = 0;\ndo {\n    require(tx.inputs[inputIndex].tokenCategory == 0x);\n    inputIndex = inputIndex + 1;\n} while (inputIndex < tx.inputs.length);\n```\n**Behavior**: Executes body first, then tests condition. Continues while condition is true. Beta feature in 0.13.0\n\n### Bitwise Operations\n```cashscript\n// Supported: AND, OR, XOR (on bytes ONLY, NOT int)\nbytes flags = 0xFF;\nbytes masked = flags & 0x0F;     // AND for masking\nbytes combined = a | b;          // OR for combining\nbytes toggled = a ^ b;           // XOR for toggling\n\n// For bit flag validation, use bytes types:\nbytes1 configFlags = 0x05;       // Example: active=1, paused=0, borrowEnabled=1\nrequire((configFlags & 0x01) == 0x01);  // Check bit 0 is set\nrequire((configFlags & 0x04) == 0x00);  // Check bit 2 is clear\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "string",
      "SYNTAX PATTERNS",
      "Contract Structure",
      "Type Conversions",
      "Collections",
      "Control Flow: Loops",
      "Bitwise Operations"
    ]
  },
  {
    "id": "language/language-reference.md-37",
    "content": "**Note**: CashScript does NOT support:\n- Bitwise operators on `int` types (use `bytes` instead)\n- Shift operators (`<<`, `>>`)\n- Bitwise NOT (`~`)\n\n### Array Bounds\n```cashscript\n// ALWAYS validate length before access\nrequire(tx.outputs.length > index);\nrequire(tx.outputs[index].value >= amount);\n```\n\n## MASTER EXAMPLE",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "int",
      "Array Bounds",
      "MASTER EXAMPLE"
    ]
  },
  {
    "id": "language/language-reference.md-38",
    "content": "## MASTER EXAMPLE\n\n**Production-grade contract demonstrating real-world patterns:**\n\n```cashscript\npragma cashscript ^0.13.0;\n\n// PRODUCTION PATTERN: Empty constructor with hardcoded values (common for deployed contracts)\ncontract MasterReference() {\n\n    // PATTERN 1: Stateful NFT Management with Structured Commitment\n    // Input layout: [0] masterNFT (from contract), [1] userUTXO (from user)\n    // Output layout: [0] masterNFT (to contract), [1] lockNFT (to contract), [2] optional change\n    function lock(int amount, int lockBlocks, bytes20 userPkh) {\n        // CRITICAL: Always validate this contract is the expected input\n        require(this.activeInputIndex == 0);\n\n        // CRITICAL: Exact input/output validation (not >=, exact counts)\n        require(tx.inputs.length == 2);\n        require(tx.outputs.length <= 3);\n\n        // Business logic constraints\n        require(lockBlocks <= 65536);\n        require(amount >= 5000);  // Minimum dust for unlock fees\n\n        // PATTERN: Hardcoded token category + capability check\n        bytes masterCategory = 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24;\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x02);  // Must be minting NFT\n        require(tx.inputs[1].tokenCategory == 0x);  // User input must be pure BCH\n\n        // PATTERN: UTXO-based authorization (NO checkSig needed!)\n        // User proves ownership by spending their UTXO\n        require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(userPkh));\n\n        // PATTERN: Structured commitment packing (40 bytes current)\n        // Layout: userPkh(20) + reserved(18) + lockBlocks(2) = 40 bytes\n        bytes lockLength = bytes2(lockBlocks);\n        require(tx.outputs[1].nftCommitment == userPkh + bytes18(0) + lockLength);\n\n        // PATTERN: Read fee from master NFT commitment (first 2 bytes)\n        bytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\n\n        // PATTERN: Contract self-preservation with fee collection\n        require(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\n\n        // PATTERN: Calculate rewards and deduct from master\n        int reward = amount * lockBlocks / 100000000;\n        require(reward >= 1);\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - reward);\n\n        // PATTERN: Create child NFT with different capability\n        // Strip minting capability (32 bytes), add mutable (0x01)\n        require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0] + 0x01);\n        require(tx.outputs[1].value == amount);\n        require(tx.outputs[1].tokenAmount == reward);\n\n        // PATTERN: Optional output handling\n        if (tx.outputs.length == 3) {\n            require(tx.outputs[2].lockingBytecode == tx.inputs[1].lockingBytecode);\n            require(tx.outputs[2].tokenCategory == 0x);  // Change must be pure BCH\n        }\n    }\n\n    // PATTERN 2: Time-locked redemption with commitment unpacking\n    function unlock() {\n        require(this.activeInputIndex == 0);\n        require(tx.inputs.length == 1);\n        require(tx.outputs.length == 3);\n\n        bytes masterCategory = 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24;\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x01);  // Must be mutable NFT\n\n        // PATTERN: Unpack structured commitment\n        // Layout: userPkh(20) + reserved(18) + lockBlocks(2)\n        bytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\n        require(tx.age >= int(stakeBlocks));  // Time lock validation\n\n        bytes20 payoutAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\n        bytes payoutBytecode = new LockingBytecodeP2PKH(payoutAddress);\n\n        // PATTERN: Distribute tokens to user\n        require(tx.outputs[0].lockingBytecode == payoutBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);  // Strip to immutable\n        require(tx.outputs[0].value == 1000);  // Dust for token UTXO\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n\n        // PATTERN: Create receipt NFT with computed commitment\n        require(tx.outputs[1].lockingBytecode == payoutBytecode);\n        require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n        require(tx.outputs[1].value == 1000);\n        bytes commitment = 0x0000 + bytes(tx.inputs[0].tokenAmount);\n        require(tx.outputs[1].nftCommitment == commitment);\n\n        // PATTERN: Fee accounting (explicit dust subtraction)\n        require(tx.outputs[2].lockingBytecode == payoutBytecode);\n        require(tx.outputs[2].tokenCategory == 0x);\n        require(tx.outputs[2].value == tx.inputs[0].value - 3000);  // Miner fee + dust UTXOs\n    }\n\n    // PATTERN 3: Admin function with UTXO-based authorization\n    function withdraw(int newFee) {\n        require(this.activeInputIndex == 0);\n        require(tx.inputs.length == 2);\n        require(tx.outputs.length == 2);\n\n        bytes masterCategory = 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24;\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x02);\n        require(tx.inputs[1].tokenCategory == 0x);\n\n        // PATTERN: Admin authorization via commitment-stored pubkeyhash\n        bytes20 adminAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\n        bytes payoutBytecode = new LockingBytecodeP2PKH(adminAddress);\n        require(tx.inputs[1].lockingBytecode == payoutBytecode);  // Admin must provide input1\n\n        // PATTERN: Withdraw accumulated fees\n        require(tx.outputs[1].tokenCategory == 0x);\n        require(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\n\n        // PATTERN: Update commitment state (modify first N bytes, preserve rest)\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].value == 1000);\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n        bytes restCommitment = tx.inputs[0].nftCommitment.split(2)[1];\n        require(tx.outputs[0].nftCommitment == bytes2(newFee) + restCommitment);\n    }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "MASTER EXAMPLE"
    ]
  },
  {
    "id": "language/language-reference.md-39",
    "content": "**Key Production Patterns Demonstrated:**\n1. **`this.activeInputIndex`** - Always validate which input is executing the contract\n2. **Exact counts** - Use `==` not `>=` for input/output validation\n3. **UTXO authorization** - Prove ownership by spending UTXOs, not signatures\n4. **Structured commitments** - Pack multiple values into commitment (40 bytes, 128 in May 2026) with clear layout\n5. **Capability manipulation** - `.split(32)[0] + 0x01` to change NFT capabilities\n6. **Fee accounting** - Explicit dust (1000 sats) and fee subtraction\n7. **Optional outputs** - Use `if` blocks for variable output counts\n\n## UNSUPPORTED SOLIDITY FEATURES",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "UNSUPPORTED SOLIDITY FEATURES"
    ]
  },
  {
    "id": "language/language-reference.md-40",
    "content": "## UNSUPPORTED SOLIDITY FEATURES\n\n**CRITICAL**: CashScript is stack-based, not storage-based. Many Solidity concepts do not exist.\n\n| Solidity Feature | CashScript | Notes |\n|-----------------|-----------|-------|\n| `import` | N/A | No code modularity - single file contracts only |\n| `interface/abstract` | N/A | No abstract contracts or interfaces |\n| `library` | N/A | No reusable library contracts |\n| `enum` | int constants | Use `int` values: `int PENDING = 0; int ACTIVE = 1;` |\n| `struct` | bytes + `.split()` | Pack data into bytes, unpack with split() |\n| `mapping` | NFT commitments | NO O(1) lookups - fundamentally different model |\n| `storage/memory/calldata` | N/A | Stack-based execution, no data locations |\n| `assert` | `require()` | Single error handler, no assert/revert distinction |\n| `revert` | `require()` | Transaction fails if require() is false |\n| `tx.origin` | N/A | No transaction originator - signature-based authorization |\n| `address` | `bytes20` or `pubkey` | Hash160 for addresses, pubkey for keys |\n| `constant` keyword | Literals only | Constructor params are immutable per UTXO |\n| `++/--/+=` | Manual operations | `x = x + 1;` not `x++;` |\n| `for/while` loops | `do {} while()` | Beta in v0.13.0, body executes first |\n\n**Key paradigm shifts:**\n- **No persistent state** - State lives in NFT commitments (40 bytes, 128 in May 2026)\n- **No O(1) lookups** - Must loop over UTXOs, no hash tables\n- **No code reuse** - No import/library/inheritance mechanisms\n- **Fee = tx size** - Cost based on bytes, not opcodes (no \"gas optimization\")",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "transaction",
      "bytes",
      "int",
      "UNSUPPORTED SOLIDITY FEATURES"
    ]
  },
  {
    "id": "language/language-reference.md-41",
    "content": "- **Stack-based** - All operations ephemeral, no storage slots\n\n## CONSTRAINTS\n\n### Compile-Time Errors\n- Type mismatch: `int x = \"text\";`\n- Invalid operation: `bool + int`\n- Undefined variable reference\n- Wrong function arity\n- Invalid type in operation: `string * int`\n\n### Runtime Failures\n- Division by zero: `int / 0`\n- Array out of bounds: `tx.outputs[i]` when `i >= tx.outputs.length`\n- Invalid signature format (non-NULLFAIL context)\n- Failed `require()` statement\n- Overflow/underflow (follows Bitcoin Script rules)\n- Invalid locking bytecode construction\n\n### Type System Rules\n- All variables must be explicitly typed\n- No implicit numeric conversions (`int` ↔ `string`)\n- Specialized types (`sig`, `pubkey`, `datasig`) auto-convert to `bytes`\n- Fixed-length types: `bytesN` where N ∈ [1, 64]\n- Collections: arrays limited (mainly `sig[]`, `pubkey[]` for checkMultiSig)\n- Tuples: only from `split()` operations\n\n### Operational Limits\n\n**VM Limits (May 2025 - ACTIVE):**\n- Stack element limit: 10,000 bytes (was 520 bytes)\n- 201-opcode limit: REMOVED, replaced by operation cost system\n- Operation cost budget: (41 + unlocking_bytecode_length) × 800\n- BigInt support: enabled for large number arithmetic\n\n**Other Limits:**\n- `tx.time` semantics: <500,000,000 = block height, ≥500,000,000 = Unix timestamp. Only use with `require(tx.time >= expr)`\n- `this.age` encoding: blocks only (SDK limitation, not 512-sec chunks). Only use with `require(this.age >= expr)`\n- Array access: ALWAYS validate `.length` before indexing",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "function",
      "bytes",
      "int",
      "string",
      "bool",
      "CONSTRAINTS",
      "Compile-Time Errors",
      "Runtime Failures",
      "Type System Rules",
      "Operational Limits"
    ]
  },
  {
    "id": "language/language-reference.md-42",
    "content": "- Integer arithmetic: no decimals, integer division only\n- `checkMultiSig`: NOT supported in TypeScript SDK (compile-time only)\n- NFT commitment: max 40 bytes (128 bytes in May 2026 upgrade)\n- String/bytes operations: `.split(index)` returns tuple, requires destructuring\n- Bitwise operators: Only `&`, `|`, `^` supported. NO shift (`<<`, `>>`) or invert (`~`)\n- Loops: `do {} while ()` syntax, beta in CashScript 0.13.0. Body executes at least once\n- Token category byte order: Returned in unreversed order\n- Compound assignment: NOT supported (`+=`, `-=`, etc.)\n\n### Best Practices for AI Agents\n- **DATA STORAGE**: Use NFT commitments for persistent state, NOT OP_RETURN (which is unspendable)\n- Always check array bounds before access\n- Use fixed-length types (`bytes20`, `bytes32`) for hash outputs\n- Validate inputs at function entry\n- Use `within(x, lower, upper)` for range checks (`x >= lower && x < upper`, upper is exclusive)\n- Use bitwise `&`, `|`, `^` for flag operations and masking\n- Store reused bytecode in variables vs. reconstructing\n- Extract common validation logic into separate contract functions\n- Check both `tx.time` and `this.age` for robust time locks\n- Validate token category AND amount for CashTokens\n- Use NULLFAIL behavior: empty sig `0x` returns false without failure\n\n## PROFESSIONAL CONTRACT DOCUMENTATION",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "string",
      "Best Practices for AI Agents",
      "PROFESSIONAL CONTRACT DOCUMENTATION"
    ]
  },
  {
    "id": "language/language-reference.md-43",
    "content": "## PROFESSIONAL CONTRACT DOCUMENTATION\n\n**MANDATORY**: ALL CashScript contracts MUST include professional documentation following BCHess production standards.\n\n### NFT STATE DOCUMENTATION BLOCK\n\n**Location**: BEFORE contract declaration\n**Format**:\n```cashscript\n/*  --- [ContractName] [Mutable/Immutable] NFT State ---\n    [type] [variableName] = [defaultValue]        // [optional comment]\n*/\n```\n\n**Rules**:\n- Use \"**Mutable**\" if contract modifies `nftCommitment` during execution\n- Use \"**Immutable**\" if contract has fixed parameters only (constructor params)\n- Use \"**none**\" if no NFT state exists in the contract\n- List ALL state variables with types and default values\n- Add inline comments for enum-style values\n\n**BCHess Examples**:\n\n```cashscript\n/*  --- ChessMaster Mutable NFT State ---\n    bytes8 turnCounter = 0x0000000000000000\n    byte deadKing = 0x00\n*/\n\n/*  --- Squares Mutable NFT State ---\n    byte startingTeam = 0x00\n    byte startingPiece = 0x00\n    bytes2 x = 0x0000\n    bytes2 y = 0x0000\n    byte team = 0x00            // 0x00 white, 0x01 black, 0x02 empty\n    byte pieceType = 0x00       // 0x01 pawn, 0x02 knight, 0x03 bishop, 0x04 rook, 0x05 queen, 0x06 king\n*/\n\n/*  --- King Immutable NFT State ---\n    none\n*/\n```\n\n**CashStarter Example**:\n```cashscript\n/*  --- Campaign Mutable NFT State ---\n    bytes4 pledgeCount = 0x00000000\n    bytes6 totalPledged = 0x000000000000        // Satoshis pledged\n    bytes4 deadline = 0x00000000                 // Block height deadline\n    byte status = 0x00                           // 0x00 active, 0x01 funded, 0x02 refunding\n*/\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "PROFESSIONAL CONTRACT DOCUMENTATION",
      "NFT STATE DOCUMENTATION BLOCK"
    ]
  },
  {
    "id": "language/language-reference.md-44",
    "content": "### FUNCTION DOCUMENTATION BLOCK\n\n**Location**: BEFORE each function declaration\n**Format**:\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  [Brief description of what the function does and why]\n//\n//inputs:\n//  [idx]   [Name]                [TYPE]      (from [source])\n//  ...\n//outputs:\n//  [idx]   [Name]                [TYPE]      (to [destination])\n//  ...\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction functionName(...) { }\n```\n\n**Separator Rules**:\n- Use forward slashes (`/`) for header and footer separators\n- **Dynamic length**: Minimum 78 characters, extend to match longest line if needed\n- Count from start of comment to end of longest input/output line\n- Maintain visual balance and readability\n\n**Column Alignment**:\n- **Index**: Position 4 after `//  ` (2 spaces after comment marker)\n- **Name**: Align at column ~30 (pad with spaces)\n- **Type**: Align at column ~42 (in brackets `[TYPE]`)\n- **Source/Destination**: After type, in parentheses\n\n**Index Notation**:\n- **Fixed positions**: `0`, `1`, `2`, `3`, etc. - Explicit numeric indexes\n- **Variable quantity**: `?` - Optional or variable number of inputs/outputs\n- **Last position**: `N` - Calculated last index (when total is variable)\n- **Ranges**: `2-65` - Multiple sequential UTXOs\n- **Optional elements**: Add `{optional}` tag to name\n\n**Type Annotations**:\n- `[NFT]` - Non-fungible token (CashTokens NFT)\n- `[BCH]` - Pure satoshi UTXO (no tokens)",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "function",
      "FUNCTION DOCUMENTATION BLOCK"
    ]
  },
  {
    "id": "language/language-reference.md-45",
    "content": "- `[FT]` - Fungible tokens (if applicable)\n\n**Source/Destination Notation**:\n- **Format**: `(from [location])` and `(to [location])`\n- **Locations**: Contract name, \"user\", \"P2PKH address\", etc.\n- **ALWAYS specify** - Never leave blank\n\n**BCHess Examples**:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Reset all squares to new game state.\n//\n//inputs:\n//  0       ChessMaster         [NFT]       (from ChessMaster contract)\n//  1       userBCH             [BCH]       (from user)\n//  2-65    Squares             [NFT]       (from Squares contract)\n//outputs:\n//  0       ChessMaster         [NFT]       (to ChessMaster contract)\n//  1       userBCH             [BCH]       (to user)\n//  2-65    Squares             [NFT]       (to Squares contract)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction reset() { ... }\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Move a piece, overwrites any existing piece on the destination square.\n//\n//inputs:\n//  0   userBCH                   [BCH]       (from user)\n//  1   PieceLogic                [NFT]       (from PieceLogic contract)\n//  2   ChessMaster               [NFT]       (from ChessMaster contract)\n//  3   SourceSquare              [NFT]       (from Squares contract)\n//  ?   CheckEmptySquare(s)       [NFT]       (from Squares contract)\n//  N   DestinationSquare         [NFT]       (from Squares contract)\n//outputs:\n//  0   userBCH                   [BCH]       (to user)\n//  1   PieceLogic                [NFT]       (to PieceLogic contract)\n//  2   ChessMaster               [NFT]       (to ChessMaster contract)\n//  3   SourceSquare              [NFT]       (to Squares contract)\n//  ?   CheckEmptySquare(s)       [NFT]       (to Squares contract)\n//  N   DestinationSquare         [NFT]       (to Squares contract)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction move() { ... }\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Check if a square is empty. Used with non-knight pieces that move multiple squares\n//  in a single move to verify they don't pass through other pieces.\n//\n//inputs:\n//  0   PieceNFT                  [NFT]       (from PieceLogic contract)\n//  1   ChessMasterNFT            [NFT]       (from ChessMaster contract)\n//  2   SourceSquare              [NFT]       (from Squares contract)\n//  ?   CheckEmptySquare(s)       [NFT]       (from Squares contract)\n//  3   DestinationSquare         [NFT]       (from Squares contract)\n//  4   userBCH                   [BCH]       (from user)\n//outputs:\n//  0   PieceNFT                  [NFT]       (to PieceLogic contract)\n//  1   ChessMasterNFT            [NFT]       (to ChessMaster contract)\n//  2   SourceSquare              [NFT]       (to Squares contract)\n//  3   DestinationSquare         [NFT]       (to Squares contract)\n//  4   change {optional}         [BCH]       (to user)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction checkEmpty() { ... }\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "p2pkh"
    ]
  },
  {
    "id": "language/language-reference.md-46",
    "content": "### COMPLETE CONTRACT TEMPLATE\n\n```cashscript\npragma cashscript ^0.13.0;\n\n/*  --- [ContractName] [Mutable/Immutable] NFT State ---\n    [type] [varName] = [default]        // [optional comment]\n*/\n\ncontract [ContractName]([constructorParams]) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  [Brief description of what this function does and why it's important]\n    //\n    //inputs:\n    //  [0]     [InputName1]            [TYPE]      (from [source])\n    //  [1]     [InputName2]            [TYPE]      (from [source])\n    //  [?]     [OptionalInputs]        [TYPE]      (from [source])\n    //  [N]     [LastInput]             [TYPE]      (from [source])\n    //outputs:\n    //  [0]     [OutputName1]           [TYPE]      (to [destination])\n    //  [1]     [OutputName2]           [TYPE]      (to [destination])\n    //  [N]     [LastOutput]            [TYPE]      (to [destination])\n    //  [?]     [change {optional}]     [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function functionName([params]) {\n        require(this.activeInputIndex == 0);        // Validate which input is executing\n        require(tx.inputs.length == 3);              // Fixed input count\n        require(tx.outputs.length >= 2);             // Variable output count\n\n        // Business logic with inline comments explaining WHY\n        bytes nftCommitment = tx.inputs[0].nftCommitment;\n        bytes4 counter = bytes4(nftCommitment.split(4)[0]);\n        int newCounter = int(counter) + 1;\n        require(newCounter < 2147483647);            // Prevent overflow\n\n        // Recreate NFT with updated state\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].nftCommitment == bytes4(newCounter) + restOfCommitment);\n        require(tx.outputs[0].value == 1000);        // Preserve dust\n    }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "COMPLETE CONTRACT TEMPLATE"
    ]
  },
  {
    "id": "language/language-reference.md-47",
    "content": "### MULTI-CONTRACT DOCUMENTATION PATTERNS\n\nWhen generating multi-contract systems, show clear UTXO flow between contracts:\n\n**Example: Voting System with 3 Contracts**\n\n```cashscript\n// ===== CONTRACT 1: VotingBooth (PRIMARY) =====\n/*  --- VotingBooth Mutable NFT State ---\n    bytes4 activeVotes = 0x00000000\n    byte votingOpen = 0x01\n*/\n\ncontract VotingBooth() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Cast a vote. Routes to appropriate ProposalCounter contract.\n    //\n    //inputs:\n    //  0   votingBoothNFT            [NFT]       (from VotingBooth contract)\n    //  1   voterAuth                 [BCH]       (from user)\n    //  2   proposalCounter           [NFT]       (from ProposalCounter contract)\n    //outputs:\n    //  0   votingBoothNFT            [NFT]       (to VotingBooth contract)\n    //  1   voterAuth                 [BCH]       (to user)\n    //  2   proposalCounter           [NFT]       (to ProposalCounter contract)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function vote(int proposalId) { ... }\n}\n\n// ===== CONTRACT 2: ProposalCounter (HELPER) =====\n/*  --- ProposalCounter Mutable NFT State ---\n    bytes4 proposalId = 0x00000000\n    bytes4 voteCount = 0x00000000\n    bytes32 proposalName = 0x00...\n*/\n\ncontract ProposalCounter() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Increment vote count for this proposal.\n    //\n    //inputs:\n    //  0   proposalNFT               [NFT]       (from ProposalCounter contract)\n    //  1   votingBoothNFT            [NFT]       (from VotingBooth contract)\n    //  2   voterAuth                 [BCH]       (from user)\n    //outputs:\n    //  0   proposalNFT               [NFT]       (to ProposalCounter contract)\n    //  1   votingBoothNFT            [NFT]       (to VotingBooth contract)\n    //  2   voterAuth                 [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function increment() { ... }\n}\n\n// ===== CONTRACT 3: VoterRegistry (STATE) =====\n/*  --- VoterRegistry Mutable NFT State ---\n    bytes voterList = 0x                // Packed list of voter PKHs (20 bytes each)\n*/\n\ncontract VoterRegistry() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Add a new eligible voter to the registry.\n    //\n    //inputs:\n    //  0   registryNFT               [NFT]       (from VoterRegistry contract)\n    //  1   adminAuth                 [BCH]       (from admin)\n    //outputs:\n    //  0   registryNFT               [NFT]       (to VoterRegistry contract)\n    //  1   adminAuth                 [BCH]       (to admin)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function addVoter(bytes20 voterPkh) { ... }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "MULTI-CONTRACT DOCUMENTATION PATTERNS"
    ]
  },
  {
    "id": "language/language-reference.md-48",
    "content": "**Example: CashStarter Crowdfunding with 6 Contracts**\n\n```cashscript\n// ===== CONTRACT 1: Manager (PRIMARY) =====\n/*  --- Manager Mutable NFT State ---\n    bytes4 campaignCount = 0x00000000\n    bytes20 adminPkh = 0x0000000000000000000000000000000000000000\n*/\n\ncontract Manager(bytes32 mainContractAddress) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Initialize a new crowdfunding campaign. Creates campaign NFT in Main contract.\n    //\n    //inputs:\n    //  0   managerNFT                [NFT]       (from Manager contract)\n    //  1   creatorBCH                [BCH]       (from campaign creator)\n    //outputs:\n    //  0   managerNFT                [NFT]       (to Manager contract)\n    //  1   campaignNFT               [NFT]       (to Main contract)\n    //  2   serviceFee {optional}     [BCH]       (to service provider)\n    //  ?   change {optional}         [BCH]       (to campaign creator)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function initialize(int goal, int deadline, bytes20 servicePkh, int serviceFee) { ... }\n}\n\n// ===== CONTRACT 2: Main (PRIMARY) =====\n/*  --- Campaign Mutable NFT State ---\n    bytes5 campaignId = 0x0000000000\n    bytes6 goalAmount = 0x000000000000\n    bytes4 deadline = 0x00000000                 // Block height deadline\n    bytes4 pledgeCount = 0x00000000\n    bytes6 totalPledged = 0x000000000000\n    byte status = 0x00                           // 0x00 active, 0x01 funded, 0x02 cancelled\n    bytes20 creatorPkh = 0x0000000000000000000000000000000000000000\n*/\n\ncontract Main() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Accept a pledge from a backer. Issues an immutable receipt NFT as proof.\n    //\n    //inputs:\n    //  0   campaignNFT               [NFT]       (from Main contract)\n    //  1   backerBCH                 [BCH]       (from backer)\n    //outputs:\n    //  0   campaignNFT               [NFT]       (to Main contract)\n    //  1   pledgeReceipt             [NFT]       (to backer)\n    //  2   change {optional}         [BCH]       (to backer)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function pledge(bytes20 backerPkh, int pledgeAmount) { ... }\n}\n\n// ===== CONTRACT 3: Cancel (HELPER) =====\n/*  --- CancelHelper Immutable NFT State ---\n    bytes5 sentinelId = 0xFFFFFFFFFF           // Sentinel value identifying helper master\n*/\n\ncontract Cancel() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Cancel a campaign before deadline. Burns campaign NFT if no pledges exist.\n    //\n    //inputs:\n    //  0   cancelMasterNFT           [NFT]       (from Cancel contract)\n    //  1   campaignNFT               [NFT]       (from Main contract)\n    //  2   creatorBCH                [BCH]       (from campaign creator)\n    //outputs:\n    //  0   cancelMasterNFT           [NFT]       (to Cancel contract)\n    //  1   campaignNFT {if pledges}  [NFT]       (to Main contract)\n    //  ?   creatorRefund             [BCH]       (to campaign creator)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function cancel() { ... }\n}\n\n// ===== CONTRACT 4: Claim (HELPER) =====\n/*  --- ClaimHelper Immutable NFT State ---\n    bytes5 sentinelId = 0xFFFFFFFFFF\n*/\n\ncontract Claim() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Claim successful campaign funds after reaching goal and passing deadline.\n    //\n    //inputs:\n    //  0   claimMasterNFT            [NFT]       (from Claim contract)\n    //  1   campaignNFT               [NFT]       (from Main contract)\n    //  2   creatorBCH                [BCH]       (from campaign creator)\n    //outputs:\n    //  0   claimMasterNFT            [NFT]       (to Claim contract)\n    //  1   campaignFunds             [BCH]       (to campaign creator)\n    //  2   serviceFee {optional}     [BCH]       (to service provider)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function claim(bytes20 servicePkh, int serviceFee) { ... }\n}\n\n// ===== CONTRACT 5: Refund (HELPER) =====\n/*  --- RefundHelper Immutable NFT State ---\n    bytes5 sentinelId = 0xFFFFFFFFFF\n*/\n\ncontract Refund() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Refund a backer after campaign failure. Validates receipt NFT authenticity.\n    //\n    //inputs:\n    //  0   refundMasterNFT           [NFT]       (from Refund contract)\n    //  1   campaignNFT               [NFT]       (from Main contract)\n    //  2   pledgeReceipt             [NFT]       (from backer)\n    //  3   backerBCH                 [BCH]       (from backer)\n    //outputs:\n    //  0   refundMasterNFT           [NFT]       (to Refund contract)\n    //  1   campaignNFT               [NFT]       (to Main contract)\n    //  2   refundPayment             [BCH]       (to backer)\n    //  3   change {optional}         [BCH]       (to backer)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function refund() { ... }\n}\n\n// ===== CONTRACT 6: Stop (HELPER) =====\n/*  --- StopHelper Immutable NFT State ---\n    bytes5 sentinelId = 0xFFFFFFFFFF\n*/\n\ncontract Stop() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Stop a campaign after deadline passes without reaching goal.\n    //\n    //inputs:\n    //  0   stopMasterNFT             [NFT]       (from Stop contract)\n    //  1   campaignNFT               [NFT]       (from Main contract)\n    //  2   creatorBCH                [BCH]       (from campaign creator)\n    //outputs:\n    //  0   stopMasterNFT             [NFT]       (to Stop contract)\n    //  1   campaignNFT {if pledges}  [NFT]       (to Main contract)\n    //  ?   creatorRefund             [BCH]       (to campaign creator)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function stop() { ... }\n}\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "language/language-reference.md-49",
    "content": "**CashStarter System Architecture**:\n- **Manager**: Creates new campaigns (primary initialization contract)\n- **Main**: Core campaign logic (pledge acceptance)\n- **Cancel/Claim/Refund/Stop**: Each helper has its own masterNFT with sentinel ID (0xFFFFFFFFFF)\n- **UTXO Flow**: Helper contracts validate Main contract's minting NFT, enabling trustless cross-contract operations\n- **Receipt Pattern**: Pledge function creates immutable NFT receipts for later refund validation\n\n### COMMON PATTERNS BY USE CASE\n\n**Simple Token Contract (Single UTXO)**:\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Transfer tokens to a new owner.\n//\n//inputs:\n//  0   tokenNFT                  [NFT]       (from Token contract)\n//  1   ownerAuth                 [BCH]       (from current owner)\n//outputs:\n//  0   tokenNFT                  [NFT]       (to Token contract)\n//  1   change {optional}         [BCH]       (to current owner)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction transfer(bytes20 newOwner) { ... }\n```\n\n**Crowdfunding (Variable Pledges)**:\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Accept a new pledge from a backer. Updates campaign state.\n//\n//inputs:\n//  0   campaignNFT               [NFT]       (from Campaign contract)\n//  1   pledge                    [BCH]       (from backer)\n//outputs:\n//  0   campaignNFT               [NFT]       (to Campaign contract)\n//  1   pledgeReceipt             [NFT]       (to backer)\n//  2   change {optional}         [BCH]       (to backer)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction pledge(bytes20 backerPkh) { ... }\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "COMMON PATTERNS BY USE CASE"
    ]
  },
  {
    "id": "language/language-reference.md-50",
    "content": "**Time-Locked Release**:\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Release funds after deadline. Requires time validation.\n//\n//inputs:\n//  0   lockedFunds               [BCH]       (from TimeRelease contract)\n//outputs:\n//  0   releasedFunds             [BCH]       (to beneficiary)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction release() {\n    require(tx.time >= deadline);               // Enforce time lock\n    ...\n}\n```\n\n**Batch Operations (Variable Inputs)**:\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Process multiple NFTs in a single transaction for gas efficiency.\n//\n//inputs:\n//  0       masterNFT             [NFT]       (from Master contract)\n//  1-N     batchNFTs             [NFT]       (from Batch contract)\n//outputs:\n//  0       masterNFT             [NFT]       (to Master contract)\n//  1-N     batchNFTs             [NFT]       (to Batch contract)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction batchProcess() {\n    require(tx.inputs.length >= 2);             // At least master + 1 batch\n    require(tx.inputs.length <= 66);            // Max 65 batch items\n    ...\n}\n```\n\n### INLINE CODE COMMENTS\n\nIn addition to input/output documentation, include inline comments explaining:\n\n**Validation Logic**:\n```cashscript\nrequire(tx.inputs[0].tokenCategory == campaignCategory);    // Verify correct campaign\nrequire(int(weight) > 0);                                    // Must have voting rights\nrequire(voted == 0x00);                                      // Hasn't voted yet\n```",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "INLINE CODE COMMENTS"
    ]
  },
  {
    "id": "language/language-reference.md-51",
    "content": "**State Transitions**:\n```cashscript\nbytes4 currentCount = bytes4(commitment.split(4)[0]);       // Extract counter\nint newCount = int(currentCount) + 1;                       // Increment\nrequire(newCount <= 2147483647);                             // Max bytes4 (MSB safety)\n```\n\n**Mathematical Operations**:\n```cashscript\nint feeAmount = pledgeValue / 100;                          // 1% fee\nrequire(feeAmount <= 10000);                                 // Max 10k sat fee cap\nint netPledge = pledgeValue - feeAmount;                    // After fee deduction\n```\n\n**NFT Recreation**:\n```cashscript\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);    // Same contract\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);        // Same category\nrequire(tx.outputs[0].value == 1000);                                      // Preserve dust\n```\n\n### DOCUMENTATION QUALITY CHECKLIST\n\nBefore finalizing any contract, verify:\n\n- [ ] NFT state block present and accurate (Mutable/Immutable/none)\n- [ ] All state variables listed with types and defaults\n- [ ] All functions have input/output documentation\n- [ ] Separator length appropriate (78+ chars, matches content)\n- [ ] Column alignment correct (index @4, name @30, type @42)\n- [ ] Index notation appropriate (0-N, ?, ranges)\n- [ ] All inputs have type annotations ([NFT], [BCH], [FT])\n- [ ] All inputs have source specification (from X)\n- [ ] All outputs have destination specification (to X)\n- [ ] Optional outputs marked with {optional}",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "int",
      "DOCUMENTATION QUALITY CHECKLIST"
    ]
  },
  {
    "id": "language/language-reference.md-52",
    "content": "- [ ] Function description explains WHAT and WHY\n- [ ] Inline comments explain validation logic\n- [ ] Multi-contract systems show clear UTXO flow\n- [ ] Consistent terminology across related contracts\n\n**MANDATORY FOR ALL CONTRACTS**: Every generated CashScript contract must meet ALL these documentation standards before being returned to the user.\n\n## CONTRACT DESIGN PRINCIPLES",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "CONTRACT DESIGN PRINCIPLES"
    ]
  },
  {
    "id": "language/language-reference.md-53",
    "content": "## CONTRACT DESIGN PRINCIPLES\n\n### The Validation Rule\n\n**Before creating ANY contract, answer: \"What does this contract validate?\"**\n\nEvery CashScript contract exists to add CONSTRAINTS to a transaction. If a contract adds no constraints, it should not exist.\n\n**Questions to ask:**\n1. What would go wrong if this contract didn't exist?\n2. What relationship does this contract prove?\n3. What attack does this contract's validation prevent?\n\nIf you cannot answer these questions, the contract should be deleted or merged into another.\n\n### The Minimum Viable Contract\n\nThe smallest legitimate contract is NOT empty. Even a \"sidecar\" contract has real validation:\n\n```cashscript\ncontract MinimumViableContract() {\n    function attach() {\n        int mainIdx = this.activeInputIndex - 1;\n\n        // VALIDATES: Same-transaction origin\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIdx].outpointTransactionHash);\n\n        // VALIDATES: Sequential creation\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIdx].outpointIndex + 1);\n\n        // VALIDATES: Self-preservation\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n    }\n}\n```\n\nThis is NOT a placeholder - it validates three critical relationships.\n\n### What Each Contract Type Validates\n\n| Contract Type | Core Validation Purpose |\n|--------------|------------------------|",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "CONTRACT DESIGN PRINCIPLES",
      "The Validation Rule",
      "The Minimum Viable Contract",
      "What Each Contract Type Validates"
    ]
  },
  {
    "id": "language/language-reference.md-54",
    "content": "| **Main Contract** | State transitions, business logic |\n| **Sidecar Contract** | Same-origin bond with main |\n| **Function Contract** | Authority to execute specific operation |\n| **Router Contract** | Transaction structure matches operation |\n| **Oracle Contract** | External data authenticity |\n| **Receipt/Proof Contract** | Immutable record of completed action |\n\n### Anti-Placeholder Philosophy\n\n**OLD THINKING** (wrong): \"I need to implement this Solidity function in CashScript\"\n\n**NEW THINKING** (correct): \"What constraint does this contract add to valid transactions?\"\n\nThe shift is from:\n- ~~Code structure~~ -> **Transaction structure**\n- ~~Function implementation~~ -> **Constraint specification**\n- ~~What code runs~~ -> **What must be true**\n\n### Empty Contracts = Code Smell\n\nIf you find yourself writing:\n- A function with no `require()` statements\n- A contract that just \"exists\"\n- Logic that \"will be implemented later\"\n\n**STOP.** Ask: \"What does this validate?\" If nothing, delete it.\n\n### The Output Count Rule\n\n**CRITICAL**: Every contract MUST limit output count to prevent unauthorized minting.\n\n```cashscript\nfunction anyOperation() {\n    // ALWAYS include this\n    require(tx.outputs.length <= 7);  // Appropriate limit for operation\n\n    // ... rest of logic\n}\n```\n\nWithout this, attackers can add arbitrary outputs minting unauthorized tokens.\n\n### Validation Checklist\n\nBefore any contract is complete, verify it has:\n\n- [ ] At least one meaningful `require()` statement",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Anti-Placeholder Philosophy",
      "Empty Contracts = Code Smell",
      "The Output Count Rule",
      "Validation Checklist"
    ]
  },
  {
    "id": "language/language-reference.md-55",
    "content": "- [ ] Input position validation (`this.activeInputIndex == N`)\n- [ ] Output count limit (`tx.outputs.length <= N`)\n- [ ] Self-replication validation (if covenant)\n- [ ] Cross-contract authentication (if multi-contract)\n\n### The Contract Purpose Test\n\nFor every contract, complete this sentence:\n\n**\"This contract validates that _______________.\"**\n\nExamples:\n- \"This contract validates that the sidecar was created in the same transaction as the main contract.\"\n- \"This contract validates that only authorized function NFTs can trigger state changes.\"\n- \"This contract validates that the price data was signed by the oracle.\"\n- \"This contract validates that output count cannot exceed 5 to prevent minting attacks.\"\n\nIf you cannot complete the sentence, the contract should not exist.",
    "source": "language/language-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "The Contract Purpose Test"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-0",
    "content": "# CashScript SDK: Contract Instantiation\n\n## Overview\n\nThe CashScript SDK provides a JavaScript/TypeScript interface for interacting with CashScript contracts. Contract instantiation is the process of creating a contract instance from a compiled artifact.\n\n## Installation",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "CashScript SDK: Contract Instantiation",
      "Overview",
      "Installation"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-1",
    "content": "## Installation\n\n```bash\n# Install the SDK\nnpm install cashscript\n\n# Install the compiler (optional, for compilation)\nnpm install -g cashc\n```\n\n## Basic Contract Instantiation\n\n### 1. Contract Class\n\nThe `Contract` class represents a CashScript contract instance.\n\n```javascript\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\n\nconst contract = new Contract(artifact, constructorArgs, options);\n```\n\n### 2. Constructor Parameters\n\n```javascript\nnew Contract(\n    artifact,           // Compiled contract artifact\n    constructorArgs,    // Constructor arguments array\n    options?           // Optional configuration\n)\n```\n\n## Contract Artifacts",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Installation",
      "Install the SDK",
      "Install the compiler (optional, for compilation)",
      "Basic Contract Instantiation",
      "1. Contract Class",
      "2. Constructor Parameters",
      "Contract Artifacts"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-2",
    "content": "## Contract Artifacts\n\n### Compilation Methods\n\n#### Method 1: CLI Compilation\n\n```bash\n# Compile to JSON\ncashc contract.cash\n\n# Compile to TypeScript\ncashc --format ts contract.cash\n```\n\n#### Method 2: Programmatic Compilation\n\n```javascript\nimport { compileFile, compileString } from 'cashc';\n\n// Compile from file\nconst artifact = compileFile('path/to/contract.cash');\n\n// Compile from string\nconst contractCode = `\n    pragma cashscript ^0.12.1;\n    contract SimpleContract(pubkey owner) {\n        function spend(sig ownerSig) {\n            require(checkSig(ownerSig, owner));\n        }\n    }\n`;\nconst artifact = compileString(contractCode);\n```\n\n#### Method 3: Import JSON Artifact\n\n```javascript\nimport artifact from './contract.json' with { type: 'json' };\n```\n\n## Network Providers",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "string",
      "Contract Artifacts",
      "Compilation Methods",
      "Method 1: CLI Compilation",
      "Compile to JSON",
      "Compile to TypeScript",
      "Method 2: Programmatic Compilation",
      "Method 3: Import JSON Artifact",
      "Network Providers"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-3",
    "content": "## Network Providers\n\n### ElectrumNetworkProvider\n\nDefault network provider for Bitcoin Cash.\n\n```javascript\nimport { ElectrumNetworkProvider } from 'cashscript';\n\n// Mainnet\nconst provider = new ElectrumNetworkProvider('mainnet');\n\n// Testnet (Chipnet)\nconst provider = new ElectrumNetworkProvider('chipnet');\n\n// Custom server\nconst provider = new ElectrumNetworkProvider('mainnet', 'fulcrum.example.com');\n```\n\n### Custom Provider Options\n\n```javascript\nconst provider = new ElectrumNetworkProvider('mainnet', {\n    servers: ['electrum.example.com:50001'],\n    timeout: 10000,\n    retries: 3\n});\n```\n\n## Contract Options",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Network Providers",
      "ElectrumNetworkProvider",
      "Custom Provider Options",
      "Contract Options"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-4",
    "content": "## Contract Options\n\n### Address Type\n\n```javascript\nconst options = {\n    provider: provider,\n    addressType: 'p2sh32'  // or 'p2sh20' or 'p2s'\n};\n```\n\n**Address Types:**\n- `p2sh32`: SHA-256 hash (default, more secure)\n- `p2sh20`: RIPEMD-160 hash (less secure, legacy)\n- `p2s`: Pay to Script - direct script usage without hashing (more efficient, standard)\n\n## Complete Examples",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Contract Options",
      "Address Type",
      "Complete Examples"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-5",
    "content": "## Complete Examples\n\n### Simple Contract\n\n```javascript\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\nimport { compileFile } from 'cashc';\n\n// Compile contract\nconst artifact = compileFile('simple.cash');\n\n// Create provider\nconst provider = new ElectrumNetworkProvider('mainnet');\n\n// Constructor arguments\nconst ownerPubkey = Buffer.from('03...', 'hex');\nconst constructorArgs = [ownerPubkey];\n\n// Create contract instance\nconst contract = new Contract(artifact, constructorArgs, { provider });\n\nconsole.log('Contract address:', contract.address);\nconsole.log('Contract balance:', await contract.getBalance());\n```\n\n### Multi-Parameter Contract\n\n```javascript\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\nimport artifact from './escrow.json' with { type: 'json' };\n\nconst provider = new ElectrumNetworkProvider('mainnet');\n\n// Multiple constructor parameters\nconst buyerPubkey = Buffer.from('03...', 'hex');\nconst sellerPubkey = Buffer.from('02...', 'hex');\nconst arbiterPubkey = Buffer.from('03...', 'hex');\nconst escrowAmount = 1000000n;  // 0.01 BCH in satoshis\n\nconst constructorArgs = [\n    buyerPubkey,\n    sellerPubkey,\n    arbiterPubkey,\n    escrowAmount\n];\n\nconst contract = new Contract(artifact, constructorArgs, { provider });\n```\n\n### TypeScript Contract\n\n```javascript\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\nimport { P2PKH } from './p2pkh.js';  // TypeScript artifact\n\nconst provider = new ElectrumNetworkProvider('mainnet');\nconst ownerPkh = Buffer.from('14...', 'hex');  // 20-byte pubkey hash\n\nconst contract = new Contract(P2PKH, [ownerPkh], { provider });\n```",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "p2pkh",
      "Complete Examples",
      "Simple Contract",
      "Multi-Parameter Contract",
      "TypeScript Contract"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-6",
    "content": "## Contract Properties\n\n### Basic Properties\n\n```javascript\nconst contract = new Contract(artifact, constructorArgs, { provider });\n\n// Contract address\nconsole.log('Address:', contract.address);\n\n// Contract bytecode\nconsole.log('Bytecode:', contract.bytecode);\n\n// Contract byte size\nconsole.log('Size:', contract.bytesize);\n\n// Contract functions\nconsole.log('Functions:', Object.keys(contract.functions));\n```\n\n### Balance and UTXOs\n\n```javascript\n// Get balance\nconst balance = await contract.getBalance();\nconsole.log('Balance:', balance, 'satoshis');\n\n// Get UTXOs\nconst utxos = await contract.getUtxos();\nconsole.log('UTXOs:', utxos.length);\n\n// Get specific UTXO\nconst utxo = utxos[0];\nconsole.log('UTXO value:', utxo.satoshis);\nconsole.log('UTXO txid:', utxo.txid);\n```\n\n## Error Handling",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Contract Properties",
      "Basic Properties",
      "Balance and UTXOs",
      "Error Handling"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-7",
    "content": "## Error Handling\n\n### Compilation Errors\n\n```javascript\ntry {\n    const artifact = compileFile('invalid.cash');\n} catch (error) {\n    console.error('Compilation error:', error.message);\n}\n```\n\n### Network Errors\n\n```javascript\ntry {\n    const balance = await contract.getBalance();\n} catch (error) {\n    console.error('Network error:', error.message);\n}\n```\n\n### Parameter Validation\n\n```javascript\ntry {\n    const contract = new Contract(artifact, invalidArgs, { provider });\n} catch (error) {\n    console.error('Parameter error:', error.message);\n}\n```\n\n## Advanced Patterns",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Error Handling",
      "Compilation Errors",
      "Network Errors",
      "Parameter Validation",
      "Advanced Patterns"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-8",
    "content": "## Advanced Patterns\n\n### Contract Factory\n\n```javascript\nclass ContractFactory {\n    constructor(artifact, provider) {\n        this.artifact = artifact;\n        this.provider = provider;\n    }\n    \n    createContract(constructorArgs) {\n        return new Contract(this.artifact, constructorArgs, {\n            provider: this.provider\n        });\n    }\n}\n\nconst factory = new ContractFactory(artifact, provider);\nconst contract1 = factory.createContract([pubkey1]);\nconst contract2 = factory.createContract([pubkey2]);\n```\n\n### Dynamic Contract Creation\n\n```javascript\nfunction createTimeLockContract(owner, lockTime) {\n    const artifact = compileString(`\n        pragma cashscript ^0.12.1;\n        contract TimeLock(pubkey owner, int lockTime) {\n            function spend(sig ownerSig) {\n                require(checkSig(ownerSig, owner));\n                require(tx.time >= lockTime);\n            }\n        }\n    `);\n    \n    return new Contract(artifact, [owner, lockTime], { provider });\n}\n\nconst contract = createTimeLockContract(ownerPubkey, 1640995200);\n```\n\n### Contract Monitoring\n\n```javascript\nclass ContractMonitor {\n    constructor(contract) {\n        this.contract = contract;\n    }\n    \n    async checkStatus() {\n        const balance = await this.contract.getBalance();\n        const utxos = await this.contract.getUtxos();\n        \n        return {\n            address: this.contract.address,\n            balance: balance,\n            utxoCount: utxos.length,\n            lastUpdate: new Date()\n        };\n    }\n    \n    async startMonitoring(interval = 60000) {\n        setInterval(async () => {\n            const status = await this.checkStatus();\n            console.log('Contract status:', status);\n        }, interval);\n    }\n}\n\nconst monitor = new ContractMonitor(contract);\nawait monitor.startMonitoring();\n```",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "Advanced Patterns",
      "Contract Factory",
      "Dynamic Contract Creation",
      "Contract Monitoring"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-9",
    "content": "## Best Practices\n\n### 1. Provider Management\n\n```javascript\n// Reuse provider instances\nconst provider = new ElectrumNetworkProvider('mainnet');\n\n// Multiple contracts with same provider\nconst contract1 = new Contract(artifact1, args1, { provider });\nconst contract2 = new Contract(artifact2, args2, { provider });\n```\n\n### 2. Error Handling\n\n```javascript\nasync function createContractSafely(artifact, args) {\n    try {\n        const provider = new ElectrumNetworkProvider('mainnet');\n        const contract = new Contract(artifact, args, { provider });\n        \n        // Validate contract\n        await contract.getBalance();\n        \n        return contract;\n    } catch (error) {\n        console.error('Contract creation failed:', error.message);\n        throw error;\n    }\n}\n```\n\n### 3. Type Safety\n\n```javascript\n// Use TypeScript for better type safety\nimport { Contract, ElectrumNetworkProvider } from 'cashscript';\nimport type { Artifact } from 'cashscript';\n\nfunction createTypedContract(\n    artifact: Artifact,\n    args: any[],\n    network: 'mainnet' | 'chipnet' = 'mainnet'\n): Contract {\n    const provider = new ElectrumNetworkProvider(network);\n    return new Contract(artifact, args, { provider });\n}\n```\n\n### 4. Configuration Management\n\n```javascript\nconst config = {\n    network: process.env.NETWORK || 'mainnet',\n    addressType: 'p2sh32',\n    timeout: 30000\n};\n\nconst provider = new ElectrumNetworkProvider(config.network);\nconst contract = new Contract(artifact, args, {\n    provider,\n    addressType: config.addressType\n});\n```",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Best Practices",
      "1. Provider Management",
      "2. Error Handling",
      "3. Type Safety",
      "4. Configuration Management"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-10",
    "content": "## Common Patterns\n\n### Contract Deployment Helper\n\n```javascript\nasync function deployContract(artifact, constructorArgs, initialFunding = 0) {\n    const provider = new ElectrumNetworkProvider('mainnet');\n    const contract = new Contract(artifact, constructorArgs, { provider });\n    \n    if (initialFunding > 0) {\n        // Fund contract logic would go here\n        console.log(`Contract ${contract.address} needs ${initialFunding} satoshis`);\n    }\n    \n    return contract;\n}\n```\n\n### Multi-Network Support\n\n```javascript\nclass NetworkManager {\n    constructor() {\n        this.providers = {\n            mainnet: new ElectrumNetworkProvider('mainnet'),\n            testnet: new ElectrumNetworkProvider('chipnet')\n        };\n    }\n    \n    createContract(network, artifact, args) {\n        const provider = this.providers[network];\n        if (!provider) {\n            throw new Error(`Unsupported network: ${network}`);\n        }\n        \n        return new Contract(artifact, args, { provider });\n    }\n}\n```\n\n### Contract Validation\n\n```javascript\nasync function validateContract(contract) {\n    try {\n        // Check if contract is accessible\n        await contract.getBalance();\n        \n        // Validate contract structure\n        if (!contract.address) {\n            throw new Error('Invalid contract address');\n        }\n        \n        if (!contract.functions || Object.keys(contract.functions).length === 0) {\n            throw new Error('Contract has no functions');\n        }\n        \n        return true;\n    } catch (error) {\n        console.error('Contract validation failed:', error.message);\n        return false;\n    }\n}\n```",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Common Patterns",
      "Contract Deployment Helper",
      "Multi-Network Support",
      "Contract Validation"
    ]
  },
  {
    "id": "sdk/contracts/contract-instantiation.md-11",
    "content": "## Troubleshooting\n\n### Common Issues\n\n1. **Network Connection**: Ensure network connectivity to Electrum servers\n2. **Invalid Arguments**: Check constructor argument types and order\n3. **Compilation Errors**: Verify contract syntax and CashScript version\n4. **Provider Issues**: Try different Electrum servers if connection fails\n\n### Debug Information\n\n```javascript\nconst contract = new Contract(artifact, args, { provider });\n\nconsole.log('Contract Debug Info:');\nconsole.log('- Address:', contract.address);\nconsole.log('- Bytecode length:', contract.bytecode.length);\nconsole.log('- Functions:', Object.keys(contract.functions));\nconsole.log('- Provider network:', provider.network);\n```\n\nThis comprehensive guide covers all aspects of CashScript contract instantiation, from basic setup to advanced patterns and troubleshooting.",
    "source": "sdk/contracts/contract-instantiation.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "Troubleshooting",
      "Common Issues",
      "Debug Information"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-0",
    "content": "# CashScript SDK: Transaction Building\n\n## Overview\n\nThe CashScript SDK provides powerful transaction building capabilities for interacting with smart contracts. This includes constructing transactions, managing inputs and outputs, handling fees, and broadcasting to the network.\n\n## Transaction Building Methods",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "transaction",
      "CashScript SDK: Transaction Building",
      "Overview",
      "Transaction Building Methods"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-1",
    "content": "## Transaction Building Methods\n\n### 1. Function-Based Transaction Building\n\nThe primary method for building transactions is through contract functions.\n\n```javascript\nconst txDetails = await contract.functions\n    .functionName(arg1, arg2, ...)\n    .to(address, amount)\n    .send();\n```\n\n### 2. Advanced Transaction Builder\n\nFor more complex transactions, use the `TransactionBuilder` class.\n\n```javascript\nimport { TransactionBuilder } from 'cashscript';\n\nconst txDetails = await new TransactionBuilder({ provider })\n    .addInput(utxo, unlockingScript)\n    .addOutput({ to: address, amount: amount })\n    .send();\n```\n\n### Pay to Script (P2S) Support\n\nBitcoin Cash supports Pay to Script (P2S) outputs, allowing direct script usage without hashing overhead. P2S becomes standard in the May 2026 upgrade and reduces transaction size by 23-35 bytes per output compared to P2SH. The unlocking bytecode limit unifies to 10,000 bytes in May 2026, enabling complex contract logic.\n\n## Basic Transaction Building",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "Transaction Building Methods",
      "1. Function-Based Transaction Building",
      "2. Advanced Transaction Builder",
      "Pay to Script (P2S) Support",
      "Basic Transaction Building"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-2",
    "content": "## Basic Transaction Building\n\n### Simple Transfer\n\n```javascript\nimport { Contract, ElectrumNetworkProvider, SignatureTemplate } from 'cashscript';\n\nconst provider = new ElectrumNetworkProvider('mainnet');\nconst contract = new Contract(artifact, constructorArgs, { provider });\n\n// Create signature template\nconst privateKey = 'your-private-key-here';\nconst sigTemplate = new SignatureTemplate(privateKey);\n\n// Build and send transaction\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to('bitcoincash:qr7gmtgmvsdtuwcskladnsrqrzf24td68qxg9rsqca', 100000n)\n    .send();\n\nconsole.log('Transaction ID:', txDetails.txid);\n```\n\n### Multi-Output Transaction\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to('bitcoincash:qr7gmtgmvsdtuwcskladnsrqrzf24td68qxg9rsqca', 50000n)\n    .to('bitcoincash:qrhea03074073ff3zv9whh0nggxc7k03ssh8jv9mkx', 30000n)\n    .send();\n```\n\n## Transaction Options",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Basic Transaction Building",
      "Simple Transfer",
      "Multi-Output Transaction",
      "Transaction Options"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-3",
    "content": "## Transaction Options\n\n### Fee Management\n\n#### Default Fee Rate\n\n```javascript\n// Uses default fee rate (1.0 sat/byte)\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .send();\n```\n\n#### Custom Fee Rate\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withFeePerByte(2.0)  // 2 sat/byte\n    .send();\n```\n\n#### Hardcoded Fee\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withHardcodedFee(1000n)  // 1000 satoshis\n    .send();\n```\n\n### Change Management\n\n#### Minimum Change\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withMinChange(5000n)  // Minimum 5000 sat change\n    .send();\n```\n\n#### No Change Output\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withoutChange()\n    .send();\n```\n\n### Input Selection\n\n#### Automatic Input Selection\n\n```javascript\n// SDK automatically selects UTXOs\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .send();\n```\n\n#### Manual Input Selection\n\n```javascript\nconst utxos = await contract.getUtxos();\nconst selectedUtxo = utxos[0];\n\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .from(selectedUtxo)\n    .to(address, amount)\n    .send();\n```\n\n## Advanced Transaction Building",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Transaction Options",
      "Fee Management",
      "Default Fee Rate",
      "Custom Fee Rate",
      "Hardcoded Fee",
      "Change Management",
      "Minimum Change",
      "No Change Output",
      "Input Selection",
      "Automatic Input Selection",
      "Manual Input Selection",
      "Advanced Transaction Building"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-4",
    "content": "## Advanced Transaction Building\n\n### Using TransactionBuilder\n\n```javascript\nimport { TransactionBuilder, SignatureTemplate } from 'cashscript';\n\nconst provider = new ElectrumNetworkProvider('mainnet');\nconst sigTemplate = new SignatureTemplate(privateKey);\n\nconst txDetails = await new TransactionBuilder({ provider })\n    .addInput(contractUtxo, contract.unlock.spend(sigTemplate))\n    .addOutput({\n        to: 'bitcoincash:qr7gmtgmvsdtuwcskladnsrqrzf24td68qxg9rsqca',\n        amount: 50000n\n    })\n    .addOutput({\n        to: 'bitcoincash:qrhea03074073ff3zv9whh0nggxc7k03ssh8jv9mkx',\n        amount: 30000n\n    })\n    .setMaxFee(2000n)\n    .send();\n```\n\n### P2PKH Input Integration\n\n```javascript\nconst aliceUtxos = await provider.getUtxos(aliceAddress);\nconst aliceTemplate = new SignatureTemplate(alicePrivateKey);\n\nconst txDetails = await new TransactionBuilder({ provider })\n    .addInput(contractUtxo, contract.unlock.spend(contractSig))\n    .addInput(aliceUtxos[0], aliceTemplate.unlockP2PKH())\n    .addOutput({ to: bobAddress, amount: 100000n })\n    .send();\n```\n\n## OP_RETURN Data",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "p2pkh",
      "Advanced Transaction Building",
      "Using TransactionBuilder",
      "P2PKH Input Integration",
      "OP_RETURN Data"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-5",
    "content": "## OP_RETURN Data\n\n### Simple OP_RETURN\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withOpReturn(['Hello, Bitcoin Cash!'])\n    .send();\n```\n\n### Protocol-Specific OP_RETURN\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withOpReturn(['0x6d02', 'memo.cash message'])\n    .send();\n```\n\n### Multiple OP_RETURN Outputs\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withOpReturn(['0x534c5000', 'SLP token data'])\n    .withOpReturn(['0x6d02', 'memo.cash message'])\n    .send();\n```\n\n## CashTokens Integration",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "OP_RETURN Data",
      "Simple OP_RETURN",
      "Protocol-Specific OP_RETURN",
      "Multiple OP_RETURN Outputs",
      "CashTokens Integration"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-6",
    "content": "## CashTokens Integration\n\nBitcoin Cash supports CashTokens for fungible and non-fungible token functionality. Token commitments are currently max 40 bytes (128 bytes in May 2026 upgrade), supporting advanced use cases like BLS12-381 KZG commitments for bilinear pairing-based accumulators.\n\n### Fungible Token Outputs\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to({\n        to: address,\n        amount: 1000n,\n        token: {\n            category: tokenCategory,\n            amount: 100n\n        }\n    })\n    .send();\n```\n\n### NFT Outputs\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to({\n        to: address,\n        amount: 1000n,\n        token: {\n            category: tokenCategory,\n            nft: {\n                capability: 'none',\n                commitment: Buffer.from('unique-data')\n            }\n        }\n    })\n    .send();\n```\n\n### Token Minting\n\n```javascript\nconst txDetails = await contract.functions\n    .mint(sigTemplate, 1000n)\n    .to({\n        to: address,\n        amount: 1000n,\n        token: {\n            category: tokenCategory,\n            amount: 1000n\n        }\n    })\n    .send();\n```\n\n## Time Constraints",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "CashTokens Integration",
      "Fungible Token Outputs",
      "NFT Outputs",
      "Token Minting",
      "Time Constraints"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-7",
    "content": "## Time Constraints\n\n### Absolute Time Locks\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withTime(1640995200)  // Unix timestamp\n    .send();\n```\n\n### Relative Time Locks\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withAge(144)  // 144 blocks\n    .send();\n```\n\n## Transaction Debugging",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Time Constraints",
      "Absolute Time Locks",
      "Relative Time Locks",
      "Transaction Debugging"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-8",
    "content": "## Transaction Debugging\n\n### Debug Mode\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .debug()  // Shows detailed transaction info\n    .send();\n```\n\n### BitAuth URI\n\n```javascript\nconst uri = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .bitauthUri();\n\nconsole.log('Debug URI:', uri);\n```\n\n### Build Without Broadcasting\n\n```javascript\nconst txHex = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .build();\n\nconsole.log('Transaction hex:', txHex);\n```\n\n## Error Handling",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Transaction Debugging",
      "Debug Mode",
      "BitAuth URI",
      "Build Without Broadcasting",
      "Error Handling"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-9",
    "content": "## Error Handling\n\n### Transaction Validation\n\n```javascript\ntry {\n    const txDetails = await contract.functions\n        .spend(sigTemplate)\n        .to(address, amount)\n        .send();\n} catch (error) {\n    if (error.message.includes('insufficient funds')) {\n        console.error('Not enough funds in contract');\n    } else if (error.message.includes('script failed')) {\n        console.error('Contract validation failed');\n    } else {\n        console.error('Transaction error:', error.message);\n    }\n}\n```\n\n### Network Errors\n\n```javascript\ntry {\n    const txDetails = await contract.functions\n        .spend(sigTemplate)\n        .to(address, amount)\n        .send();\n} catch (error) {\n    if (error.code === 'ECONNREFUSED') {\n        console.error('Network connection failed');\n    } else if (error.code === 'TIMEOUT') {\n        console.error('Transaction broadcast timeout');\n    } else {\n        console.error('Network error:', error.message);\n    }\n}\n```\n\n## Complete Examples",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Error Handling",
      "Transaction Validation",
      "Network Errors",
      "Complete Examples"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-10",
    "content": "## Complete Examples\n\n### Escrow Contract Transaction\n\n```javascript\nimport { Contract, ElectrumNetworkProvider, SignatureTemplate } from 'cashscript';\n\nconst provider = new ElectrumNetworkProvider('mainnet');\nconst escrowContract = new Contract(escrowArtifact, [\n    buyerPubkey,\n    sellerPubkey,\n    arbiterPubkey,\n    escrowAmount\n], { provider });\n\n// Buyer and seller complete the escrow\nconst buyerSig = new SignatureTemplate(buyerPrivateKey);\nconst sellerSig = new SignatureTemplate(sellerPrivateKey);\n\nconst txDetails = await escrowContract.functions\n    .complete(buyerSig, sellerSig)\n    .to(sellerAddress, escrowAmount)\n    .send();\n```\n\n### Multi-Path Contract\n\n```javascript\nconst timeLockContract = new Contract(timeLockArtifact, [\n    ownerPubkey,\n    lockTime\n], { provider });\n\nconst ownerSig = new SignatureTemplate(ownerPrivateKey);\n\n// Try immediate spend first\ntry {\n    const txDetails = await timeLockContract.functions\n        .spend(ownerSig)\n        .to(ownerAddress, amount)\n        .send();\n} catch (error) {\n    // If time lock not expired, wait\n    console.log('Time lock not expired, waiting...');\n}\n```\n\n### Complex Multi-Input Transaction\n\n```javascript\nconst provider = new ElectrumNetworkProvider('mainnet');\n\n// Multiple contract UTXOs\nconst contractUtxos = await contract.getUtxos();\nconst userUtxos = await provider.getUtxos(userAddress);\n\nconst userSig = new SignatureTemplate(userPrivateKey);\nconst contractSig = new SignatureTemplate(contractPrivateKey);\n\nconst txDetails = await new TransactionBuilder({ provider })\n    .addInput(contractUtxos[0], contract.unlock.spend(contractSig))\n    .addInput(contractUtxos[1], contract.unlock.spend(contractSig))\n    .addInput(userUtxos[0], userSig.unlockP2PKH())\n    .addOutput({ to: recipientAddress, amount: 100000n })\n    .addOutput({ to: changeAddress, amount: 50000n })\n    .setMaxFee(3000n)\n    .send();\n```",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Complete Examples",
      "Escrow Contract Transaction",
      "Multi-Path Contract",
      "Complex Multi-Input Transaction"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-11",
    "content": "## Best Practices\n\n### 1. Fee Management\n\n```javascript\n// Always set appropriate fees\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withFeePerByte(1.1)  // Slightly above minimum\n    .send();\n```\n\n### 2. Input Validation\n\n```javascript\n// Validate inputs before transaction\nconst balance = await contract.getBalance();\nconst requiredAmount = amount + estimatedFee;\n\nif (balance < requiredAmount) {\n    throw new Error('Insufficient contract balance');\n}\n```\n\n### 3. Error Recovery\n\n```javascript\nasync function sendTransactionWithRetry(contractTx, maxRetries = 3) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await contractTx.send();\n        } catch (error) {\n            if (i === maxRetries - 1) throw error;\n            \n            console.log(`Attempt ${i + 1} failed, retrying...`);\n            await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n    }\n}\n```\n\n### 4. Transaction Monitoring\n\n```javascript\nasync function monitorTransaction(txid) {\n    const provider = new ElectrumNetworkProvider('mainnet');\n    \n    while (true) {\n        try {\n            const tx = await provider.getTransaction(txid);\n            if (tx.confirmations >= 1) {\n                console.log('Transaction confirmed');\n                break;\n            }\n        } catch (error) {\n            console.log('Transaction not found, waiting...');\n        }\n        \n        await new Promise(resolve => setTimeout(resolve, 30000));\n    }\n}\n```",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Best Practices",
      "1. Fee Management",
      "2. Input Validation",
      "3. Error Recovery",
      "4. Transaction Monitoring"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-12",
    "content": "## Common Patterns\n\n### Batch Transactions\n\n```javascript\nconst transactions = [];\n\nfor (const recipient of recipients) {\n    const tx = contract.functions\n        .spend(sigTemplate)\n        .to(recipient.address, recipient.amount)\n        .build();\n    \n    transactions.push(tx);\n}\n\n// Send all transactions\nconst results = await Promise.allSettled(\n    transactions.map(tx => provider.sendRawTransaction(tx))\n);\n```\n\n### Conditional Spending\n\n```javascript\nconst balance = await contract.getBalance();\nconst utxos = await contract.getUtxos();\n\nlet txBuilder = contract.functions.spend(sigTemplate);\n\nif (balance > 100000n) {\n    txBuilder = txBuilder.to(primaryAddress, 50000n);\n    txBuilder = txBuilder.to(secondaryAddress, 30000n);\n} else {\n    txBuilder = txBuilder.to(primaryAddress, balance - 1000n);\n}\n\nconst txDetails = await txBuilder.send();\n```\n\n### Token-Aware Transactions\n\n```javascript\nconst contractUtxos = await contract.getUtxos();\nconst tokenUtxo = contractUtxos.find(utxo => utxo.token);\n\nif (tokenUtxo) {\n    const txDetails = await contract.functions\n        .spend(sigTemplate)\n        .to({\n            to: recipientAddress,\n            amount: 1000n,\n            token: {\n                category: tokenUtxo.token.category,\n                amount: tokenUtxo.token.amount\n            }\n        })\n        .send();\n}\n```\n\n## Transaction Analysis",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Common Patterns",
      "Batch Transactions",
      "Conditional Spending",
      "Token-Aware Transactions",
      "Transaction Analysis"
    ]
  },
  {
    "id": "sdk/transactions/transaction-building.md-13",
    "content": "## Transaction Analysis\n\n### Fee Calculation\n\n```javascript\nconst txHex = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .build();\n\nconst txSize = txHex.length / 2;  // Hex to bytes\nconst feeRate = 1.0;  // sat/byte\nconst estimatedFee = txSize * feeRate;\n\nconsole.log(`Transaction size: ${txSize} bytes`);\nconsole.log(`Estimated fee: ${estimatedFee} satoshis`);\n```\n\n### Input/Output Analysis\n\n```javascript\nconst txDetails = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .send();\n\nconsole.log('Transaction Analysis:');\nconsole.log('- TXID:', txDetails.txid);\nconsole.log('- Inputs:', txDetails.inputs.length);\nconsole.log('- Outputs:', txDetails.outputs.length);\nconsole.log('- Fee:', txDetails.fee);\n```\n\nThis comprehensive guide covers all aspects of transaction building with the CashScript SDK, from basic transfers to complex multi-input transactions with CashTokens support.",
    "source": "sdk/transactions/transaction-building.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "Transaction Analysis",
      "Fee Calculation",
      "Input/Output Analysis"
    ]
  },
  {
    "id": "reference/quick-reference.md-0",
    "content": "# CashScript Quick Reference Guide\n\n## Language Syntax\n\n### Contract Structure\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract ContractName(Type param1, Type param2) {\n    function functionName(Type arg1, Type arg2) {\n        require(condition);\n    }\n}\n```\n\n### Data Types\n| Type | Description | Example |\n|------|-------------|---------|\n| `bool` | Boolean | `true`, `false` |\n| `int` | Integer | `42`, `-100`, `1_000_000` |\n| `string` | UTF-8 string | `\"Hello World\"` |\n| `bytes` | Byte sequence | `0x1234abcd` |\n| `bytes4` | Fixed 4 bytes | `0x12345678` |\n| `bytes20` | Fixed 20 bytes | Hash160 result |\n| `bytes32` | Fixed 32 bytes | SHA256 result |\n| `pubkey` | Public key | `0x03...` (33 bytes) |\n| `sig` | Signature | Transaction signature |\n| `datasig` | Data signature | Message signature |\n\n### Operators\n| Category | Operators |\n|----------|-----------|\n| Arithmetic | `+`, `-`, `*`, `/`, `%` |\n| Comparison | `<`, `<=`, `>`, `>=`, `==`, `!=` |\n| Logical | `!`, `&&`, `||` |\n| Bitwise | `&`, `|`, `^` |\n\n### Built-in Functions\n\n#### Arithmetic\n```cashscript\nabs(int a) -> int\nmin(int a, int b) -> int\nmax(int a, int b) -> int\nwithin(int x, int lower, int upper) -> bool\n```\n\n#### Hash Functions\n```cashscript\nsha256(any x) -> bytes32\nsha1(any x) -> bytes20\nripemd160(any x) -> bytes20\nhash160(any x) -> bytes20\nhash256(any x) -> bytes32\n```\n\n#### Signature Functions\n```cashscript\ncheckSig(sig s, pubkey pk) -> bool\ncheckMultiSig(sig[] sigs, pubkey[] pks) -> bool\ncheckDataSig(datasig s, bytes msg, pubkey pk) -> bool\n```",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "string",
      "bool",
      "CashScript Quick Reference Guide",
      "Language Syntax",
      "Contract Structure",
      "Data Types",
      "Operators",
      "Built-in Functions",
      "Arithmetic",
      "Hash Functions",
      "Signature Functions"
    ]
  },
  {
    "id": "reference/quick-reference.md-1",
    "content": "### Global Variables\n\n#### Time Variables\n```cashscript\ntx.time        // Absolute time lock\ntx.age         // Relative time lock (UTXO age)\n```\n\n#### Transaction Introspection\n```cashscript\ntx.version     // Transaction version\ntx.locktime    // Transaction locktime\ntx.inputs      // Array of inputs\ntx.outputs     // Array of outputs\n```\n\n#### Contract Context\n```cashscript\nthis.activeInputIndex    // Current input index\nthis.activeBytecode     // Current input bytecode\n```\n\n#### Input/Output Properties\n```cashscript\n// Input/Output properties\n.value              // Satoshi amount\n.lockingBytecode    // Script bytecode\n.tokenCategory      // CashToken category\n.nftCommitment      // NFT commitment\n.tokenAmount        // Token amount\n```\n\n### Locking Bytecode Constructors\n```cashscript\nnew LockingBytecodeP2PKH(bytes20 pkHash)\nnew LockingBytecodeP2SH20(bytes20 scriptHash)\nnew LockingBytecodeP2SH32(bytes32 scriptHash)\nnew LockingBytecodeNullData(bytes[] chunks)\n```\n\n### Units\n```cashscript\n// BCH Units\n1 * sats         // 1 satoshi\n1 * finney       // 0.001 BCH\n1 * bits         // 0.000001 BCH\n1 * bitcoin      // 1 BCH\n\n// Time Units\n1 * seconds      // 1 second\n1 * minutes      // 60 seconds\n1 * hours        // 3600 seconds\n1 * days         // 86400 seconds\n1 * weeks        // 604800 seconds\n```\n\n## JavaScript/TypeScript SDK",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "introspection",
      "bytes",
      "Global Variables",
      "Time Variables",
      "Transaction Introspection",
      "Contract Context",
      "Input/Output Properties",
      "Locking Bytecode Constructors",
      "Units",
      "JavaScript/TypeScript SDK"
    ]
  },
  {
    "id": "reference/quick-reference.md-2",
    "content": "## JavaScript/TypeScript SDK\n\n### Installation\n```bash\nnpm install cashscript  # SDK\nnpm install -g cashc    # Compiler\n```\n\n### Basic Imports\n```javascript\nimport { \n    Contract, \n    ElectrumNetworkProvider, \n    SignatureTemplate, \n    TransactionBuilder \n} from 'cashscript';\nimport { compileFile, compileString } from 'cashc';\n```\n\n### Contract Compilation\n```javascript\n// Compile from file\nconst artifact = compileFile('contract.cash');\n\n// Compile from string\nconst artifact = compileString(contractCode);\n\n// Import JSON artifact\nimport artifact from './contract.json' with { type: 'json' };\n```\n\n### Contract Instantiation\n```javascript\nconst provider = new ElectrumNetworkProvider('mainnet');\nconst contract = new Contract(artifact, constructorArgs, { provider });\n```\n\n### Basic Transaction\n```javascript\nconst sigTemplate = new SignatureTemplate(privateKey);\n\nconst txDetails = await contract.functions\n    .functionName(arg1, arg2)\n    .to('bitcoincash:address', amount)\n    .send();\n```\n\n### Advanced Transaction Builder\n```javascript\nconst txDetails = await new TransactionBuilder({ provider })\n    .addInput(utxo, unlockingScript)\n    .addOutput({ to: address, amount: amount })\n    .setMaxFee(1000n)\n    .send();\n```\n\n### Transaction Options\n```javascript\ncontract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .withFeePerByte(1.1)           // Custom fee rate\n    .withHardcodedFee(1000n)       // Fixed fee\n    .withMinChange(5000n)          // Minimum change\n    .withoutChange()               // No change output\n    .withOpReturn(['data'])        // OP_RETURN output\n    .withTime(timestamp)           // Time lock\n    .withAge(blocks)               // Age lock\n    .send();\n```",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "string",
      "JavaScript/TypeScript SDK",
      "Installation",
      "Basic Imports",
      "Contract Compilation",
      "Contract Instantiation",
      "Basic Transaction",
      "Advanced Transaction Builder",
      "Transaction Options"
    ]
  },
  {
    "id": "reference/quick-reference.md-3",
    "content": "## CashTokens Integration\n\n*Token commitments: max 40 bytes (128 bytes in May 2026 upgrade). Unlocking bytecode limit: 10,000 bytes (May 2026 upgrade).*\n\n### Token Output (SDK)\n```javascript\n// Fungible Token\n.to({\n    to: address,\n    amount: 1000n,\n    token: {\n        category: tokenCategory,\n        amount: 100n\n    }\n})\n\n// NFT\n.to({\n    to: address,\n    amount: 1000n,\n    token: {\n        category: tokenCategory,\n        nft: {\n            capability: 'none',  // 'none', 'mutable', 'minting'\n            commitment: Buffer.from('data')\n        }\n    }\n})\n```\n\n### Token Validation (Contract)\n```cashscript\n// Check token category\nrequire(tx.outputs[0].tokenCategory == expectedCategory);\n\n// Check fungible token amount\nrequire(tx.outputs[0].tokenAmount >= 100);\n\n// Check NFT commitment\nrequire(tx.outputs[0].nftCommitment == expectedCommitment);\n```\n\n## Common Patterns",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "CashTokens Integration",
      "Token Output (SDK)",
      "Token Validation (Contract)",
      "Common Patterns"
    ]
  },
  {
    "id": "reference/quick-reference.md-4",
    "content": "## Common Patterns\n\n### Simple Transfer\n```cashscript\ncontract SimpleTransfer(pubkey owner) {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n    }\n}\n```\n\n### Time Lock\n```cashscript\ncontract TimeLock(pubkey owner, int lockTime) {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        require(tx.time >= lockTime);\n    }\n}\n```\n\n### Hash Lock\n```cashscript\ncontract HashLock(pubkey owner, bytes32 secretHash) {\n    function spend(sig ownerSig, bytes secret) {\n        require(checkSig(ownerSig, owner));\n        require(sha256(secret) == secretHash);\n    }\n}\n```\n\n### Multi-Signature\n```cashscript\ncontract MultiSig(pubkey pk1, pubkey pk2, pubkey pk3) {\n    function spend(sig s1, sig s2) {\n        require(checkMultiSig([s1, s2], [pk1, pk2, pk3]));\n    }\n}\n```\n\n### Covenant (Output Restriction)\n```cashscript\ncontract Covenant(bytes20 targetAddress) {\n    function spend() {\n        require(tx.outputs[0].lockingBytecode == \n                new LockingBytecodeP2PKH(targetAddress));\n        require(tx.outputs[0].value >= 1000);\n    }\n}\n```\n\n### Oracle Integration\n```cashscript\ncontract Oracle(pubkey oraclePk) {\n    function spend(datasig oracleData, int price) {\n        require(checkDataSig(oracleData, bytes(price), oraclePk));\n        require(price >= 1000);\n    }\n}\n```\n\n## Error Handling",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int",
      "Common Patterns",
      "Simple Transfer",
      "Time Lock",
      "Hash Lock",
      "Multi-Signature",
      "Covenant (Output Restriction)",
      "Oracle Integration",
      "Error Handling"
    ]
  },
  {
    "id": "reference/quick-reference.md-5",
    "content": "## Error Handling\n\n### Common Errors\n| Error | Cause | Solution |\n|-------|-------|----------|\n| Script failed | `require()` condition failed | Check contract logic |\n| Insufficient funds | Not enough BCH in contract | Fund contract or reduce amount |\n| Invalid signature | Wrong private key or format | Verify signature creation |\n| Network error | Connection issues | Check network/provider |\n| Compilation error | Syntax errors in contract | Fix CashScript syntax |\n\n### Debug Techniques\n```javascript\n// Debug transaction\nconst debugInfo = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .debug();\n\n// Build without sending\nconst txHex = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .build();\n\n// Generate debug URI\nconst uri = await contract.functions\n    .spend(sigTemplate)\n    .to(address, amount)\n    .bitauthUri();\n```\n\n## Security Checklist",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Error Handling",
      "Common Errors",
      "Debug Techniques",
      "Security Checklist"
    ]
  },
  {
    "id": "reference/quick-reference.md-6",
    "content": "## Security Checklist\n\n### Contract Security\n- [ ] Validate all function inputs\n- [ ] Use proper access control\n- [ ] Implement bounds checking\n- [ ] Handle overflow/underflow\n- [ ] Validate transaction structure\n- [ ] Use appropriate time comparisons\n- [ ] Implement proper signature validation\n\n### SDK Security\n- [ ] Validate network connections\n- [ ] Use appropriate fee rates\n- [ ] Implement retry logic\n- [ ] Validate transaction results\n- [ ] Handle errors gracefully\n- [ ] Monitor contract activity\n\n## Network Configuration",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Security Checklist",
      "Contract Security",
      "SDK Security",
      "Network Configuration"
    ]
  },
  {
    "id": "reference/quick-reference.md-7",
    "content": "## Network Configuration\n\n### Providers\n```javascript\n// Mainnet\nnew ElectrumNetworkProvider('mainnet')\n\n// Testnet (Chipnet)\nnew ElectrumNetworkProvider('chipnet')\n\n// Custom server\nnew ElectrumNetworkProvider('mainnet', 'server.example.com')\n```\n\n### Address Types\n```javascript\n// P2SH32 (default, more secure)\n{ addressType: 'p2sh32' }\n\n// P2SH20 (legacy, less secure)\n{ addressType: 'p2sh20' }\n```\n\n## Version Compatibility",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "Network Configuration",
      "Providers",
      "Address Types",
      "Version Compatibility"
    ]
  },
  {
    "id": "reference/quick-reference.md-8",
    "content": "## Version Compatibility\n\n### CashScript Versions\n- `^0.12.1` - Latest stable\n- `>=0.10.0` - Minimum supported\n- `^0.8.0` - Legacy support\n\n### Pragma Directive\n```cashscript\npragma cashscript ^0.12.1;  // Compatible with 0.11.x\npragma cashscript >=0.10.0; // 0.10.0 and above\n```\n\n## Useful Resources",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "Version Compatibility",
      "CashScript Versions",
      "Pragma Directive",
      "Useful Resources"
    ]
  },
  {
    "id": "reference/quick-reference.md-9",
    "content": "## Useful Resources\n\n### Documentation\n- [CashScript Docs](https://cashscript.org/docs/)\n- [Bitcoin Cash Docs](https://developer.bitcoin.com/)\n- [CashTokens Spec](https://cashtokens.org/docs/spec/)\n\n### Tools\n- [CashScript Playground](https://playground.cashscript.org/)\n- [Bitcoin Cash Explorer](https://explorer.bitcoin.com/)\n- [Electrum Cash](https://electroncash.org/)\n\n### Libraries\n- `cashscript` - Main SDK\n- `cashc` - Compiler\n- `bitcore-lib-cash` - Bitcoin Cash utilities\n- `bip39` - Mnemonic generation\n\n## CLI Commands",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "Useful Resources",
      "Documentation",
      "Tools",
      "Libraries",
      "CLI Commands"
    ]
  },
  {
    "id": "reference/quick-reference.md-10",
    "content": "## CLI Commands\n\n### Compilation\n```bash\n# Compile to JSON\ncashc contract.cash\n\n# Compile to TypeScript\ncashc --format ts contract.cash\n\n# Specify output file\ncashc --output artifact.json contract.cash\n\n# Show help\ncashc --help\n```\n\n### Version Check\n```bash\ncashc --version\n```\n\nThis quick reference provides a comprehensive overview of CashScript syntax, SDK usage, and common patterns for rapid development and debugging.",
    "source": "reference/quick-reference.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "CLI Commands",
      "Compilation",
      "Compile to JSON",
      "Compile to TypeScript",
      "Specify output file",
      "Show help",
      "Version Check"
    ]
  },
  {
    "id": "cashtokens/overview.md-0",
    "content": "# CashTokens Integration with CashScript\n\n## Overview\n\nCashTokens is a native token system on Bitcoin Cash that provides fungible and non-fungible token (NFT) capabilities. CashScript provides comprehensive support for CashTokens through both language features and SDK integration.\n\n## CashTokens Fundamentals",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": [
      "CashTokens Integration with CashScript",
      "Overview",
      "CashTokens Fundamentals"
    ]
  },
  {
    "id": "cashtokens/overview.md-1",
    "content": "## CashTokens Fundamentals\n\n### Token Categories\n\nEvery CashToken belongs to a **token category** identified by a 32-byte category ID.\n\n```cashscript\nbytes32 tokenCategory = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n```\n\n### Token Types\n\n#### 1. Fungible Tokens (FT)\n- Divisible tokens with amounts\n- Similar to ERC-20 tokens\n- Represented by `tokenAmount` property\n\n#### 2. Non-Fungible Tokens (NFT)\n- Unique tokens with capabilities and commitments\n- Can have minting, mutable, or no capabilities\n- Represented by `nftCommitment` and capability flags\n\n## CashScript Language Support",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "CashTokens Fundamentals",
      "Token Categories",
      "Token Types",
      "1. Fungible Tokens (FT)",
      "2. Non-Fungible Tokens (NFT)",
      "CashScript Language Support"
    ]
  },
  {
    "id": "cashtokens/overview.md-2",
    "content": "## CashScript Language Support\n\n### Transaction Introspection\n\nAccess token properties through transaction introspection:\n\n```cashscript\ncontract TokenValidator(bytes32 expectedCategory) {\n    function validateToken() {\n        // Check token category\n        require(tx.outputs[0].tokenCategory == expectedCategory);\n        \n        // Check token amount (for fungible tokens)\n        require(tx.outputs[0].tokenAmount >= 100);\n        \n        // Check NFT commitment (for NFTs)\n        require(tx.outputs[0].nftCommitment.length > 0);\n    }\n}\n```\n\n### Token Properties\n\nAvailable token properties in CashScript:\n\n```cashscript\n// Token category (32 bytes)\nbytes32 category = tx.outputs[0].tokenCategory;\n\n// Fungible token amount\nint amount = tx.outputs[0].tokenAmount;\n\n// NFT commitment data\nbytes commitment = tx.outputs[0].nftCommitment;\n\n// Check if output has tokens\nbool hasTokens = tx.outputs[0].tokenCategory != 0x;\n```\n\n### Token Validation Patterns\n\n#### Fungible Token Transfer\n\n```cashscript\ncontract FungibleTokenTransfer(bytes32 tokenCategory, int minimumAmount) {\n    function transfer(sig ownerSig, pubkey ownerPk) {\n        require(checkSig(ownerSig, ownerPk));\n        \n        // Ensure correct token category\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        \n        // Ensure minimum amount\n        require(tx.outputs[0].tokenAmount >= minimumAmount);\n    }\n}\n```\n\n#### NFT Ownership Transfer\n\n```cashscript\ncontract NFTTransfer(bytes32 tokenCategory, bytes expectedCommitment) {\n    function transfer(sig ownerSig, pubkey ownerPk) {\n        require(checkSig(ownerSig, ownerPk));\n        \n        // Ensure correct token category\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        \n        // Ensure specific NFT commitment\n        require(tx.outputs[0].nftCommitment == expectedCommitment);\n    }\n}\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "introspection",
      "bytes",
      "int",
      "bool",
      "CashScript Language Support",
      "Transaction Introspection",
      "Token Properties",
      "Token Validation Patterns",
      "Fungible Token Transfer",
      "NFT Ownership Transfer"
    ]
  },
  {
    "id": "cashtokens/overview.md-3",
    "content": "## CashScript SDK Integration\n\n### Token Output Creation\n\n#### Fungible Token Output\n\n```javascript\nconst txDetails = await contract.functions\n    .transfer(sigTemplate)\n    .to({\n        to: 'bitcoincash:qr7gmtgmvsdtuwcskladnsrqrzf24td68qxg9rsqca',\n        amount: 1000n,  // BCH amount in satoshis\n        token: {\n            category: '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',\n            amount: 100n  // Token amount\n        }\n    })\n    .send();\n```\n\n#### NFT Output\n\n```javascript\nconst txDetails = await contract.functions\n    .transfer(sigTemplate)\n    .to({\n        to: 'bitcoincash:qr7gmtgmvsdtuwcskladnsrqrzf24td68qxg9rsqca',\n        amount: 1000n,\n        token: {\n            category: '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',\n            nft: {\n                capability: 'none',  // 'none', 'mutable', 'minting'\n                commitment: Buffer.from('unique-data-here')\n            }\n        }\n    })\n    .send();\n```\n\n### Token UTXO Management\n\n#### Finding Token UTXOs\n\n```javascript\nconst utxos = await contract.getUtxos();\n\n// Find fungible token UTXOs\nconst tokenUtxos = utxos.filter(utxo => \n    utxo.token && utxo.token.amount > 0\n);\n\n// Find NFT UTXOs\nconst nftUtxos = utxos.filter(utxo => \n    utxo.token && utxo.token.nft\n);\n\n// Find specific token category\nconst specificTokens = utxos.filter(utxo => \n    utxo.token && utxo.token.category === targetCategory\n);\n```\n\n#### Token Balance Calculation\n\n```javascript\nfunction calculateTokenBalance(utxos, tokenCategory) {\n    return utxos\n        .filter(utxo => utxo.token && utxo.token.category === tokenCategory)\n        .reduce((total, utxo) => total + (utxo.token.amount || 0n), 0n);\n}\n\nconst balance = calculateTokenBalance(utxos, tokenCategory);\nconsole.log('Token balance:', balance.toString());\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "CashScript SDK Integration",
      "Token Output Creation",
      "Fungible Token Output",
      "NFT Output",
      "Token UTXO Management",
      "Finding Token UTXOs",
      "Token Balance Calculation"
    ]
  },
  {
    "id": "cashtokens/overview.md-4",
    "content": "## Advanced CashTokens Patterns\n\n### Token Distribution Contract\n\n> **Important**: Fungible tokens cannot be \"minted\" post-genesis. ALL fungible tokens for a category are created in the genesis transaction. The contract below distributes pre-existing tokens from a pool. Only NFTs can be created post-genesis using minting capability (0x02).\n\n```cashscript\ncontract TokenDistribution(pubkey distributor, bytes32 tokenCategory) {\n    function distribute(sig distributorSig, int amount) {\n        require(checkSig(distributorSig, distributor));\n\n        // Distribute tokens from pool to correct category\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n\n        // Ensure positive amount\n        require(amount > 0);\n        require(tx.outputs[0].tokenAmount == amount);\n    }\n}\n```\n\n### NFT Minting with Metadata\n\n```cashscript\ncontract NFTMinting(pubkey minter, bytes32 tokenCategory) {\n    function mint(sig minterSig, bytes commitment) {\n        require(checkSig(minterSig, minter));\n        \n        // Ensure correct token category\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        \n        // Ensure NFT has commitment\n        require(tx.outputs[0].nftCommitment == commitment);\n        require(commitment.length > 0);\n    }\n}\n```\n\n### Token Burning\n\n```cashscript\ncontract TokenBurning(pubkey owner, bytes32 tokenCategory) {\n    function burn(sig ownerSig, int amount) {\n        require(checkSig(ownerSig, owner));\n        \n        // Ensure input has tokens to burn\n        require(tx.inputs[0].tokenCategory == tokenCategory);\n        require(tx.inputs[0].tokenAmount >= amount);\n        \n        // Ensure no token outputs (burning)\n        require(tx.outputs[0].tokenCategory == 0x || tx.outputs[0].tokenAmount == 0);\n    }\n}\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "Advanced CashTokens Patterns",
      "Token Distribution Contract",
      "NFT Minting with Metadata",
      "Token Burning"
    ]
  },
  {
    "id": "cashtokens/overview.md-5",
    "content": "## Token State Management\n\n### NFT-Based State Storage\n\n```cashscript\ncontract StatefulContract(bytes32 stateTokenCategory) {\n    function updateState(sig ownerSig, bytes newState) {\n        require(checkSig(ownerSig, owner));\n        \n        // Input must have current state NFT\n        require(tx.inputs[0].tokenCategory == stateTokenCategory);\n        \n        // Output must have updated state NFT\n        require(tx.outputs[0].tokenCategory == stateTokenCategory);\n        require(tx.outputs[0].nftCommitment == newState);\n    }\n}\n```\n\n### Token-Gated Access\n\n```cashscript\ncontract TokenGatedAccess(bytes32 requiredTokenCategory, int minimumAmount) {\n    function access(sig userSig, pubkey userPk) {\n        require(checkSig(userSig, userPk));\n        \n        // User must hold minimum token amount\n        bool hasRequiredTokens = false;\n        \n        // Check all inputs for required tokens\n        for (int i = 0; i < tx.inputs.length; i++) {\n            if (tx.inputs[i].tokenCategory == requiredTokenCategory) {\n                if (tx.inputs[i].tokenAmount >= minimumAmount) {\n                    hasRequiredTokens = true;\n                    break;\n                }\n            }\n        }\n        \n        require(hasRequiredTokens);\n    }\n}\n```\n\n## Real-World Examples",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "bool",
      "Token State Management",
      "NFT-Based State Storage",
      "Token-Gated Access",
      "Real-World Examples"
    ]
  },
  {
    "id": "cashtokens/overview.md-6",
    "content": "## Real-World Examples\n\n### Decentralized Exchange (DEX)\n\n```cashscript\ncontract SimpleTokenSwap(\n    bytes32 tokenACategory,\n    bytes32 tokenBCategory,\n    int exchangeRate\n) {\n    function swap(sig traderSig, pubkey traderPk, int amountA) {\n        require(checkSig(traderSig, traderPk));\n        \n        // Calculate required amount B\n        int amountB = amountA * exchangeRate;\n        \n        // Ensure input has token A\n        require(tx.inputs[0].tokenCategory == tokenACategory);\n        require(tx.inputs[0].tokenAmount >= amountA);\n        \n        // Ensure output has token B\n        require(tx.outputs[0].tokenCategory == tokenBCategory);\n        require(tx.outputs[0].tokenAmount >= amountB);\n    }\n}\n```\n\n### Token Vesting\n\n```cashscript\ncontract TokenVesting(\n    pubkey beneficiary,\n    bytes32 tokenCategory,\n    int vestingPeriod,\n    int totalAmount\n) {\n    function claim(sig beneficiarySig, int claimAmount) {\n        require(checkSig(beneficiarySig, beneficiary));\n        \n        // Calculate vested amount based on time\n        int vestedAmount = (tx.locktime * totalAmount) / vestingPeriod;\n        \n        // Ensure claim doesn't exceed vested amount\n        require(claimAmount <= vestedAmount);\n        \n        // Ensure correct token output\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        require(tx.outputs[0].tokenAmount == claimAmount);\n    }\n}\n```\n\n### Multi-Token Portfolio\n\n```javascript\n// SDK example for managing multiple tokens\nclass TokenPortfolio {\n    constructor(contract, provider) {\n        this.contract = contract;\n        this.provider = provider;\n    }\n    \n    async getTokenBalances() {\n        const utxos = await this.contract.getUtxos();\n        const balances = new Map();\n        \n        for (const utxo of utxos) {\n            if (utxo.token && utxo.token.amount > 0) {\n                const category = utxo.token.category;\n                const current = balances.get(category) || 0n;\n                balances.set(category, current + utxo.token.amount);\n            }\n        }\n        \n        return balances;\n    }\n    \n    async transferToken(tokenCategory, amount, recipient) {\n        const sigTemplate = new SignatureTemplate(this.privateKey);\n        \n        return await this.contract.functions\n            .transfer(sigTemplate)\n            .to({\n                to: recipient,\n                amount: 1000n,\n                token: {\n                    category: tokenCategory,\n                    amount: amount\n                }\n            })\n            .send();\n    }\n}\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "Real-World Examples",
      "Decentralized Exchange (DEX)",
      "Token Vesting",
      "Multi-Token Portfolio"
    ]
  },
  {
    "id": "cashtokens/overview.md-7",
    "content": "## CashTokens Best Practices\n\n### 1. Token Category Validation\n\n```cashscript\n// Always validate token categories\ncontract TokenValidator(bytes32 expectedCategory) {\n    function validate() {\n        require(tx.outputs[0].tokenCategory == expectedCategory);\n        // Additional validation...\n    }\n}\n```\n\n### 2. Amount Validation\n\n```javascript\n// Validate token amounts in SDK\nfunction validateTokenAmount(amount) {\n    if (amount <= 0n) {\n        throw new Error('Token amount must be positive');\n    }\n    if (amount > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error('Token amount too large');\n    }\n}\n```\n\n### 3. NFT Commitment Handling\n\n```cashscript\ncontract NFTHandler() {\n    function handleNFT(bytes commitment) {\n        // Ensure commitment is not empty\n        require(commitment.length > 0);\n\n        // Validate commitment format\n        require(commitment.length <= 128);  // Max commitment size\n\n        // Process commitment...\n    }\n}\n```\n\n### 4. Token Conservation\n\n```cashscript\ncontract TokenConservation(bytes32 tokenCategory) {\n    function conserveTokens() {\n        int inputAmount = 0;\n        int outputAmount = 0;\n        \n        // Sum input token amounts\n        for (int i = 0; i < tx.inputs.length; i++) {\n            if (tx.inputs[i].tokenCategory == tokenCategory) {\n                inputAmount += tx.inputs[i].tokenAmount;\n            }\n        }\n        \n        // Sum output token amounts\n        for (int i = 0; i < tx.outputs.length; i++) {\n            if (tx.outputs[i].tokenCategory == tokenCategory) {\n                outputAmount += tx.outputs[i].tokenAmount;\n            }\n        }\n        \n        // Ensure tokens are conserved\n        require(inputAmount >= outputAmount);\n    }\n}\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "CashTokens Best Practices",
      "1. Token Category Validation",
      "2. Amount Validation",
      "3. NFT Commitment Handling",
      "4. Token Conservation"
    ]
  },
  {
    "id": "cashtokens/overview.md-8",
    "content": "## Common Pitfalls\n\n### 1. Category ID Format\n\n```javascript\n// Wrong - string instead of hex\nconst category = 'my-token-category';\n\n// Right - 32-byte hex string\nconst category = '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';\n```\n\n### 2. Token Amount Type\n\n```javascript\n// Wrong - regular number\nconst amount = 100;\n\n// Right - BigInt\nconst amount = 100n;\n```\n\n### 3. NFT Capability Values\n\n```javascript\n// Wrong - invalid capability\nconst capability = 'readonly';\n\n// Right - valid capabilities\nconst capability = 'none';     // or 'mutable' or 'minting'\n```\n\n### 4. Commitment Size\n\n```javascript\n// Wrong - commitment too large\nconst commitment = Buffer.alloc(200);\n\n// Right - commitment within limits\nconst commitment = Buffer.from('metadata', 'utf8');  // Max 128 bytes\n```\n\n## Testing CashTokens",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "bytes",
      "string",
      "Common Pitfalls",
      "1. Category ID Format",
      "2. Token Amount Type",
      "3. NFT Capability Values",
      "4. Commitment Size",
      "Testing CashTokens"
    ]
  },
  {
    "id": "cashtokens/overview.md-9",
    "content": "## Testing CashTokens\n\n### Unit Testing\n\n```javascript\ndescribe('Token Contract', () => {\n    it('should transfer tokens correctly', async () => {\n        const txDetails = await contract.functions\n            .transfer(sigTemplate)\n            .to({\n                to: recipientAddress,\n                amount: 1000n,\n                token: {\n                    category: tokenCategory,\n                    amount: 50n\n                }\n            })\n            .send();\n        \n        expect(txDetails.txid).toBeDefined();\n        \n        // Verify token transfer\n        const recipientUtxos = await provider.getUtxos(recipientAddress);\n        const tokenUtxo = recipientUtxos.find(utxo => \n            utxo.token && utxo.token.category === tokenCategory\n        );\n        \n        expect(tokenUtxo.token.amount).toBe(50n);\n    });\n});\n```\n\n### Integration Testing\n\n```javascript\ndescribe('Token Integration', () => {\n    it('should handle multi-token transactions', async () => {\n        // Create transaction with multiple token types\n        const txDetails = await new TransactionBuilder({ provider })\n            .addInput(tokenAUtxo, contract.unlock.swap(sigTemplate))\n            .addOutput({\n                to: userAddress,\n                amount: 1000n,\n                token: {\n                    category: tokenBCategory,\n                    amount: 100n\n                }\n            })\n            .send();\n        \n        // Verify swap occurred\n        const userUtxos = await provider.getUtxos(userAddress);\n        const newTokens = userUtxos.filter(utxo => \n            utxo.token && utxo.token.category === tokenBCategory\n        );\n        \n        expect(newTokens.length).toBeGreaterThan(0);\n    });\n});\n```",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Testing CashTokens",
      "Unit Testing",
      "Integration Testing"
    ]
  },
  {
    "id": "cashtokens/overview.md-10",
    "content": "This comprehensive guide covers CashTokens integration with CashScript, providing both language-level and SDK-level examples for working with fungible and non-fungible tokens on Bitcoin Cash.",
    "source": "cashtokens/overview.md",
    "tier": "tier_a_canonical",
    "type": "text",
    "topics": []
  },
  {
    "id": "concepts/cashscript-mental-model.md-0",
    "content": "# CashScript Mental Model for Production Systems\n\nA comprehensive framework for designing safe, production-ready CashScript contract systems. Derived from analysis of ParityUSD's 26-contract stablecoin system.\n\n---\n\n## Part 1: The UTXO Mindset",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "CashScript Mental Model for Production Systems",
      "Part 1: The UTXO Mindset"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-1",
    "content": "## Part 1: The UTXO Mindset\n\n### Think in Transactions\n\n\"Transaction T consumes UTXO A and creates UTXO B. Contract script validates whether this transformation is allowed.\"\n\nThe fundamental unit is the **transaction**, not the contract. A contract doesn't \"do\" anything - it only **validates** whether a proposed transaction meets its rules.\n\n### The Core Question\n\nFor every contract, ask: **\"What transformation of UTXOs does this contract permit?\"**\n\nNot \"what does this contract do\" but \"what does this contract ALLOW to happen to itself?\"\n\n### State Lives in UTXOs\n\n```\nUTXO → consumed & recreated → state carried in new UTXO\n```\n- **Mutable NFT commitment** = where state lives\n- **Contract recreation** = how state persists\n- **NFT capability** = authority identifier\n\n---\n\n## Part 2: Multi-Contract Architecture Patterns",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Part 1: The UTXO Mindset",
      "Think in Transactions",
      "The Core Question",
      "State Lives in UTXOs",
      "Part 2: Multi-Contract Architecture Patterns"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-2",
    "content": "## Part 2: Multi-Contract Architecture Patterns\n\n### Pattern 1: Dumb Container + Smart Functions\n\n**Problem**: Complex contracts exceed size limits, waste transaction space\n\n**Solution**: Split into a minimal \"container\" contract and separate \"function\" contracts\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ Container Contract (Loan.cash - minimal logic)          │\n│  - Holds BCH collateral                                 │\n│  - Holds state in mutable NFT                           │\n│  - Only validates: \"Is correct function attached?\"       │\n└─────────────────────────────────────────────────────────┘\n          ↓ authenticates presence of\n┌─────────────────────────────────────────────────────────┐\n│ Function Contract (e.g., manageLoan.cash)               │\n│  - Contains all business logic                          │\n│  - Validates state transitions                          │\n│  - Enforces recreation rules                            │\n└─────────────────────────────────────────────────────────┘\n```\n\n**Container authenticates function**:\n```cashscript\n// In Loan.cash\nfunction interact() {\n  // Authenticate function contract is present\n  bytes32 parityTokenId = tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0];\n  int nftFunctionInputIndex = this.activeInputIndex + 2;\n  require(tx.inputs[nftFunctionInputIndex].tokenCategory == parityTokenId);\n  bytes commitmentNftFunction = tx.inputs[nftFunctionInputIndex].nftCommitment;\n  require(commitmentNftFunction.length == 1); // Single-byte identifier\n}\n```",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "Part 2: Multi-Contract Architecture Patterns",
      "Pattern 1: Dumb Container + Smart Functions"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-3",
    "content": "**Benefits**:\n- Transaction only includes the function logic being used\n- Each function can be audited independently\n- Easy to add new functions (new contracts with new identifiers)\n\n### Pattern 2: Sidecar UTXOs\n\n**Problem**: A UTXO can only hold ONE token category. What if contract needs to track a loan owner's token AND hold its own state token?\n\n**Solution**: Create companion \"sidecar\" UTXOs that travel together\n\n```\n┌──────────────────────┐  ┌──────────────────────┐\n│ Main UTXO            │  │ Sidecar UTXO         │\n│ - Has BCH collateral │  │ - Holds owner tokenId│\n│ - Has state NFT      │  │ - Simple contract    │\n│ - Main logic         │  │ - Just validates it  │\n└──────────────────────┘  │   stays attached     │\n         ↑                └──────────────────────┘\n         └── created together, travel together ──┘\n```\n\n**Sidecar authentication** (always at adjacent index):\n```cashscript\n// In LoanTokenSidecar.cash\nfunction attach() {\n  int loanInputIndex = this.activeInputIndex - 1;\n  // Verify we were created in same tx as loan (same outpoint hash)\n  require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n          tx.inputs[loanInputIndex].outpointTransactionHash);\n  // Verify we're the next output after loan\n  require(tx.inputs[this.activeInputIndex].outpointIndex ==\n          tx.inputs[loanInputIndex].outpointIndex + 1);\n}\n```\n\n### Pattern 3: Input Index Pinning\n\n**Problem**: How do contracts find and authenticate each other?\n\n**Solution**: Enforce exact input positions in every transaction",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "Pattern 2: Sidecar UTXOs",
      "Pattern 3: Input Index Pinning"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-4",
    "content": "```\n// Example: payInterest transaction\n// Inputs: 00-PriceContract, 01-loan, 02-loanSidecar, 03-payInterest, 04-collector\nfunction payInterest() {\n  require(this.activeInputIndex == 3);  // Function MUST be at index 3\n\n  // Authenticate price contract at index 0\n  require(tx.inputs[0].tokenCategory == parityTokenId + 0x01);\n  require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00); // Price identifier\n\n  // Authenticate loan at index 1\n  require(tx.inputs[1].tokenCategory == parityTokenId + 0x01);\n  require(tx.inputs[1].nftCommitment.split(1)[0] == 0x01); // Loan identifier\n}\n```\n\n**Why this works**: Every function documents its expected layout. Transaction builders MUST follow this layout. Contracts validate each other's presence at exact positions.\n\n### Pattern 4: Token Category as Identity + Authority\n\nToken categories encode BOTH identity and capability:\n\n```cashscript\n// tokenCategory = 32-byte categoryId + optional 1-byte capability\n// 0x01 = mutable NFT capability\n// 0x02 = minting NFT capability\n\n// Authenticate price contract (mutable NFT)\nrequire(tx.inputs[0].tokenCategory == parityTokenId + 0x01);\n\n// Authenticate stability pool (minting NFT)\nrequire(tx.inputs[4].tokenCategory == stabilityPoolTokenId + 0x02);\n\n// Authenticate function contract (immutable NFT - no suffix)\nrequire(tx.inputs[3].tokenCategory == parityTokenId);\n```\n\n**Hierarchy of trust**:\n- Minting NFT (`+ 0x02`) = highest authority, can create tokens\n- Mutable NFT (`+ 0x01`) = stateful contract\n- Immutable NFT (no suffix) = static function/identifier",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Pattern 4: Token Category as Identity + Authority"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-5",
    "content": "---\n\n## Part 3: State Management\n\n### NFT Commitment as Structured State\n\nState is stored as tightly-packed bytes in NFT commitments:\n\n```cashscript\n/*  --- State Mutable NFT (10 items, 27 bytes) ---\n    byte identifier == 0x01\n    bytes6 borrowedTokenAmount (tokens)\n    bytes6 amountBeingRedeemed (tokens)\n    byte status (0x00 newLoan, 0x01 single period, 0x02 mature loan)\n    bytes4 lastPeriodInterestPaid\n    byte2 currentInterestRate\n    byte2 nextInterestRate\n    byte interestManager\n    bytes2 minRateManager\n    bytes2 maxRateManager\n*/\n```\n\n**Parsing state**:\n```cashscript\nbytes loanState = tx.inputs[0].nftCommitment;\nbytes7 firstPart, bytes remainingPart = loanState.split(7);\nbyte identifier, bytes6 borrowedAmountBytes = firstPart.split(1);\nrequire(identifier == 0x01);  // Validate this is indeed a loan\n```\n\n**Updating state**:\n```cashscript\n// Keep fixed parts, update variable parts\nbytes20 fixedPartLoanState = loanState.split(20)[0];\nbytes27 newLoanCommitment = fixedPartLoanState + nextInterestRate + bytes5(interestManagerConfiguration);\n```\n\n### First Byte as Type Identifier\n\nUse first byte to distinguish contract types sharing same tokenId:\n\n```cashscript\n// Same parityTokenId, different contract types\n0x00 = Price contract\n0x01 = Loan contract\n0x04 = startRedemption function\n0x07 = payInterest function\n```\n\nThis allows:\n```cashscript\nrequire(tx.inputs[0].nftCommitment.split(1)[0] == 0x00); // Must be price contract\n```\n\n---\n\n## Part 4: The 5-Point Covenant Validation",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "Part 3: State Management",
      "NFT Commitment as Structured State",
      "First Byte as Type Identifier",
      "Part 4: The 5-Point Covenant Validation"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-6",
    "content": "## Part 4: The 5-Point Covenant Validation\n\n**EVERY self-replicating contract must validate ALL 5 points**:\n\n```cashscript\n// 1. lockingBytecode - same contract code\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n// 2. tokenCategory - same token identity + capability\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n// 3. value - BCH amount (often exactly 1000 sats)\nrequire(tx.outputs[0].value == 1000);\n\n// 4. tokenAmount - fungible token balance\nrequire(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n\n// 5. nftCommitment - state data\nrequire(tx.outputs[0].nftCommitment == newStateCommitment);\n```\n\n**Missing ANY of these is a critical vulnerability.**\n\n---\n\n## Part 5: Covenant Categories",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "covenant",
      "Part 4: The 5-Point Covenant Validation",
      "Part 5: Covenant Categories"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-7",
    "content": "## Part 5: Covenant Categories\n\n### 1. Exactly Self-Replicating (Eternal)\n\nThese UTXOs ALWAYS recreate themselves exactly. They live forever.\n\n```cashscript\n// Examples: Redeemer, LoanKeyFactory, Function contracts\nrequire(tx.outputs[idx].lockingBytecode == tx.inputs[idx].lockingBytecode);\nrequire(tx.outputs[idx].tokenCategory == tx.inputs[idx].tokenCategory);\nrequire(tx.outputs[idx].nftCommitment == tx.inputs[idx].nftCommitment);\nrequire(tx.outputs[idx].value == 1000);\n```\n\n### 2. State-Mutating (Eternal with changing state)\n\nSame contract, but NFT commitment updates:\n\n```cashscript\n// Examples: Parity borrowing contract, PriceContract\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\nrequire(tx.outputs[0].nftCommitment == newPeriodState);  // Different!\nrequire(tx.outputs[0].value == 1000);\n```\n\n### 3. State-and-Balance-Mutating (Eternal with changing state + value)\n\nBoth state AND BCH amount can change:\n\n```cashscript\n// Example: StabilityPool - accumulates BCH from liquidations\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\nrequire(tx.outputs[0].nftCommitment == newPoolState);\nrequire(tx.outputs[0].value == newPoolBalance);  // Changes!\n```\n\n### 4. Conditionally-Replicating (Mortal)\n\nMay or may not recreate - these can be destroyed:\n\n```cashscript\n// Example: Loan - can be closed when fully repaid\nbool isLoanRecreated = tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory;\nif(isLoanRecreated) {\n  // Enforce recreation rules\n}\n// Otherwise, loan is being closed\n```",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bool",
      "Part 5: Covenant Categories",
      "1. Exactly Self-Replicating (Eternal)",
      "2. State-Mutating (Eternal with changing state)",
      "3. State-and-Balance-Mutating (Eternal with changing state + value)",
      "4. Conditionally-Replicating (Mortal)"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-8",
    "content": "---\n\n## Part 6: Minting Authority Protection\n\nContracts with minting NFTs are HIGH VALUE TARGETS. Attackers want to create unauthorized tokens.\n\n### Rule: Control ALL Outputs\n\n```cashscript\n// ALWAYS limit output count\nrequire(tx.outputs.length <= 10);\n\n// ALWAYS validate each output's token category\nif (tx.outputs.length > 4) {\n  bool noTokenOrParityTokens = tx.outputs[4].tokenCategory == 0x ||\n                                tx.outputs[4].tokenCategory == parityTokenId;\n  require(noTokenOrParityTokens);\n}\n\n// ALWAYS validate optional outputs\nif (tx.outputs.length > 5) {\n  require(tx.outputs[5].tokenCategory == 0x);  // Pure BCH only\n}\n```\n\n### Why Output Limiting Matters\n\nA minting NFT can create ANY token with that category. If you allow arbitrary outputs, attackers can:\n1. Create fake receipts\n2. Mint unauthorized tokens\n3. Create fake function NFTs\n\n**Every output in a transaction with a minting contract MUST be explicitly validated.**\n\n---\n\n## Part 7: Time Management",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bool",
      "Part 6: Minting Authority Protection",
      "Rule: Control ALL Outputs",
      "Why Output Limiting Matters",
      "Part 7: Time Management"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-9",
    "content": "## Part 7: Time Management\n\nContracts cannot read \"current time\" directly. Time is derived from transaction metadata.\n\n### Absolute Time (Block Height)\n\n- Transaction's `locktime` field can represent block height (if < 500M) or unix timestamp\n- Contract validates locktime meets requirements\n- Transaction builder sets the locktime value\n\n**Use case**: Period boundaries, unlock dates, expiration\n\n### Relative Time (UTXO Age)\n\n- Sequence numbers encode \"blocks since UTXO creation\"\n- Requires transaction version 2\n\n**Use case**: Waiting periods (e.g., 12 blocks before redemption finalizes)\n\n---\n\n## Part 8: Design Rules for Production Systems",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "Part 7: Time Management",
      "Absolute Time (Block Height)",
      "Relative Time (UTXO Age)",
      "Part 8: Design Rules for Production Systems"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-10",
    "content": "## Part 8: Design Rules for Production Systems\n\n### Rule 1: Start with Transaction Layouts\n\nBefore writing ANY code, document every transaction type:\n\n```\n// ALWAYS document like this:\n// Inputs:  00-PriceContract, 01-loan, 02-loanSidecar, 03-function, 04-collector\n// Outputs: 00-PriceContract, 01-loan, 02-loanSidecar, 03-function, 04-collector\n```\n\n### Rule 2: One Contract, One Responsibility\n\nEach contract does ONE thing:\n- Container holds value/state\n- Function validates one operation\n- Sidecar holds one additional token\n\n### Rule 3: Explicit Input Indices\n\n```cashscript\n// ALWAYS start with this\nrequire(this.activeInputIndex == EXPECTED_INDEX);\n```\n\n### Rule 4: Authenticate Everything\n\n```cashscript\n// For EACH input you depend on:\nrequire(tx.inputs[idx].tokenCategory == expectedCategory);\nrequire(tx.inputs[idx].nftCommitment.split(1)[0] == expectedIdentifier);\n```\n\n### Rule 5: Protect All Outputs\n\n```cashscript\n// ALWAYS limit and validate outputs\nrequire(tx.outputs.length <= MAX_OUTPUTS);\n// Validate each possible output\n```\n\n### Rule 6: Use Function Identifiers\n\n```cashscript\n// Single-byte identifiers for function contracts\nenum LoanFunction {\n  LIQUIDATED = 0x01,\n  MANAGE_LOAN = 0x02,\n  // ...\n}\n```\n\n### Rule 7: Minimum Value Requirements\n\n```cashscript\n// Standard UTXO value\nrequire(tx.outputs[idx].value == 1000);\n\n// For contracts accumulating value\nrequire(tx.outputs[idx].value >= minimumValue);\n```\n\n### Rule 8: Document State Layout\n\n```cashscript\n/*  --- State NFT (X items, Y bytes) ---\n    byte identifier == 0xNN\n    bytesN field1 (description)\n    bytesN field2 (description)\n    ...\n*/\n```",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "Part 8: Design Rules for Production Systems",
      "Rule 1: Start with Transaction Layouts",
      "Rule 2: One Contract, One Responsibility",
      "Rule 3: Explicit Input Indices",
      "Rule 4: Authenticate Everything",
      "Rule 5: Protect All Outputs",
      "Rule 6: Use Function Identifiers",
      "Rule 7: Minimum Value Requirements",
      "Rule 8: Document State Layout"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-11",
    "content": "---\n\n## Part 9: Security Checklist\n\nBefore deploying ANY CashScript system:\n\n### Covenant Validation\n- [ ] All 5 points validated for self-replicating contracts\n- [ ] Correct capability flags checked (0x01 mutable, 0x02 minting)\n- [ ] NFT commitment structure validated (first byte identifier)\n\n### Authority\n- [ ] All input contracts authenticated via tokenCategory\n- [ ] Position indices enforced with `this.activeInputIndex`\n- [ ] No unauthorized tokens can be created\n\n### Minting Protection\n- [ ] Output count limited (`require(tx.outputs.length <= N)`)\n- [ ] Each output's tokenCategory validated\n- [ ] Change outputs restricted to BCH-only or known tokens\n\n### State\n- [ ] State byte layouts documented\n- [ ] All state transitions validated\n- [ ] No state can be corrupted by invalid input\n\n### Value\n- [ ] BCH values validated (minimum 1000 sats typically)\n- [ ] Value changes calculated correctly\n- [ ] No value can leak\n\n### Time\n- [ ] Locktime validated appropriately\n- [ ] Sequence numbers used correctly for relative locks\n- [ ] Period/epoch boundaries handled\n\n### Edge Cases\n- [ ] Division by zero prevented\n- [ ] Minimum amounts enforced\n- [ ] Partial operations handled correctly\n- [ ] Empty/full scenarios covered\n\n---\n\n## Part 10: From Intent to Implementation",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "Part 9: Security Checklist",
      "Covenant Validation",
      "Authority",
      "Minting Protection",
      "State",
      "Value",
      "Time",
      "Edge Cases",
      "Part 10: From Intent to Implementation"
    ]
  },
  {
    "id": "concepts/cashscript-mental-model.md-12",
    "content": "## Part 10: From Intent to Implementation\n\n### Step 1: Define the System\n\n\"What economic/business logic does this system encode?\"\n\nExample: \"A lending protocol where users deposit BCH, borrow stablecoins, pay interest, and can be liquidated.\"\n\n### Step 2: Identify Value Flows\n\nDraw arrows showing how value moves:\n- BCH: User → Loan (collateral) → User (on repayment) / StabilityPool (on liquidation)\n- Tokens: Minting contract → User (on borrow) → Burn (on repay/redeem)\n\n### Step 3: Identify State\n\nWhat needs to be tracked?\n- Loan: borrowed amount, collateral, interest rate, status\n- Pool: total staked, period, accumulated interest\n- Price: current price, last update\n\n### Step 4: Design Contract Topology\n\n```\n1. What holds value? → Container contracts (Loan, StabilityPool)\n2. What operations exist? → Function contracts (manage, payInterest, liquidate)\n3. What needs extra tokens? → Sidecar contracts\n4. What creates things? → Minting contracts (Redeemer, Factory)\n```\n\n### Step 5: Design Transaction Layouts\n\nFor EACH operation, document:\n```\nOperation: payInterest\nInputs:  [price, loan, sidecar, function, collector]\nOutputs: [price, loan, sidecar, function, collector]\nState changes: loan.lastPeriodInterestPaid++, collector.balance += interest\n```",
    "source": "concepts/cashscript-mental-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Part 10: From Intent to Implementation",
      "Step 1: Define the System",
      "Step 2: Identify Value Flows",
      "Step 3: Identify State",
      "Step 4: Design Contract Topology",
      "Step 5: Design Transaction Layouts"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-0",
    "content": "# Multi-Contract Architecture in CashScript\n\nThis document covers production-grade patterns for building complex systems with multiple interacting CashScript contracts. These patterns are derived from analysis of ParityUSD, a 26-contract production stablecoin system.\n\n---\n\n## The Fundamental Challenge",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "Multi-Contract Architecture in CashScript",
      "The Fundamental Challenge"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-1",
    "content": "## The Fundamental Challenge\n\nIn the UTXO model, contracts cannot \"call\" each other like in EVM. Instead, multiple contracts must participate in the SAME transaction, with each validating its own constraints. This requires careful architecture.\n\n**Key Insight**: Multi-contract systems are transaction-structure problems, not code-flow problems.\n\n---\n\n## Pattern 1: Main+Sidecar",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "The Fundamental Challenge",
      "Pattern 1: Main+Sidecar"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-2",
    "content": "## Pattern 1: Main+Sidecar\n\n### The Problem\nBitcoin Cash allows only **one token category per UTXO output**. A contract that needs to manage both an NFT (for state) and fungible tokens (for value) cannot hold them in a single UTXO.\n\n### The Solution\nPair every \"main\" contract with a \"sidecar\" that holds additional tokens.\n\n```\n┌─────────────────┐      ┌─────────────────────┐\n│   Main.cash     │      │  MainSidecar.cash   │\n│   (NFT state)   │◄────►│  (fungible tokens)  │\n└─────────────────┘      └─────────────────────┘\n```\n\n### The Attach Pattern\nThe sidecar proves it belongs to the main contract by verifying they were created in the same transaction:\n\n```cashscript\ncontract TokenSidecar() {\n    function attach() {\n        // Sidecar must be immediately after main contract in inputs\n        int mainIndex = this.activeInputIndex - 1;\n\n        // CRITICAL: Prove same-transaction origin\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIndex].outpointTransactionHash);\n\n        // CRITICAL: Prove sequential output indices\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIndex].outpointIndex + 1);\n\n        // Self-replicate\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        require(tx.outputs[this.activeInputIndex].value == 1000);\n    }\n}\n```\n\n### Why This Works\n- `outpointTransactionHash` equality proves both UTXOs came from the same creating transaction",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "Pattern 1: Main+Sidecar",
      "The Problem",
      "The Solution",
      "The Attach Pattern",
      "Why This Works"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-3",
    "content": "- `outpointIndex` sequential ordering proves they were created as adjacent outputs\n- Together, this creates an unbreakable bond between main and sidecar\n\n### When to Use\n- Contract manages NFT state AND fungible tokens\n- Contract needs to hold multiple token categories\n- Complex DeFi protocols (lending, stablecoins, DEXes)\n\n---\n\n## Pattern 2: Function Contracts",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "When to Use",
      "Pattern 2: Function Contracts"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-4",
    "content": "## Pattern 2: Function Contracts\n\n### The Problem\nA contract with many functions becomes:\n- Hard to maintain\n- Expensive to execute (all code loaded even if using one function)\n- Difficult to upgrade\n\n### The Solution\nSplit each logical \"function\" into a separate contract file, authenticated by NFT commitment bytes.\n\n```\nMainCoordinator.cash\n   │\n   ├── functionA.cash     (NFT commitment prefix: 0x00)\n   ├── functionB.cash     (NFT commitment prefix: 0x01)\n   ├── functionC.cash     (NFT commitment prefix: 0x02)\n   └── functionD.cash     (NFT commitment prefix: 0x03)\n```\n\n### The Routing Pattern\n\nMain contract routes to appropriate validation based on function identifier:\n\n```cashscript\ncontract MainCoordinator(bytes32 systemTokenId) {\n    function interact(int functionInputIndex) {\n        // Extract function identifier from the function contract's NFT\n        bytes functionId = tx.inputs[functionInputIndex].nftCommitment.split(1)[0];\n\n        // Authenticate the function contract\n        require(tx.inputs[functionInputIndex].tokenCategory == systemTokenId + 0x01);\n\n        // Route to appropriate validation\n        if (functionId == 0x00) {\n            // Function A validation logic\n            require(tx.outputs.length <= 5);\n            // ... specific constraints\n        } else if (functionId == 0x01) {\n            // Function B validation logic\n            require(tx.outputs.length <= 7);\n            // ... specific constraints\n        } else if (functionId == 0x02) {\n            // Function C validation logic\n            // ...\n        }\n        // Add more functions as needed\n    }\n}\n```",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Pattern 2: Function Contracts",
      "The Problem",
      "The Solution",
      "The Routing Pattern"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-5",
    "content": "### Function Contract Template\n\nEach function contract validates its own logic and position:\n\n```cashscript\ncontract FunctionA(bytes32 systemTokenId) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Execute function A operation.\n    //\n    //inputs:\n    //  0   MainCoordinator           [NFT]       (from MainCoordinator contract)\n    //  1   functionA                 [NFT]       (from FunctionA contract - this)\n    //  2   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   MainCoordinator           [NFT]       (to MainCoordinator contract)\n    //  1   functionA                 [NFT]       (to FunctionA contract)\n    //  2   result                    [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function execute() {\n        // Validate this contract's position\n        require(this.activeInputIndex == 1);\n\n        // Validate main coordinator at position 0\n        require(tx.inputs[0].tokenCategory == systemTokenId + 0x01);\n        require(tx.inputs[0].nftCommitment.split(1)[0] == 0xFF); // Main identifier\n\n        // Function-specific validation\n        // ...\n\n        // Self-replicate at fixed value\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);\n        require(tx.outputs[1].value == 1000);\n    }\n}\n```\n\n### Benefits",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Function Contract Template",
      "Benefits"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-6",
    "content": "- **Modularity**: Add new functions without changing main contract\n- **Efficiency**: Only load code for the function being executed\n- **Security**: Each function can have specific output limits\n- **Upgradability**: Deploy new function contracts while keeping main contract\n\n---\n\n## Pattern 3: Strict Input Position",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "Pattern 3: Strict Input Position"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-7",
    "content": "## Pattern 3: Strict Input Position\n\n### The Rule\nEvery contract in a multi-contract transaction must know exactly which input index it occupies and which indices other contracts occupy.\n\n### Why This Matters\nWithout explicit position validation:\n- Attackers could reorder inputs to bypass validation\n- Contracts might validate the wrong input\n- Transaction structure becomes ambiguous\n\n### Implementation\n\n```cashscript\nfunction myOperation() {\n    // ALWAYS validate your own position first\n    require(this.activeInputIndex == 2);\n\n    // Define expected positions\n    // Index 0: Price oracle\n    // Index 1: Main contract\n    // Index 2: This function contract\n    // Index 3: User BCH\n\n    // Validate each position\n    require(tx.inputs[0].tokenCategory == oracleCategory);\n    require(tx.inputs[1].tokenCategory == mainCategory);\n    require(tx.inputs[3].tokenCategory == 0x); // Pure BCH\n\n    // Now safe to use these indices\n}\n```\n\n### Position Documentation Pattern\n\nAlways document input/output positions in function headers:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Process a redemption operation.\n//\n//inputs:\n//  0   PriceOracle               [NFT]       (from PriceOracle contract)\n//  1   MainContract              [NFT]       (from Main contract)\n//  2   MainSidecar               [NFT]       (from Sidecar contract)\n//  3   redeemFunction            [NFT]       (from Redeem contract - this)\n//  4   userKey                   [NFT]       (from user)\n//  5   feeBCH                    [BCH]       (from fee payer)\n//outputs:\n//  0   PriceOracle               [NFT]       (to PriceOracle contract)\n//  1   MainContract              [NFT]       (to Main contract)\n//  2   MainSidecar               [NFT]       (to Sidecar contract)\n//  3   redeemFunction            [NFT]       (to Redeem contract)\n//  4   userPayment               [BCH]       (to user)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction redeem() {\n    require(this.activeInputIndex == 3);\n    // ...\n}\n```",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Pattern 3: Strict Input Position",
      "The Rule",
      "Why This Matters",
      "Implementation",
      "Position Documentation Pattern"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-8",
    "content": "---\n\n## Pattern 4: Self-Replicating Covenant Categories\n\n### Four Types of Covenants\n\n| Type | What Changes | Example Use |\n|------|--------------|-------------|\n| **Exactly Self-Replicating** | Nothing | Factory contracts, routers |\n| **State-Mutating** | Only NFT commitment | Price oracles, counters |\n| **State-and-Balance-Mutating** | NFT commitment + BCH value | Liquidity pools, treasuries |\n| **Conditionally-Replicating** | Sometimes doesn't replicate | Loans (close on repayment) |\n\n### The 5-Point Validation Checklist\n\nFor any self-replicating covenant, validate ALL of:\n\n```cashscript\n// 1. Same contract code\nrequire(tx.outputs[idx].lockingBytecode == tx.inputs[idx].lockingBytecode);\n\n// 2. Same token category\nrequire(tx.outputs[idx].tokenCategory == tx.inputs[idx].tokenCategory);\n\n// 3. Expected satoshi value\nrequire(tx.outputs[idx].value == expectedValue);\n\n// 4. Expected token amount\nrequire(tx.outputs[idx].tokenAmount == expectedTokenAmount);\n\n// 5. Expected state (or modified state)\nrequire(tx.outputs[idx].nftCommitment == newCommitment);\n```\n\n### Exactly Self-Replicating Example\n\n```cashscript\ncontract Router() {\n    function route() {\n        // Validate exact self-replication\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].value == tx.inputs[0].value);\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n        require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\n\n        // Router logic...\n    }\n}\n```",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "Pattern 4: Self-Replicating Covenant Categories",
      "Four Types of Covenants",
      "The 5-Point Validation Checklist",
      "Exactly Self-Replicating Example"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-9",
    "content": "### State-Mutating Example\n\n```cashscript\ncontract Counter() {\n    function increment() {\n        // Parse current count\n        int count = int(tx.inputs[0].nftCommitment);\n\n        // Increment\n        int newCount = count + 1;\n\n        // Self-replicate with new state\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        require(tx.outputs[0].value == tx.inputs[0].value);\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n        require(tx.outputs[0].nftCommitment == bytes8(newCount)); // Changed!\n    }\n}\n```\n\n---\n\n## Pattern 5: Cross-Contract Trust Model",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "State-Mutating Example",
      "Pattern 5: Cross-Contract Trust Model"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-10",
    "content": "## Pattern 5: Cross-Contract Trust Model\n\n### Token Category Arithmetic\n\nContracts authenticate each other using deterministic category offsets:\n\n```cashscript\n// Root category (32 bytes)\nbytes32 systemTokenId = 0x1234...;\n\n// Different contracts/NFTs use offsets\n// systemTokenId + 0x00 = immutable NFTs\n// systemTokenId + 0x01 = mutable NFTs\n// systemTokenId + 0x02 = minting NFTs\n\n// Validate another contract has minting authority\nrequire(tx.inputs[0].tokenCategory == systemTokenId + 0x02);\n\n// Validate another contract has mutable NFT\nrequire(tx.inputs[1].tokenCategory == systemTokenId + 0x01);\n```\n\n### The 33rd Byte\n\nThe `tokenCategory` field is 33 bytes:\n- Bytes 0-31: The category ID\n- Byte 32: The capability flag\n  - `0x00` or absent = immutable\n  - `0x01` = mutable\n  - `0x02` = minting\n\n### Extracting Category vs Capability\n\n```cashscript\nbytes category, bytes capability = tx.inputs[0].tokenCategory.split(32);\n\n// Check specific capability\nrequire(capability == 0x02); // Must be minting\nrequire(capability == 0x01); // Must be mutable\nrequire(capability == 0x);   // Must be immutable\n```\n\n### Trust Hierarchies\n\n```\nMinting NFT (0x02)\n   │\n   ├── Can create new mutable NFTs\n   ├── Can create new immutable NFTs\n   │\n   └── Mutable NFT (0x01)\n          │\n          ├── Can modify own commitment once\n          ├── Can downgrade to immutable\n          │\n          └── Immutable NFT (0x00)\n                 │\n                 └── Permanent, cannot change\n```\n\n---\n\n## Pattern 6: Origin Proof Chains",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "Pattern 5: Cross-Contract Trust Model",
      "Token Category Arithmetic",
      "The 33rd Byte",
      "Extracting Category vs Capability",
      "Trust Hierarchies",
      "Pattern 6: Origin Proof Chains"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-11",
    "content": "## Pattern 6: Origin Proof Chains\n\n### The Problem\nHow do you prove an NFT was legitimately created by your system?\n\n### The Solution\nChain of contracts that verify same-transaction origin:\n\n```\nFactory.cash\n    │\n    ├─► Enforcer.cash (verifies Factory co-created)\n    │       │\n    │       └─► Proof.cash (verifies Enforcer co-created)\n    │               │\n    └───────────────┴─► [final verified NFT]\n```\n\n### Implementation\n\n**Factory** creates both Enforcer and Proof in same transaction:\n```cashscript\ncontract Factory() {\n    function create() {\n        // Create enforcer at output 1\n        require(tx.outputs[1].tokenCategory == factoryCategory + 0x01);\n\n        // Create proof at output 2\n        require(tx.outputs[2].tokenCategory == factoryCategory);\n        require(tx.outputs[2].nftCommitment == proofData);\n    }\n}\n```\n\n**Enforcer** verifies it was co-created with Factory:\n```cashscript\ncontract Enforcer() {\n    function verify() {\n        int factoryIdx = this.activeInputIndex - 1;\n\n        // Must have been created together\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[factoryIdx].outpointTransactionHash);\n    }\n}\n```\n\n---\n\n## Pattern 7: Output Count Limiting",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "Pattern 6: Origin Proof Chains",
      "The Problem",
      "The Solution",
      "Implementation",
      "Pattern 7: Output Count Limiting"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-12",
    "content": "## Pattern 7: Output Count Limiting\n\n### Critical Security Rule\n\n**ALWAYS limit the maximum number of outputs** to prevent unauthorized token minting.\n\n```cashscript\nfunction anyOperation() {\n    // CRITICAL: Prevent minting attacks\n    require(tx.outputs.length <= 5);\n\n    // ... rest of logic\n}\n```\n\n### Standard Limits by Contract Type\n\n| Contract Type | Typical Limit | Reason |\n|--------------|---------------|--------|\n| Simple transfer | 3-4 | Input + output + change |\n| Function contract | 5-7 | Participants + change |\n| Batch operation | 10-20 | Multiple recipients |\n| Maximum recommended | 50 | Transaction size limits |\n\n### Why This Matters\n\nWithout output limits, an attacker could:\n1. Create a valid transaction\n2. Add extra outputs minting unauthorized tokens\n3. The contract wouldn't notice the extra outputs\n\n---\n\n## Contract Purpose Philosophy",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Pattern 7: Output Count Limiting",
      "Critical Security Rule",
      "Standard Limits by Contract Type",
      "Why This Matters",
      "Contract Purpose Philosophy"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-13",
    "content": "## Contract Purpose Philosophy\n\n### The Golden Rule\n\n**Before creating any contract, answer: \"What does this contract validate?\"**\n\nIf the answer is \"nothing,\" the contract should not exist.\n\n### What Real Contracts Validate\n\n| Contract Type | What It Validates |\n|--------------|-------------------|\n| Sidecar | Same-origin with main contract |\n| Function | Authority to execute operation |\n| Router | Transaction structure matches operation type |\n| Oracle | Price data authenticity |\n| Receipt | Proof of completed action |\n\n### Minimum Viable Contract\n\nEven the simplest contract (a sidecar) has meaningful validation:\n\n```cashscript\ncontract MinimalSidecar() {\n    function attach() {\n        int mainIdx = this.activeInputIndex - 1;\n\n        // Validates: Was created with main contract\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIdx].outpointTransactionHash);\n\n        // Validates: Sequential output position\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIdx].outpointIndex + 1);\n\n        // Validates: Self-replication\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n    }\n}\n```\n\nThis is NOT a placeholder - it validates three critical relationships.\n\n### Anti-Placeholder Principle\n\nThe question is never \"how do I implement this function?\"\n\nThe question is \"what constraint does this contract add to the transaction?\"",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "Contract Purpose Philosophy",
      "The Golden Rule",
      "What Real Contracts Validate",
      "Minimum Viable Contract",
      "Anti-Placeholder Principle"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-14",
    "content": "If no constraint, no contract.\n\n---\n\n## Deployment Checklist\n\nWhen deploying a multi-contract system:\n\n1. **Deploy all contracts** - Get P2SH32 addresses\n2. **Create token category** - Genesis transaction\n3. **Hardcode addresses** - Embed in source where needed\n4. **Recompile** - With embedded addresses\n5. **Redeploy** - Final deployment with trust anchors\n6. **Mint system NFTs** - Create master/function/sidecar NFTs\n7. **Initialize positions** - Send NFTs to their contracts\n8. **Test transactions** - Verify all positions work\n\n### Critical Note\n\nContracts are **immutable after deployment**. All inter-contract addresses must be correct at compile time. Plan carefully.\n\n---\n\n## MANDATORY CONTRACT VALIDATION CHECKLIST",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Deployment Checklist",
      "Critical Note",
      "MANDATORY CONTRACT VALIDATION CHECKLIST"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-15",
    "content": "## MANDATORY CONTRACT VALIDATION CHECKLIST\n\n**CRITICAL: Before finalizing ANY contract, verify ALL items below.**\n\n### For EVERY Contract (Primary, Helper, or State)\n\n| # | Requirement | Example |\n|---|-------------|---------|\n| 1 | **Output count is LIMITED** | `require(tx.outputs.length <= 5);` |\n| 2 | **Function name describes purpose** | `validateUpdate()`, `attachToMain()` |\n| 3 | **Input/output positions documented** | See Position Documentation Pattern |\n\n### For Self-Replicating Contracts (5-Point Covenant)\n\n| # | Validation | Code |\n|---|------------|------|\n| 1 | Same contract code | `require(tx.outputs[idx].lockingBytecode == tx.inputs[idx].lockingBytecode);` |\n| 2 | Same token category | `require(tx.outputs[idx].tokenCategory == tx.inputs[idx].tokenCategory);` |\n| 3 | Expected satoshi value | `require(tx.outputs[idx].value == 1000);` |\n| 4 | Expected token amount | `require(tx.outputs[idx].tokenAmount == expectedAmount);` |\n| 5 | Expected/validated commitment | `require(tx.outputs[idx].nftCommitment == expectedCommitment);` |\n\n### BANNED Patterns\n\n```cashscript\n// WRONG - Never use these:\nfunction placeholder() { ... }     // Vague, suggests stub\nfunction update() { ... }          // Too generic\nfunction handle() { ... }          // Meaningless\n\n// RIGHT - Descriptive names:\nfunction validateVoteUpdate() { ... }\nfunction attachToVotingBooth() { ... }\nfunction processRedemption() { ... }\n```\n\n### State Contract Minimum Requirements\n\nState contracts that participate in transactions with other contracts MUST:",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "MANDATORY CONTRACT VALIDATION CHECKLIST",
      "For EVERY Contract (Primary, Helper, or State)",
      "For Self-Replicating Contracts (5-Point Covenant)",
      "BANNED Patterns",
      "State Contract Minimum Requirements"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-16",
    "content": "1. **Validate their position**: `require(this.activeInputIndex == expectedIndex);`\n2. **Authenticate the primary contract**: Verify token category of the coordinating contract\n3. **Limit outputs**: `require(tx.outputs.length <= N);`\n4. **Complete 5-point self-replication**: All 5 covenant validations\n5. **Document the transaction structure**: Input/output position comments\n\n### Example: Correct State Contract\n\n```cashscript\ncontract ProposalCounter() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Validate proposal vote count updates during VotingBooth.vote() transactions.\n    //\n    //inputs:\n    //  0   VotingBooth               [NFT]       (from VotingBooth contract)\n    //  1   VoterKey                  [NFT]       (from voter)\n    //  2   ProposalCounter           [NFT]       (this contract)\n    //  3   voterBCH                  [BCH]       (from voter)\n    //outputs:\n    //  0   VotingBooth               [NFT]       (to VotingBooth contract)\n    //  1   VoterKey                  [NFT]       (to voter)\n    //  2   ProposalCounter           [NFT]       (to ProposalCounter contract)\n    //  3   change {optional}         [BCH]       (to voter)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function validateVoteUpdate() {\n        // 1. Validate position\n        require(this.activeInputIndex == 2);\n\n        // 2. CRITICAL: Limit outputs\n        require(tx.outputs.length <= 4);\n\n        // 3. Authenticate VotingBooth at position 0\n        bytes masterCategory = tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0];\n        require(tx.inputs[0].tokenCategory == masterCategory + 0x01);\n\n        // 4. Complete 5-point self-replication\n        require(tx.outputs[2].lockingBytecode == tx.inputs[2].lockingBytecode);\n        require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);\n        require(tx.outputs[2].value == 1000);\n        require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount);\n        // Commitment validated by VotingBooth (vote count increment)\n        // But we still verify structure is preserved\n        bytes4 proposalIdx = bytes4(tx.inputs[2].nftCommitment.split(4)[0]);\n        bytes32 proposalName = bytes32(tx.inputs[2].nftCommitment.split(12)[1]);\n        bytes8 newVoteCount = bytes8(tx.outputs[2].nftCommitment.split(4)[1].split(8)[0]);\n        require(tx.outputs[2].nftCommitment.split(4)[0] == proposalIdx);\n        require(tx.outputs[2].nftCommitment.split(12)[1] == proposalName);\n    }\n}\n```",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes",
      "Example: Correct State Contract"
    ]
  },
  {
    "id": "concepts/multi-contract-architecture.md-17",
    "content": "This contract validates:\n- Its position in the transaction\n- Output count security limit\n- Primary contract authentication\n- All 5 covenant points\n- State transition integrity (proposal index and name preserved)",
    "source": "concepts/multi-contract-architecture.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-0",
    "content": "# UTXO vs Account Model - EVM→CashScript Conversion Reference\n\n## Core Model Differences\n\n| Aspect | UTXO (CashScript/BCH) | Account (EVM/Solidity) |\n|--------|----------------------|------------------------|\n| **State** | No global state, independent atomic UTXOs | Global state tree, persistent storage |\n| **Execution** | Transaction-level validation, stateless scripts | Contract-level execution, stateful |\n| **Concurrency** | Parallel spending of different UTXOs | Sequential (nonce-based) |\n| **Persistence** | UTXO chains, NFT commitments (40 bytes, 128 in May 2026) | Storage slots, mappings, state variables |\n| **Transaction** | Multiple inputs → Multiple outputs | Single sender → Single recipient |\n| **Gas Model** | Fee based on tx size (bytes) | Computational steps (opcode-based) |\n| **Introspection** | Full tx visibility (`tx.inputs[]`, `tx.outputs[]`) | Limited (`msg.sender`, `msg.value`) |\n| **Covenants** | Native output constraints via bytecode validation | No native support |\n| **Reentrancy** | N/A (atomic transactions) | Vulnerable (requires guards) |\n| **Arrays** | Limited (multiple UTXOs or covenant chains) | Native arrays, mappings |\n| **Tokens** | Native CashTokens (FT/NFT) | ERC-20/721 contract standards |\n| **Inter-Contract** | Via multi-input transactions | `call`, `delegatecall`, `staticcall` |\n| **Loops** | `do {} while()` (v0.13.0+, beta) | `for`, `while`, `do while` |\n| **Signatures** | Explicit `checkSig(sig, pk)` | Implicit `msg.sender` recovery |\n| **Time** | `tx.time` (block height or Unix timestamp) | `block.timestamp`, `block.number` |",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "introspection",
      "bytes",
      "UTXO vs Account Model - EVM→CashScript Conversion Reference",
      "Core Model Differences"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-1",
    "content": "## CashScript UTXO Primitives\n\n### Transaction Introspection\n\n```cashscript\n// Input Properties\ntx.inputs[i].value                 // int: BCH amount in satoshis\ntx.inputs[i].lockingBytecode       // bytes: Input script\ntx.inputs[i].tokenCategory         // bytes: 32-byte category + optional capability (0x01=mutable, 0x02=minting)\ntx.inputs[i].tokenAmount           // int: Fungible token amount\ntx.inputs[i].nftCommitment         // bytes: NFT data (40 bytes, 128 in May 2026)\ntx.inputs[i].sequenceNumber        // int: nSequence field value\ntx.inputs[i].unlockingBytecode     // bytes: scriptSig of input\ntx.inputs[i].outpointTransactionHash // bytes32: Previous transaction hash\ntx.inputs[i].outpointIndex         // int: Previous output index\n\n// Output Properties\ntx.outputs[i].value                // int: BCH amount in satoshis\ntx.outputs[i].lockingBytecode      // bytes: Output script\ntx.outputs[i].tokenCategory        // bytes: 32-byte category + optional capability (0x01=mutable, 0x02=minting)\ntx.outputs[i].tokenAmount          // int: Fungible token amount\ntx.outputs[i].nftCommitment        // bytes: NFT data (40 bytes, 128 in May 2026)\n\n// Context\nthis.activeInputIndex              // int: Current UTXO being spent\nthis.activeBytecode                // bytes: Current UTXO's script\n\n// Time\ntx.time                           // int: nLocktime (<500M=block, ≥500M=Unix timestamp)\ntx.version                        // int: Transaction version\ntx.locktime                       // int: nLocktime value (use for arithmetic/assignments)\nthis.age                          // int: nSequence relative timelock (blocks only in SDK)\n```",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "transaction",
      "introspection",
      "bytes",
      "int",
      "CashScript UTXO Primitives",
      "Transaction Introspection"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-2",
    "content": "### Locking Bytecode Constructors\n\n```cashscript\nnew LockingBytecodeP2PKH(bytes20 pkHash)           // Standard payment\nnew LockingBytecodeP2SH20(bytes20 scriptHash)      // Legacy (less secure)\nnew LockingBytecodeP2SH32(bytes32 scriptHash)      // Default (more secure)\nnew LockingBytecodeNullData(bytes[] chunks)        // OP_RETURN (223 bytes total/tx)\n```\n\n### Timelock Semantics\n\n```cashscript\n// Absolute Time (nLocktime)\nrequire(tx.time >= lockTime);      // ✅ ALWAYS use >= (not >)\n\n// Relative Time (nSequence)\nrequire(this.age >= blocks);       // Blocks only (SDK limitation, not 512-sec chunks)\n```\n\n## EVM→CashScript Pattern Mappings",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "bytes",
      "Locking Bytecode Constructors",
      "Timelock Semantics",
      "EVM→CashScript Pattern Mappings"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-3",
    "content": "## EVM→CashScript Pattern Mappings\n\n| Solidity | CashScript | Notes |\n|----------|-----------|-------|\n| `constructor(address _owner)` | `contract MyContract(pubkey owner)` | Parameters are immutable, set at instantiation |\n| `uint256 balance;` | NFT commitment or UTXO chain | State stored in NFT commitments (40 bytes, 128 in May 2026) |\n| `mapping(address => uint)` | NFT commitment + loop validation | No native mappings, use arrays or commitment data |\n| `require(condition, \"msg\")` | `require(condition);` | No error messages, tx fails if false |\n| `msg.sender` | `checkSig(sig, pubkey)` | Explicit signature verification required |\n| `msg.value` | `tx.inputs[this.activeInputIndex].value` | Must sum inputs, validate outputs |\n| `transfer(recipient, amount)` | `require(tx.outputs[0].value >= amount)` | Covenant-based output validation |\n| `payable` keyword | No keyword | All functions can handle value |\n| `emit Event(data)` | UTXO change is implicit event; OP_RETURN optional | Transaction IS the event. OP_RETURN only for extra off-chain metadata |\n| `modifier onlyOwner` | `require(checkSig(s, pk));` | No native modifiers, inline checks |\n| `for(uint i=0; i<n; i++)` | `do { i=i+1; } while(i<n)` | Beta in v0.13.0, body executes first |\n| Reentrancy guard | N/A | No reentrancy in UTXO model |\n| `storage[]` arrays | Multiple UTXOs or covenant | No storage arrays, separate UTXOs |\n| ERC-20 | CashTokens fungible | Native: `tokenAmount`, `tokenCategory` |\n| ERC-721 | CashTokens NFT | Native: `nftCommitment`, capabilities |",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "bytes",
      "EVM→CashScript Pattern Mappings"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-4",
    "content": "| `balanceOf[addr]` | `tx.inputs[i].tokenAmount` | Query UTXOs for token balance |\n| `view` functions | N/A | All validation happens in spending tx |\n| `pure` functions | User-defined functions | `function myFunc(): int { return 42; }` |\n| `public` function | All functions (no keyword) | No visibility modifiers in CashScript |\n| `private` function | `require(checkSig(s, pk))` | Gate access with signature checks |\n| `internal` function | N/A | No contract inheritance |\n| `external` function | All functions (no keyword) | All functions externally callable |\n| `this.balance` | `tx.inputs[this.activeInputIndex].value` | Current UTXO value |\n| `block.timestamp` | `tx.time` | nLocktime value |\n| `block.number` | `tx.time` (when <500M) | Block height |\n| `selfdestruct()` | Spend to any output | No self-destruct, just spend UTXO |\n| `delegatecall()` | N/A | No contract calls |\n| `call{value: x}()` | Multi-input transaction | Construct tx with multiple contract inputs |\n| `import` | N/A | No code imports - single file contracts |\n| `interface` | N/A | No abstract contracts |\n| `library` | N/A | No reusable libraries |\n| `enum` | int constants | `int PENDING = 0; int ACTIVE = 1;` |\n| `struct` | bytes + `.split()` | Pack into bytes, unpack with split() |\n| `address` type | `bytes20` or `pubkey` | Hash160 or 33-byte public key |\n| `constant` keyword | Constructor params | Immutable per UTXO instance |\n| `immutable` keyword | Constructor params | Same as constant - set at deployment |\n| `assert(condition)` | `require(condition);` | Only require() exists |",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-5",
    "content": "| `revert(\"msg\")` | N/A | No explicit revert - use conditional require() instead. **NEVER use `require(false)` - it creates dead code** |\n| `tx.origin` | N/A | No transaction originator concept |\n| `storage` location | N/A | Stack-based execution, no storage |\n| `memory` location | N/A | Ephemeral stack, no memory allocation |\n| `calldata` location | N/A | Transaction introspection instead |\n\n## Critical Gotchas",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "introspection",
      "Critical Gotchas"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-6",
    "content": "## Critical Gotchas\n\n### No Visibility Modifiers\n- ❌ No public/private/internal/external keywords\n- ❌ All functions callable by anyone who constructs valid transaction\n- ✅ Access control via explicit `require(checkSig(s, pk))` checks\n- ✅ Functions don't restrict callers - they restrict valid signatures\n\n### Stack-Based Execution (No Data Locations)\n- ❌ No `storage`, `memory`, `calldata` keywords\n- ❌ No persistent storage slots or state variables\n- ❌ No memory allocation or deallocation\n- ✅ All operations on ephemeral stack\n- ✅ State lives in NFT commitments (40 bytes, 128 in May 2026) or UTXO outputs\n- ✅ Transaction introspection provides input data\n\n### No O(1) Lookups\n- ❌ No mappings - NO hash table lookups\n- ❌ Cannot do `balances[address]` constant-time access\n- ✅ Must loop over UTXOs or commitment data\n- ✅ Off-chain indexing for complex queries\n- ⚠️ Fundamentally different from Solidity's O(1) mapping pattern\n\n### No Code Reuse Mechanisms\n- ❌ No `import` statements\n- ❌ No `library` contracts\n- ❌ No contract inheritance (`is` keyword)\n- ❌ No `virtual`/`override` patterns\n- ✅ Single file contracts only\n- ✅ Copy-paste or user-defined functions for reuse\n\n### Transaction Size Fees (Not Gas)\n- ❌ No opcode-based gas costs\n- ❌ No storage slot packing optimization\n- ✅ Fee = transaction size in bytes × sat/byte rate\n- ✅ Optimize by minimizing output count, using P2S over P2SH\n- ✅ NFT commitment size (40 bytes, 128 in May 2026) affects fee, not \"gas\"\n\n### State Management\n- ❌ No persistent state variables",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "introspection",
      "bytes",
      "Critical Gotchas",
      "No Visibility Modifiers",
      "Stack-Based Execution (No Data Locations)",
      "No O(1) Lookups",
      "No Code Reuse Mechanisms",
      "Transaction Size Fees (Not Gas)",
      "State Management"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-7",
    "content": "- ✅ State via UTXO chains: validate input state → create output with new state\n- ✅ Pattern: `require(tx.inputs[0].nftCommitment == oldState)` + `require(tx.outputs[0].nftCommitment == newState)`\n\n### No Inter-Contract Calls\n- ❌ Cannot call other contracts\n- ❌ No `call`, `delegatecall`, `staticcall`\n- ✅ Multi-contract interaction via transaction construction (multiple inputs from different contracts)\n\n### Array Bounds Validation\n- ❌ No automatic bounds checking\n- ✅ ALWAYS validate: `require(tx.outputs.length > index)` before access\n- ✅ Same for `tx.inputs.length`\n\n### No Short-Circuit Evaluation\n- ❌ `&&` and `||` evaluate ALL operands (not lazy)\n- ❌ Cannot use `array.length > 0 && array[0] == value` safely\n- ✅ Must separate: `require(array.length > 0); require(array[0] == value);`\n\n### Time Comparison Operators\n- ❌ `tx.time > lockTime` is WRONG\n- ✅ `tx.time >= lockTime` is CORRECT (ALWAYS use `>=`)\n- ❌ `this.age` is NOT 512-second chunks (SDK limitation)\n- ✅ `this.age` is blocks only\n\n### Arithmetic Limitations\n- ❌ No decimals, no floating point\n- ❌ Integer-only, division truncates\n- ❌ No compound assignment (`+=`, `-=`, `*=`, `/=`, `%=`)\n- ✅ Manual operations: `x = x + 1` (not `x++` or `x += 1`)\n- ✅ Overflow checks: `require(a + b >= a)`\n\n### Bitwise Operations\n- ❌ Current: No shift operators (`<<`, `>>`)\n- ❌ Current: No bitwise NOT (`~`)\n- ✅ Current: Only `&`, `|`, `^`\n- ✅ May 2026 upgrade: Full bitwise support including `~`, shifts\n\n### Token Category Byte Order\n- ⚠️ `tokenCategory` returned in unreversed order (unlike tx hashes)",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "No Inter-Contract Calls",
      "Array Bounds Validation",
      "No Short-Circuit Evaluation",
      "Time Comparison Operators",
      "Arithmetic Limitations",
      "Bitwise Operations",
      "Token Category Byte Order"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-8",
    "content": "- ✅ Use as-is without reversal\n\n### Signature Validation\n- ⚠️ `checkSig(0x, pubkey)` returns `false` (not failure)\n- ⚠️ Empty signature = valid false response\n- ⚠️ Invalid signature format = transaction failure\n- ✅ Nullfail rule enforced\n\n### OP_RETURN (Off-Chain Metadata ONLY)\n- ❌ NOT for data storage (provably unspendable, funds burned)\n- ❌ NOT needed for \"events\" - UTXO changes are inherently observable\n- ❌ 223 bytes TOTAL across ALL OP_RETURN outputs in transaction\n- ✅ Use for optional off-chain indexer metadata (app-specific data)\n- ✅ For data storage, use NFT commitments\n- ✅ Transaction structure itself communicates state changes\n\n### Loops\n- ❌ No `for`, `while` loops in v0.12.1 (current stable)\n- ✅ v0.13.0+: `do { } while()` syntax (experimental/beta, not yet released)\n- ✅ ALWAYS validate bounds: `require(count <= maxIterations)` before loop\n- ✅ Check loop state for overflows\n\n### No Fallback/Receive\n- ❌ No automatic payment handling\n- ❌ No `fallback()` or `receive()`\n- ✅ Explicit function calls required\n\n### P2SH Standards\n- ✅ P2SH32 (32-byte hash) is default and more secure\n- ⚠️ P2SH20 (20-byte hash) is legacy, less collision-resistant\n- ✅ P2S (Pay to Script) reduces tx size by 23-35 bytes vs P2SH\n\n### VM Limits (May 2025 - ACTIVE)\n- ✅ Stack element limit: 10,000 bytes (was 520 bytes)\n- ✅ 201-operation limit removed, replaced by operation cost system\n- ✅ BigInt support for large number arithmetic\n- ✅ Operation cost budget: (41 + unlocking_bytecode_length) × 800\n\n### May 2026 Upgrade (Future)",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "transaction",
      "bytes",
      "Signature Validation",
      "OP_RETURN (Off-Chain Metadata ONLY)",
      "Loops",
      "No Fallback/Receive",
      "P2SH Standards",
      "VM Limits (May 2025 - ACTIVE)",
      "May 2026 Upgrade (Future)"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-9",
    "content": "- ✅ 10,000 bytes unlocking bytecode limit (standard transactions)\n- ✅ NFT commitment: 40 bytes current (128 bytes in May 2026)\n- ✅ P2S (Pay to Script) becomes standard\n- ✅ Native loops and functions\n\n## Type System Reference",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "bytes",
      "Type System Reference"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-10",
    "content": "## Type System Reference\n\n| Type | Size | Range/Constraints | Operations | Auto-Convert To |\n|------|------|------------------|------------|----------------|\n| `bool` | 1 byte | `true`, `false` | `!`, `&&`, `\\|\\|` | N/A |\n| `int` | Variable | -2^63 to 2^63-1 | `+`, `-`, `*`, `/`, `%`, `<`, `>`, `==`, `!=`, `<=`, `>=` | `bytes` |\n| `string` | Variable | UTF-8 or hex (`0x...`) | `.split()`, `.slice()`, `.length`, `.reverse()` | `bytes` |\n| `bytes` | Variable | Arbitrary byte sequence | `.split()`, `.slice()`, `.length`, `.reverse()`, `&`, `\\|`, `^` | N/A |\n| `bytes1` to `bytes64` | Fixed (N) | Fixed-length byte sequence | Same as `bytes` | `bytes` |\n| `pubkey` | 33 bytes | Compressed public key | Used in `checkSig`, `checkMultiSig` | `bytes` |\n| `sig` | 64-65 bytes | Schnorr signature | Used in `checkSig`, `checkMultiSig` | `bytes` |\n| `datasig` | 64-65 bytes | Data signature | Used in `checkDataSig` | `bytes` |\n\n### Type Constraints\n- All variables explicitly typed (no `var`)\n- No implicit conversions\n- Fixed-length: `bytesN` where N ∈ [1, 64]\n- Collections: Arrays limited (mainly `sig[]`, `pubkey[]` for `checkMultiSig`)\n- Tuples: Only from `split()` operations, requires destructuring\n- Use `slice(start, end)` to extract bytes from middle positions without tuples\n\n### Operators\n\n| Category | Supported | Notes |\n|----------|-----------|-------|\n| Arithmetic | `+`, `-`, `*`, `/`, `%` | Integer only, division truncates |\n| Comparison | `<`, `<=`, `>`, `>=`, `==`, `!=` | All types |",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "bytes",
      "int",
      "string",
      "bool",
      "Type System Reference",
      "Type Constraints",
      "Operators"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-11",
    "content": "| Logical | `!`, `&&`, `\\|\\|` | No short-circuit evaluation |\n| Bitwise | `&`, `\\|`, `^` | `bytes` only - NOT supported on `int`. No `~`, `<<`, `>>` |\n| Assignment | `=` | No compound (`+=`, `-=`, etc.) |\n\n### Units\n\n```cashscript\n// BCH Units\n1 sats    = 1\n1 finney  = 10\n1 bits    = 100\n1 bitcoin = 100_000_000\n\n// Time Units\n1 seconds = 1\n1 minutes = 60 seconds\n1 hours   = 60 minutes\n1 days    = 24 hours\n1 weeks   = 7 days\n```\n\n### Built-in Functions\n\n| Function | Signature | Returns | Notes |\n|----------|-----------|---------|-------|\n| `abs()` | `abs(int a)` | `int` | Absolute value |\n| `min()` | `min(int a, int b)` | `int` | Minimum of two values |\n| `max()` | `max(int a, int b)` | `int` | Maximum of two values |\n| `within()` | `within(int x, int lower, int upper)` | `bool` | `lower <= x < upper` (upper exclusive) |\n| `sha256()` | `sha256(bytes data)` | `bytes32` | SHA-256 hash |\n| `sha1()` | `sha1(bytes data)` | `bytes20` | SHA-1 hash |\n| `ripemd160()` | `ripemd160(bytes data)` | `bytes20` | RIPEMD-160 hash |\n| `hash160()` | `hash160(bytes data)` | `bytes20` | SHA-256 then RIPEMD-160 |\n| `hash256()` | `hash256(bytes data)` | `bytes32` | Double SHA-256 |\n| `checkSig()` | `checkSig(sig s, pubkey pk)` | `bool` | Verify signature |\n| `checkMultiSig()` | `checkMultiSig(sig[] sigs, pubkey[] pks)` | `bool` | NOT supported in SDK |\n| `checkDataSig()` | `checkDataSig(datasig s, bytes msg, pubkey pk)` | `bool` | Verify data signature |\n| `bytes()` | `bytes(T data)` | `bytes` | Convert to bytes |",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "function",
      "bytes",
      "int",
      "bool",
      "Units",
      "Built-in Functions"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-12",
    "content": "### Mental Model: UTXO State Continuity\n\n```\nEVM: storage.balance += amount (in-place state update)\n\nCashScript:\n1. Consume UTXO with current balance (input)\n2. Validate input has expected balance state: require(tx.inputs[0].nftCommitment == oldState)\n3. Create new UTXO with updated balance (output)\n4. Enforce balance conservation: sum(inputs) == sum(outputs) + fee\n5. Set new state: require(tx.outputs[0].nftCommitment == newState)\n```\n\nThink in terms of:\n- **Input Selection**: Which UTXOs to consume\n- **Validation Logic**: What conditions must inputs/outputs satisfy\n- **Output Creation**: What UTXOs to create\n- **State Continuity**: How to link current UTXO to next state\n\nNOT:\n- ~~Storage updates~~\n- ~~State transitions in-place~~\n- ~~Function calls between contracts~~\n- ~~Persistent memory~~\n\n## Solidity Multi-Contract Pattern Mappings",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Mental Model: UTXO State Continuity",
      "Solidity Multi-Contract Pattern Mappings"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-13",
    "content": "## Solidity Multi-Contract Pattern Mappings\n\nWhen converting multi-contract Solidity systems, use these CashScript equivalents:\n\n### Contract Interaction Patterns\n\n| Solidity Pattern | CashScript Equivalent |\n|-----------------|----------------------|\n| `contractA.call(contractB)` | Multi-input transaction with both contracts |\n| Shared state between contracts | Shared token category or NFT commitment |\n| Factory pattern | Main+Sidecar with function contracts |\n| Library pattern | N/A - inline everything directly |\n| Proxy/upgradeable pattern | Conditionally-replicating covenant |\n| Interface/abstract contract | Contract constructor parameters |\n\n### Storage Pattern Mappings\n\n| Solidity Storage | CashScript Equivalent |\n|-----------------|----------------------|\n| `mapping(address => uint)` | NFT commitment with pubkeyhash + value |\n| `array[]` | Multiple UTXOs or serialized bytes |\n| `struct` | Structured NFT commitment bytes |\n| Global state variable | NFT commitment field |\n| Immutable variable | Contract constructor parameter |\n\n### Function Call Mappings\n\n| Solidity | CashScript |\n|----------|------------|\n| `external function()` | Separate contract in transaction |\n| `internal function()` | Inline code (no functions) |\n| `view function()` | Read from NFT commitment |\n| `payable function()` | Accept BCH in transaction |\n| Modifier | `require()` statements at function start |\n\n### Multi-Contract Architecture Translation\n\n**Solidity: Contract calls contract**\n```solidity\ncontract A {\n    B otherContract;\n    function callB() {\n        otherContract.doSomething();\n    }\n}\n```",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes",
      "Solidity Multi-Contract Pattern Mappings",
      "Contract Interaction Patterns",
      "Storage Pattern Mappings",
      "Function Call Mappings",
      "Multi-Contract Architecture Translation"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-14",
    "content": "**CashScript: Multi-input transaction**\n```cashscript\n// Contract A and B must BOTH be inputs in same transaction\ncontract A(bytes32 contractBCategory) {\n    function interact() {\n        // Validate B is in transaction at known position\n        require(tx.inputs[1].tokenCategory == contractBCategory);\n\n        // B's contract will also validate its constraints\n        // Both must pass for transaction to succeed\n    }\n}\n```\n\n### Key Translation Rules\n\n1. **Every cross-contract call becomes a transaction structure**\n   - Caller and callee are both inputs\n   - Each validates its own constraints\n   - Transaction succeeds only if ALL pass\n\n2. **Every storage mapping becomes commitment bytes**\n   - Key = identifier byte(s)\n   - Value = serialized in commitment\n   - Lookups = byte.split() operations\n\n3. **Every modifier becomes require() guards**\n   - No separation between modifier and function\n   - All checks inline at function start\n\n4. **Every event becomes implicit**\n   - Transaction structure IS the event\n   - Input/output changes are observable\n   - No need for explicit event emission\n\n### Complete Translation Example\n\n**Solidity: Token with allowance**\n```solidity\ncontract Token {\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowances;\n\n    function transfer(address to, uint256 amount) {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n\n    function approve(address spender, uint256 amount) {\n        allowances[msg.sender][spender] = amount;\n    }\n}\n```",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "Key Translation Rules",
      "Complete Translation Example"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-15",
    "content": "**CashScript: Token with allowance (conceptual)**\n```cashscript\n// NOT directly translatable - requires architectural redesign\n// Option 1: Each user has their own NFT with balance commitment\n// Option 2: Central contract tracks via fungible tokens\n// Option 3: Allowance is separate approval NFT\n\ncontract UserBalance(bytes32 tokenCategory) {\n    // Balance stored in NFT commitment: bytes6 balance + bytes20 owner\n    function transfer(int amount, bytes20 recipientPkh) {\n        // Parse current balance from commitment\n        bytes commitment = tx.inputs[0].nftCommitment;\n        int balance = int(commitment.split(6)[0]);\n        bytes20 owner = bytes20(commitment.split(6)[1]);\n\n        // Validate sender owns this UTXO\n        require(tx.inputs[1].lockingBytecode ==\n                new LockingBytecodeP2PKH(owner));\n\n        // Validate amount\n        require(amount > 0);\n        require(amount <= balance);\n\n        // Create output with reduced balance (or burn if zero)\n        int newBalance = balance - amount;\n        if (newBalance > 0) {\n            bytes newCommitment = bytes6(newBalance) + owner;\n            require(tx.outputs[0].nftCommitment == newCommitment);\n        }\n\n        // Create recipient output\n        bytes recipientCommitment = bytes6(amount) + recipientPkh;\n        require(tx.outputs[1].nftCommitment == recipientCommitment);\n    }\n}\n```\n\n### What Cannot Be Directly Translated\n\n| Solidity Feature | Why Impossible | Alternative |\n|-----------------|----------------|-------------|",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "What Cannot Be Directly Translated"
    ]
  },
  {
    "id": "concepts/utxo-vs-account-model.md-16",
    "content": "| Dynamic arrays | No loops over arbitrary length | Fixed-size structures |\n| Unbounded mappings | No iteration | Split into multiple UTXOs |\n| Reentrancy guards | No reentrancy possible | Not needed (UTXO consumed) |\n| `msg.sender` as trust | No inherent sender identity | Signature verification |\n| Contract creation | Cannot spawn contracts | Pre-deploy all contracts |\n| `selfdestruct` | Contracts are UTXOs | Simply don't replicate |\n\n### Best Practice: Design First, Code Second\n\nWhen converting multi-contract Solidity:\n\n1. **Identify state** - What mappings/arrays exist?\n2. **Map to UTXOs** - Each \"record\" = one UTXO?\n3. **Identify interactions** - Which contracts call which?\n4. **Design transaction templates** - What inputs/outputs for each operation?\n5. **Then write CashScript** - Code the constraints\n\nDon't try to \"port\" Solidity line-by-line. Redesign for UTXO model first.",
    "source": "concepts/utxo-vs-account-model.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "Best Practice: Design First, Code Second"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-0",
    "content": "# ParityUSD Deep Analysis Report\n## CashScript Multi-Contract Patterns & Lessons Learned\n\n---\n\n## 1. SYSTEM ARCHITECTURE OVERVIEW\n\nParityUSD is a production-grade stablecoin system with **26 CashScript contracts** organized into 4 domains:\n\n```\nParityUSD System (26 contracts)\n├── Loan Module (10 contracts)\n│   ├── Loan.cash (main state holder)\n│   ├── LoanSidecar.cash (token holder)\n│   └── 8 function contracts (liquidate, manage, redeem, etc.)\n├── LoanKey Module (3 contracts)\n│   ├── LoanKeyFactory.cash\n│   ├── LoanKeyOriginEnforcer.cash\n│   └── LoanKeyOriginProof.cash\n├── Redeemer Module (3 contracts)\n│   ├── Redeemer.cash\n│   ├── Redemption.cash\n│   └── RedemptionSidecar.cash\n├── Stability Pool Module (8 contracts)\n│   ├── StabilityPool.cash\n│   ├── StabilityPoolSidecar.cash\n│   ├── Collector.cash\n│   ├── Payout.cash\n│   └── 4 function contracts\n└── Core (2 contracts)\n    ├── Parity.cash (borrowing)\n    └── PriceContract.cash (oracle)\n```\n\n---\n\n## 2. FUNDAMENTAL MULTI-CONTRACT PATTERNS",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "ParityUSD Deep Analysis Report",
      "CashScript Multi-Contract Patterns & Lessons Learned",
      "1. SYSTEM ARCHITECTURE OVERVIEW",
      "2. FUNDAMENTAL MULTI-CONTRACT PATTERNS"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-1",
    "content": "## 2. FUNDAMENTAL MULTI-CONTRACT PATTERNS\n\n### Pattern 1: The Main+Sidecar Pattern\n\n**Problem**: Bitcoin Cash allows only ONE token category per UTXO output.\n\n**Solution**: Pair every \"main\" contract with a \"sidecar\" that holds tokens.\n\n```\n┌─────────────────┐      ┌─────────────────────┐\n│   Loan.cash     │      │  LoanSidecar.cash   │\n│   (NFT state)   │◄────►│  (fungible tokens)  │\n└─────────────────┘      └─────────────────────┘\n```\n\n**Implementation Pattern (LoanSidecar.cash)**:\n```cashscript\ncontract LoanTokenSidecar() {\n    function attach() {\n        // Must be immediately after main contract\n        int mainIndex = this.activeInputIndex - 1;\n\n        // Prove same UTXO origin (created together)\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIndex].outpointTransactionHash);\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIndex].outpointIndex + 1);\n    }\n}\n```\n\n**Key Insight**: The sidecar validates it was created in the SAME transaction as the main contract by checking `outpointTransactionHash` equality.\n\n---\n\n### Pattern 2: Function Contract Pattern (Modular Logic)\n\n**Problem**: Complex contracts become unwieldy and expensive to execute.\n\n**Solution**: Split each \"function\" into a separate contract file, authenticated by NFT identifier bytes.\n\n```\nLoan.cash (coordinator)\n   │\n   ├── liquidate.cash     (NFT commitment: 0x00)\n   ├── manage.cash        (NFT commitment: 0x01)\n   ├── redeem.cash        (NFT commitment: 0x02)\n   ├── payInterest.cash   (NFT commitment: 0x03)\n   └── ... 4 more\n```",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "2. FUNDAMENTAL MULTI-CONTRACT PATTERNS",
      "Pattern 1: The Main+Sidecar Pattern",
      "Pattern 2: Function Contract Pattern (Modular Logic)"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-2",
    "content": "**Main Contract Pattern (Loan.cash)**:\n```cashscript\ncontract Loan(bytes32 parityTokenId) {\n    function interact(\n        int functionInputIndex,\n        int sidecarOutputIndex,\n        int functionOutputIndex\n    ) {\n        // Extract function identifier from NFT commitment\n        bytes functionNftIdentifier =\n            tx.inputs[functionInputIndex].nftCommitment.split(1)[0];\n\n        // Authenticate each function by its unique identifier\n        if (functionNftIdentifier == 0x00) {\n            // liquidate logic - validate outputs\n        } else if (functionNftIdentifier == 0x01) {\n            // manage logic\n        } else if (functionNftIdentifier == 0x02) {\n            // redeem logic\n        }\n        // ... etc\n    }\n}\n```\n\n**Why This Works**: Each function contract holds an NFT with a unique first-byte identifier. The main contract routes to appropriate validation logic based on this byte.\n\n---\n\n### Pattern 3: Strict Input Position Pattern\n\n**Critical Pattern**: Every contract REQUIRES specific input indices.\n\n```cashscript\n// From redeem.cash - note the EXPLICIT index requirements\nfunction redeem(int loanBchAfterTxFee) {\n    // THIS FUNCTION MUST BE AT INDEX 3\n    require(this.activeInputIndex == 3);\n\n    // Each input has a KNOWN position\n    // Index 0: PriceContract\n    // Index 1: Loan\n    // Index 2: LoanTokenSidecar\n    // Index 3: redeem (this)\n    // Index 4: LoanKey\n    // Index 5: feeBch\n\n    // Authenticate price contract at index 0\n    require(tx.inputs[0].tokenCategory == parityTokenId + 0x01);\n    require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00);\n\n    // Authenticate loan at index 1\n    require(tx.inputs[1].tokenCategory == parityTokenId + 0x01);\n    bytes loanIdentifier = tx.inputs[1].nftCommitment.split(1)[0];\n    require(loanIdentifier == 0x01);\n}\n```",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Pattern 3: Strict Input Position Pattern"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-3",
    "content": "**Lesson**: There's NO dynamic lookup. Every participant knows exactly which input index holds which contract.\n\n---\n\n### Pattern 4: NFT Commitment State Management\n\n**Problem**: No account-based storage in UTXO model.\n\n**Solution**: Encode ALL state in NFT commitment bytes with strict byte-position layout.\n\n```\nLoan NFT Commitment (27 bytes):\n┌─────────┬────────────────┬───────────────────┬────────┐\n│ 1 byte  │    6 bytes     │     6 bytes       │ ...    │\n│ 0x01    │ borrowedAmount │ beingRedeemed     │ state  │\n│ (ID)    │                │                   │        │\n└─────────┴────────────────┴───────────────────┴────────┘\n```\n\n**State Parsing Pattern**:\n```cashscript\n// Parse state from commitment\nbytes rawCommitment = tx.inputs[1].nftCommitment;\nbytes identifier, bytes remaining = rawCommitment.split(1);\nrequire(identifier == 0x01);\n\nbytes borrowedAmountBytes, remaining = remaining.split(6);\nint borrowedAmount = int(borrowedAmountBytes);\n\nbytes beingRedeemedBytes, remaining = remaining.split(6);\nint beingRedeemed = int(beingRedeemedBytes);\n```\n\n**State Reconstruction Pattern**:\n```cashscript\n// Reconstruct state with updates\nbytes newCommitment = 0x01\n    + bytes6(newBorrowedAmount)\n    + bytes6(newBeingRedeemed)\n    + remainingState;\n\n// Enforce output has new state\nrequire(tx.outputs[1].nftCommitment == newCommitment);\n```\n\n---\n\n### Pattern 5: Self-Replicating Covenant Categories\n\nFour distinct types based on what changes between input and output:\n\n| Type | Changes | Example |",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int",
      "Pattern 4: NFT Commitment State Management",
      "Pattern 5: Self-Replicating Covenant Categories"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-4",
    "content": "|------|---------|---------|\n| **Exactly Self-Replicating** | Nothing | Redeemer, LoanKeyFactory |\n| **State-Mutating** | NFT commitment only | Parity, PriceContract |\n| **State-and-Balance-Mutating** | NFT + BCH value | StabilityPool |\n| **Conditionally-Replicating** | Sometimes doesn't replicate | Loans (can be closed) |\n\n**Validation Checklist for Self-Replication**:\n```cashscript\n// All 5 must be validated for covenant preservation:\nrequire(tx.outputs[idx].lockingBytecode == tx.inputs[idx].lockingBytecode);\nrequire(tx.outputs[idx].tokenCategory == tx.inputs[idx].tokenCategory);\nrequire(tx.outputs[idx].value == expectedValue);\nrequire(tx.outputs[idx].tokenAmount == expectedTokens);\nrequire(tx.outputs[idx].nftCommitment == newCommitment);\n```\n\n---\n\n### Pattern 6: Cross-Contract Authentication via Token Categories\n\n**Problem**: How does one contract know another is legitimate?\n\n**Solution**: Token category arithmetic with deterministic offsets.\n\n```cashscript\n// parityTokenId is the \"root\" category (32 bytes)\n// Different contracts use offsets:\n\n// Price contract: parityTokenId + 0x01\nrequire(tx.inputs[0].tokenCategory == parityTokenId + 0x01);\n\n// Loan contract: parityTokenId + 0x01 (same category, different NFT)\n// Distinguished by NFT commitment first byte (0x00 vs 0x01)\n\n// Redeemer: redeemerTokenId + 0x02\nrequire(tx.inputs[4].tokenCategory == redeemerTokenId + 0x02);\n```\n\n**Key Insight**: The 33rd byte of tokenCategory encodes the NFT capability:\n- `0x01` = mutable NFT\n- `0x02` = minting NFT",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "Pattern 6: Cross-Contract Authentication via Token Categories"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-5",
    "content": "---\n\n### Pattern 7: Burn-to-Destroy Pattern\n\n**Problem**: How to \"delete\" tokens/NFTs?\n\n**Solution**: Send to OP_RETURN output.\n\n```cashscript\n// From LiquidateLoan.cash - burning ParityUSD during liquidation\nrequire(tx.outputs[5].lockingBytecode == 0x6a); // OP_RETURN\nrequire(tx.outputs[5].tokenCategory == parityTokenId);\nrequire(tx.outputs[5].tokenAmount == burnAmount);\n```\n\n---\n\n### Pattern 8: Output Count Limiting\n\n**Critical Security Pattern**: Always limit max outputs to prevent unauthorized minting.\n\n```cashscript\n// From Redeemer.cash\nrequire(tx.outputs.length <= 10);\n\n// From AddLiquidity.cash\nrequire(tx.outputs.length <= 6);\n\n// From WithdrawFromPool.cash\nrequire(tx.outputs.length <= 7);\n```\n\n---\n\n### Pattern 9: Fixed Value Anchors\n\n**Pattern**: Function contracts always output exactly 1000 satoshis.\n\n```cashscript\n// Every function contract\nrequire(tx.outputs[functionIdx].value == 1000);\n```\n\n**Why**: Creates predictable dust threshold and prevents value manipulation.\n\n---\n\n## 3. ADVANCED PATTERNS",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Pattern 7: Burn-to-Destroy Pattern",
      "Pattern 8: Output Count Limiting",
      "Pattern 9: Fixed Value Anchors",
      "3. ADVANCED PATTERNS"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-6",
    "content": "## 3. ADVANCED PATTERNS\n\n### Pattern 10: Origin Proof Chain\n\n**Problem**: How to prove an NFT was legitimately created?\n\n**Solution**: Chain of origin proof contracts.\n\n```\nLoanKeyFactory\n      │\n      ├─► LoanKeyOriginEnforcer\n      │         │\n      │         └─► LoanKeyOriginProof\n      │                   │\n      └───────────────────┴─► [verified loanKey]\n```\n\nThe Enforcer and Proof contracts verify they were created together (same tx hash, sequential indices), establishing provenance.\n\n---\n\n### Pattern 11: Time Tracking Without Block Height\n\n**Problem**: CashScript cannot directly read block height.\n\n**Solution**: Use `tx.locktime` + state tracking.\n\n```cashscript\n// Period calculation\nint currentPeriod = (tx.locktime - startBlockHeight) / periodLengthBlocks;\n\n// Require locktime is valid blockheight (not timestamp)\nrequire(tx.locktime < 500000000);\n\n// Require new period > stored period\nint storedPeriod = int(commitment.split(4)[0]);\nrequire(currentPeriod > storedPeriod);\n```\n\n---\n\n### Pattern 12: Minimum Amount Guards\n\n**Pattern**: All operations have minimum thresholds.\n\n```cashscript\n// 100.00 ParityUSD minimum everywhere\nrequire(borrowAmount >= 100_00);\nrequire(redemptionAmount >= 100_00);\nrequire(depositAmount >= 100_00);\nrequire(withdrawalAmount >= 100_00);\n```\n\n**Why**: Prevents UTXO congestion attacks and griefing.\n\n---\n\n## 4. CRITICAL LESSONS FOR EVM-TO-CASHSCRIPT CONVERSION",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "int",
      "3. ADVANCED PATTERNS",
      "Pattern 10: Origin Proof Chain",
      "Pattern 11: Time Tracking Without Block Height",
      "Pattern 12: Minimum Amount Guards",
      "4. CRITICAL LESSONS FOR EVM-TO-CASHSCRIPT CONVERSION"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-7",
    "content": "## 4. CRITICAL LESSONS FOR EVM-TO-CASHSCRIPT CONVERSION\n\n### Lesson 1: NO STORAGE - EVERYTHING IS COMMITMENT BYTES\n\nEVM:\n```solidity\nmapping(address => uint256) balances;\nbalances[user] = 100;\n```\n\nCashScript:\n```cashscript\n// NO MAPPING EXISTS. State IS the NFT commitment.\nbytes commitment = 0x01 + bytes6(balance) + pubkeyhash;\nrequire(tx.outputs[0].nftCommitment == commitment);\n```\n\n### Lesson 2: NO LOOPS - FIXED INPUT/OUTPUT COUNTS\n\nEVM:\n```solidity\nfor (uint i = 0; i < holders.length; i++) {\n    transfer(holders[i], amount);\n}\n```\n\nCashScript: **IMPOSSIBLE**. You must:\n- Use fixed input/output counts per function\n- Create separate transactions for each iteration\n- Or redesign the architecture entirely\n\n### Lesson 3: NO INTERNAL CALLS - ONLY TRANSACTION STRUCTURE\n\nEVM:\n```solidity\notherContract.doSomething();\n```\n\nCashScript: The other contract must be IN THE SAME TRANSACTION as an input, and you validate it through its token category and position.\n\n### Lesson 4: NO DYNAMIC DISPATCH - EXPLICIT BYTE ROUTING\n\nEVM:\n```solidity\nfunction execute(bytes4 selector) { ... }\n```\n\nCashScript: Explicit if/else on commitment bytes:\n```cashscript\nif (functionId == 0x00) { /* liquidate */ }\nelse if (functionId == 0x01) { /* manage */ }\n// ...\n```\n\n### Lesson 5: FUNCTIONS ARE CONTRACTS\n\nEVM function -> CashScript contract file\n\nEVM contract with 8 functions -> 1 main contract + 8 function contracts\n\n### Lesson 6: MANDATORY SIDECAR FOR TOKEN HOLDING\n\nIf your EVM contract holds multiple token types, you MUST create sidecar contracts to hold each additional token type.",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "4. CRITICAL LESSONS FOR EVM-TO-CASHSCRIPT CONVERSION",
      "Lesson 1: NO STORAGE - EVERYTHING IS COMMITMENT BYTES",
      "Lesson 2: NO LOOPS - FIXED INPUT/OUTPUT COUNTS",
      "Lesson 3: NO INTERNAL CALLS - ONLY TRANSACTION STRUCTURE",
      "Lesson 4: NO DYNAMIC DISPATCH - EXPLICIT BYTE ROUTING",
      "Lesson 5: FUNCTIONS ARE CONTRACTS",
      "Lesson 6: MANDATORY SIDECAR FOR TOKEN HOLDING"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-8",
    "content": "### Lesson 7: ALWAYS VALIDATE OUTPUT RECONSTRUCTION\n\nEvery contract must explicitly check that outputs match expected:\n- lockingBytecode\n- tokenCategory\n- value (satoshis)\n- tokenAmount\n- nftCommitment\n\n---\n\n## 5. ANTI-PLACEHOLDER LESSONS",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "Lesson 7: ALWAYS VALIDATE OUTPUT RECONSTRUCTION",
      "5. ANTI-PLACEHOLDER LESSONS"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-9",
    "content": "## 5. ANTI-PLACEHOLDER LESSONS\n\n### Why ParityUSD Has No Placeholders\n\n1. **Every contract has REAL logic**: The simplest contract (LoanSidecar) still has meaningful validation - checking transaction hash and index relationships.\n\n2. **Empty functions don't compile**: CashScript requires at least one `require()` statement to generate valid bytecode.\n\n3. **Contracts exist to VALIDATE**: If a contract has nothing to validate, it shouldn't exist. The question becomes: \"What relationship does this prove?\"\n\n### The Minimum Viable Contract\n\nThe smallest real contract in ParityUSD (StabilityPoolSidecar):\n```cashscript\ncontract StabilityPoolSidecar(bytes32 parityTokenId) {\n    function attach() {\n        // STILL has real validation:\n        int mainIndex = this.activeInputIndex - 1;\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIndex].outpointTransactionHash);\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIndex].outpointIndex + 1);\n\n        // Output validation\n        require(tx.outputs[outputIndex].value == 1000);\n        require(tx.outputs[outputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        require(tx.outputs[outputIndex].nftCommitment == 0x);\n\n        // Token constraint\n        require(tx.outputs[outputIndex].tokenCategory == parityTokenId ||\n                tx.outputs[outputIndex].tokenCategory == 0x);\n    }\n}\n```\n\n### The Golden Rule",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "5. ANTI-PLACEHOLDER LESSONS",
      "Why ParityUSD Has No Placeholders",
      "The Minimum Viable Contract",
      "The Golden Rule"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-10",
    "content": "**If you cannot identify what a contract VALIDATES, it should not exist.**\n\nEvery contract must answer: \"What would go wrong if this contract didn't exist?\" If nothing, delete it.\n\n---\n\n## 6. ARCHITECTURAL PRINCIPLES FOR MULTI-CONTRACT SYSTEMS",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "6. ARCHITECTURAL PRINCIPLES FOR MULTI-CONTRACT SYSTEMS"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-11",
    "content": "## 6. ARCHITECTURAL PRINCIPLES FOR MULTI-CONTRACT SYSTEMS\n\n1. **One Contract = One Responsibility**\n   - Loan.cash: Coordinate loan operations\n   - LoanSidecar: Hold loan tokens\n   - liquidate.cash: Validate liquidation logic\n\n2. **Explicit Over Implicit**\n   - Input indices are explicit, not discovered\n   - Token categories are hardcoded with offsets\n   - State byte positions are fixed\n\n3. **Composition Over Inheritance**\n   - Function contracts compose with main contracts\n   - Sidecars compose with their parents\n   - No inheritance hierarchy exists\n\n4. **Validation at Boundaries**\n   - Every input is authenticated\n   - Every output is constrained\n   - Every state change is explicit\n\n5. **Fail Closed**\n   - Missing require = transaction fails\n   - Wrong commitment = transaction fails\n   - Wrong category = transaction fails\n\n---\n\n## 7. SUMMARY: WHAT THIS TEACHES US",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "6. ARCHITECTURAL PRINCIPLES FOR MULTI-CONTRACT SYSTEMS",
      "7. SUMMARY: WHAT THIS TEACHES US"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-12",
    "content": "## 7. SUMMARY: WHAT THIS TEACHES US\n\nFor converting EVM to CashScript:\n\n1. **Decompose** - Split EVM contracts into main + function + sidecar contracts\n2. **Flatten state** - Convert mappings/arrays to commitment byte layouts\n3. **Fix positions** - Assign explicit input/output indices to every participant\n4. **Validate everything** - Every contract must have real `require()` statements\n5. **Limit outputs** - Always cap `tx.outputs.length`\n6. **Use token arithmetic** - Authenticate contracts via category offsets\n7. **Never placeholder** - If nothing to validate, the contract shouldn't exist\n\n---\n\n## 8. KEY TAKEAWAYS FOR PREVENTING PLACEHOLDER VIOLATIONS",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "7. SUMMARY: WHAT THIS TEACHES US",
      "8. KEY TAKEAWAYS FOR PREVENTING PLACEHOLDER VIOLATIONS"
    ]
  },
  {
    "id": "examples/real-world/parityusd-analysis.md-13",
    "content": "## 8. KEY TAKEAWAYS FOR PREVENTING PLACEHOLDER VIOLATIONS\n\nThe ParityUSD analysis reveals **why placeholders are architecturally impossible in well-designed CashScript**:\n\n1. **Every contract PROVES something** - The sidecar proves it was created with the main contract. The function contract proves it has authority to execute that operation. If a contract proves nothing, it has no reason to exist.\n\n2. **The minimum viable contract is not empty** - Even the simplest \"attach()\" function validates transaction hash equality and output constraints. There's always SOMETHING to validate.\n\n3. **Contracts exist to CONSTRAIN** - Not to \"hold functions\" like in EVM. A CashScript contract's purpose is to add constraints to a transaction. No constraints = no contract.\n\n**For the conversion system**, instead of telling the model \"don't use placeholders\", we should:\n\n1. Require the model to identify **what each contract validates**\n2. If a contract validates nothing, eliminate it (don't create it)\n3. Enforce minimum require() statements per contract\n4. Validate that every contract has meaningful logic connecting inputs to outputs\n\nThe ParityUSD patterns give us concrete examples of what \"real\" multi-contract systems look like - every contract has purpose, every function has validation, and every interaction is explicitly constrained.",
    "source": "examples/real-world/parityusd-analysis.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "8. KEY TAKEAWAYS FOR PREVENTING PLACEHOLDER VIOLATIONS"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-0",
    "content": "# Real-World CashScript Production Patterns\n\n**⚠️ IMPORTANT**: All helper functions in these examples (like `calculateOutput()`, `getCurrentPrice()`, `getProposalDeadline()`) are **LEGITIMATE INTERNAL HELPER FUNCTIONS** that are called by other functions within the same contract. They are NOT placeholders, stubs, or documentation-only functions. Every function shown here is production code that executes on-chain as part of the contract's validation logic.\n\n**DO NOT create functions that exist only for documentation purposes.** If a Solidity function cannot be implemented in CashScript (like view/pure functions), DELETE it entirely from the conversion. Never use `require(false)` or create placeholder functions.\n\n## Overview",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "Real-World CashScript Production Patterns",
      "Overview"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-1",
    "content": "## Overview\n\nThis document showcases production-ready CashScript patterns used in real Bitcoin Cash applications. These examples demonstrate best practices, security considerations, and practical implementations.\n\n## Decentralized Finance (DeFi) Patterns",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "Overview",
      "Decentralized Finance (DeFi) Patterns"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-2",
    "content": "## Decentralized Finance (DeFi) Patterns\n\n### 1. Automated Market Maker (AMM)\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract SimpleAMM(\n    bytes32 tokenACategory,\n    bytes32 tokenBCategory,\n    int feeRate,  // in basis points (100 = 1%)\n    pubkey operator\n) {\n    function swap(\n        sig operatorSig,\n        int amountIn,\n        int amountOutMin,\n        bool swapAToB\n    ) {\n        require(checkSig(operatorSig, operator));\n        require(amountIn > 0);\n        require(amountOutMin > 0);\n        \n        // Validate input token\n        if (swapAToB) {\n            require(tx.inputs[0].tokenCategory == tokenACategory);\n            require(tx.inputs[0].tokenAmount >= amountIn);\n        } else {\n            require(tx.inputs[0].tokenCategory == tokenBCategory);\n            require(tx.inputs[0].tokenAmount >= amountIn);\n        }\n        \n        // Calculate fee\n        int fee = (amountIn * feeRate) / 10000;\n        int amountAfterFee = amountIn - fee;\n        \n        // Validate minimum output (slippage protection)\n        int expectedOutput = calculateOutput(amountAfterFee, swapAToB);\n        require(expectedOutput >= amountOutMin);\n        \n        // Validate output token\n        if (swapAToB) {\n            require(tx.outputs[0].tokenCategory == tokenBCategory);\n            require(tx.outputs[0].tokenAmount >= expectedOutput);\n        } else {\n            require(tx.outputs[0].tokenCategory == tokenACategory);\n            require(tx.outputs[0].tokenAmount >= expectedOutput);\n        }\n    }\n    \n    function calculateOutput(int amountIn, bool swapAToB) -> int {\n        // Simplified constant product formula\n        // In production, this would use actual reserve data\n        return amountIn * 997 / 1000;  // 0.3% fee approximation\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "bool",
      "Decentralized Finance (DeFi) Patterns",
      "1. Automated Market Maker (AMM)"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-3",
    "content": "### 2. Lending Protocol\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract LendingPool(\n    bytes32 collateralTokenCategory,\n    bytes32 loanTokenCategory,\n    int collateralRatio,  // e.g., 150 for 150%\n    int liquidationThreshold,  // e.g., 120 for 120%\n    pubkey oracle\n) {\n    function borrow(\n        sig borrowerSig,\n        pubkey borrowerPk,\n        datasig priceData,\n        int collateralAmount,\n        int loanAmount\n    ) {\n        require(checkSig(borrowerSig, borrowerPk));\n        require(checkDataSig(priceData, bytes(getCurrentPrice()), oracle));\n        \n        // Validate collateral input\n        require(tx.inputs[0].tokenCategory == collateralTokenCategory);\n        require(tx.inputs[0].tokenAmount >= collateralAmount);\n        \n        // Calculate required collateral\n        int currentPrice = getCurrentPrice();\n        int requiredCollateral = (loanAmount * collateralRatio) / currentPrice;\n        require(collateralAmount >= requiredCollateral);\n        \n        // Validate loan output\n        require(tx.outputs[0].tokenCategory == loanTokenCategory);\n        require(tx.outputs[0].tokenAmount == loanAmount);\n        \n        // Lock collateral in escrow\n        require(tx.outputs[1].tokenCategory == collateralTokenCategory);\n        require(tx.outputs[1].tokenAmount == collateralAmount);\n    }\n    \n    function liquidate(\n        sig liquidatorSig,\n        pubkey liquidatorPk,\n        datasig priceData,\n        int collateralAmount,\n        int debtAmount\n    ) {\n        require(checkSig(liquidatorSig, liquidatorPk));\n        require(checkDataSig(priceData, bytes(getCurrentPrice()), oracle));\n        \n        // Check liquidation threshold\n        int currentPrice = getCurrentPrice();\n        int collateralValue = collateralAmount * currentPrice;\n        int collateralRatio = (collateralValue * 100) / debtAmount;\n        require(collateralRatio <= liquidationThreshold);\n        \n        // Process liquidation\n        require(tx.outputs[0].tokenCategory == collateralTokenCategory);\n        require(tx.outputs[0].tokenAmount <= collateralAmount);\n    }\n    \n    function getCurrentPrice() -> int {\n        // This would integrate with actual price oracle\n        return 45000;  // Example price in cents\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "2. Lending Protocol"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-4",
    "content": "## NFT and Gaming Patterns\n\n### 3. NFT Marketplace\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract NFTMarketplace(\n    bytes32 nftCategory,\n    int marketplaceFee,  // in basis points\n    pubkey marketplace\n) {\n    function listNFT(\n        sig sellerSig,\n        pubkey sellerPk,\n        bytes nftCommitment,\n        int askPrice\n    ) {\n        require(checkSig(sellerSig, sellerPk));\n        require(askPrice > 0);\n        \n        // Validate NFT input\n        require(tx.inputs[0].tokenCategory == nftCategory);\n        require(tx.inputs[0].nftCommitment == nftCommitment);\n        \n        // Create listing (lock NFT in marketplace)\n        require(tx.outputs[0].tokenCategory == nftCategory);\n        require(tx.outputs[0].nftCommitment == nftCommitment);\n        \n        // Store listing data in OP_RETURN\n        bytes listingData = new LockingBytecodeNullData([\n            0x4c53,  // \"LS\" for listing\n            bytes(sellerPk),\n            bytes(askPrice),\n            nftCommitment\n        ]);\n        require(tx.outputs[1].lockingBytecode == listingData);\n    }\n    \n    function buyNFT(\n        sig buyerSig,\n        pubkey buyerPk,\n        pubkey sellerPk,\n        bytes nftCommitment,\n        int askPrice\n    ) {\n        require(checkSig(buyerSig, buyerPk));\n        \n        // Validate payment\n        require(tx.inputs[1].value >= askPrice);\n        \n        // Calculate marketplace fee\n        int fee = (askPrice * marketplaceFee) / 10000;\n        int sellerAmount = askPrice - fee;\n        \n        // Transfer NFT to buyer\n        require(tx.outputs[0].tokenCategory == nftCategory);\n        require(tx.outputs[0].nftCommitment == nftCommitment);\n        \n        // Pay seller\n        bytes sellerBytecode = new LockingBytecodeP2PKH(hash160(sellerPk));\n        require(tx.outputs[1].lockingBytecode == sellerBytecode);\n        require(tx.outputs[1].value >= sellerAmount);\n        \n        // Pay marketplace fee\n        bytes marketplaceBytecode = new LockingBytecodeP2PKH(hash160(marketplace));\n        require(tx.outputs[2].lockingBytecode == marketplaceBytecode);\n        require(tx.outputs[2].value >= fee);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "NFT and Gaming Patterns",
      "3. NFT Marketplace"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-5",
    "content": "### 4. Gaming Item Upgrade\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract GameItemUpgrade(\n    bytes32 itemCategory,\n    pubkey gameOperator,\n    int upgradeBaseCost\n) {\n    function upgradeItem(\n        sig playerSig,\n        pubkey playerPk,\n        sig operatorSig,\n        bytes currentItem,\n        bytes upgradedItem,\n        int upgradeCost\n    ) {\n        require(checkSig(playerSig, playerPk));\n        require(checkSig(operatorSig, gameOperator));\n        \n        // Validate current item\n        require(tx.inputs[0].tokenCategory == itemCategory);\n        require(tx.inputs[0].nftCommitment == currentItem);\n        \n        // Validate upgrade cost\n        require(upgradeCost >= upgradeBaseCost);\n        require(tx.inputs[1].value >= upgradeCost);\n        \n        // Create upgraded item\n        require(tx.outputs[0].tokenCategory == itemCategory);\n        require(tx.outputs[0].nftCommitment == upgradedItem);\n        \n        // Validate upgrade progression\n        require(validateUpgrade(currentItem, upgradedItem));\n        \n        // Pay upgrade cost to game operator\n        bytes operatorBytecode = new LockingBytecodeP2PKH(hash160(gameOperator));\n        require(tx.outputs[1].lockingBytecode == operatorBytecode);\n        require(tx.outputs[1].value >= upgradeCost);\n    }\n    \n    function validateUpgrade(bytes current, bytes upgraded) -> bool {\n        // Extract item level from commitment\n        int currentLevel = int(current.split(4)[0]);\n        int upgradedLevel = int(upgraded.split(4)[0]);\n        \n        // Validate level progression\n        require(upgradedLevel == currentLevel + 1);\n        require(upgradedLevel <= 100);  // Max level\n        \n        return true;\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "bool",
      "4. Gaming Item Upgrade"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-6",
    "content": "## Governance and DAOs\n\n### 5. Decentralized Autonomous Organization (DAO)\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract SimpleDAO(\n    bytes32 governanceTokenCategory,\n    int proposalThreshold,\n    int votingPeriod,\n    int quorumRequirement\n) {\n    function createProposal(\n        sig proposerSig,\n        pubkey proposerPk,\n        bytes proposalData,\n        int proposalId\n    ) {\n        require(checkSig(proposerSig, proposerPk));\n        \n        // Validate proposer has enough tokens\n        require(tx.inputs[0].tokenCategory == governanceTokenCategory);\n        require(tx.inputs[0].tokenAmount >= proposalThreshold);\n        \n        // Create proposal NFT\n        require(tx.outputs[0].tokenCategory == governanceTokenCategory);\n        require(tx.outputs[0].nftCommitment == proposalData);\n        \n        // Store proposal metadata\n        bytes proposalMetadata = new LockingBytecodeNullData([\n            0x5052,  // \"PR\" for proposal\n            bytes(proposalId),\n            bytes(tx.locktime + votingPeriod),  // Voting deadline\n            proposalData\n        ]);\n        require(tx.outputs[1].lockingBytecode == proposalMetadata);\n    }\n    \n    function vote(\n        sig voterSig,\n        pubkey voterPk,\n        int proposalId,\n        bool support,\n        int votingPower\n    ) {\n        require(checkSig(voterSig, voterPk));\n        \n        // Validate voter has tokens\n        require(tx.inputs[0].tokenCategory == governanceTokenCategory);\n        require(tx.inputs[0].tokenAmount >= votingPower);\n        \n        // Validate voting period\n        require(tx.locktime <= getProposalDeadline(proposalId));\n        \n        // Record vote\n        bytes voteData = new LockingBytecodeNullData([\n            0x564f,  // \"VO\" for vote\n            bytes(proposalId),\n            bytes(support ? 1 : 0),\n            bytes(votingPower)\n        ]);\n        require(tx.outputs[0].lockingBytecode == voteData);\n    }\n    \n    function executeProposal(\n        sig executorSig,\n        pubkey executorPk,\n        int proposalId,\n        int totalVotes,\n        int supportVotes\n    ) {\n        require(checkSig(executorSig, executorPk));\n        \n        // Validate voting period ended\n        require(tx.locktime > getProposalDeadline(proposalId));\n        \n        // Validate quorum\n        require(totalVotes >= quorumRequirement);\n        \n        // Validate majority support\n        require(supportVotes > (totalVotes / 2));\n        \n        // Execute proposal logic would go here\n    }\n    \n    function getProposalDeadline(int proposalId) -> int {\n        // This would lookup the actual deadline from stored data\n        return tx.locktime + votingPeriod;\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "bool",
      "Governance and DAOs",
      "5. Decentralized Autonomous Organization (DAO)"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-7",
    "content": "## Subscription and Streaming\n\n### 6. Streaming Payments\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract StreamingPayment(\n    pubkey subscriber,\n    pubkey recipient,\n    int paymentRate,    // per second\n    int streamDuration  // in seconds\n) {\n    function claim(\n        sig recipientSig,\n        int currentTime,\n        int lastClaimTime\n    ) {\n        require(checkSig(recipientSig, recipient));\n        \n        // Validate time progression\n        require(currentTime > lastClaimTime);\n        require(currentTime <= lastClaimTime + streamDuration);\n        \n        // Calculate claimable amount\n        int elapsedTime = currentTime - lastClaimTime;\n        int claimableAmount = elapsedTime * paymentRate;\n        \n        // Validate payment\n        require(tx.outputs[0].value >= claimableAmount);\n        \n        // Update stream state\n        bytes newStreamState = bytes(currentTime);\n        require(tx.outputs[1].nftCommitment == newStreamState);\n    }\n    \n    function cancel(sig subscriberSig) {\n        require(checkSig(subscriberSig, subscriber));\n        \n        // Return remaining balance to subscriber\n        bytes subscriberBytecode = new LockingBytecodeP2PKH(hash160(subscriber));\n        require(tx.outputs[0].lockingBytecode == subscriberBytecode);\n    }\n}\n```\n\n## Oracle Integration",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Subscription and Streaming",
      "6. Streaming Payments",
      "Oracle Integration"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-8",
    "content": "## Oracle Integration\n\n### 7. Price Feed Oracle\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract PriceFeedOracle(\n    pubkey[] oracles,\n    int minimumOracles,\n    int maxPriceDeviation  // in basis points\n) {\n    function updatePrice(\n        datasig[] oracleSignatures,\n        int[] prices,\n        int timestamp\n    ) {\n        require(oracleSignatures.length >= minimumOracles);\n        require(prices.length == oracleSignatures.length);\n        \n        // Validate timestamp\n        require(timestamp >= tx.locktime - 300);  // Max 5 minutes old\n        require(timestamp <= tx.locktime);\n        \n        // Validate oracle signatures\n        for (int i = 0; i < oracleSignatures.length; i++) {\n            bool validOracle = false;\n            for (int j = 0; j < oracles.length; j++) {\n                if (checkDataSig(oracleSignatures[i], bytes(prices[i]), oracles[j])) {\n                    validOracle = true;\n                    break;\n                }\n            }\n            require(validOracle);\n        }\n        \n        // Calculate median price\n        int medianPrice = calculateMedian(prices);\n        \n        // Validate price deviation\n        for (int i = 0; i < prices.length; i++) {\n            int deviation = abs(prices[i] - medianPrice) * 10000 / medianPrice;\n            require(deviation <= maxPriceDeviation);\n        }\n        \n        // Store price data\n        bytes priceData = new LockingBytecodeNullData([\n            0x5052,  // \"PR\" for price\n            bytes(medianPrice),\n            bytes(timestamp)\n        ]);\n        require(tx.outputs[0].lockingBytecode == priceData);\n    }\n    \n    function calculateMedian(int[] values) -> int {\n        // Simplified median calculation\n        // In production, this would use a proper sorting algorithm\n        require(values.length > 0);\n        \n        if (values.length == 1) return values[0];\n        if (values.length == 2) return (values[0] + values[1]) / 2;\n        \n        // For simplicity, return middle value for arrays of 3+\n        return values[values.length / 2];\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "bool",
      "Oracle Integration",
      "7. Price Feed Oracle"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-9",
    "content": "## Multi-Signature Patterns\n\n### 8. Corporate Treasury\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract CorporateTreasury(\n    pubkey[] executives,\n    pubkey[] boardMembers,\n    int executiveThreshold,\n    int boardThreshold,\n    int largeAmountThreshold\n) {\n    function executiveSpend(\n        sig[] executiveSigs,\n        pubkey[] signingExecutives,\n        int amount\n    ) {\n        require(amount <= largeAmountThreshold);\n        require(executiveSigs.length >= executiveThreshold);\n        \n        // Validate executive signatures\n        for (int i = 0; i < executiveSigs.length; i++) {\n            bool validExecutive = false;\n            for (int j = 0; j < executives.length; j++) {\n                if (signingExecutives[i] == executives[j]) {\n                    require(checkSig(executiveSigs[i], executives[j]));\n                    validExecutive = true;\n                    break;\n                }\n            }\n            require(validExecutive);\n        }\n    }\n    \n    function boardSpend(\n        sig[] boardSigs,\n        pubkey[] signingBoard,\n        int amount\n    ) {\n        require(boardSigs.length >= boardThreshold);\n        \n        // Validate board signatures\n        for (int i = 0; i < boardSigs.length; i++) {\n            bool validBoard = false;\n            for (int j = 0; j < boardMembers.length; j++) {\n                if (signingBoard[i] == boardMembers[j]) {\n                    require(checkSig(boardSigs[i], boardMembers[j]));\n                    validBoard = true;\n                    break;\n                }\n            }\n            require(validBoard);\n        }\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "bool",
      "Multi-Signature Patterns",
      "8. Corporate Treasury"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-10",
    "content": "## JavaScript Integration Examples\n\n### 9. Production Transaction Builder\n\n```javascript\nclass ProductionTransactionBuilder {\n    constructor(provider, contract) {\n        this.provider = provider;\n        this.contract = contract;\n        this.gasLimit = 2000; // satoshis\n        this.retryCount = 3;\n    }\n    \n    async buildSecureTransaction(functionCall, outputs, options = {}) {\n        const {\n            maxFeeRate = 1.1,\n            minChange = 5000,\n            timeoutMs = 30000\n        } = options;\n        \n        // Validate inputs\n        this.validateOutputs(outputs);\n        \n        // Build transaction with retry logic\n        for (let attempt = 0; attempt < this.retryCount; attempt++) {\n            try {\n                const utxos = await this.contract.getUtxos();\n                \n                if (utxos.length === 0) {\n                    throw new Error('No UTXOs available');\n                }\n                \n                let txBuilder = functionCall;\n                \n                // Add outputs\n                for (const output of outputs) {\n                    txBuilder = txBuilder.to(output.address, output.amount);\n                }\n                \n                // Configure fee and change\n                txBuilder = txBuilder\n                    .withFeePerByte(maxFeeRate)\n                    .withMinChange(minChange);\n                \n                // Add timeout\n                const timeoutPromise = new Promise((_, reject) => {\n                    setTimeout(() => reject(new Error('Transaction timeout')), timeoutMs);\n                });\n                \n                // Execute transaction\n                const txPromise = txBuilder.send();\n                const txDetails = await Promise.race([txPromise, timeoutPromise]);\n                \n                // Validate result\n                this.validateTransaction(txDetails);\n                \n                return txDetails;\n                \n            } catch (error) {\n                console.warn(`Transaction attempt ${attempt + 1} failed:`, error.message);\n                \n                if (attempt === this.retryCount - 1) {\n                    throw error;\n                }\n                \n                // Wait before retry\n                await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n            }\n        }\n    }\n    \n    validateOutputs(outputs) {\n        if (!Array.isArray(outputs) || outputs.length === 0) {\n            throw new Error('Invalid outputs array');\n        }\n        \n        for (const output of outputs) {\n            if (!output.address || typeof output.address !== 'string') {\n                throw new Error('Invalid output address');\n            }\n            \n            if (!output.amount || output.amount <= 0) {\n                throw new Error('Invalid output amount');\n            }\n        }\n    }\n    \n    validateTransaction(txDetails) {\n        if (!txDetails.txid || typeof txDetails.txid !== 'string') {\n            throw new Error('Invalid transaction ID');\n        }\n        \n        if (txDetails.fee && txDetails.fee > this.gasLimit) {\n            console.warn('Transaction fee exceeds limit:', txDetails.fee);\n        }\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "string",
      "JavaScript Integration Examples",
      "9. Production Transaction Builder"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-11",
    "content": "### 12. Multi-Contract Orchestrator\n\n```javascript\nclass MultiContractOrchestrator {\n    constructor(provider) {\n        this.provider = provider;\n        this.contracts = new Map();\n        this.monitoring = new Map();\n    }\n    \n    addContract(name, contract) {\n        this.contracts.set(name, contract);\n        this.startMonitoring(name);\n    }\n    \n    async executeMultiContractTransaction(operations) {\n        const results = [];\n        \n        try {\n            // Execute operations in sequence\n            for (const operation of operations) {\n                const { contractName, functionName, args, outputs } = operation;\n                \n                const contract = this.contracts.get(contractName);\n                if (!contract) {\n                    throw new Error(`Contract ${contractName} not found`);\n                }\n                \n                const txDetails = await contract.functions[functionName](...args)\n                    .to(outputs.address, outputs.amount)\n                    .send();\n                \n                results.push({\n                    contractName,\n                    functionName,\n                    txid: txDetails.txid,\n                    success: true\n                });\n            }\n            \n            return results;\n            \n        } catch (error) {\n            // Rollback logic would go here\n            console.error('Multi-contract transaction failed:', error);\n            throw error;\n        }\n    }\n    \n    startMonitoring(contractName) {\n        const contract = this.contracts.get(contractName);\n        \n        const monitor = setInterval(async () => {\n            try {\n                const balance = await contract.getBalance();\n                const utxos = await contract.getUtxos();\n                \n                const status = {\n                    balance,\n                    utxoCount: utxos.length,\n                    lastCheck: new Date()\n                };\n                \n                this.monitoring.set(contractName, status);\n                \n                // Alert if balance is low\n                if (balance < 10000) {\n                    console.warn(`Low balance for ${contractName}:`, balance);\n                }\n                \n            } catch (error) {\n                console.error(`Monitoring error for ${contractName}:`, error);\n            }\n        }, 60000); // Check every minute\n        \n        return monitor;\n    }\n    \n    getStatus() {\n        const status = {};\n        \n        for (const [name, info] of this.monitoring) {\n            status[name] = info;\n        }\n        \n        return status;\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "12. Multi-Contract Orchestrator"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-12",
    "content": "## Testing Patterns\n\n### 13. Comprehensive Test Suite\n\n```javascript\ndescribe('Production Contract Tests', () => {\n    let contract, provider, sigTemplate;\n    \n    beforeEach(async () => {\n        provider = new ElectrumNetworkProvider('chipnet');\n        contract = new Contract(artifact, constructorArgs, { provider });\n        sigTemplate = new SignatureTemplate(testPrivateKey);\n    });\n    \n    describe('Security Tests', () => {\n        it('should prevent unauthorized access', async () => {\n            const maliciousSig = new SignatureTemplate(randomPrivateKey);\n            \n            await expect(\n                contract.functions\n                    .spend(maliciousSig)\n                    .to(testAddress, 1000n)\n                    .send()\n            ).rejects.toThrow('Script failed');\n        });\n        \n        it('should validate amount limits', async () => {\n            await expect(\n                contract.functions\n                    .spend(sigTemplate, -1)\n                    .to(testAddress, 1000n)\n                    .send()\n            ).rejects.toThrow();\n        });\n    });\n    \n    describe('Integration Tests', () => {\n        it('should handle complex multi-output transactions', async () => {\n            const outputs = [\n                { address: address1, amount: 1000n },\n                { address: address2, amount: 2000n },\n                { address: address3, amount: 3000n }\n            ];\n            \n            const txDetails = await contract.functions\n                .multiOutput(sigTemplate)\n                .to(outputs[0].address, outputs[0].amount)\n                .to(outputs[1].address, outputs[1].amount)\n                .to(outputs[2].address, outputs[2].amount)\n                .send();\n            \n            expect(txDetails.txid).toBeDefined();\n            expect(txDetails.outputs.length).toBe(3);\n        });\n    });\n    \n    describe('Performance Tests', () => {\n        it('should complete transactions within time limit', async () => {\n            const startTime = Date.now();\n            \n            const txDetails = await contract.functions\n                .spend(sigTemplate)\n                .to(testAddress, 1000n)\n                .send();\n            \n            const duration = Date.now() - startTime;\n            expect(duration).toBeLessThan(10000); // 10 seconds\n        });\n    });\n});\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "Testing Patterns",
      "13. Comprehensive Test Suite"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-13",
    "content": "These real-world patterns demonstrate how CashScript can be used to build sophisticated applications on Bitcoin Cash, from DeFi protocols to NFT marketplaces and governance systems. Each pattern includes security considerations, error handling, and practical implementation details suitable for production use.\n\n## ParityUSD-Derived Production Patterns",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "ParityUSD-Derived Production Patterns"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-14",
    "content": "## ParityUSD-Derived Production Patterns\n\nThe following patterns are derived from analysis of ParityUSD, a production stablecoin system with 26 contracts. See `parityusd-analysis.md` for the full analysis.\n\n### 14. Sidecar Contract Template\n\nWhen a contract needs to hold multiple token categories, use a sidecar to hold additional tokens:\n\n```cashscript\npragma cashscript ^0.12.1;\n\n/*  --- TokenSidecar Immutable NFT State ---\n    none (validates relationship only)\n*/\n\ncontract TokenSidecar() {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Attach to main contract. Validates same-transaction origin.\n    //\n    //inputs:\n    //  0   MainContract              [NFT]       (from Main contract)\n    //  1   TokenSidecar              [NFT]       (from Sidecar contract - this)\n    //outputs:\n    //  0   MainContract              [NFT]       (to Main contract)\n    //  1   TokenSidecar              [NFT+FT]    (to Sidecar contract)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function attach() {\n        // Sidecar must be immediately after main contract\n        int mainIdx = this.activeInputIndex - 1;\n\n        // CRITICAL: Prove same-transaction origin\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIdx].outpointTransactionHash);\n\n        // CRITICAL: Prove sequential output indices (created together)\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIdx].outpointIndex + 1);\n\n        // Self-replicate at dust value\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        require(tx.outputs[this.activeInputIndex].value == 1000);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "ParityUSD-Derived Production Patterns",
      "14. Sidecar Contract Template"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-15",
    "content": "**Key Insight**: The `outpointTransactionHash` equality proves both UTXOs originated from the same transaction, creating an unbreakable bond.\n\n### 15. Function Router Contract Template\n\nWhen a contract has many operations, split into function contracts authenticated by NFT identifier bytes:\n\n```cashscript\npragma cashscript ^0.12.1;\n\n/*  --- MainRouter Mutable NFT State ---\n    bytes1 identifier = 0xFF           // Router identifier\n    bytes8 counter = 0x0000000000000000\n*/\n\ncontract MainRouter(bytes32 systemTokenId) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Route to appropriate function based on function NFT identifier.\n    //\n    //inputs:\n    //  0   MainRouter                [NFT]       (from Router contract - this)\n    //  1   FunctionNFT               [NFT]       (from appropriate function contract)\n    //  2   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   MainRouter                [NFT]       (to Router contract)\n    //  1   FunctionNFT               [NFT]       (to function contract)\n    //  2   result                    [varies]    (to user or destination)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function interact(int functionInputIndex) {\n        require(this.activeInputIndex == 0);\n\n        // CRITICAL: Limit outputs to prevent minting attacks\n        require(tx.outputs.length <= 7);\n\n        // Extract function identifier from NFT commitment first byte\n        bytes functionId = tx.inputs[functionInputIndex].nftCommitment.split(1)[0];\n\n        // Validate function NFT belongs to this system\n        require(tx.inputs[functionInputIndex].tokenCategory == systemTokenId + 0x01);\n\n        // Route to appropriate validation logic\n        if (functionId == 0x00) {\n            // Function A: specific validation\n            require(tx.outputs.length <= 4);\n            // ... function A constraints\n        } else if (functionId == 0x01) {\n            // Function B: specific validation\n            require(tx.outputs.length <= 5);\n            // ... function B constraints\n        } else if (functionId == 0x02) {\n            // Function C: specific validation\n            require(tx.outputs.length <= 6);\n            // ... function C constraints\n        }\n\n        // Self-replicate router\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "15. Function Router Contract Template"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-16",
    "content": "### 16. Function Contract Template\n\nEach function contract validates its authority and specific operation:\n\n```cashscript\npragma cashscript ^0.12.1;\n\n/*  --- FunctionA Immutable NFT State ---\n    bytes1 identifier = 0x00           // Function A identifier\n*/\n\ncontract FunctionA(bytes32 systemTokenId) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Execute function A operation. Validates authority via NFT identifier.\n    //\n    //inputs:\n    //  0   MainRouter                [NFT]       (from Router contract)\n    //  1   FunctionA                 [NFT]       (from FunctionA contract - this)\n    //  2   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   MainRouter                [NFT]       (to Router contract)\n    //  1   FunctionA                 [NFT]       (to FunctionA contract)\n    //  2   result                    [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function execute() {\n        // Validate position\n        require(this.activeInputIndex == 1);\n\n        // CRITICAL: Limit outputs\n        require(tx.outputs.length <= 4);\n\n        // Validate router at position 0\n        require(tx.inputs[0].tokenCategory == systemTokenId + 0x01);\n        require(tx.inputs[0].nftCommitment.split(1)[0] == 0xFF); // Router identifier\n\n        // Function-specific business logic\n        // ...\n\n        // Self-replicate at dust value\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);\n        require(tx.outputs[1].value == 1000);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "16. Function Contract Template"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-17",
    "content": "### 17. Self-Replicating Covenant with State\n\nPattern for contracts that must persist with updated state:\n\n```cashscript\npragma cashscript ^0.12.1;\n\n/*  --- StatefulCovenant Mutable NFT State ---\n    bytes4 counter = 0x00000000\n    bytes6 totalValue = 0x000000000000\n    bytes20 adminPkh = 0x0000000000000000000000000000000000000000\n*/\n\ncontract StatefulCovenant(bytes32 covenantCategory) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Update state while preserving covenant.\n    //\n    //inputs:\n    //  0   StatefulCovenant          [NFT]       (from Covenant contract - this)\n    //  1   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   StatefulCovenant          [NFT]       (to Covenant contract)\n    //  1   change {optional}         [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function updateState(int newValue) {\n        require(this.activeInputIndex == 0);\n        require(tx.outputs.length <= 3);\n\n        // Parse current state from commitment\n        bytes commitment = tx.inputs[0].nftCommitment;\n        bytes4 counter, bytes remaining = commitment.split(4);\n        bytes6 totalValue, bytes20 adminPkh = remaining.split(6);\n\n        // Update state\n        int newCounter = int(counter) + 1;\n        require(newCounter < 2147483647); // MSB safety\n\n        int newTotal = int(totalValue) + newValue;\n        require(newTotal >= 0);\n        require(newTotal < 140737488355327); // bytes6 max\n\n        // Reconstruct commitment with new state\n        bytes newCommitment = bytes4(newCounter) + bytes6(newTotal) + adminPkh;\n\n        // THE 5-POINT VALIDATION CHECKLIST\n        // 1. Same contract code\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        // 2. Same token category\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n        // 3. Expected value (preserve or update)\n        require(tx.outputs[0].value >= tx.inputs[0].value);\n        // 4. Token amount (if applicable)\n        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n        // 5. New state commitment\n        require(tx.outputs[0].nftCommitment == newCommitment);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int",
      "17. Self-Replicating Covenant with State"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-18",
    "content": "### 18. Cross-Contract Authentication Pattern\n\nPattern for contracts that need to verify other contracts in the same transaction:\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract CrossContractValidator(\n    bytes32 priceOracleCategory,\n    bytes32 mainContractCategory,\n    bytes32 sidecarCategory\n) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Execute operation requiring multiple contract authentication.\n    //\n    //inputs:\n    //  0   PriceOracle               [NFT]       (from Oracle contract)\n    //  1   MainContract              [NFT]       (from Main contract)\n    //  2   Sidecar                   [NFT+FT]    (from Sidecar contract)\n    //  3   Validator                 [NFT]       (from Validator contract - this)\n    //  4   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   PriceOracle               [NFT]       (to Oracle contract)\n    //  1   MainContract              [NFT]       (to Main contract)\n    //  2   Sidecar                   [NFT+FT]    (to Sidecar contract)\n    //  3   Validator                 [NFT]       (to Validator contract)\n    //  4   result                    [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function executeWithAuth() {\n        require(this.activeInputIndex == 3);\n        require(tx.outputs.length <= 6);\n\n        // Authenticate price oracle at index 0\n        require(tx.inputs[0].tokenCategory == priceOracleCategory + 0x01);\n        require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00); // Oracle identifier\n\n        // Authenticate main contract at index 1\n        require(tx.inputs[1].tokenCategory == mainContractCategory + 0x01);\n        require(tx.inputs[1].nftCommitment.split(1)[0] == 0x01); // Main identifier\n\n        // Authenticate sidecar at index 2 (same category, sequential origin)\n        require(tx.inputs[2].tokenCategory == sidecarCategory + 0x01);\n        require(tx.inputs[2].outpointTransactionHash ==\n                tx.inputs[1].outpointTransactionHash);\n\n        // Now safe to use data from authenticated contracts\n        bytes priceData = tx.inputs[0].nftCommitment.split(1)[1];\n        int price = int(priceData.split(8)[0]);\n\n        // Business logic using authenticated data\n        // ...\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "18. Cross-Contract Authentication Pattern"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-19",
    "content": "### 19. Receipt/Proof NFT Pattern\n\nPattern for creating immutable receipts that prove actions occurred:\n\n```cashscript\npragma cashscript ^0.12.1;\n\ncontract ReceiptIssuer(bytes32 systemCategory) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Create immutable receipt NFT as proof of action.\n    //\n    //inputs:\n    //  0   Issuer                    [NFT]       (from Issuer contract - this, minting)\n    //  1   userBCH                   [BCH]       (from user)\n    //outputs:\n    //  0   Issuer                    [NFT]       (to Issuer contract)\n    //  1   Receipt                   [NFT]       (to user - immutable proof)\n    //  2   change {optional}         [BCH]       (to user)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function issueReceipt(bytes20 recipientPkh, int amount, int actionId) {\n        require(this.activeInputIndex == 0);\n        require(tx.outputs.length <= 3);\n\n        // Must be minting NFT to create receipts\n        bytes category, bytes capability = tx.inputs[0].tokenCategory.split(32);\n        require(capability == 0x02); // Minting capability\n\n        // Build receipt commitment\n        // Layout: recipientPkh(20) + amount(6) + actionId(4) + timestamp(4) = 34 bytes\n        bytes receiptCommitment = recipientPkh +\n                                  bytes6(amount) +\n                                  bytes4(actionId) +\n                                  bytes4(tx.locktime);\n\n        // Create IMMUTABLE receipt (no capability byte = immutable)\n        bytes recipientBytecode = new LockingBytecodeP2PKH(recipientPkh);\n        require(tx.outputs[1].lockingBytecode == recipientBytecode);\n        require(tx.outputs[1].tokenCategory == category); // No capability = immutable\n        require(tx.outputs[1].nftCommitment == receiptCommitment);\n        require(tx.outputs[1].value == 1000); // Dust\n\n        // Self-replicate issuer with minting capability\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "19. Receipt/Proof NFT Pattern"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-20",
    "content": "### 20. Origin Proof Pattern\n\nPattern for proving an NFT was legitimately created by the system:\n\n```cashscript\npragma cashscript ^0.12.1;\n\n/*  --- OriginEnforcer Immutable NFT State ---\n    bytes32 factoryTxHash\n*/\n\ncontract OriginEnforcer(bytes32 factoryCategory) {\n    //////////////////////////////////////////////////////////////////////////////////////////\n    //  Verify this NFT was created by a legitimate factory.\n    //\n    //inputs:\n    //  0   Factory                   [NFT]       (from Factory contract)\n    //  1   OriginEnforcer            [NFT]       (from Enforcer contract - this)\n    //outputs:\n    //  0   Factory                   [NFT]       (to Factory contract)\n    //  1   OriginEnforcer            [NFT]       (to Enforcer contract)\n    //////////////////////////////////////////////////////////////////////////////////////////\n    function verify() {\n        require(this.activeInputIndex == 1);\n        require(tx.outputs.length <= 3);\n\n        // Get factory input index\n        int factoryIdx = this.activeInputIndex - 1;\n\n        // CRITICAL: Verify same-transaction origin with factory\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[factoryIdx].outpointTransactionHash);\n\n        // Verify factory has correct category\n        require(tx.inputs[factoryIdx].tokenCategory == factoryCategory + 0x02); // Minting\n\n        // Self-replicate\n        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);\n        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);\n    }\n}\n```",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "20. Origin Proof Pattern"
    ]
  },
  {
    "id": "examples/real-world/production-patterns.md-21",
    "content": "These ParityUSD-derived patterns represent battle-tested approaches used in production DeFi systems. Each pattern emphasizes explicit validation, output limiting, and clear constraint specification.",
    "source": "examples/real-world/production-patterns.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "best-practices/security/smart-contract-security.md-0",
    "content": "# CashScript Smart Contract Security\n\n## Overview\n\nSmart contract security is critical when handling value on the Bitcoin Cash blockchain. This guide covers essential security practices, common vulnerabilities, and defensive programming techniques for CashScript contracts.\n\n## Core Security Principles",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "CashScript Smart Contract Security",
      "Overview",
      "Core Security Principles"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-1",
    "content": "## Core Security Principles\n\n### 1. Fail-Safe Defaults\n\nDesign contracts to fail securely when conditions aren't met.\n\n```cashscript\ncontract SecureContract(pubkey owner, int threshold) {\n    function spend(sig ownerSig, int amount) {\n        // Explicit validation required\n        require(checkSig(ownerSig, owner));\n        require(amount >= threshold);\n        \n        // Additional safety checks\n        require(tx.outputs.length >= 1);\n        require(tx.outputs[0].value >= amount);\n    }\n}\n```\n\n### 2. Input Validation\n\nNever trust function arguments - validate everything.\n\n```cashscript\ncontract InputValidation(pubkey owner) {\n    function spend(sig userSig, int amount, bytes data) {\n        // Validate signature\n        require(checkSig(userSig, owner));\n        \n        // Validate amount\n        require(amount > 0);\n        require(amount <= 100000000);  // Max 1 BCH\n        \n        // Validate data\n        require(data.length > 0);\n        require(data.length <= 256);  // Reasonable data limit\n    }\n}\n```\n\n### 3. Principle of Least Privilege\n\nGrant minimum necessary permissions.\n\n```cashscript\ncontract RestrictedAccess(pubkey owner, pubkey operator, int operatorLimit) {\n    function ownerSpend(sig ownerSig, int amount) {\n        require(checkSig(ownerSig, owner));\n        // Owner can spend any amount\n    }\n    \n    function operatorSpend(sig operatorSig, int amount) {\n        require(checkSig(operatorSig, operator));\n        // Operator has limited spending power\n        require(amount <= operatorLimit);\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Core Security Principles",
      "1. Fail-Safe Defaults",
      "2. Input Validation",
      "3. Principle of Least Privilege"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-2",
    "content": "## Common Vulnerabilities\n\n### 1. Insufficient Input Validation\n\n**Vulnerable Code:**\n```cashscript\ncontract VulnerableContract(pubkey owner) {\n    function spend(sig userSig, int amount) {\n        require(checkSig(userSig, owner));\n        // Missing amount validation!\n    }\n}\n```\n\n**Secure Version:**\n```cashscript\ncontract SecureContract(pubkey owner, int maxAmount) {\n    function spend(sig userSig, int amount) {\n        require(checkSig(userSig, owner));\n        require(amount > 0);\n        require(amount <= maxAmount);\n    }\n}\n```\n\n### 2. Time-Based Vulnerabilities\n\n**Vulnerable Code:**\n```cashscript\ncontract VulnerableTimelock(pubkey owner, int lockTime) {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        // Vulnerable to time manipulation\n        require(tx.time > lockTime);\n    }\n}\n```\n\n**Secure Version:**\n```cashscript\ncontract SecureTimelock(pubkey owner, int lockTime) {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        // Use >= for time comparisons\n        require(tx.time >= lockTime);\n        \n        // Additional validation\n        require(lockTime > 0);\n    }\n}\n```\n\n### 3. Signature Malleability\n\n**Vulnerable Code:**\n```cashscript\ncontract VulnerableMultiSig(pubkey pk1, pubkey pk2) {\n    function spend(sig s1, sig s2) {\n        // Vulnerable to signature substitution\n        require(checkSig(s1, pk1));\n        require(checkSig(s2, pk2));\n    }\n}\n```\n\n**Secure Version:**\n```cashscript\ncontract SecureMultiSig(pubkey pk1, pubkey pk2) {\n    function spend(sig s1, sig s2) {\n        // Use checkMultiSig for proper validation\n        require(checkMultiSig([s1, s2], [pk1, pk2]));\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "Common Vulnerabilities",
      "1. Insufficient Input Validation",
      "2. Time-Based Vulnerabilities",
      "3. Signature Malleability"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-3",
    "content": "### 4. Reentrancy-Like Issues\n\n**Vulnerable Code:**\n```cashscript\ncontract VulnerableState() {\n    function spend(int counter) {\n        // No validation of state consistency\n        require(counter > 0);\n    }\n}\n```\n\n**Secure Version:**\n```cashscript\ncontract SecureState(bytes32 stateHash) {\n    function spend(int counter, bytes stateData) {\n        // Validate state integrity\n        require(sha256(stateData) == stateHash);\n        require(counter > 0);\n        \n        // Extract and validate counter from state\n        int currentCounter = int(stateData.split(4)[0]);\n        require(counter == currentCounter + 1);\n    }\n}\n```\n\n## Defensive Programming Patterns",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "4. Reentrancy-Like Issues",
      "Defensive Programming Patterns"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-4",
    "content": "## Defensive Programming Patterns\n\n### 1. Bounds Checking\n\n```cashscript\ncontract BoundsChecker(int minValue, int maxValue) {\n    function validate(int value) {\n        // Explicit bounds checking\n        require(value >= minValue);\n        require(value <= maxValue);\n        \n        // Additional safety for array-like operations\n        require(minValue <= maxValue);\n    }\n}\n```\n\n### 2. Overflow Protection\n\n```cashscript\ncontract OverflowProtection() {\n    function safeAdd(int a, int b) {\n        // Check for addition overflow\n        require(a >= 0);\n        require(b >= 0);\n        \n        int result = a + b;\n        require(result >= a);  // Overflow check\n        require(result >= b);  // Overflow check\n    }\n    \n    function safeMultiply(int a, int b) {\n        // Check for multiplication overflow\n        require(a >= 0);\n        require(b >= 0);\n        \n        if (a == 0 || b == 0) {\n            // Safe multiplication by zero\n            return;\n        }\n        \n        int result = a * b;\n        require(result / a == b);  // Overflow check\n    }\n}\n```\n\n### 3. Access Control\n\n```cashscript\ncontract AccessControl(pubkey admin, pubkey[] operators) {\n    function adminAction(sig adminSig) {\n        require(checkSig(adminSig, admin));\n        // Admin-only actions\n    }\n    \n    function operatorAction(sig operatorSig, pubkey operatorPk) {\n        // Validate operator is in authorized list\n        bool isAuthorized = false;\n        for (int i = 0; i < operators.length; i++) {\n            if (operators[i] == operatorPk) {\n                isAuthorized = true;\n                break;\n            }\n        }\n        \n        require(isAuthorized);\n        require(checkSig(operatorSig, operatorPk));\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "int",
      "bool",
      "Defensive Programming Patterns",
      "1. Bounds Checking",
      "2. Overflow Protection",
      "3. Access Control"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-5",
    "content": "### 4. State Validation\n\n```cashscript\ncontract StateValidation(bytes32 initialStateHash) {\n    function updateState(bytes oldState, bytes newState) {\n        // Validate old state\n        require(sha256(oldState) == initialStateHash);\n        \n        // Validate state transition\n        require(newState.length == oldState.length);\n        require(newState != oldState);  // State must change\n        \n        // Validate new state format\n        require(newState.length >= 32);\n    }\n}\n```\n\n## Transaction Security",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "4. State Validation",
      "Transaction Security"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-6",
    "content": "## Transaction Security\n\n### 1. Output Validation\n\n```cashscript\ncontract OutputValidator(bytes20 authorizedRecipient) {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        \n        // Validate transaction structure\n        require(tx.outputs.length >= 1);\n        \n        // Validate recipient\n        bytes expectedBytecode = new LockingBytecodeP2PKH(authorizedRecipient);\n        require(tx.outputs[0].lockingBytecode == expectedBytecode);\n        \n        // Validate amount\n        require(tx.outputs[0].value >= 1000);\n    }\n}\n```\n\n### 2. Input Validation\n\n```cashscript\ncontract InputValidator() {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        \n        // Validate input count\n        require(tx.inputs.length >= 1);\n        require(tx.inputs.length <= 10);  // Reasonable limit\n        \n        // Validate input values\n        int totalInput = 0;\n        for (int i = 0; i < tx.inputs.length; i++) {\n            require(tx.inputs[i].value > 0);\n            totalInput += tx.inputs[i].value;\n        }\n        \n        // Ensure sufficient input value\n        require(totalInput >= 1000);\n    }\n}\n```\n\n### 3. Fee Validation\n\n```cashscript\ncontract FeeValidator() {\n    function spend(sig ownerSig) {\n        require(checkSig(ownerSig, owner));\n        \n        // Calculate total input and output values\n        int totalInput = 0;\n        int totalOutput = 0;\n        \n        for (int i = 0; i < tx.inputs.length; i++) {\n            totalInput += tx.inputs[i].value;\n        }\n        \n        for (int i = 0; i < tx.outputs.length; i++) {\n            totalOutput += tx.outputs[i].value;\n        }\n        \n        // Validate reasonable fee\n        int fee = totalInput - totalOutput;\n        require(fee >= 1000);     // Minimum fee\n        require(fee <= 100000);   // Maximum fee (prevent fee attacks)\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "Transaction Security",
      "1. Output Validation",
      "2. Input Validation",
      "3. Fee Validation"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-7",
    "content": "## Cryptographic Security\n\n### 1. Hash Validation\n\n```cashscript\ncontract HashValidator(bytes32 expectedHash) {\n    function validate(bytes preimage) {\n        // Validate preimage length\n        require(preimage.length > 0);\n        require(preimage.length <= 1024);  // Reasonable limit\n        \n        // Validate hash\n        require(sha256(preimage) == expectedHash);\n        \n        // Additional validation for sensitive data\n        require(preimage[0] != 0x00);  // Prevent null byte attacks\n    }\n}\n```\n\n### 2. Signature Validation\n\n```cashscript\ncontract SignatureValidator(pubkey trustedKey) {\n    function validate(sig signature, bytes message) {\n        // Validate signature format\n        require(signature.length > 0);\n        require(signature != 0x00);  // Prevent null signature\n        \n        // Validate message\n        require(message.length > 0);\n        require(message.length <= 256);\n        \n        // Validate signature\n        require(checkDataSig(signature, message, trustedKey));\n    }\n}\n```\n\n### 3. Key Validation\n\n```cashscript\ncontract KeyValidator() {\n    function validateKey(pubkey key) {\n        // Validate key format\n        require(key.length == 33);  // Compressed public key\n        \n        // Validate key prefix\n        require(key[0] == 0x02 || key[0] == 0x03);  // Valid compressed key prefix\n        \n        // Prevent all-zero keys\n        bool isZero = true;\n        for (int i = 1; i < key.length; i++) {\n            if (key[i] != 0x00) {\n                isZero = false;\n                break;\n            }\n        }\n        require(!isZero);\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "bool",
      "Cryptographic Security",
      "1. Hash Validation",
      "2. Signature Validation",
      "3. Key Validation"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-8",
    "content": "## CashTokens Security\n\n### 1. Token Validation\n\n```cashscript\ncontract TokenValidator(bytes32 authorizedCategory) {\n    function validateToken() {\n        // Validate token category\n        require(tx.outputs[0].tokenCategory == authorizedCategory);\n        \n        // Validate token amount\n        require(tx.outputs[0].tokenAmount > 0);\n        \n        // Prevent token overflow\n        require(tx.outputs[0].tokenAmount <= 18446744073709551615);  // Max uint64\n    }\n}\n```\n\n### 2. NFT Security\n\n```cashscript\ncontract NFTValidator(bytes32 authorizedCategory) {\n    function validateNFT(bytes expectedCommitment) {\n        // Validate NFT category\n        require(tx.outputs[0].tokenCategory == authorizedCategory);\n        \n        // Validate NFT commitment\n        require(tx.outputs[0].nftCommitment == expectedCommitment);\n        require(expectedCommitment.length > 0);\n        require(expectedCommitment.length <= 128);  // Max commitment size\n    }\n}\n```\n\n## Bitwise Operation Security",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "CashTokens Security",
      "1. Token Validation",
      "2. NFT Security",
      "Bitwise Operation Security"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-9",
    "content": "## Bitwise Operation Security\n\n### 1. Shift Amount Validation\n\n**Risk**: Invalid shift amounts causing unexpected results.\n\n**Secure Pattern**:\n```cashscript\ncontract SecureBitwise() {\n    function safeShift(int value, int shiftAmount) {\n        // Validate shift amount is reasonable\n        require(shiftAmount >= 0);\n        require(shiftAmount <= 64);  // Max meaningful shift\n\n        int result = value << shiftAmount;\n        require(result > 0);  // Validate result as expected\n    }\n}\n```\n\n**Best Practices**:\n- Validate shift amounts before operations\n- Check for zero shifts\n- Verify shift results are as expected\n- Test boundary cases (0, 1, max bits)\n\n### 2. Bitwise Operation Security\n\n**Risk**: Bitwise operations producing unexpected values or type errors.\n\n**CRITICAL**: CashScript only supports bitwise operators (`& | ^`) on `bytes` types, NOT on `int`.\n\n**Secure Pattern**:\n```cashscript\ncontract BitwiseSecurity(bytes4 mask) {\n    function processFlags(bytes4 flags) {\n        // Bitwise AND on bytes types\n        bytes4 result = flags & mask;\n\n        // Verify result matches expected pattern\n        require(result == mask);  // All mask bits must be set\n    }\n}\n```\n\n**Best Practices**:\n- Use `bytes` or `bytesN` types for bitwise operations (NOT `int`)\n- Use appropriate fixed-length bytes for bit ranges (bytes1, bytes2, bytes4)\n- Test with edge values (0x00, 0xFF, all bits set)\n\n### 3. Bit Flag Security\n\n**Risk**: Incorrect flag checking allowing unauthorized access.\n\n**Secure Pattern**:",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Bitwise Operation Security",
      "1. Shift Amount Validation",
      "2. Bitwise Operation Security",
      "3. Bit Flag Security"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-10",
    "content": "```cashscript\ncontract FlagValidator(bytes1 requiredFlags) {\n    function checkPermissions(bytes1 userFlags) {\n        // Check required flags are ALL set (bitwise AND on bytes)\n        bytes1 result = userFlags & requiredFlags;\n        require(result == requiredFlags);\n\n        // Check specific bit flags using bytes comparison\n        bytes1 allowedFlags = 0xFF;\n        bytes1 extraFlags = userFlags & (allowedFlags ^ requiredFlags);\n        require(extraFlags == 0x00);  // No unauthorized flags\n    }\n}\n```\n\n**Best Practices**:\n- Use `bytes1` for single-byte flag fields\n- Validate all required flags are set using `& mask == mask` pattern\n- Define explicit flag masks as `bytes` constants\n- Test all flag combinations\n\n## Security Testing",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "Security Testing"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-11",
    "content": "## Security Testing\n\n### 1. Boundary Testing\n\n```javascript\ndescribe('Contract Security Tests', () => {\n    it('should reject negative amounts', async () => {\n        await expect(\n            contract.functions\n                .spend(sigTemplate, -1)\n                .to(address, 1000n)\n                .send()\n        ).rejects.toThrow();\n    });\n    \n    it('should reject zero amounts', async () => {\n        await expect(\n            contract.functions\n                .spend(sigTemplate, 0)\n                .to(address, 1000n)\n                .send()\n        ).rejects.toThrow();\n    });\n    \n    it('should reject excessive amounts', async () => {\n        await expect(\n            contract.functions\n                .spend(sigTemplate, 2100000000000000n)  // > 21M BCH\n                .to(address, 1000n)\n                .send()\n        ).rejects.toThrow();\n    });\n});\n```\n\n### 2. Attack Simulation\n\n```javascript\ndescribe('Attack Vector Tests', () => {\n    it('should prevent signature replay', async () => {\n        // Create valid transaction\n        const txDetails = await contract.functions\n            .spend(sigTemplate)\n            .to(address, 1000n)\n            .send();\n        \n        // Attempt to replay same signature\n        await expect(\n            contract.functions\n                .spend(sigTemplate)  // Same signature\n                .to(address, 1000n)\n                .send()\n        ).rejects.toThrow();\n    });\n});\n```\n\n## Security Checklist",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "Security Testing",
      "1. Boundary Testing",
      "2. Attack Simulation",
      "Security Checklist"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-12",
    "content": "## Security Checklist\n\n### Pre-Deployment\n\n- [ ] All inputs are validated\n- [ ] Bounds checking implemented\n- [ ] Overflow protection in place\n- [ ] Access control properly implemented\n- [ ] Time-based logic uses appropriate comparisons\n- [ ] Signature validation follows best practices\n- [ ] Token validation includes all necessary checks\n- [ ] Error cases are handled gracefully\n\n### Testing\n\n- [ ] Unit tests cover all functions\n- [ ] Boundary conditions tested\n- [ ] Attack vectors simulated\n- [ ] Integration tests with real transactions\n- [ ] Gas/fee optimization verified\n- [ ] Multi-signature scenarios tested\n\n### Production\n\n- [ ] Code audited by security experts\n- [ ] Deployed on testnet first\n- [ ] Monitoring in place\n- [ ] Upgrade/migration plan prepared\n- [ ] Emergency procedures documented\n- [ ] Insurance or backup funds available\n\n## Emergency Response",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "Security Checklist",
      "Pre-Deployment",
      "Testing",
      "Production",
      "Emergency Response"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-13",
    "content": "## Emergency Response\n\n### 1. Incident Detection\n\n```javascript\n// Monitor contract for suspicious activity\nasync function monitorContract(contract) {\n    const utxos = await contract.getUtxos();\n    \n    for (const utxo of utxos) {\n        // Check for unusual patterns\n        if (utxo.satoshis > 1000000) {  // Large amount\n            console.warn('Large UTXO detected:', utxo);\n        }\n        \n        if (utxo.token && utxo.token.amount > 1000000) {\n            console.warn('Large token amount detected:', utxo);\n        }\n    }\n}\n```\n\n### 2. Emergency Procedures\n\n```javascript\n// Emergency contract pause (if implemented)\nasync function emergencyPause(contract, adminKey) {\n    const adminSig = new SignatureTemplate(adminKey);\n    \n    try {\n        const txDetails = await contract.functions\n            .emergencyPause(adminSig)\n            .send();\n        \n        console.log('Emergency pause activated:', txDetails.txid);\n    } catch (error) {\n        console.error('Emergency pause failed:', error);\n    }\n}\n```\n\n## Best Practices Summary",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Emergency Response",
      "1. Incident Detection",
      "2. Emergency Procedures",
      "Best Practices Summary"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-14",
    "content": "## Best Practices Summary\n\n1. **Always validate inputs** - Never trust function arguments\n2. **Use explicit bounds checking** - Prevent overflow and underflow\n3. **Implement proper access control** - Restrict sensitive operations\n4. **Validate transaction structure** - Check inputs and outputs\n5. **Use secure cryptographic practices** - Proper signature validation\n6. **Test thoroughly** - Include boundary and attack vector tests\n7. **Monitor in production** - Watch for unusual activity\n8. **Plan for emergencies** - Have response procedures ready\n9. **Keep contracts simple** - Complexity increases attack surface\n10. **Regular security audits** - External review of contract code\n\n## Output Count Security (CRITICAL)",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Best Practices Summary",
      "Output Count Security (CRITICAL)"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-15",
    "content": "## Output Count Security (CRITICAL)\n\n### The Minting Attack\n\n**Vulnerability**: Without output count limits, attackers can add unauthorized outputs to mint tokens.\n\n**Attack Vector**:\n1. Attacker creates a valid transaction that satisfies all contract constraints\n2. Attacker adds extra outputs minting new tokens or NFTs\n3. Contract validates expected outputs but ignores the extras\n4. Unauthorized tokens enter circulation\n\n### Mandatory Output Limiting\n\n**EVERY contract function MUST limit output count**:\n\n```cashscript\ncontract SecureContract(bytes32 tokenCategory) {\n    function spend() {\n        // CRITICAL: ALWAYS include this as first validation\n        require(tx.outputs.length <= 4);\n\n        // ... rest of logic\n    }\n}\n```\n\n### Standard Output Limits\n\n| Operation Type | Recommended Limit | Reason |\n|---------------|-------------------|--------|\n| Simple transfer | 3-4 | Input + output + change |\n| Swap/exchange | 5-6 | Multiple participants |\n| Complex DeFi | 7-10 | Multiple contracts + change |\n| Batch operations | 15-20 | Multiple recipients |\n| Maximum | 50 | Transaction size limits |\n\n### Secure Pattern\n\n```cashscript\ncontract OutputSecureContract() {\n    function processTransaction() {\n        // FIRST: Limit outputs\n        require(tx.outputs.length <= 5);\n\n        // THEN: Validate specific outputs\n        require(tx.outputs[0].lockingBytecode == expectedBytecode);\n        require(tx.outputs[0].value >= 1000);\n\n        // Even with validation, output limit prevents extra unauthorized outputs\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "Output Count Security (CRITICAL)",
      "The Minting Attack",
      "Mandatory Output Limiting",
      "Standard Output Limits",
      "Secure Pattern"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-16",
    "content": "## Covenant Preservation Checklist\n\n### The 5-Point Validation\n\nFor ANY self-replicating covenant, you MUST validate all five properties:\n\n```cashscript\n// THE 5-POINT COVENANT VALIDATION CHECKLIST\n// Missing ANY of these creates vulnerabilities\n\n// 1. Same contract code (prevents code injection)\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n// 2. Same token category (prevents category substitution)\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n// 3. Expected satoshi value (prevents value extraction)\nrequire(tx.outputs[0].value == expectedValue);\n\n// 4. Expected token amount (prevents token extraction)\nrequire(tx.outputs[0].tokenAmount == expectedTokenAmount);\n\n// 5. Expected/new state commitment (prevents state manipulation)\nrequire(tx.outputs[0].nftCommitment == newCommitment);\n```\n\n### Common Mistakes\n\n**Missing lockingBytecode check**:\n```cashscript\n// VULNERABLE - attacker can substitute contract\nfunction spend() {\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    // Missing: lockingBytecode check!\n}\n```\n\n**Missing tokenCategory check**:\n```cashscript\n// VULNERABLE - attacker can substitute token\nfunction spend() {\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    // Missing: tokenCategory check!\n}\n```\n\n### Covenant Type Security\n\n| Covenant Type | What MUST Be Validated |",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "Covenant Preservation Checklist",
      "The 5-Point Validation",
      "Common Mistakes",
      "Covenant Type Security"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-17",
    "content": "|--------------|------------------------|\n| Exactly self-replicating | All 5 properties unchanged |\n| State-mutating | 4 properties + valid new state |\n| Balance-mutating | 3 properties + valid new value + valid new state |\n| Conditionally-replicating | Full validation when replicating |\n\n## Minting Authority Control",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "Minting Authority Control"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-18",
    "content": "## Minting Authority Control\n\n### The Minting NFT Problem\n\nMinting NFTs (capability `0x02`) can create unlimited tokens. If a minting NFT escapes to an untrusted address, the entire token system is compromised.\n\n### Secure Minting Patterns\n\n**1. Never release minting authority**:\n```cashscript\ncontract MintingController(bytes32 category) {\n    function mint(int amount) {\n        // Verify this contract holds minting NFT\n        require(tx.inputs[0].tokenCategory == category + 0x02);\n\n        // CRITICAL: Keep minting NFT in contract\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n        // Never send minting NFT to user addresses\n    }\n}\n```\n\n**2. Downgrade minting to mutable when possible**:\n```cashscript\n// After initial setup, downgrade minting NFT\nrequire(tx.outputs[0].tokenCategory == category + 0x01); // Mutable only\n```\n\n**3. Burn minting authority when done**:\n```cashscript\n// Send minting NFT to OP_RETURN to destroy it\nrequire(tx.outputs[destroyIdx].lockingBytecode == 0x6a);\nrequire(tx.outputs[destroyIdx].tokenCategory == category + 0x02);\n```\n\n### Origin Proof for Legitimate Creation\n\nWhen minting new NFTs, prove they came from authorized source:\n\n```cashscript\ncontract AuthorizedMinter(bytes32 factoryCategory) {\n    function mint() {\n        // Verify factory is present\n        require(tx.inputs[0].tokenCategory == factoryCategory + 0x02);\n\n        // New NFTs must be in same transaction as factory\n        // This proves legitimate origin\n    }\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "Minting Authority Control",
      "The Minting NFT Problem",
      "Secure Minting Patterns",
      "Origin Proof for Legitimate Creation"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-19",
    "content": "## Multi-Contract Security\n\n### Input Position Attacks\n\n**Vulnerability**: Without position validation, attackers can reorder inputs.\n\n**Attack**:\n1. Contract expects input 0 = Oracle, input 1 = Main\n2. Attacker swaps positions: input 0 = Main, input 1 = Oracle\n3. Contract reads wrong data from wrong position\n\n**Defense**:\n```cashscript\nfunction operation() {\n    // ALWAYS validate your own position first\n    require(this.activeInputIndex == 2);\n\n    // ALWAYS validate other contracts at expected positions\n    require(tx.inputs[0].tokenCategory == oracleCategory);\n    require(tx.inputs[1].tokenCategory == mainCategory);\n}\n```\n\n### Cross-Contract Authentication\n\n**Rule**: Never trust a contract just because it's in the transaction.\n\n```cashscript\n// INSECURE - trusts any input at position 0\nfunction insecure() {\n    bytes data = tx.inputs[0].nftCommitment;\n    // ... uses data without verification\n}\n\n// SECURE - verifies contract identity before trusting\nfunction secure() {\n    // Verify category and identifier\n    require(tx.inputs[0].tokenCategory == trustedCategory + 0x01);\n    require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00);\n\n    // NOW safe to use data\n    bytes data = tx.inputs[0].nftCommitment.split(1)[1];\n}\n```\n\n### Same-Origin Verification\n\nFor sidecar/main pairs, verify same-transaction origin:\n\n```cashscript\nfunction verifySidecar() {\n    int mainIdx = this.activeInputIndex - 1;\n\n    // CRITICAL: Same transaction hash proves co-creation\n    require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n            tx.inputs[mainIdx].outpointTransactionHash);\n\n    // CRITICAL: Sequential indices proves ordering\n    require(tx.inputs[this.activeInputIndex].outpointIndex ==\n            tx.inputs[mainIdx].outpointIndex + 1);\n}\n```",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "Multi-Contract Security",
      "Input Position Attacks",
      "Cross-Contract Authentication",
      "Same-Origin Verification"
    ]
  },
  {
    "id": "best-practices/security/smart-contract-security.md-20",
    "content": "## Security Checklist Update\n\n### Multi-Contract Security\n\n- [ ] Output count limited in every function\n- [ ] All 5 covenant properties validated\n- [ ] Input positions explicitly validated\n- [ ] Cross-contract authentication verified\n- [ ] Minting authority controlled and contained\n- [ ] Same-origin verification for paired contracts\n- [ ] Token category arithmetic correct\n\n### Pre-Deployment (Extended)\n\n- [ ] All inputs are validated\n- [ ] Bounds checking implemented\n- [ ] Overflow protection in place\n- [ ] Access control properly implemented\n- [ ] Time-based logic uses appropriate comparisons\n- [ ] Signature validation follows best practices\n- [ ] Token validation includes all necessary checks\n- [ ] Error cases are handled gracefully\n- [ ] **Output count limited in all functions**\n- [ ] **5-point covenant validation complete**\n- [ ] **Minting authority secured**\n- [ ] **Input positions validated**\n\nFollowing these security practices will help ensure your CashScript contracts are robust and secure when handling real value on the Bitcoin Cash network.",
    "source": "best-practices/security/smart-contract-security.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "Security Checklist Update",
      "Multi-Contract Security",
      "Pre-Deployment (Extended)"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-0",
    "content": "# CashScript Security & Architecture Guide\n\n**Security patterns and multi-contract architecture for production CashScript systems.**\n\n---\n\n## 1. The 5-Point Covenant Validation (MANDATORY)\n\nFor ANY self-replicating covenant, you MUST validate ALL five properties. **Missing ANY creates critical vulnerabilities.**\n\n```cashscript\n// 1. Same contract code (prevents code injection)\nrequire(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n// 2. Same token category (prevents category substitution)\nrequire(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n// 3. Expected satoshi value (prevents value extraction)\nrequire(tx.outputs[0].value == expectedValue);\n\n// 4. Expected token amount (prevents token extraction)\nrequire(tx.outputs[0].tokenAmount == expectedTokenAmount);\n\n// 5. Expected/new state commitment (prevents state manipulation)\nrequire(tx.outputs[0].nftCommitment == newCommitment);\n```\n\n### Common Mistakes\n\n**Missing lockingBytecode check** - attacker can substitute contract:\n```cashscript\n// VULNERABLE\nfunction spend() {\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    // Missing: lockingBytecode check!\n}\n```\n\n**Missing tokenCategory check** - attacker can substitute token:\n```cashscript\n// VULNERABLE\nfunction spend() {\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    // Missing: tokenCategory check!\n}\n```",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "covenant",
      "CashScript Security & Architecture Guide",
      "1. The 5-Point Covenant Validation (MANDATORY)",
      "Common Mistakes"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-1",
    "content": "### Covenant Type Security\n\n| Covenant Type | What MUST Be Validated |\n|--------------|------------------------|\n| Exactly self-replicating | All 5 properties unchanged |\n| State-mutating | 4 properties + valid new state |\n| Balance-mutating | 3 properties + valid new value + valid new state |\n| Conditionally-replicating | Full validation when replicating |\n\n---\n\n## 2. Output Count Security (CRITICAL)",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "Covenant Type Security",
      "2. Output Count Security (CRITICAL)"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-2",
    "content": "## 2. Output Count Security (CRITICAL)\n\n### The Minting Attack\n\n**Vulnerability**: Without output count limits, attackers can add unauthorized outputs to mint tokens.\n\n**Attack Vector**:\n1. Attacker creates a valid transaction satisfying contract constraints\n2. Attacker adds extra outputs minting new tokens or NFTs\n3. Contract validates expected outputs but ignores the extras\n4. Unauthorized tokens enter circulation\n\n### Mandatory Output Limiting\n\n**EVERY contract function MUST limit output count as FIRST validation**:\n\n```cashscript\nfunction anyOperation() {\n    // CRITICAL: ALWAYS include this FIRST\n    require(tx.outputs.length <= 5);\n\n    // ... rest of logic\n}\n```\n\n### Standard Output Limits\n\n| Operation Type | Recommended Limit | Reason |\n|---------------|-------------------|--------|\n| Simple transfer | 3-4 | Input + output + change |\n| Swap/exchange | 5-6 | Multiple participants |\n| Complex DeFi | 7-10 | Multiple contracts + change |\n| Batch operations | 15-20 | Multiple recipients |\n| Maximum | 50 | Transaction size limits |\n\n### Secure Pattern\n\n```cashscript\ncontract SecureContract() {\n    function process() {\n        // FIRST: Limit outputs\n        require(tx.outputs.length <= 5);\n\n        // THEN: Validate specific outputs\n        require(tx.outputs[0].lockingBytecode == expectedBytecode);\n        require(tx.outputs[0].value >= 1000);\n\n        // Even with validation, output limit prevents extra unauthorized outputs\n    }\n}\n```\n\n---\n\n## 3. Multi-Contract Architecture Patterns",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "2. Output Count Security (CRITICAL)",
      "The Minting Attack",
      "Mandatory Output Limiting",
      "Standard Output Limits",
      "Secure Pattern",
      "3. Multi-Contract Architecture Patterns"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-3",
    "content": "## 3. Multi-Contract Architecture Patterns\n\n### Pattern 1: Main+Sidecar\n\n**Problem**: BCH allows only one token category per UTXO output. A contract managing both NFT (state) and fungible tokens cannot hold them in a single UTXO.\n\n**Solution**: Pair every \"main\" contract with a \"sidecar\" that holds additional tokens.\n\n```\n┌─────────────────┐      ┌─────────────────────┐\n│   Main.cash     │      │  MainSidecar.cash   │\n│   (NFT state)   │◄────►│  (fungible tokens)  │\n└─────────────────┘      └─────────────────────┘\n```\n\n**The Attach Pattern** - Sidecar proves it belongs to main contract:\n\n```cashscript\ncontract TokenSidecar() {\n    function attach() {\n        int mainIndex = this.activeInputIndex - 1;\n\n        // CRITICAL: Prove same-transaction origin\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n                tx.inputs[mainIndex].outpointTransactionHash);\n\n        // CRITICAL: Prove sequential output indices\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\n                tx.inputs[mainIndex].outpointIndex + 1);\n\n        // Self-replicate\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\n                tx.inputs[this.activeInputIndex].lockingBytecode);\n        require(tx.outputs[this.activeInputIndex].value == 1000);\n    }\n}\n```\n\n### Pattern 2: Function Contracts\n\n**Problem**: Complex contracts with many functions become hard to maintain and expensive.\n\n**Solution**: Split each logical \"function\" into a separate contract authenticated by NFT commitment bytes.",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "3. Multi-Contract Architecture Patterns",
      "Pattern 1: Main+Sidecar",
      "Pattern 2: Function Contracts"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-4",
    "content": "```\nMainCoordinator.cash\n   │\n   ├── functionA.cash     (NFT commitment prefix: 0x00)\n   ├── functionB.cash     (NFT commitment prefix: 0x01)\n   ├── functionC.cash     (NFT commitment prefix: 0x02)\n   └── functionD.cash     (NFT commitment prefix: 0x03)\n```\n\n**Routing Pattern**:\n\n```cashscript\ncontract MainCoordinator(bytes32 systemTokenId) {\n    function interact(int functionInputIndex) {\n        // Extract function identifier from function contract's NFT\n        bytes functionId = tx.inputs[functionInputIndex].nftCommitment.split(1)[0];\n\n        // Authenticate the function contract\n        require(tx.inputs[functionInputIndex].tokenCategory == systemTokenId + 0x01);\n\n        // Route to appropriate validation\n        if (functionId == 0x00) {\n            require(tx.outputs.length <= 5);\n            // Function A constraints...\n        } else if (functionId == 0x01) {\n            require(tx.outputs.length <= 7);\n            // Function B constraints...\n        }\n    }\n}\n```\n\n### Pattern 3: Strict Input Position\n\n**Rule**: Every contract must know exactly which input index it occupies.\n\n**Why**: Without explicit position validation, attackers could reorder inputs to bypass validation.\n\n```cashscript\nfunction myOperation() {\n    // ALWAYS validate your own position first\n    require(this.activeInputIndex == 2);\n\n    // Define expected positions\n    // Index 0: Price oracle\n    // Index 1: Main contract\n    // Index 2: This function contract (self)\n    // Index 3: User BCH\n\n    // Validate each position\n    require(tx.inputs[0].tokenCategory == oracleCategory + 0x01);\n    require(tx.inputs[1].tokenCategory == mainCategory + 0x01);\n    require(tx.inputs[3].tokenCategory == 0x); // Pure BCH\n\n    // Now safe to use these indices\n}\n```",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "Pattern 3: Strict Input Position"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-5",
    "content": "### Position Documentation Pattern\n\nAlways document input/output positions in function headers:\n\n```cashscript\n//////////////////////////////////////////////////////////////////////////////////////////\n//  Process a redemption operation.\n//\n//inputs:\n//  0   PriceOracle               [NFT]       (from PriceOracle contract)\n//  1   MainContract              [NFT]       (from Main contract)\n//  2   MainSidecar               [NFT]       (from Sidecar contract)\n//  3   redeemFunction            [NFT]       (from Redeem contract - this)\n//  4   userKey                   [NFT]       (from user)\n//  5   feeBCH                    [BCH]       (from fee payer)\n//outputs:\n//  0   PriceOracle               [NFT]       (to PriceOracle contract)\n//  1   MainContract              [NFT]       (to Main contract)\n//  2   MainSidecar               [NFT]       (to Sidecar contract)\n//  3   redeemFunction            [NFT]       (to Redeem contract)\n//  4   userPayment               [BCH]       (to user)\n//////////////////////////////////////////////////////////////////////////////////////////\nfunction redeem() {\n    require(this.activeInputIndex == 3);\n    // ...\n}\n```\n\n---\n\n## 4. Minting Authority Control",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "Position Documentation Pattern",
      "4. Minting Authority Control"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-6",
    "content": "## 4. Minting Authority Control\n\n### The Minting NFT Problem\n\nMinting NFTs (capability `0x02`) can create unlimited tokens. If a minting NFT escapes to an untrusted address, the entire token system is compromised.\n\n### Secure Minting Patterns\n\n**1. Never release minting authority**:\n```cashscript\ncontract MintingController(bytes32 category) {\n    function mint(int amount) {\n        // Verify this contract holds minting NFT\n        require(tx.inputs[0].tokenCategory == category + 0x02);\n\n        // CRITICAL: Keep minting NFT in contract\n        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n        // Never send minting NFT to user addresses\n    }\n}\n```\n\n**2. Downgrade minting to mutable when possible**:\n```cashscript\n// After initial setup, downgrade\nrequire(tx.outputs[0].tokenCategory == category + 0x01); // Mutable only\n```\n\n**3. Burn minting authority when done**:\n```cashscript\n// Send minting NFT to OP_RETURN to destroy it\nrequire(tx.outputs[destroyIdx].lockingBytecode == 0x6a);\nrequire(tx.outputs[destroyIdx].tokenCategory == category + 0x02);\n```\n\n### Origin Proof for Legitimate Creation\n\nWhen minting new NFTs, prove they came from authorized source:\n\n```cashscript\ncontract AuthorizedMinter(bytes32 factoryCategory) {\n    function mint() {\n        // Verify factory is present\n        require(tx.inputs[0].tokenCategory == factoryCategory + 0x02);\n        // New NFTs must be in same transaction as factory\n    }\n}\n```",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int",
      "4. Minting Authority Control",
      "The Minting NFT Problem",
      "Secure Minting Patterns",
      "Origin Proof for Legitimate Creation"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-7",
    "content": "---\n\n## 5. Cross-Contract Trust Model\n\n### Token Category as Identity + Authority\n\nContracts authenticate each other using deterministic category offsets:\n\n```cashscript\nbytes32 systemTokenId = 0x1234...;\n\n// Different contracts/NFTs use offsets:\n// systemTokenId + 0x00 = immutable NFTs\n// systemTokenId + 0x01 = mutable NFTs\n// systemTokenId + 0x02 = minting NFTs\n\n// Validate another contract has minting authority\nrequire(tx.inputs[0].tokenCategory == systemTokenId + 0x02);\n```\n\n### Cross-Contract Authentication\n\n**Rule**: Never trust a contract just because it's in the transaction.\n\n```cashscript\n// INSECURE - trusts any input at position 0\nfunction insecure() {\n    bytes data = tx.inputs[0].nftCommitment;\n    // ... uses data without verification\n}\n\n// SECURE - verifies contract identity before trusting\nfunction secure() {\n    // Verify category and identifier\n    require(tx.inputs[0].tokenCategory == trustedCategory + 0x01);\n    require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00);\n\n    // NOW safe to use data\n    bytes data = tx.inputs[0].nftCommitment.split(1)[1];\n}\n```\n\n### Same-Origin Verification\n\nFor sidecar/main pairs, verify same-transaction origin:\n\n```cashscript\nfunction verifySidecar() {\n    int mainIdx = this.activeInputIndex - 1;\n\n    // CRITICAL: Same transaction hash proves co-creation\n    require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\n            tx.inputs[mainIdx].outpointTransactionHash);\n\n    // CRITICAL: Sequential indices proves ordering\n    require(tx.inputs[this.activeInputIndex].outpointIndex ==\n            tx.inputs[mainIdx].outpointIndex + 1);\n}\n```",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int",
      "5. Cross-Contract Trust Model",
      "Token Category as Identity + Authority",
      "Cross-Contract Authentication",
      "Same-Origin Verification"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-8",
    "content": "---\n\n## 6. State Management Security\n\n### NFT Commitment as Structured State\n\nState is stored as tightly-packed bytes in NFT commitments:\n\n```cashscript\n/*  --- State Mutable NFT (10 items, 27 bytes) ---\n    byte identifier == 0x01\n    bytes6 borrowedTokenAmount (tokens)\n    bytes6 amountBeingRedeemed (tokens)\n    byte status (0x00 newLoan, 0x01 single period, 0x02 mature loan)\n    bytes4 lastPeriodInterestPaid\n    byte2 currentInterestRate\n    byte2 nextInterestRate\n    byte interestManager\n    bytes2 minRateManager\n    bytes2 maxRateManager\n*/\n```\n\n### First Byte as Type Identifier\n\nUse first byte to distinguish contract types sharing same tokenId:\n\n```cashscript\n// Same systemTokenId, different contract types\n0x00 = Price contract\n0x01 = Loan contract\n0x04 = startRedemption function\n0x07 = payInterest function\n\n// Validation\nrequire(tx.inputs[0].nftCommitment.split(1)[0] == 0x00); // Must be price contract\n```\n\n### State Validation\n\n```cashscript\ncontract StateValidator(bytes32 stateHash) {\n    function updateState(bytes oldState, bytes newState) {\n        // Validate old state\n        require(sha256(oldState) == stateHash);\n\n        // Validate state transition\n        require(newState.length == oldState.length);\n        require(newState != oldState);  // State must change\n\n        // Validate new state format\n        require(newState.length >= 32);\n    }\n}\n```\n\n---\n\n## 7. NFT Capability as State Machine",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "6. State Management Security",
      "NFT Commitment as Structured State",
      "First Byte as Type Identifier",
      "State Validation",
      "7. NFT Capability as State Machine"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-9",
    "content": "## 7. NFT Capability as State Machine\n\nToken capabilities encode contract state, not just permissions:\n\n```\nMINTING (0x02)     →    MUTABLE (0x01)      →    IMMUTABLE (0x)\nActive state            Stopped state            Final state\nCan modify freely       Can modify once more     Proof/receipt only\n```\n\n**State transition pattern**:\n```cashscript\n// Downgrade from minting to mutable (stop/cancel campaign)\nrequire(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory.split(32)[0] + 0x01);\n\n// Downgrade from minting to immutable (create receipt)\nrequire(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n\n// Verify state\nbytes category, bytes capability = tx.inputs[1].tokenCategory.split(32);\nrequire(capability == 0x02);  // Must be minting (active)\n```\n\n### Receipt NFT Pattern\n\nImmutable NFTs serve as cryptographic receipts/proofs:\n\n```cashscript\nfunction pledge(int pledgeAmount) {\n    // Create IMMUTABLE receipt NFT (proof of pledge)\n    require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n    require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);  // To user\n    require(tx.outputs[1].value == 1000);  // Dust\n    require(tx.outputs[1].tokenAmount == 0);  // No fungible tokens\n\n    // Receipt contains proof data\n    require(tx.outputs[1].nftCommitment ==\n        bytes6(pledgeAmount) + bytes21(0) + endBlock + bytes4(pledgeID) + campaignID\n    );\n}\n```\n\n---\n\n## 8. Input Position Attacks",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int",
      "7. NFT Capability as State Machine",
      "Receipt NFT Pattern",
      "8. Input Position Attacks"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-10",
    "content": "## 8. Input Position Attacks\n\n### The Attack\n\nWithout position validation, attackers can reorder inputs:\n1. Contract expects input 0 = Oracle, input 1 = Main\n2. Attacker swaps positions: input 0 = Main, input 1 = Oracle\n3. Contract reads wrong data from wrong position\n\n### Defense\n\n```cashscript\nfunction operation() {\n    // ALWAYS validate your own position first\n    require(this.activeInputIndex == 2);\n\n    // ALWAYS validate other contracts at expected positions\n    require(tx.inputs[0].tokenCategory == oracleCategory);\n    require(tx.inputs[1].tokenCategory == mainCategory);\n}\n```\n\n---\n\n## 9. Common Vulnerabilities",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "contract",
      "function",
      "8. Input Position Attacks",
      "The Attack",
      "Defense",
      "9. Common Vulnerabilities"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-11",
    "content": "## 9. Common Vulnerabilities\n\n### 1. Insufficient Input Validation\n\n**Vulnerable**:\n```cashscript\nfunction spend(sig userSig, int amount) {\n    require(checkSig(userSig, owner));\n    // Missing amount validation!\n}\n```\n\n**Secure**:\n```cashscript\nfunction spend(sig userSig, int amount) {\n    require(checkSig(userSig, owner));\n    require(amount > 0);\n    require(amount <= maxAmount);\n}\n```\n\n### 2. Time-Based Vulnerabilities\n\n**Vulnerable**:\n```cashscript\n// WRONG - strict inequality\nrequire(tx.time > lockTime);\n```\n\n**Secure**:\n```cashscript\n// CORRECT - use >=\nrequire(tx.time >= lockTime);\nrequire(lockTime > 0);\n```\n\n### 3. Missing Output Token Validation\n\n**Vulnerable**:\n```cashscript\n// Allows attacker to add tokens to output\nrequire(tx.outputs[0].value == 1000);\n```\n\n**Secure**:\n```cashscript\nrequire(tx.outputs[0].value == 1000);\nrequire(tx.outputs[0].tokenCategory == 0x);  // Pure BCH only\n```\n\n### 4. Overflow in State Counters\n\n**Vulnerable**:\n```cashscript\nint newID = int(currentID) + 1;\nrequire(tx.outputs[0].nftCommitment == bytes4(newID) + rest);\n```\n\n**Secure**:\n```cashscript\nint newID = int(currentID) + 1;\nrequire(newID != 2147483647);  // Check BEFORE using\nrequire(tx.outputs[0].nftCommitment == bytes4(newID) + rest);\n```\n\n---\n\n## 10. Security Checklist",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "mixed",
    "topics": [
      "function",
      "int",
      "9. Common Vulnerabilities",
      "1. Insufficient Input Validation",
      "2. Time-Based Vulnerabilities",
      "3. Missing Output Token Validation",
      "4. Overflow in State Counters",
      "10. Security Checklist"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-12",
    "content": "## 10. Security Checklist\n\n### Pre-Deployment\n\n**Covenant Validation**:\n- [ ] All 5 properties validated for self-replicating contracts\n- [ ] Correct capability flags checked (0x01 mutable, 0x02 minting)\n- [ ] NFT commitment structure validated (first byte identifier)\n\n**Authority**:\n- [ ] All input contracts authenticated via tokenCategory\n- [ ] Position indices enforced with `this.activeInputIndex`\n- [ ] No unauthorized tokens can be created\n\n**Minting Protection**:\n- [ ] Output count limited in ALL functions\n- [ ] Each output's tokenCategory validated\n- [ ] Change outputs restricted to BCH-only or known tokens\n\n**State**:\n- [ ] State byte layouts documented\n- [ ] All state transitions validated\n- [ ] No state can be corrupted by invalid input\n\n**Value**:\n- [ ] BCH values validated (minimum 1000 sats typically)\n- [ ] Value changes calculated correctly\n- [ ] No value can leak\n\n**Time**:\n- [ ] Locktime uses `>=` not `>`\n- [ ] `this.age` used for relative locks (blocks only)\n\n**Edge Cases**:\n- [ ] Division by zero prevented\n- [ ] Minimum amounts enforced\n- [ ] Partial operations handled correctly\n\n### Testing\n\n- [ ] Unit tests cover all functions\n- [ ] Boundary conditions tested\n- [ ] Attack vectors simulated\n- [ ] Integration tests with real transactions\n\n### Production\n\n- [ ] Code audited by security experts\n- [ ] Deployed on testnet first\n- [ ] Monitoring in place\n- [ ] Emergency procedures documented\n\n---\n\n## 11. Deployment Checklist",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "10. Security Checklist",
      "Pre-Deployment",
      "Testing",
      "Production",
      "11. Deployment Checklist"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-13",
    "content": "## 11. Deployment Checklist\n\nWhen deploying a multi-contract system:\n\n1. **Deploy all contracts** - Get P2SH32 addresses\n2. **Create token category** - Genesis transaction\n3. **Hardcode addresses** - Embed in source where needed\n4. **Recompile** - With embedded addresses\n5. **Redeploy** - Final deployment with trust anchors\n6. **Mint system NFTs** - Create master/function/sidecar NFTs\n7. **Initialize positions** - Send NFTs to their contracts\n8. **Test transactions** - Verify all positions work\n\n**Critical Note**: Contracts are **immutable after deployment**. All inter-contract addresses must be correct at compile time.\n\n---\n\n## Quick Reference Links",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "11. Deployment Checklist",
      "Quick Reference Links"
    ]
  },
  {
    "id": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md-14",
    "content": "## Quick Reference Links\n\n- **Core Language Reference**: See `CORE_REFERENCE.md`\n- **FAQ & Troubleshooting**: See `FAQ_DISTILLED.md`",
    "source": "Knowledge-Base-V2/SECURITY_ARCHITECTURE.md",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "Quick Reference Links"
    ]
  },
  {
    "id": "NexKB/security_rules.json-0",
    "content": "[\r\n  {\r\n    \"id\": \"SEC-001\",\r\n    \"category\": \"covenant\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"ALL self-replicating covenants MUST validate all 5 properties: lockingBytecode, tokenCategory, value, tokenAmount, and nftCommitment\",\r\n    \"description\": \"Missing ANY of the 5-point validation creates critical vulnerabilities allowing code injection, category substitution, value extraction, token extraction, or state manipulation\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-002\",\r\n    \"category\": \"general\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"EVERY contract function MUST limit output count as FIRST validation\",\r\n    \"description\": \"Without output count limits, attackers can add unauthorized outputs to mint tokens. Use require(tx.outputs.length <= N) as the first line in every function\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-003\",\r\n    \"category\": \"minting\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Minting NFTs (capability 0x02) must NEVER be released to untrusted addresses\",\r\n    \"description\": \"If a minting NFT escapes to an untrusted address, the entire token system is compromised. Always keep minting authority in contract or burn it\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-004\",\r\n    \"category\": \"covenant\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Validate lockingBytecode equality to prevent code injection: require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode)\",\r\n    \"description\": \"Without lockingBytecode check, attacker can substitute a different contract while preserving other properties\"",
    "source": "NexKB/security_rules.json",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant"
    ]
  },
  {
    "id": "NexKB/security_rules.json-1",
    "content": "},\r\n  {\r\n    \"id\": \"SEC-005\",\r\n    \"category\": \"covenant\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Validate tokenCategory equality to prevent category substitution: require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory)\",\r\n    \"description\": \"Without tokenCategory check, attacker can substitute a different token category\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-006\",\r\n    \"category\": \"multi-contract\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Every contract must validate its own input position using this.activeInputIndex\",\r\n    \"description\": \"Without explicit position validation, attackers can reorder inputs to bypass validation logic\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-007\",\r\n    \"category\": \"multi-contract\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Sidecar contracts must prove same-transaction origin using outpointTransactionHash and sequential outpointIndex\",\r\n    \"description\": \"Prevents attacker from pairing main contract with unauthorized sidecar from different transaction\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-008\",\r\n    \"category\": \"authentication\",\r\n    \"severity\": \"critical\",\r\n    \"rule\": \"Never trust a contract just because it's in the transaction - always verify tokenCategory and identifier\",\r\n    \"description\": \"Validate category and identifier before trusting data from other contracts\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-009\",\r\n    \"category\": \"time\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Use >= for time comparisons, not >. Always validate lockTime > 0\",\r\n    \"description\": \"Strict inequality (>) creates edge case vulnerabilities at exact locktime boundaries\"",
    "source": "NexKB/security_rules.json",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/security_rules.json-2",
    "content": "},\r\n  {\r\n    \"id\": \"SEC-010\",\r\n    \"category\": \"validation\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Always validate input parameters: amounts > 0, amounts <= maxAmount, data.length > 0, data.length <= maxLength\",\r\n    \"description\": \"Never trust function arguments - validate everything to prevent unexpected behavior\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-011\",\r\n    \"category\": \"state\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Use first byte of NFT commitment as type identifier to distinguish contract types sharing same tokenId\",\r\n    \"description\": \"Enables multiple contract types to share a token category while maintaining type safety\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-012\",\r\n    \"category\": \"overflow\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Check for overflow before using incremented counters: require(newID != 2147483647)\",\r\n    \"description\": \"Prevents state corruption from integer overflow in counters and IDs\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-013\",\r\n    \"category\": \"tokens\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Validate output tokenCategory to prevent unauthorized token attachment: require(tx.outputs[0].tokenCategory == 0x) for BCH-only outputs\",\r\n    \"description\": \"Without token validation, attacker can attach tokens to outputs that should be pure BCH\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-014\",\r\n    \"category\": \"minting\",\r\n    \"severity\": \"high\",\r\n    \"rule\": \"Downgrade minting NFT to mutable (0x01) after setup, or burn to OP_RETURN (0x6a) when done\",\r\n    \"description\": \"Reduces attack surface by removing minting capability when no longer needed\"",
    "source": "NexKB/security_rules.json",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function"
    ]
  },
  {
    "id": "NexKB/security_rules.json-3",
    "content": "},\r\n  {\r\n    \"id\": \"SEC-015\",\r\n    \"category\": \"general\",\r\n    \"severity\": \"medium\",\r\n    \"rule\": \"Document input/output positions in function headers with explicit position mapping\",\r\n    \"description\": \"Improves code maintainability and helps prevent position-related bugs\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-016\",\r\n    \"category\": \"validation\",\r\n    \"severity\": \"medium\",\r\n    \"rule\": \"Validate state transitions: require(newState.length == oldState.length) and require(newState != oldState)\",\r\n    \"description\": \"Ensures state changes are intentional and maintain expected format\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-017\",\r\n    \"category\": \"cryptography\",\r\n    \"severity\": \"medium\",\r\n    \"rule\": \"Validate preimage length before hashing: require(preimage.length > 0 && preimage.length <= 1024)\",\r\n    \"description\": \"Prevents null byte attacks and excessive resource consumption\"\r\n  },\r\n  {\r\n    \"id\": \"SEC-018\",\r\n    \"category\": \"bitwise\",\r\n    \"severity\": \"medium\",\r\n    \"rule\": \"Use bytes types for bitwise operations (&, |, ^), NOT int. Validate shift amounts: require(shiftAmount >= 0 && shiftAmount <= 64)\",\r\n    \"description\": \"CashScript only supports bitwise operators on bytes types. Invalid shift amounts cause unexpected results\"\r\n  }\r\n]",
    "source": "NexKB/security_rules.json",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-0",
    "content": "// ANTI-PATTERN: Fee Assumption Violation\n// VULNERABILITY: Incorrect fee assumptions enable value extraction and invariant bypass\n// ATTACK VECTOR: Fee subsidy, value hiding, covenant economics manipulation, free tx building\n//\n// This file demonstrates the critical vulnerability of making assumptions about\n// transaction fees in covenant contracts. Covenants cannot reliably reason about\n// fees because attackers control which inputs are included. Fee assumptions lead\n// to value extraction, invariant violations, and covenant economics bypass.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Assumed Fixed Fee\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract assumes fee = inputValue - outputValue\n// RISK: Multi-input transactions allow fee subsidy and value extraction\ncontract VulnerableCovenantAssumedFee(\n    pubkey ownerPubKey,\n    int minimumValue  // Minimum covenant value to maintain\n) {\n    // VULNERABILITY: Assumes transaction fee comes from THIS covenant input only\n    // MISSING: Recognition that fees can be paid by OTHER inputs\n    // MISSING: Understanding that multi-input txs break fee assumptions\n    // MISSING: tx.outputs.length validation\n    // Attacker can hide value in extra outputs\n    function spend(sig ownerSig, int outputValue) {",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-1",
    "content": "// Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Get input value from this covenant\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        \n        // CRITICAL FLAW: Assumes fee is paid from this input\n        // Calculates: fee = inputValue - outputValue\n        int assumedFee = inputValue - outputValue;\n        \n        // Validates fee is \"reasonable\" (e.g., <= 1000 sats)\n        require(assumedFee >= 0);\n        require(assumedFee <= 1000);\n        \n        // Validates covenant maintains minimum value\n        require(outputValue >= minimumValue);\n        \n        // THE PROBLEM:\n        // This logic assumes: Total Fee = inputValue - outputValue\n        // \n        // Reality in multi-input transactions:\n        // Total Fee = (SUM all inputs) - (SUM all outputs)\n        //\n        // Attacker can:\n        // 1. Add their own input with extra value\n        // 2. Pay the ENTIRE fee from their input\n        // 3. Covenant input value = Covenant output value (no fee from covenant)\n        // 4. Contract sees: assumedFee = 0 (passes check)\n        // 5. Actual transaction fee = 1000 sats (paid by attacker)\n        //\n        // This breaks the assumption that covenant pays its own fees\n    }\n}\n\n// ============================================================================\n// UNDERSTANDING THE VULNERABILITY: How BCH Fees Work\n// ============================================================================",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-2",
    "content": "//\n// CRITICAL CONCEPT: Transaction Fee Calculation\n// ----------------------------------------------\n//\n// BCH Transaction Structure:\n// Inputs:  [Input0: 10,000 sats, Input1: 5,000 sats, Input2: 3,000 sats]\n// Outputs: [Output0: 8,000 sats, Output1: 9,500 sats]\n// \n// Fee Calculation:\n// Total Inputs  = 10,000 + 5,000 + 3,000 = 18,000 sats\n// Total Outputs = 8,000 + 9,500 = 17,500 sats\n// Fee = Total Inputs - Total Outputs = 18,000 - 17,500 = 500 sats\n//\n// Key Properties:\n// 1. Fee is TRANSACTION-WIDE (not per-input)\n// 2. ANY input can contribute to fee\n// 3. Fee can be paid entirely by non-covenant inputs\n// 4. Covenant cannot determine which input paid the fee\n//\n// COVENANT PERSPECTIVE (limited view):\n// - Covenant can see: tx.inputs[this.activeInputIndex].value (its own input)\n// - Covenant can see: tx.outputs[N].value (all outputs)\n// - Covenant CANNOT see: Total of all other inputs\n// - Covenant CANNOT calculate: Actual transaction fee\n//\n// Why Covenants Can't Calculate Fees:\n// - No access to SUM(all input values)\n// - Can only read own input value\n// - Can read all output values\n// - But cannot determine: \"How much did OTHER inputs contribute?\"\n//\n// THE DANGEROUS ASSUMPTION:\n// Many covenants assume: \"My input value - My output value = Fee I'm paying\"\n// This is ONLY true if: Transaction has exactly 1 input (the covenant)\n// This is FALSE if: Transaction has multiple inputs (very common)\n\n// ============================================================================",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-3",
    "content": "// ATTACK SCENARIO 1: Fee Subsidy for Value Extraction\n// ============================================================================\n//\n// Setup:\n// - Covenant holds 10,000 sats (minimum required: 5,000 sats)\n// - Contract allows withdrawals as long as minimumValue maintained\n// - Contract assumes fee is deducted from covenant input\n// - Expected fee: ~200 sats\n//\n// Vulnerable Logic:\n//   int inputValue = 10,000;\n//   int outputValue = 5,000;  // Maintain minimum\n//   int assumedFee = inputValue - outputValue = 5,000;\n//   require(assumedFee <= 1000);  // FAILS - too high\n//\n// This prevents direct extraction of 5,000 sats (fee limit blocks it)\n//\n// ATTACK: Fee Subsidy to Bypass Limit\n// Inputs:\n//   [0] Covenant UTXO (10,000 sats)\n//   [1] Attacker's UTXO (5,200 sats) ← Attacker adds this\n//\n// Outputs:\n//   [0] Covenant continuation (5,000 sats) ← Maintains minimum\n//   [1] To attacker (10,000 sats) ← Withdrawal\n//\n// Fee: 200 sats (10,000 + 5,200 - 5,000 - 10,000 = 200)\n//\n// Covenant's View:\n//   inputValue (covenant) = 10,000\n//   outputValue (covenant continuation) = 5,000\n//   assumedFee = 10,000 - 5,000 = 5,000\n//   Check: assumedFee <= 1000? → FAILS\n//\n// Wait, attack should fail? Let's reconsider...\n//\n// ACTUAL ATTACK: Zero-Fee from Covenant Perspective\n// Inputs:\n//   [0] Covenant UTXO (10,000 sats)\n//   [1] Attacker's UTXO (200 sats) ← Just enough for fee\n//\n// Outputs:\n//   [0] Covenant continuation (10,000 sats) ← SAME as input\n//   [1] To attacker (0 sats) ← Dust or omitted",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-4",
    "content": "//\n// Fee: 200 sats (paid entirely by Input[1])\n//\n// Covenant's View:\n//   inputValue = 10,000\n//   outputValue = 10,000\n//   assumedFee = 0\n//   Check: assumedFee <= 1000? → PASSES ✓\n//\n// Result:\n// - Covenant sees no fee deduction (input = output)\n// - Attacker paid the entire 200 sat fee\n// - Covenant transaction used as free transaction builder\n// - Attacker can batch multiple operations without covenant paying fees\n//\n// Impact:\n// - Covenant economics broken (supposed to pay own fees)\n// - Attacker gets free transaction building\n// - Fee budget assumptions violated\n\n// ============================================================================\n// ATTACK SCENARIO 2: Hidden Value Extraction via Fee Subsidy\n// ============================================================================\n//\n// Setup:\n// - Vault covenant holds 100,000 sats\n// - Allows partial withdrawals with fee deduction\n// - Validates: withdrawalAmount + fee <= inputValue - minimumBalance\n// - Minimum balance: 50,000 sats\n// - Maximum withdrawal calculated as: 100,000 - 50,000 - 1000 (fee) = 49,000 sats\n//\n// Vulnerable Contract:\n//\n// contract VulnerableVault(pubkey ownerPubKey, int minBalance) {\n//     function withdraw(sig ownerSig, int withdrawalAmount) {\n//         require(checkSig(ownerSig, ownerPubKey));\n//         int inputValue = tx.inputs[this.activeInputIndex].value;\n//         int outputValue = tx.outputs[0].value;\n//         int assumedFee = inputValue - outputValue - withdrawalAmount;\n//",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-5",
    "content": "//         // Validates fee is reasonable\n//         require(assumedFee >= 100);\n//         require(assumedFee <= 1000);\n//         \n//         // Validates minimum balance maintained\n//         require(outputValue >= minBalance);\n//         \n//         // Output[1] is withdrawal to user\n//         require(tx.outputs[1].value == withdrawalAmount);\n//     }\n// }\n//\n// Legitimate Withdrawal:\n// Inputs:\n//   [0] Vault (100,000 sats)\n// Outputs:\n//   [0] Vault continuation (50,000 sats)\n//   [1] Withdrawal (49,000 sats)\n// Fee: 1,000 sats\n//\n// Covenant's view:\n//   inputValue = 100,000\n//   outputValue = 50,000\n//   withdrawalAmount = 49,000\n//   assumedFee = 100,000 - 50,000 - 49,000 = 1,000 ✓\n//\n// ATTACK: Extract More by Subsidizing Fee\n// Inputs:\n//   [0] Vault (100,000 sats)\n//   [1] Attacker (1,000 sats) ← Fee subsidy\n//\n// Outputs:\n//   [0] Vault continuation (50,000 sats)\n//   [1] Withdrawal (50,000 sats) ← 1,000 more than limit!\n//\n// Actual Fee: 1,000 sats (100,000 + 1,000 - 50,000 - 50,000)\n//\n// Covenant's View:\n//   inputValue = 100,000\n//   outputValue = 50,000\n//   withdrawalAmount = 50,000\n//   assumedFee = 100,000 - 50,000 - 50,000 = 0\n//   Check: 0 >= 100? → FAILS\n//\n// Hmm, this fails. Need different approach...\n//\n// ACTUAL ATTACK: Hide Value in Fee Budget\n// Inputs:\n//   [0] Vault (100,000 sats)\n//   [1] Attacker (10,000 sats) ← Large subsidy\n//\n// Outputs:\n//   [0] Vault continuation (50,000 sats)\n//   [1] Withdrawal (49,000 sats)\n//   [2] To attacker (10,000 sats) ← Subsidy returned",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-6",
    "content": "//\n// Fee: 1,000 sats\n//\n// If contract only validates outputs[0] and outputs[1]:\n//   assumedFee = 100,000 - 50,000 - 49,000 = 1,000 ✓\n//\n// But outputs[2] exists (attacker's refund)\n// Covenant used attacker's transaction for free\n// Attacker got free transaction building\n\n// ============================================================================\n// ATTACK SCENARIO 3: Covenant as Free Transaction Builder\n// ============================================================================\n//\n// Setup:\n// - Time-locked covenant (releases after certain time)\n// - User wants to batch multiple operations in one transaction\n// - Covenant validates basic properties but assumes fee\n//\n// Vulnerable Time Lock:\n//\n// contract VulnerableTimeLock(pubkey beneficiaryPubKey, int unlockTime) {\n//     function unlock(sig beneficiarySig) {\n//         require(checkSig(beneficiarySig, beneficiaryPubKey));\n//         require(tx.time >= unlockTime);\n//         \n//         // Validates covenant continues with same value\n//         int inputValue = tx.inputs[this.activeInputIndex].value;\n//         int outputValue = tx.outputs[0].value;\n//         int assumedFee = inputValue - outputValue;\n//         require(assumedFee <= 500);  // Max 500 sat fee\n//         \n//         // MISSING: Output count validation\n//         // MISSING: Recognition of multi-input scenario\n//     }\n// }\n//\n// ATTACK: Free Transaction Building\n// User wants to:\n// 1. Unlock time-locked funds (1,000,000 sats)\n// 2. Consolidate 5 other UTXOs (500,000 sats total)",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-7",
    "content": "// 3. Pay for something (300,000 sats)\n//\n// Single Transaction:\n// Inputs:\n//   [0] Time-locked covenant (1,000,000 sats)\n//   [1] User UTXO 1 (100,000 sats)\n//   [2] User UTXO 2 (100,000 sats)\n//   [3] User UTXO 3 (100,000 sats)\n//   [4] User UTXO 4 (100,000 sats)\n//   [5] User UTXO 5 (100,000 sats)\n//   [6] User UTXO 6 (1,000 sats) ← For fee\n//\n// Outputs:\n//   [0] Covenant release (1,000,000 sats) ← Same as input\n//   [1] Payment (300,000 sats)\n//   [2] Consolidation (800,000 sats)\n//\n// Fee: 1,000 sats (paid by input[6])\n//\n// Covenant's View:\n//   inputValue = 1,000,000\n//   outputValue = 1,000,000\n//   assumedFee = 0\n//   Check: 0 <= 500? → PASSES ✓\n//\n// Result:\n// - Covenant validates successfully\n// - User batched 6 inputs + covenant operation\n// - Fee paid entirely by user input[6]\n// - Covenant transaction used to consolidate UTXOs\n// - User saved on fees (single tx vs multiple txs)\n//\n// Problem:\n// - Covenant assumed it pays fees\n// - Actually paid zero fees\n// - Used as transaction vehicle for unrelated operations\n// - Fee economics completely bypassed\n\n// ============================================================================\n// ATTACK SCENARIO 4: Fee-Based Invariant Bypass\n// ============================================================================\n//\n// Setup:\n// - AMM-style covenant maintaining ratio invariant\n// - Validates: outputValue >= inputValue - maxSlippage\n// - maxSlippage = 1% = 100 sats per 10,000 sats\n// - Assumes small fee deduction is acceptable",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-8",
    "content": "//\n// Vulnerable AMM:\n//\n// contract VulnerableAMM(pubkey lpPubKey, int maxSlippage) {\n//     function swap(sig lpSig, int expectedOutput) {\n//         require(checkSig(lpSig, lpPubKey));\n//         \n//         int inputValue = tx.inputs[this.activeInputIndex].value;\n//         \n//         // Validates output maintains value within slippage\n//         require(tx.outputs[0].value >= inputValue - maxSlippage);\n//         \n//         // Assumes fee is part of slippage budget\n//         // Fee + slippage <= maxSlippage\n//     }\n// }\n//\n// ATTACK: Hide Value Extraction in Fee\n// Inputs:\n//   [0] AMM covenant (10,000 sats)\n//   [1] Attacker (0 sats) ← Empty input (if allowed by protocol)\n//\n// Outputs:\n//   [0] AMM continuation (9,900 sats) ← Lost 100 sats\n//   [1] To attacker (0 sats)\n//\n// Fee: 100 sats (10,000 - 9,900)\n//\n// Covenant's View:\n//   inputValue = 10,000\n//   outputValue = 9,900\n//   slippage = 100\n//   Check: 9,900 >= 10,000 - 100? → PASSES ✓\n//\n// This attack works even if \"fee\" is intended,\n// because the contract cannot distinguish fee vs extraction.\n//\n// Repeat Attack:\n// After 100 iterations:\n// - AMM value: 10,000 → 0 sats (drained via \"fees\")\n// - Each tx: 100 sat \"fee\" (actually value extraction)\n// - Total extracted: 10,000 sats\n// - All disguised as legitimate fee payments\n//\n// Result:\n// - Covenant slowly drained\n// - Extraction hidden in fee allowance\n// - Appears as normal fee variance\n// - Economic invariant violated\n\n// ============================================================================",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-9",
    "content": "// SECURE VERSION: No Fee Assumptions\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract does NOT make assumptions about transaction fees\n// PROTECTION: Prevents fee-based value extraction and invariant bypass\ncontract SecureCovenantNoFeeAssumptions(\n    pubkey ownerPubKey,\n    int minimumValue\n) {\n    // SECURE: Validates value conservation without assuming fee behavior\n    function spend(sig ownerSig) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 1 input\n        // This is the KEY to safe fee handling\n        // With single input, we KNOW all fee comes from this input\n        // But this is very restrictive (no multi-input support)\n        // See alternative patterns below for multi-input cases\n        //\n        // NOTE: CashScript doesn't provide tx.inputs.length directly\n        // This pattern is conceptual - in practice, design around\n        // single-input assumptions or avoid fee reasoning entirely\n        \n        // Step 3: Read input value\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        \n        // Step 4: Read output value\n        int outputValue = tx.outputs[0].value;\n        \n        // Step 5: CRITICAL - Enforce exactly 1 output\n        // Prevents value splitting/hiding\n        require(tx.outputs.length == 1);\n        \n        // Step 6: SECURE PATTERN - Validate minimum value maintained",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-10",
    "content": "// Do NOT calculate fee\n        // Do NOT validate fee amount\n        // Simply ensure output meets minimum\n        require(outputValue >= minimumValue);\n        \n        // Step 7: OPTIONAL - Validate value decrease is bounded\n        // This limits maximum fee without assuming specific amount\n        int maxValueDecrease = 10000;  // Maximum 10,000 sat reduction\n        require(outputValue >= inputValue - maxValueDecrease);\n        \n        // RESULT: Safe value validation without fee assumptions\n        // - Doesn't calculate \"fee\"\n        // - Doesn't assume who pays fee\n        // - Validates output meets minimum\n        // - Bounds value decrease (includes fee + any extraction)\n        // - Works with single-input transactions\n        //\n        // Limitations:\n        // - Restrictive (single input/output)\n        // - Doesn't support multi-input batching\n        // - But SECURE against fee-based attacks\n    }\n}\n\n// ============================================================================\n// ALTERNATIVE PATTERN: Explicit Value Conservation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ALTERNATIVE: Enforce exact value conservation (zero fee from covenant)\n// USE CASE: Covenants where fees are externally subsidized\ncontract SecureCovenantValueConservation(\n    pubkey ownerPubKey\n) {\n    // Pattern: Input value MUST equal output value (no fee deduction)\n    function spend(sig ownerSig) {\n        // Step 1: Validate authorization",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-11",
    "content": "require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Enforce single output\n        require(tx.outputs.length == 1);\n        \n        // Step 3: Read values\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        int outputValue = tx.outputs[0].value;\n        \n        // Step 4: CRITICAL - Enforce exact value conservation\n        // Fee MUST be paid by other inputs (not this covenant)\n        require(outputValue == inputValue);\n        \n        // Step 5: Validate covenant continuation\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);\n        \n        // RESULT: Zero fee from covenant\n        // - Input value = Output value (exactly)\n        // - Transaction fee MUST come from other inputs\n        // - Covenant preserves full value\n        // - User/attacker pays all fees\n        //\n        // This pattern is SAFE because:\n        // - No fee assumptions\n        // - No value extraction possible\n        // - Covenant value fully preserved\n        //\n        // Use when:\n        // - Covenant should never pay fees\n        // - External wallet/user subsidizes fees\n        // - Value preservation is critical\n    }\n}\n\n// ============================================================================\n// BEST PRACTICE: Bounded Value Loss (Conservative)\n// ============================================================================\n\npragma cashscript ^0.13.0;",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-12",
    "content": "// BEST PRACTICE: Allow value decrease but bound it conservatively\n// Does not assume why value decreases (fee, extraction, etc.)\ncontract SecureCovenantBoundedValueLoss(\n    pubkey ownerPubKey,\n    int minimumValue,\n    int maxValueDecrease  // Maximum allowed decrease per transaction\n) {\n    // Pattern: Limit value loss without assuming it's all fee\n    function spend(sig ownerSig) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Enforce single output\n        require(tx.outputs.length == 1);\n        \n        // Step 3: Read values\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        int outputValue = tx.outputs[0].value;\n        \n        // Step 4: Validate minimum value maintained\n        require(outputValue >= minimumValue);\n        \n        // Step 5: CRITICAL - Bound value decrease\n        // Does NOT assume decrease is \"fee\"\n        // Simply limits how much value can be lost\n        // Could be: fee + extraction + other factors\n        int actualDecrease = inputValue - outputValue;\n        require(actualDecrease <= maxValueDecrease);\n        require(actualDecrease >= 0);  // Prevent negative (increase OK)\n        \n        // Step 6: Validate covenant continuation\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);\n        \n        // RESULT: Conservative value protection\n        // - Minimum value enforced",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-13",
    "content": "// - Maximum decrease bounded\n        // - No assumptions about WHY value decreases\n        // - Safe against fee-based extraction\n        //\n        // This is SECURE because:\n        // - Doesn't try to calculate \"fee\"\n        // - Doesn't assume fee source\n        // - Simply bounds total value loss\n        // - Attacker cannot extract more than maxValueDecrease\n        //\n        // Recommended values:\n        // - maxValueDecrease = 1000-5000 sats (typical fee range)\n        // - Adjust based on expected transaction complexity\n        // - Higher = more flexible, but more extraction risk\n        // - Lower = more restrictive, but more secure\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Covenants Can't Reason About Fees\n// ============================================================================\n\n// FUNDAMENTAL LIMITATION: Covenant's Limited View\n// ------------------------------------------------\n// What covenant CAN see:\n// ✓ tx.inputs[this.activeInputIndex].value (own input value)\n// ✓ tx.inputs[this.activeInputIndex].* (all own input properties)\n// ✓ tx.outputs[N].value (all output values)\n// ✓ tx.outputs[N].* (all output properties)\n// ✓ tx.outputs.length (number of outputs)\n//\n// What covenant CANNOT see:\n// ✗ tx.inputs[0].value (other input values)\n// ✗ tx.inputs[1].value (other input values)\n// ✗ Number of inputs (tx.inputs.length is NOT available)\n// ✗ Sum of all input values\n// ✗ Which input contributed to fee",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-14",
    "content": "// ✗ How fee is distributed across inputs\n//\n// Fee Calculation Reality:\n// Fee = (Sum of ALL inputs) - (Sum of ALL outputs)\n//\n// Covenant's Calculation Attempt:\n// \"Fee\" = (My input) - (Sum of outputs)\n// This is WRONG if other inputs exist!\n//\n// Example:\n// Inputs: [Covenant: 10,000, User: 1,000]\n// Outputs: [Covenant: 10,000, User: 500]\n// Actual Fee: (10,000 + 1,000) - (10,000 + 500) = 500\n// Covenant's \"Fee\": 10,000 - 10,500 = -500 (negative?!)\n//\n// The covenant cannot determine:\n// - How much the user input contributed\n// - Whether fee came from user or covenant\n// - Actual transaction fee amount\n\n// WHY \"FEE = INPUT - OUTPUT\" IS DANGEROUS\n// ---------------------------------------\n// Single-Input Transaction:\n// Input: 10,000\n// Output: 9,500\n// Fee = 10,000 - 9,500 = 500 ✓ Correct\n//\n// Multi-Input Transaction:\n// Input[0] (Covenant): 10,000\n// Input[1] (User): 1,000\n// Output[0]: 10,500\n// Output[1]: 0\n// Fee = (10,000 + 1,000) - (10,500 + 0) = 500 ✓ Correct\n//\n// Covenant's Wrong Calculation:\n// \"Fee\" = 10,000 - 10,500 = -500 ✗ Wrong!\n//\n// Covenant thinks: \"Output > Input? Impossible!\"\n// Reality: Other input subsidized the difference\n//\n// This breaks ALL fee-based logic:\n// - Fee limit checks (become meaningless)\n// - Value conservation checks (break with multi-input)\n// - Economic models (assume wrong fee amounts)\n\n// THE MULTI-INPUT PROBLEM\n// ------------------------\n// Bitcoin Cash allows:\n// - Arbitrary number of inputs\n// - Arbitrary number of outputs\n// - Arbitrary distribution of value",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-15",
    "content": "//\n// Only constraint: Total In >= Total Out\n//\n// Covenant cannot prevent:\n// - User adding inputs\n// - User subsidizing fees\n// - User paying ALL fees\n// - User extracting value via other outputs\n//\n// Covenant can only control:\n// - ITS OWN output properties\n// - Output count (if validated)\n// - Which outputs exist\n//\n// Covenant CANNOT control:\n// - Total number of inputs\n// - Other inputs' values\n// - How fee is distributed\n//\n// Therefore: Covenants should NOT reason about fees\n\n// SAFE DESIGN PATTERNS\n// --------------------\n// Pattern 1: Exact Value Conservation\n//   require(outputValue == inputValue);\n//   - Covenant pays NO fee\n//   - Fee must come from other inputs\n//   - Value fully preserved\n//\n// Pattern 2: Bounded Value Decrease\n//   require(outputValue >= inputValue - maxDecrease);\n//   - Allow some value loss\n//   - Don't assume it's all fee\n//   - Could be fee + extraction\n//   - Bound total loss conservatively\n//\n// Pattern 3: Minimum Value Only\n//   require(outputValue >= minimumValue);\n//   - Ensure output meets minimum\n//   - Don't track fee at all\n//   - Don't limit value decrease\n//   - Simplest and often sufficient\n//\n// Pattern 4: No Value Validation\n//   - Don't validate value at all\n//   - Only validate other properties\n//   - Let user manage value\n//   - Appropriate for some use cases\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR FEE HANDLING\n// ============================================================================",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-16",
    "content": "// PRINCIPLE 1: AVOID FEE REASONING IN COVENANTS\n// ----------------------------------------------\n// Covenants should NOT:\n// - Calculate transaction fee\n// - Assume fee source\n// - Validate fee amount\n// - Use fee in economic models\n//\n// Instead:\n// - Validate value requirements directly\n// - Bound value changes conservatively\n// - Assume fees are externally handled\n\n// PRINCIPLE 2: USE EXACT CONSERVATION OR BOUNDED LOSS\n// ----------------------------------------------------\n// Safe patterns:\n// - require(outputValue == inputValue)  // Exact\n// - require(outputValue >= inputValue - maxDecrease)  // Bounded\n//\n// Unsafe patterns:\n// - int fee = inputValue - outputValue  // Wrong with multi-input\n// - require(fee <= maxFee)  // Meaningless with multi-input\n\n// PRINCIPLE 3: ENFORCE SINGLE OUTPUT (IF VALIDATING VALUE)\n// ---------------------------------------------------------\n// If validating value properties:\n//   require(tx.outputs.length == 1);\n// This prevents:\n// - Value hiding in other outputs\n// - Fee obfuscation via output splitting\n// - Extraction via unvalidated outputs\n\n// PRINCIPLE 4: DOCUMENT FEE EXPECTATIONS EXTERNALLY\n// --------------------------------------------------\n// Don't encode fee logic in contract\n// Instead:\n// - Document in UI/docs who pays fees\n// - Wallet handles fee calculation\n// - Contract validates only value requirements\n// - Keep contract logic simple\n\n// PRINCIPLE 5: CONSERVATIVE BOUNDS\n// ---------------------------------\n// If you must allow value decrease:",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-17",
    "content": "// - Set maxDecrease conservatively (1000-5000 sats)\n// - Assume worst case (all decrease is extraction)\n// - Don't optimize for \"typical\" fees\n// - Better too restrictive than too permissive\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Calculating Fee as Input - Output\n// ---------------------------------------------\n// WRONG:\n//   int inputValue = tx.inputs[this.activeInputIndex].value;\n//   int outputValue = tx.outputs[0].value;\n//   int fee = inputValue - outputValue;\n//   require(fee <= 1000);\n//\n// WHY WRONG:\n// - Only works with single-input transactions\n// - Breaks with multi-input (attacker adds inputs)\n// - Can become negative (if other inputs contribute)\n// - Meaningless value\n//\n// CORRECT:\n//   int inputValue = tx.inputs[this.activeInputIndex].value;\n//   int outputValue = tx.outputs[0].value;\n//   int valueDecrease = inputValue - outputValue;\n//   require(valueDecrease <= maxAllowedDecrease);\n//   // Don't call it \"fee\" - it's \"value decrease\"\n//   // Bound total value decrease (regardless of cause)\n//   // Includes fees, extraction, or any other loss\n\n// MISTAKE 2: Assuming Fee is \"Small\" or \"Negligible\"\n// ---------------------------------------------------\n// WRONG:\n//   // \"Fee is small, doesn't matter\"\n//   require(outputValue >= minimumValue);\n//   // No value decrease limit\n//\n// WHY WRONG:",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-18",
    "content": "// - Attacker can extract arbitrary amounts\n// - \"Small fee\" assumption exploited\n// - Value drained over multiple transactions\n//\n// CORRECT:\n//   require(outputValue >= minimumValue);\n//   int maxDecrease = 5000;  // Be explicit about \"small\"\n//   require(outputValue >= inputValue - maxDecrease);\n\n// MISTAKE 3: Not Enforcing Output Count\n// --------------------------------------\n// WRONG:\n//   require(tx.outputs[0].value >= minimumValue);\n//   // outputs[1], [2], [3] could exist\n//\n// WHY WRONG:\n// - Value can hide in other outputs\n// - Fee calculation assumptions break\n// - Attacker creates multiple outputs\n//\n// CORRECT:\n//   require(tx.outputs.length == 1);\n//   require(tx.outputs[0].value >= minimumValue);\n\n// MISTAKE 4: Using Fee in Economic Logic\n// ---------------------------------------\n// WRONG:\n//   int fee = inputValue - outputValue;\n//   int userProfit = someCalculation();\n//   require(userProfit >= fee * 2);  // \"Profit must exceed fee\"\n//\n// WHY WRONG:\n// - Fee calculation is wrong\n// - Economic model breaks\n// - Attacker manipulates via inputs\n//\n// CORRECT:\n//   // Don't use fee in economic logic\n//   // Validate outcomes directly\n//   int expectedOutput = calculateExpectedValue();\n//   require(outputValue >= expectedOutput);\n\n// MISTAKE 5: Allowing Unbounded Value Decrease\n// ---------------------------------------------\n// WRONG:\n//   int inputValue = tx.inputs[this.activeInputIndex].value;\n//   int outputValue = tx.outputs[0].value;\n//   require(outputValue >= minimumValue);",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-19",
    "content": "//   // No check on inputValue - outputValue\n//\n// WHY WRONG:\n// - Attacker can drain value gradually\n// - Each tx: take 1000 sats \"as fee\"\n// - Covenant drained over time\n//\n// CORRECT:\n//   require(outputValue >= minimumValue);\n//   require(outputValue >= inputValue - maxDecrease);\n//   // Bound total value loss\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR FEE-SAFE COVENANTS\n// ============================================================================\n//\n// Before deploying a covenant contract, verify:\n//\n// [ ] Does NOT calculate transaction fee\n// [ ] Does NOT use \"inputValue - outputValue\" as fee\n// [ ] Does NOT assume who pays the fee\n// [ ] Does NOT use fee in economic logic\n// [ ] DOES enforce output count if validating value\n// [ ] DOES use exact conservation OR bounded value decrease\n// [ ] DOES document fee expectations externally (in UI/docs)\n// [ ] DOES set conservative maxValueDecrease (if used)\n// [ ] Test with single-input transaction\n// [ ] Test with multi-input transaction (attacker adds input)\n// [ ] Test with fee subsidized by attacker\n// [ ] Test with zero fee from covenant (paid externally)\n// [ ] Test value extraction via \"fee\" allowance\n// [ ] Verify covenant economics work with zero fee from covenant\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================\n//",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-20",
    "content": "// Test Cases for VULNERABLE version (fee assumptions):\n// 1. Single-input transaction with normal fee\n//    Expected: SUCCEEDS (assumption holds)\n//\n// 2. Multi-input transaction with attacker subsidy\n//    Expected: SUCCEEDS (VULNERABILITY - assumption breaks)\n//\n// 3. Multi-input with zero fee from covenant\n//    Expected: SUCCEEDS (VULNERABILITY - free tx building)\n//\n// 4. Multi-input with value extraction as \"fee\"\n//    Expected: SUCCEEDS (VULNERABILITY - hidden extraction)\n//\n// Test Cases for SECURE version (no fee assumptions):\n// 1. Single-input, normal fee\n//    Expected: SUCCEEDS (valid transaction)\n//\n// 2. Multi-input with fee subsidy (exact conservation)\n//    Expected: SUCCEEDS (covenant value preserved)\n//\n// 3. Multi-input with zero covenant fee (exact conservation)\n//    Expected: SUCCEEDS (external fee payment valid)\n//\n// 4. Attempt value extraction beyond maxDecrease\n//    Expected: FAILS (bounded value loss rejects)\n//\n// 5. Value conservation version with any value decrease\n//    Expected: FAILS (exact conservation enforced)\n//\n// 6. Multiple outputs (hide value)\n//    Expected: FAILS (output count validation rejects)\n\n// ============================================================================\n// REAL-WORLD IMPACT EXAMPLES\n// ============================================================================\n//\n// Example 1: Vault Fee Drain Attack\n// ----------------------------------\n// Platform: Multi-signature vault\n// Vulnerability: Assumed fee = inputValue - outputValue",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-21",
    "content": "// Attack: Gradual value extraction via \"fee\" allowance\n// Steps:\n//   1. Vault holds 1,000,000 sats\n//   2. Each transaction: Extract 1,000 sats as \"fee\"\n//   3. Repeat 1,000 times\n//   4. Vault drained to 0\n// Impact:\n//   - 1M sats stolen (100% loss)\n//   - Appeared as legitimate fees\n//   - Auditors missed gradual drain\n//   - Users lost all funds\n//\n// Example 2: AMM Invariant Violation\n// -----------------------------------\n// Platform: Automated market maker\n// Vulnerability: Fee budget counted as slippage\n// Attack: Value extraction hidden in fee allowance\n// Steps:\n//   1. AMM allows 1% slippage (1000 sats per 100k)\n//   2. Attacker uses all slippage budget as \"fee\"\n//   3. Repeats on every trade\n//   4. AMM slowly drained\n// Impact:\n//   - Liquidity providers lose value\n//   - AMM economics broken\n//   - Appeared as normal fee variance\n//   - $50,000+ total loss\n//\n// Example 3: Free Transaction Builder\n// ------------------------------------\n// Platform: Time-locked savings\n// Vulnerability: Assumed covenant pays fees\n// Attack: Batched unrelated operations with covenant\n// Steps:\n//   1. User has time-locked 100k sats\n//   2. User wants to consolidate 20 UTXOs\n//   3. Creates transaction with covenant + 20 inputs\n//   4. Covenant pays 0 fee (subsidy from other inputs)\n//   5. User saves on consolidation fees\n// Impact:\n//   - Covenant economics broken\n//   - Free transaction building\n//   - Network fee incentives distorted\n//   - Covenant used as transaction vehicle",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/fee_assumption_violation.cash-22",
    "content": "// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/fee_assumption_violation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-0",
    "content": "// ANTI-PATTERN: Implicit Output Ordering\n// VULNERABILITY: Assuming output order without semantic validation enables output reordering attacks\n// ATTACK VECTOR: Output role swap, value theft, covenant bypass, semantic confusion\n//\n// This file demonstrates the critical vulnerability of assuming outputs appear in a\n// specific order without validating their semantic roles. Attackers can reorder outputs,\n// swap covenant continuations with attacker-controlled outputs, and redirect value by\n// exploiting index-based assumptions instead of semantic validation.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Implicit Output Ordering\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract assumes outputs appear in a specific order\n// RISK: Attacker can reorder outputs to bypass validation and steal value\ncontract VulnerableCovenantImplicitOrder(\n    pubkey ownerPubKey,\n    int minimumValue\n) {\n    // VULNERABILITY: Assumes output[0] is covenant, output[1] is withdrawal\n    // MISSING: Semantic validation of output roles\n    // MISSING: Output count enforcement\n    // MISSING: Validation that output[0] is actually the covenant continuation\n    function withdraw(sig ownerSig, int withdrawalAmount) {\n        // Validate authorization",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-1",
    "content": "require(checkSig(ownerSig, ownerPubKey));\n        \n        // Get input value\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        \n        // CRITICAL FLAW: Assumes output[0] is the covenant continuation\n        // Does NOT validate lockingBytecode or semantic role\n        int covenantOutputValue = tx.outputs[0].value;\n        \n        // Validates covenant maintains minimum value\n        require(covenantOutputValue >= minimumValue);\n        \n        // CRITICAL FLAW: Assumes output[1] is the withdrawal\n        // Does NOT validate this output exists or goes to correct recipient\n        require(tx.outputs[1].value == withdrawalAmount);\n        \n        // Validates total value conservation (with fee allowance)\n        int totalOutput = covenantOutputValue + withdrawalAmount;\n        require(totalOutput <= inputValue);\n        require(inputValue - totalOutput <= 1000);  // Max 1000 sat fee\n        \n        // THE PROBLEM:\n        // This logic assumes:\n        // - output[0] is always the covenant continuation\n        // - output[1] is always the withdrawal to legitimate recipient\n        //\n        // Reality:\n        // - BCH does NOT enforce output order\n        // - Attacker controls output order in transaction construction\n        // - Attacker can swap outputs to redirect value\n        //\n        // Attacker can:\n        // 1. Create output[0] = attacker-controlled script (looks like covenant)\n        // 2. Create output[1] = actual covenant continuation",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-2",
    "content": "// 3. Contract validates output[0].value >= minimumValue (passes)\n        // 4. Contract validates output[1].value == withdrawalAmount (passes)\n        // 5. But output[0] goes to attacker, output[1] continues covenant\n        // 6. Attacker steals covenant value by swapping output positions\n    }\n}\n\n// ============================================================================\n// UNDERSTANDING THE VULNERABILITY: BCH Output Ordering\n// ============================================================================\n//\n// CRITICAL CONCEPT: Outputs Have No Guaranteed Order\n// ---------------------------------------------------\n//\n// BCH Transaction Structure:\n// {\n//   inputs: [...],\n//   outputs: [\n//     { value: 10000, lockingBytecode: 0x... },  // Index 0\n//     { value: 5000,  lockingBytecode: 0x... },  // Index 1\n//     { value: 3000,  lockingBytecode: 0x... }   // Index 2\n//   ]\n// }\n//\n// Key Properties:\n// 1. Output order is ARBITRARY (wallet/attacker chooses)\n// 2. Output indices are POSITIONAL (0, 1, 2, ...)\n// 3. Output semantics are NOT enforced by protocol\n// 4. Transaction is valid as long as: sum(inputs) >= sum(outputs)\n//\n// COVENANT PERSPECTIVE (what it can see):\n// - tx.outputs[0].value (value at index 0)\n// - tx.outputs[0].lockingBytecode (script at index 0)\n// - tx.outputs[1].value (value at index 1)\n// - tx.outputs[1].lockingBytecode (script at index 1)\n// - tx.outputs.length (total number of outputs)\n//\n// WHAT COVENANT CANNOT ASSUME:\n// - Which output is \"the covenant continuation\"",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-3",
    "content": "// - Which output is \"the withdrawal\"\n// - Which output is \"the fee change\"\n// - That outputs appear in any particular order\n//\n// THE DANGEROUS ASSUMPTION:\n// Many covenants assume: \"output[0] is always X, output[1] is always Y\"\n// This is ONLY true if: Covenant validates the semantic role of each output\n// This is FALSE if: Covenant only checks index-based properties\n//\n// Example of Unsafe Thinking:\n// \"Output 0 is the covenant, so I'll check output[0].value >= minimum\"\n// \"Output 1 is the withdrawal, so I'll check output[1].value == amount\"\n//\n// Why This Fails:\n// Attacker can create:\n// - output[0] = attacker script with minimum value\n// - output[1] = covenant continuation with withdrawal amount\n// Contract sees correct VALUES at expected INDICES\n// But MEANINGS are swapped - attacker gets covenant value\n\n// ============================================================================\n// ATTACK SCENARIO 1: Output Role Swap (Covenant vs Withdrawal)\n// ============================================================================\n//\n// Setup:\n// - Covenant holds 100,000 sats (minimum: 50,000 sats)\n// - User requests withdrawal of 30,000 sats\n// - Contract assumes output[0] = covenant, output[1] = withdrawal\n// - Contract validates values but NOT lockingBytecode\n//\n// Legitimate Transaction (Expected):\n// Inputs:\n//   [0] Covenant (100,000 sats)\n//\n// Outputs:\n//   [0] Covenant continuation (69,000 sats) ← Covenant script\n//   [1] Withdrawal to user (30,000 sats) ← User's address",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-4",
    "content": "//\n// Fee: 1,000 sats\n//\n// Covenant's Validation:\n//   output[0].value = 69,000 >= 50,000 ✓ (minimum maintained)\n//   output[1].value = 30,000 ✓ (withdrawal amount correct)\n//   totalOutput = 99,000 <= 100,000 ✓ (value conservation)\n//   Transaction SUCCEEDS\n//\n// ATTACK: Swap Output Positions\n// Inputs:\n//   [0] Covenant (100,000 sats)\n//\n// Outputs:\n//   [0] Attacker's script (50,000 sats) ← ATTACKER CONTROLLED\n//   [1] Covenant continuation (49,000 sats) ← Covenant script\n//\n// Fee: 1,000 sats\n//\n// Covenant's Validation:\n//   output[0].value = 50,000 >= 50,000 ✓ (minimum check passes!)\n//   output[1].value = 49,000 (no withdrawal amount check in this variant)\n//   \n// Wait, this doesn't match the withdrawal check. Let me fix:\n//\n// ACTUAL ATTACK: Precise Value Swap\n// Outputs:\n//   [0] Attacker's script (69,000 sats) ← ATTACKER gets covenant value!\n//   [1] Covenant continuation (30,000 sats) ← Covenant continues with withdrawal amount\n//\n// Fee: 1,000 sats\n//\n// Covenant's Validation:\n//   output[0].value = 69,000 >= 50,000 ✓ (assumes this is covenant)\n//   output[1].value = 30,000 == 30,000 ✓ (assumes this is withdrawal)\n//   totalOutput = 99,000 <= 100,000 ✓\n//   Transaction SUCCEEDS ✓\n//\n// Result:\n// - Contract validated successfully\n// - output[0] has correct value (69,000) but WRONG script (attacker's)\n// - output[1] has correct value (30,000) but WRONG script (covenant's)\n// - Attacker received 69,000 sats (covenant's continuation value)\n// - Covenant continues with only 30,000 sats (withdrawal amount)",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-5",
    "content": "// - Covenant drained by 39,000 sats (69,000 - 30,000)\n//\n// Impact:\n// - Value theft: 39,000 sats stolen\n// - Covenant value reduced below intended amount\n// - User thinks withdrawal succeeded\n// - But covenant lost more value than withdrawal amount\n// - Attacker exploited index-based assumption\n\n// ============================================================================\n// ATTACK SCENARIO 2: Output Shadowing (Valid Output Exists, Wrong Index)\n// ============================================================================\n//\n// Setup:\n// - Vault with time-locked withdrawal\n// - Contract validates output[0] is covenant continuation\n// - Contract validates output[1] is withdrawal after time lock\n// - But does NOT enforce output count\n//\n// Vulnerable Contract:\n//\n// contract VulnerableTimedVault(pubkey ownerPubKey, int unlockTime, int minValue) {\n//     function withdraw(sig ownerSig, int amount) {\n//         require(checkSig(ownerSig, ownerPubKey));\n//         require(tx.time >= unlockTime);\n//         \n//         // Validates output[0] maintains minimum\n//         require(tx.outputs[0].value >= minValue);\n//         \n//         // Validates output[1] is withdrawal\n//         require(tx.outputs[1].value == amount);\n//         \n//         // MISSING: Output count validation\n//         // MISSING: Semantic validation of output roles\n//     }\n// }\n//\n// ATTACK: Add Shadow Outputs\n// Inputs:\n//   [0] Vault (100,000 sats)\n//\n// Outputs:\n//   [0] Attacker's script (50,000 sats) ← Satisfies minimum check",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-6",
    "content": "//   [1] Attacker's script (40,000 sats) ← Satisfies withdrawal check\n//   [2] Covenant continuation (9,000 sats) ← REAL covenant (ignored!)\n//\n// Fee: 1,000 sats\n//\n// Covenant's Validation:\n//   output[0].value = 50,000 >= minValue ✓ (assumes covenant)\n//   output[1].value = 40,000 == amount ✓ (assumes withdrawal)\n//   Transaction SUCCEEDS ✓\n//\n// Result:\n// - output[0] and output[1] validated successfully\n// - BUT both are attacker-controlled scripts\n// - output[2] (real covenant) exists but wasn't validated\n// - Attacker stole 90,000 sats (50,000 + 40,000)\n// - Covenant continues with only 9,000 sats\n// - Completely bypassed covenant logic\n//\n// Impact:\n// - Near-total value theft (90% stolen)\n// - Covenant continuation exists but severely depleted\n// - Contract's validation was meaningless\n// - Attacker added extra outputs to shadow real covenant\n\n// ============================================================================\n// ATTACK SCENARIO 3: Multi-Output Confusion with Attacker-Added Outputs\n// ============================================================================\n//\n// Setup:\n// - AMM-style covenant with two token pools\n// - Contract assumes output[0] = pool A, output[1] = pool B\n// - Validates pool ratios but not semantic roles\n// - Allows multiple outputs for \"change\" or \"fees\"\n//\n// Vulnerable AMM:\n//\n// contract VulnerableAMM(bytes20 poolAHash, bytes20 poolBHash, int ratio) {\n//     function swap(int amountA, int amountB) {\n//         // Validates pool A maintains ratio",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-7",
    "content": "//         require(tx.outputs[0].value >= amountA);\n//         \n//         // Validates pool B maintains ratio\n//         require(tx.outputs[1].value >= amountB);\n//         \n//         // Validates ratio invariant\n//         require(tx.outputs[0].value * ratio == tx.outputs[1].value);\n//         \n//         // MISSING: Validation that output[0] is actually pool A\n//         // MISSING: Validation that output[1] is actually pool B\n//         // MISSING: Output count enforcement\n//     }\n// }\n//\n// ATTACK: Reorder Pools with Extra Outputs\n// Inputs:\n//   [0] Pool A (100,000 sats)\n//   [1] Pool B (100,000 sats)\n//\n// Outputs:\n//   [0] Attacker script (100,000 sats) ← Satisfies amountA check\n//   [1] Attacker script (100,000 sats) ← Satisfies amountB check\n//   [2] Pool A continuation (50,000 sats) ← Real pool (ignored!)\n//   [3] Pool B continuation (48,000 sats) ← Real pool (ignored!)\n//\n// Fee: 2,000 sats\n//\n// Covenant's Validation:\n//   output[0].value = 100,000 >= amountA ✓\n//   output[1].value = 100,000 >= amountB ✓\n//   100,000 * ratio == 100,000 ✓ (ratio maintained)\n//   Transaction SUCCEEDS ✓\n//\n// Result:\n// - Both pools validated at expected indices\n// - But both are attacker-controlled scripts\n// - Real pools (output[2], output[3]) exist but weren't checked\n// - Attacker stole 200,000 sats total\n// - AMM pools continue with depleted liquidity\n// - Invariant maintained on WRONG outputs\n//\n// Impact:\n// - Liquidity theft: 200,000 sats stolen\n// - AMM continues but severely damaged",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-8",
    "content": "// - Ratio checks were meaningless (checked wrong outputs)\n// - Downstream contracts expecting pool outputs will break\n\n// ============================================================================\n// ATTACK SCENARIO 4: Covenant Bypass via Index Confusion\n// ============================================================================\n//\n// Setup:\n// - DAO treasury with spending limits\n// - Contract validates output[0] is treasury continuation\n// - Contract validates output[1] is approved spending\n// - Assumes only 2 outputs exist\n//\n// Vulnerable DAO Treasury:\n//\n// contract VulnerableDAOTreasury(\n//     pubkey daoKeyA,\n//     pubkey daoKeyB,\n//     int spendingLimit\n// ) {\n//     function spend(sig sigA, sig sigB, int spendAmount) {\n//         // Multi-sig validation\n//         require(checkSig(sigA, daoKeyA));\n//         require(checkSig(sigB, daoKeyB));\n//         \n//         // Validates spending limit\n//         require(spendAmount <= spendingLimit);\n//         \n//         int inputValue = tx.inputs[this.activeInputIndex].value;\n//         \n//         // Validates treasury continues\n//         require(tx.outputs[0].value >= inputValue - spendAmount - 1000);\n//         \n//         // Validates spending amount\n//         require(tx.outputs[1].value == spendAmount);\n//         \n//         // MISSING: Semantic validation\n//         // MISSING: Output count enforcement\n//     }\n// }\n//\n// ATTACK: Add Attacker Output at Index 0\n// Inputs:\n//   [0] Treasury (1,000,000 sats)\n//",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-9",
    "content": "// Outputs:\n//   [0] Attacker script (989,000 sats) ← Satisfies treasury check!\n//   [1] Legitimate spend (10,000 sats) ← Satisfies spend check\n//   [2] Treasury continuation (0 sats) ← Real treasury (ignored!)\n//\n// Fee: 1,000 sats\n//\n// Covenant's Validation:\n//   spendAmount = 10,000 <= spendingLimit ✓\n//   output[0].value = 989,000 >= 1,000,000 - 10,000 - 1,000 ✓\n//   output[1].value = 10,000 == spendAmount ✓\n//   Transaction SUCCEEDS ✓\n//\n// Result:\n// - Appears to be legitimate 10,000 sat spend\n// - But output[0] is attacker script, not treasury\n// - Attacker stole 989,000 sats\n// - Real treasury (output[2]) gets nothing\n// - DAO thinks small spend happened\n// - Actually lost entire treasury\n//\n// Impact:\n// - Catastrophic theft: 98.9% of treasury stolen\n// - Appeared as legitimate governance action\n// - Spending limit completely bypassed\n// - DAO treasury destroyed\n\n// ============================================================================\n// SECURE VERSION: Explicit Semantic Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract validates SEMANTIC ROLES of outputs, not just indices\n// PROTECTION: Prevents output reordering, role swap, and value theft\ncontract SecureCovenantSemanticValidation(\n    pubkey ownerPubKey,\n    int minimumValue\n) {\n    // SECURE: Validates each output's semantic role explicitly\n    function withdraw(sig ownerSig, int withdrawalAmount, bytes20 recipientPkh) {",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-10",
    "content": "// Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 2 outputs\n        // This prevents shadow outputs and hidden value extraction\n        require(tx.outputs.length == 2);\n        \n        // Step 3: Get input value and own locking bytecode\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        \n        // Step 4: CRITICAL - Identify which output is covenant continuation\n        // Search for output with matching lockingBytecode\n        // This is SEMANTIC validation (what it IS, not where it IS)\n        bool foundCovenant = false;\n        int covenantOutputValue = 0;\n        \n        // Check output[0]\n        if (tx.outputs[0].lockingBytecode == inputLockingBytecode) {\n            foundCovenant = true;\n            covenantOutputValue = tx.outputs[0].value;\n        }\n        // Check output[1]\n        else if (tx.outputs[1].lockingBytecode == inputLockingBytecode) {\n            foundCovenant = true;\n            covenantOutputValue = tx.outputs[1].value;\n        }\n        \n        // Enforce covenant continuation exists\n        require(foundCovenant);\n        \n        // Step 5: Validate covenant maintains minimum value\n        require(covenantOutputValue >= minimumValue);\n        \n        // Step 6: CRITICAL - Validate withdrawal output\n        // Build expected withdrawal locking bytecode (P2PKH)",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "p2pkh",
      "bytes",
      "int",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-11",
    "content": "bytes20 expectedRecipientPkh = recipientPkh;\n        bytes expectedWithdrawalBytecode = new LockingBytecodeP2PKH(expectedRecipientPkh);\n        \n        // Find withdrawal output by semantic validation\n        bool foundWithdrawal = false;\n        int withdrawalOutputValue = 0;\n        \n        // Check output[0]\n        if (tx.outputs[0].lockingBytecode == expectedWithdrawalBytecode) {\n            foundWithdrawal = true;\n            withdrawalOutputValue = tx.outputs[0].value;\n        }\n        // Check output[1]\n        else if (tx.outputs[1].lockingBytecode == expectedWithdrawalBytecode) {\n            foundWithdrawal = true;\n            withdrawalOutputValue = tx.outputs[1].value;\n        }\n        \n        // Enforce withdrawal output exists\n        require(foundWithdrawal);\n        \n        // Step 7: Validate withdrawal amount\n        require(withdrawalOutputValue == withdrawalAmount);\n        \n        // Step 8: Validate value conservation\n        int totalOutput = covenantOutputValue + withdrawalOutputValue;\n        require(totalOutput <= inputValue);\n        require(inputValue - totalOutput <= 1000);  // Max 1000 sat fee\n        \n        // RESULT: Output order is IRRELEVANT\n        // - Covenant continuation identified by lockingBytecode match\n        // - Withdrawal identified by recipient address match\n        // - Values validated on SEMANTIC outputs, not index assumptions\n        // - Attacker cannot swap output positions\n        //\n        // This is SECURE because:",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes",
      "int",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-12",
    "content": "// - Each output validated by WHAT IT IS (semantic role)\n        // - Not by WHERE IT IS (index position)\n        // - Output order controlled by attacker doesn't matter\n        // - Covenant continuation always found and validated\n        // - Withdrawal always sent to correct recipient\n    }\n}\n\n// ============================================================================\n// ALTERNATIVE PATTERN: Index-Based with Explicit Role Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ALTERNATIVE: Use fixed indices BUT validate semantic roles\n// USE CASE: When output order is part of protocol specification\ncontract SecureCovenantIndexWithSemantics(\n    pubkey ownerPubKey,\n    int minimumValue\n) {\n    // Pattern: Fix output order AND validate semantic correctness\n    function withdraw(sig ownerSig, int withdrawalAmount, bytes20 recipientPkh) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 2 outputs\n        require(tx.outputs.length == 2);\n        \n        // Step 3: Get input properties\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        \n        // Step 4: CRITICAL - Validate output[0] IS the covenant\n        // Not just \"has the right value\" but \"has the right SCRIPT\"\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-13",
    "content": "// Step 5: Validate covenant value\n        require(tx.outputs[0].value >= minimumValue);\n        \n        // Step 6: CRITICAL - Validate output[1] IS the withdrawal\n        // Build expected recipient locking bytecode\n        bytes expectedWithdrawalBytecode = new LockingBytecodeP2PKH(recipientPkh);\n        require(tx.outputs[1].lockingBytecode == expectedWithdrawalBytecode);\n        \n        // Step 7: Validate withdrawal amount\n        require(tx.outputs[1].value == withdrawalAmount);\n        \n        // Step 8: Validate value conservation\n        int totalOutput = tx.outputs[0].value + tx.outputs[1].value;\n        require(totalOutput <= inputValue);\n        require(inputValue - totalOutput <= 1000);\n        \n        // RESULT: Fixed order with semantic validation\n        // - Output order IS enforced (covenant at [0], withdrawal at [1])\n        // - BUT each output's semantic role is validated\n        // - Attacker cannot swap outputs (semantic checks fail)\n        // - Attacker cannot use wrong scripts (lockingBytecode checks fail)\n        //\n        // This is SECURE because:\n        // - Output count enforced (exactly 2)\n        // - Output[0] validated as covenant (lockingBytecode match)\n        // - Output[1] validated as withdrawal (recipient address match)\n        // - Index-based assumptions backed by semantic validation\n        //\n        // Use when:\n        // - Protocol specifies fixed output order\n        // - External tools expect specific indices",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-14",
    "content": "// - BUT always validate semantic roles too\n    }\n}\n\n// ============================================================================\n// BEST PRACTICE: Multi-Output with Full Semantic Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// BEST PRACTICE: Support multiple outputs with complete semantic validation\n// Allows flexible output count while ensuring all outputs validated\ncontract SecureCovenantMultiOutputSemantic(\n    pubkey ownerPubKey,\n    int minimumValue\n) {\n    // Pattern: Allow multiple outputs, validate each semantically\n    function withdrawMulti(\n        sig ownerSig,\n        int withdrawalAmount1,\n        bytes20 recipient1Pkh,\n        int withdrawalAmount2,\n        bytes20 recipient2Pkh\n    ) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 3 outputs\n        // 1 covenant + 2 withdrawals\n        require(tx.outputs.length == 3);\n        \n        // Step 3: Get input properties\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        \n        // Step 4: Build expected output scripts\n        bytes expectedRecipient1Bytecode = new LockingBytecodeP2PKH(recipient1Pkh);\n        bytes expectedRecipient2Bytecode = new LockingBytecodeP2PKH(recipient2Pkh);\n        \n        // Step 5: CRITICAL - Find and validate each output semantically",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-15",
    "content": "// Initialize found flags and values\n        bool foundCovenant = false;\n        bool foundWithdrawal1 = false;\n        bool foundWithdrawal2 = false;\n        int covenantValue = 0;\n        int withdrawal1Value = 0;\n        int withdrawal2Value = 0;\n        \n        // Check all outputs for their semantic roles\n        // Output 0\n        if (tx.outputs[0].lockingBytecode == inputLockingBytecode) {\n            foundCovenant = true;\n            covenantValue = tx.outputs[0].value;\n        } else if (tx.outputs[0].lockingBytecode == expectedRecipient1Bytecode) {\n            foundWithdrawal1 = true;\n            withdrawal1Value = tx.outputs[0].value;\n        } else if (tx.outputs[0].lockingBytecode == expectedRecipient2Bytecode) {\n            foundWithdrawal2 = true;\n            withdrawal2Value = tx.outputs[0].value;\n        }\n        \n        // Output 1\n        if (tx.outputs[1].lockingBytecode == inputLockingBytecode) {\n            require(!foundCovenant);  // Prevent duplicate covenant output\n            foundCovenant = true;\n            covenantValue = tx.outputs[1].value;\n        } else if (tx.outputs[1].lockingBytecode == expectedRecipient1Bytecode) {\n            require(!foundWithdrawal1);  // Prevent duplicate withdrawal\n            foundWithdrawal1 = true;\n            withdrawal1Value = tx.outputs[1].value;\n        } else if (tx.outputs[1].lockingBytecode == expectedRecipient2Bytecode) {\n            require(!foundWithdrawal2);  // Prevent duplicate withdrawal\n            foundWithdrawal2 = true;",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "int",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-16",
    "content": "withdrawal2Value = tx.outputs[1].value;\n        }\n        \n        // Output 2\n        if (tx.outputs[2].lockingBytecode == inputLockingBytecode) {\n            require(!foundCovenant);\n            foundCovenant = true;\n            covenantValue = tx.outputs[2].value;\n        } else if (tx.outputs[2].lockingBytecode == expectedRecipient1Bytecode) {\n            require(!foundWithdrawal1);\n            foundWithdrawal1 = true;\n            withdrawal1Value = tx.outputs[2].value;\n        } else if (tx.outputs[2].lockingBytecode == expectedRecipient2Bytecode) {\n            require(!foundWithdrawal2);\n            foundWithdrawal2 = true;\n            withdrawal2Value = tx.outputs[2].value;\n        }\n        \n        // Step 6: Enforce all required outputs found\n        require(foundCovenant);\n        require(foundWithdrawal1);\n        require(foundWithdrawal2);\n        \n        // Step 7: Validate values\n        require(covenantValue >= minimumValue);\n        require(withdrawal1Value == withdrawalAmount1);\n        require(withdrawal2Value == withdrawalAmount2);\n        \n        // Step 8: Validate value conservation\n        int totalOutput = covenantValue + withdrawal1Value + withdrawal2Value;\n        require(totalOutput <= inputValue);\n        require(inputValue - totalOutput <= 1000);\n        \n        // RESULT: Complete semantic validation\n        // - All outputs validated by WHAT they are\n        // - Output order completely irrelevant\n        // - Duplicate outputs prevented",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-17",
    "content": "// - All required outputs enforced\n        //\n        // This is the MOST SECURE pattern for multi-output scenarios\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Index-Based Meaning Is Unsafe\n// ============================================================================\n\n// FUNDAMENTAL PROBLEM: Indices Are Positional, Not Semantic\n// ----------------------------------------------------------\n// \n// What an output index tells you:\n// ✓ Position in the outputs array (0, 1, 2, ...)\n// ✓ Which output to read properties from\n//\n// What an output index DOES NOT tell you:\n// ✗ What the output represents (covenant? withdrawal? fee?)\n// ✗ What script controls the output\n// ✗ Whether the output serves intended purpose\n// ✗ Whether attacker swapped output positions\n//\n// Example of Index-Based Assumption:\n// \"Output 0 is the covenant continuation\"\n// \n// Reality:\n// - Output 0 is just the FIRST output in the array\n// - It could be covenant script\n// - It could be attacker script\n// - It could be withdrawal script\n// - Contract must CHECK what it is, not ASSUME\n//\n// Why Attackers Can Exploit This:\n// 1. Attacker constructs transaction\n// 2. Attacker controls output order\n// 3. Attacker can place ANY output at ANY index\n// 4. If contract only checks index, not semantics...\n// 5. Attacker swaps positions to redirect value\n\n// SEMANTIC VALIDATION vs INDEX VALIDATION\n// ----------------------------------------\n//\n// Index Validation (UNSAFE):",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-18",
    "content": "//   require(tx.outputs[0].value >= minimumValue);\n//   // Assumes output[0] is covenant\n//   // But doesn't verify it!\n//\n// Semantic Validation (SAFE):\n//   bytes inputBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n//   require(tx.outputs[0].lockingBytecode == inputBytecode);\n//   require(tx.outputs[0].value >= minimumValue);\n//   // Verifies output[0] IS the covenant\n//   // By checking it has covenant script\n//\n// The difference:\n// - Index validation: \"output at position 0 has property X\"\n// - Semantic validation: \"output at position 0 IS the covenant\"\n//\n// Why semantic validation is required:\n// - Attacker can put wrong script at any position\n// - Only lockingBytecode check proves semantic role\n// - Value/amount checks are insufficient\n// - Must verify WHAT the output is, not just its properties\n\n// THE OUTPUT SEARCH PATTERN\n// --------------------------\n// Secure contracts search for outputs by semantic role:\n//\n// bool foundCovenant = false;\n// int covenantValue = 0;\n//\n// // Check each output for covenant script\n// if (tx.outputs[0].lockingBytecode == expectedCovenantScript) {\n//     foundCovenant = true;\n//     covenantValue = tx.outputs[0].value;\n// } else if (tx.outputs[1].lockingBytecode == expectedCovenantScript) {\n//     foundCovenant = true;\n//     covenantValue = tx.outputs[1].value;\n// }\n// // ... check all outputs\n//\n// require(foundCovenant);  // Enforce covenant exists\n// require(covenantValue >= minimum);  // Validate its value\n//\n// This pattern:",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes",
      "int",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-19",
    "content": "// - Searches ALL outputs for semantic role\n// - Finds covenant regardless of position\n// - Validates properties AFTER finding correct output\n// - Makes output order irrelevant\n// - Prevents position-based attacks\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR OUTPUT VALIDATION\n// ============================================================================\n\n// PRINCIPLE 1: VALIDATE SEMANTICS, NOT JUST INDICES\n// --------------------------------------------------\n// Unsafe:\n//   require(tx.outputs[0].value >= minimum);\n//\n// Safe:\n//   require(tx.outputs[0].lockingBytecode == expectedScript);\n//   require(tx.outputs[0].value >= minimum);\n//\n// Always validate:\n// 1. Output count (tx.outputs.length)\n// 2. LockingBytecode of each output (semantic role)\n// 3. Value of each output (after semantic validation)\n// 4. TokenCategory/amount if using tokens\n\n// PRINCIPLE 2: ENFORCE OUTPUT COUNT\n// ----------------------------------\n// ALWAYS enforce exact output count:\n//   require(tx.outputs.length == expectedCount);\n//\n// This prevents:\n// - Shadow outputs (extra attacker outputs)\n// - Hidden value extraction\n// - Output confusion attacks\n//\n// If variable output count needed:\n//   require(tx.outputs.length >= minCount);\n//   require(tx.outputs.length <= maxCount);\n//   // Then validate each possible output semantically\n\n// PRINCIPLE 3: SEARCH FOR OUTPUTS BY SEMANTIC ROLE\n// -------------------------------------------------\n// Don't assume output positions",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-20",
    "content": "// Search for outputs by what they ARE:\n//\n// For covenant continuation:\n//   bytes covenantScript = tx.inputs[this.activeInputIndex].lockingBytecode;\n//   // Search outputs for matching script\n//\n// For recipient address:\n//   bytes recipientScript = new LockingBytecodeP2PKH(recipientPkh);\n//   // Search outputs for matching script\n//\n// For token outputs:\n//   bytes32 expectedCategory = ...;\n//   // Search outputs for matching tokenCategory\n\n// PRINCIPLE 4: PREVENT DUPLICATE OUTPUTS\n// ---------------------------------------\n// When finding outputs semantically, prevent duplicates:\n//\n// bool foundCovenant = false;\n// if (output[0] is covenant) {\n//     foundCovenant = true;\n// }\n// if (output[1] is covenant) {\n//     require(!foundCovenant);  // Prevent duplicate\n//     foundCovenant = true;\n// }\n//\n// This prevents:\n// - Split value attacks (two partial covenant outputs)\n// - Confusion about which output to use\n// - Value hiding in duplicate outputs\n\n// PRINCIPLE 5: VALIDATE ALL EXPECTED OUTPUTS EXIST\n// -------------------------------------------------\n// After searching, enforce all required outputs found:\n//\n// require(foundCovenant);\n// require(foundWithdrawal);\n// require(foundRecipient);\n//\n// This ensures:\n// - Transaction has all required outputs\n// - No missing outputs\n// - No unexpected output configurations\n\n// ============================================================================\n// VALIDATION ORDER GUIDANCE\n// ============================================================================",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "bytes",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-21",
    "content": "// RECOMMENDED VALIDATION ORDER:\n// -----------------------------\n// 1. Validate authorization (signatures)\n// 2. Enforce output count (tx.outputs.length)\n// 3. Get input properties (value, lockingBytecode)\n// 4. Build expected output scripts (covenant, recipients)\n// 5. Search for outputs by semantic role\n// 6. Enforce all required outputs found\n// 7. Validate output values\n// 8. Validate value conservation\n// 9. Additional constraints (time locks, etc.)\n//\n// Why this order:\n// - Authorization first (fail fast on invalid sig)\n// - Output count prevents shadow attacks early\n// - Semantic search finds correct outputs\n// - Value validation on CORRECT outputs\n// - Value conservation ensures no hidden extraction\n\n// EXAMPLE VALIDATION SEQUENCE:\n// ----------------------------\n// function spend(sig s, int amount, bytes20 recipient) {\n//     // 1. Authorization\n//     require(checkSig(s, ownerPubKey));\n//     \n//     // 2. Output count\n//     require(tx.outputs.length == 2);\n//     \n//     // 3. Input properties\n//     bytes covenant = tx.inputs[this.activeInputIndex].lockingBytecode;\n//     int inputValue = tx.inputs[this.activeInputIndex].value;\n//     \n//     // 4. Expected scripts\n//     bytes recipientScript = new LockingBytecodeP2PKH(recipient);\n//     \n//     // 5. Find outputs\n//     bool foundCov = false;\n//     bool foundRecip = false;\n//     int covValue = 0;\n//     int recipValue = 0;\n//     \n//     if (tx.outputs[0].lockingBytecode == covenant) {\n//         foundCov = true;",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "covenant",
      "bytes",
      "int",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-22",
    "content": "//         covValue = tx.outputs[0].value;\n//     } else if (tx.outputs[0].lockingBytecode == recipientScript) {\n//         foundRecip = true;\n//         recipValue = tx.outputs[0].value;\n//     }\n//     \n//     if (tx.outputs[1].lockingBytecode == covenant) {\n//         require(!foundCov);\n//         foundCov = true;\n//         covValue = tx.outputs[1].value;\n//     } else if (tx.outputs[1].lockingBytecode == recipientScript) {\n//         require(!foundRecip);\n//         foundRecip = true;\n//         recipValue = tx.outputs[1].value;\n//     }\n//     \n//     // 6. Enforce found\n//     require(foundCov);\n//     require(foundRecip);\n//     \n//     // 7. Validate values\n//     require(recipValue == amount);\n//     require(covValue >= minimumValue);\n//     \n//     // 8. Value conservation\n//     require(covValue + recipValue <= inputValue);\n// }\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Validating Values Without Semantics\n// -----------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].value >= minimumValue);\n//   require(tx.outputs[1].value == withdrawalAmount);\n//   // Validates values but not WHAT the outputs are\n//\n// WHY WRONG:\n// - Attacker can swap output positions\n// - output[0] could be attacker script with minimum value\n// - output[1] could be covenant with withdrawal amount\n// - Values check out, but meanings are swapped",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-23",
    "content": "//\n// CORRECT:\n//   bytes covenant = tx.inputs[this.activeInputIndex].lockingBytecode;\n//   bytes recipient = new LockingBytecodeP2PKH(recipientPkh);\n//   \n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[0].value >= minimumValue);\n//   \n//   require(tx.outputs[1].lockingBytecode == recipient);\n//   require(tx.outputs[1].value == withdrawalAmount);\n\n// MISTAKE 2: Not Enforcing Output Count\n// --------------------------------------\n// WRONG:\n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[1].lockingBytecode == recipient);\n//   // What if output[2], [3], [4] exist?\n//\n// WHY WRONG:\n// - Attacker can add extra outputs\n// - Value can hide in unvalidated outputs\n// - Shadow outputs can confuse external tools\n//\n// CORRECT:\n//   require(tx.outputs.length == 2);\n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[1].lockingBytecode == recipient);\n\n// MISTAKE 3: Assuming Fixed Output Order\n// ---------------------------------------\n// WRONG:\n//   // \"Covenant is always output[0]\"\n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[1].lockingBytecode == recipient);\n//\n// WHY WRONG (if not backed by semantic validation):\n// - This is actually CORRECT if semantic validation included\n// - But if you ONLY check values, order assumption fails\n// - The fix is: always validate semantics too\n//\n// CORRECT (two approaches):\n// Approach A: Fix order + validate semantics\n//   require(tx.outputs.length == 2);",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-24",
    "content": "//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[1].lockingBytecode == recipient);\n//\n// Approach B: Search for outputs (order-independent)\n//   // Find covenant output (could be at any index)\n//   // Find recipient output (could be at any index)\n//   // Validate both exist and have correct properties\n\n// MISTAKE 4: Not Preventing Duplicate Outputs\n// --------------------------------------------\n// WRONG:\n//   bool found = false;\n//   if (tx.outputs[0].lockingBytecode == covenant) found = true;\n//   if (tx.outputs[1].lockingBytecode == covenant) found = true;\n//   require(found);\n//   // Allows TWO covenant outputs!\n//\n// WHY WRONG:\n// - Value could split between two covenant outputs\n// - Unclear which is \"the\" continuation\n// - Could break assumptions in later logic\n//\n// CORRECT:\n//   bool found = false;\n//   if (tx.outputs[0].lockingBytecode == covenant) {\n//       found = true;\n//   }\n//   if (tx.outputs[1].lockingBytecode == covenant) {\n//       require(!found);  // Prevent duplicate\n//       found = true;\n//   }\n\n// MISTAKE 5: Only Validating One Output\n// --------------------------------------\n// WRONG:\n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[0].value >= minimum);\n//   // Doesn't validate withdrawal output at all\n//\n// WHY WRONG:\n// - Attacker can create any output[1]\n// - Value can go anywhere\n// - Withdrawal not validated\n//\n// CORRECT:\n//   require(tx.outputs[0].lockingBytecode == covenant);\n//   require(tx.outputs[0].value >= minimum);",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bool"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-25",
    "content": "//   \n//   require(tx.outputs[1].lockingBytecode == expectedRecipient);\n//   require(tx.outputs[1].value == withdrawalAmount);\n//   \n//   // Validate ALL outputs\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR OUTPUT-SAFE COVENANTS\n// ============================================================================\n//\n// Before deploying a covenant contract, verify:\n//\n// [ ] DOES enforce exact output count (tx.outputs.length)\n// [ ] DOES validate lockingBytecode of ALL outputs\n// [ ] DOES validate values AFTER semantic validation\n// [ ] Does NOT assume output order without semantic checks\n// [ ] Does NOT validate only subset of outputs\n// [ ] DOES prevent duplicate outputs (if using search pattern)\n// [ ] DOES enforce all required outputs exist\n// [ ] DOES validate covenant continuation exists and correct\n// [ ] DOES validate recipient outputs go to correct addresses\n// [ ] DOES validate value conservation across all outputs\n// [ ] Test with outputs in expected order\n// [ ] Test with outputs in REVERSED order\n// [ ] Test with SWAPPED outputs (covenant vs withdrawal)\n// [ ] Test with EXTRA shadow outputs\n// [ ] Test with MISSING required outputs\n// [ ] Test with DUPLICATE outputs\n// [ ] Verify semantic validation catches all position swaps\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-26",
    "content": "//\n// Test Cases for VULNERABLE version (index assumptions):\n// 1. Outputs in expected order (covenant[0], withdrawal[1])\n//    Expected: SUCCEEDS (assumption holds)\n//\n// 2. Outputs swapped (withdrawal[0], covenant[1])\n//    Expected: SUCCEEDS (VULNERABILITY - value theft)\n//\n// 3. Shadow outputs (attacker[0], attacker[1], covenant[2])\n//    Expected: SUCCEEDS (VULNERABILITY - theft via shadows)\n//\n// 4. Extra outputs beyond expected count\n//    Expected: SUCCEEDS (VULNERABILITY - hidden value)\n//\n// Test Cases for SECURE version (semantic validation):\n// 1. Outputs in expected order\n//    Expected: SUCCEEDS (valid transaction)\n//\n// 2. Outputs swapped\n//    Expected: SUCCEEDS (order irrelevant with semantic validation)\n//\n// 3. Wrong script at output[0] (attacker script)\n//    Expected: FAILS (lockingBytecode check rejects)\n//\n// 4. Extra shadow outputs\n//    Expected: FAILS (output count check rejects)\n//\n// 5. Missing covenant output\n//    Expected: FAILS (covenant search fails)\n//\n// 6. Missing withdrawal output\n//    Expected: FAILS (recipient search fails)\n//\n// 7. Duplicate covenant outputs\n//    Expected: FAILS (duplicate prevention rejects)\n//\n// 8. Covenant output with wrong value\n//    Expected: FAILS (value check rejects after finding covenant)\n\n// ============================================================================\n// REAL-WORLD IMPACT EXAMPLES\n// ============================================================================\n//\n// Example 1: DAO Treasury Bypass",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-27",
    "content": "// -------------------------------\n// Platform: Decentralized organization treasury\n// Vulnerability: Assumed output[0] is treasury continuation\n// Attack: Placed attacker output at index 0\n// Steps:\n//   1. DAO treasury holds 10M sats\n//   2. Legitimate spend request for 100k sats\n//   3. Attacker swaps output order\n//   4. output[0] = attacker script (9.9M sats)\n//   5. output[1] = legitimate spend (100k sats)\n//   6. output[2] = treasury continuation (0 sats)\n//   7. Contract validates output[0] value (passes)\n//   8. Contract validates output[1] value (passes)\n//   9. Attacker steals 9.9M sats\n// Impact:\n//   - 99% of treasury stolen\n//   - Appeared as legitimate governance action\n//   - Organization destroyed\n//   - $100,000+ loss (at BCH prices)\n//\n// Example 2: AMM Pool Drain\n// --------------------------\n// Platform: Automated market maker\n// Vulnerability: Assumed output[0] = poolA, output[1] = poolB\n// Attack: Swapped pool outputs with attacker outputs\n// Steps:\n//   1. AMM has poolA (500k sats) and poolB (500k sats)\n//   2. User initiates swap\n//   3. Attacker crafts transaction:\n//      - output[0] = attacker script (500k)\n//      - output[1] = attacker script (500k)\n//      - output[2] = poolA continuation (100k)\n//      - output[3] = poolB continuation (100k)\n//   4. Contract validates output[0] and output[1] values\n//   5. Invariant checks pass on wrong outputs\n//   6. Attacker steals 800k sats from pools\n// Impact:\n//   - 80% liquidity theft\n//   - AMM continues but severely damaged",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/implicit_output_ordering.cash-28",
    "content": "//   - Liquidity providers lose funds\n//   - $80,000+ loss\n//\n// Example 3: Vault Shadowing Attack\n// ----------------------------------\n// Platform: Time-locked savings vault\n// Vulnerability: No output count enforcement\n// Attack: Added shadow outputs at expected indices\n// Steps:\n//   1. Vault holds 1M sats (time lock expired)\n//   2. User withdraws funds\n//   3. Attacker adds shadow outputs:\n//      - output[0] = attacker script (900k) ← \"vault\"\n//      - output[1] = attacker script (99k) ← \"withdrawal\"\n//      - output[2] = real vault (0 sats)\n//   4. Contract sees output[0] and output[1]\n//   5. Values validated at expected indices\n//   6. output[2] ignored (not checked)\n//   7. Attacker steals 999k sats\n// Impact:\n//   - Near-total fund theft (99.9%)\n//   - User lost their savings\n//   - Vault destroyed\n//   - $100,000+ loss\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/implicit_output_ordering.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-0",
    "content": "// ANTI-PATTERN: Minting Authority Leak\n// VULNERABILITY: Unrestricted minting outputs enable unauthorized token creation\n// ATTACK VECTOR: Minting to arbitrary recipients, supply inflation, governance bypass\n//\n// This file demonstrates the critical vulnerability of failing to restrict where\n// newly minted tokens can be sent. Without explicit validation of minting outputs,\n// attackers can mint unlimited tokens to themselves, inflating supply and\n// destroying token economic guarantees.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Unrestricted Minting Output\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract allows minting but doesn't control WHO receives minted tokens\n// RISK: Anyone with minting authority can mint tokens to themselves, inflating supply\ncontract VulnerableMintingNoRecipientControl(\n    pubkey mintAuthorityPubKey\n) {\n    // VULNERABILITY: Validates minting authority but not minting recipient\n    // MISSING: Validation of where minted tokens are sent\n    // MISSING: Validation of minting output lockingBytecode\n    // MISSING: Supply limit enforcement\n    function mint(sig authSig, int mintAmount) {\n        // Validate minting authority signature\n        require(checkSig(authSig, mintAuthorityPubKey));",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-1",
    "content": "// Validate mint amount is positive\n        require(mintAmount > 0);\n        \n        // CRITICAL FLAW: No validation of outputs\n        // Contract never checks:\n        // - WHERE the minted tokens go (output[1] recipient)\n        // - HOW MANY outputs are created\n        // - WHAT ELSE happens in the transaction\n        //\n        // Attacker with mintAuthorityPubKey can:\n        // - Mint tokens to their own address\n        // - Mint unlimited amounts (no supply cap)\n        // - Create multiple minting outputs\n        // - Bypass all intended token distribution rules\n    }\n}\n\n// ============================================================================\n// ATTACK SCENARIO 1: Direct Minting to Attacker Address\n// ============================================================================\n//\n// Setup:\n// - Token contract holds minting capability NFT\n// - Intended use: Mint tokens only to DAO treasury\n// - Attacker compromises mintAuthorityPubKey (insider, leaked key, etc.)\n//\n// Legitimate Minting (intended behavior):\n// Inputs:\n//   [0] Minting contract UTXO (holds minting capability NFT)\n//\n// Outputs:\n//   [0] Minting contract continuation (preserves minting capability)\n//   [1] 1,000 tokens to DAO treasury address (intended recipient)\n//\n// ATTACK: Mint to Self Instead\n// Inputs:\n//   [0] Minting contract UTXO (holds minting capability NFT)\n//   [1] Valid signature from mintAuthorityPubKey (compromised)\n//\n// Outputs:\n//   [0] Minting contract continuation (preserves minting capability)",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-2",
    "content": "//   [1] 1,000,000 tokens to ATTACKER's personal address ← UNAUTHORIZED\n//\n// Result:\n// - Contract validates signature ✓\n// - Contract validates mint amount > 0 ✓\n// - Contract NEVER validates output[1] recipient\n// - Attacker receives 1 million tokens\n// - Token supply inflated without authorization\n// - DAO treasury receives nothing\n//\n// Why it works:\n// - Contract has minting capability in output[0]\n// - BCH consensus allows minting tokens in ANY output using that capability\n// - Contract never checks: tx.outputs[1].lockingBytecode == treasuryBytecode\n// - Attacker is authorized to TRIGGER minting, but not WHERE to mint\n// - Authorization confusion: signature proves WHO, not WHAT\n\n// ============================================================================\n// ATTACK SCENARIO 2: Unlimited Supply Inflation\n// ============================================================================\n//\n// Setup:\n// - Token intended to have maximum supply of 21,000,000\n// - Minting contract should enforce supply cap\n// - No supply tracking implemented\n//\n// Attack Transaction #1:\n// Inputs:\n//   [0] Minting contract UTXO\n// Outputs:\n//   [0] Minting contract continuation\n//   [1] 10,000,000 tokens to attacker address\n// Result: 10M tokens minted ✓\n//\n// Attack Transaction #2:\n// Inputs:\n//   [0] Minting contract UTXO (from previous tx)\n// Outputs:\n//   [0] Minting contract continuation\n//   [1] 10,000,000 tokens to attacker address\n// Result: Another 10M tokens minted ✓\n//\n// Attack Transaction #3:",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-3",
    "content": "// Inputs:\n//   [0] Minting contract UTXO (from previous tx)\n// Outputs:\n//   [0] Minting contract continuation\n//   [1] 10,000,000 tokens to attacker address\n// Result: Another 10M tokens minted ✓\n//\n// Total minted: 30,000,000 tokens (exceeds 21M cap)\n//\n// Why it works:\n// - Contract never tracks total minted supply\n// - Contract never validates against maximum supply\n// - Each transaction independently validates (no state accumulation)\n// - Attacker can repeat minting indefinitely\n// - Token economic model destroyed (hyperinflation)\n\n// ============================================================================\n// ATTACK SCENARIO 3: Multi-Output Minting Abuse\n// ============================================================================\n//\n// Setup:\n// - Contract intended to mint to single authorized recipient per transaction\n// - No output count validation\n//\n// Attack Transaction:\n// Inputs:\n//   [0] Minting contract UTXO (holds minting capability NFT)\n//\n// Outputs:\n//   [0] Minting contract continuation (preserves minting capability)\n//   [1] 1,000,000 tokens to attacker address #1\n//   [2] 1,000,000 tokens to attacker address #2\n//   [3] 1,000,000 tokens to attacker address #3\n//   [4] 1,000,000 tokens to attacker address #4\n//   [5] 1,000,000 tokens to attacker address #5\n//\n// Result:\n// - Single transaction mints 5,000,000 tokens\n// - All to attacker-controlled addresses\n// - Contract validates signature once\n// - No limit on number of minting outputs\n// - Massive supply inflation in single transaction",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-4",
    "content": "//\n// Why it works:\n// - Contract never checks: require(tx.outputs.length == 2);\n// - Minting capability in output[0] allows minting in outputs[1..N]\n// - No validation of how many tokens are minted total\n// - Each output can receive arbitrary amounts\n\n// ============================================================================\n// ATTACK SCENARIO 4: Governance Bypass via Unauthorized Distribution\n// ============================================================================\n//\n// Setup:\n// - Token has governance model (holders vote on proposals)\n// - Minting is supposed to follow governance decisions\n// - DAO voted to mint 100,000 tokens to community treasury\n// - Attacker has mintAuthorityPubKey but must follow DAO decisions\n//\n// Legitimate Minting (following governance):\n// - DAO votes: \"Mint 100,000 tokens to community treasury\"\n// - Minting authority executes as approved\n//\n// Attack (governance bypass):\n// Inputs:\n//   [0] Minting contract UTXO\n//\n// Outputs:\n//   [0] Minting contract continuation\n//   [1] 100,000 tokens to community treasury (as voted) ✓\n//   [2] 900,000 tokens to attacker's address (NOT voted) ✗\n//\n// Result:\n// - Governance decision \"followed\" (100k to treasury)\n// - But 900k additional tokens minted to attacker\n// - Total: 1M tokens instead of 100k\n// - Governance process undermined\n// - Attacker accumulates 90% of mint for themselves\n//\n// Why it works:\n// - Contract validates authority signature\n// - Contract doesn't validate ONLY authorized outputs exist",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-5",
    "content": "// - Attacker adds unauthorized outputs\n// - Governance cannot enforce on-chain restrictions\n\n// ============================================================================\n// SECURE VERSION: Explicit Minting Output Control\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract restricts minting to specific authorized recipients\n// PROTECTION: Prevents unauthorized minting, supply inflation, governance bypass\ncontract SecureMintingWithRecipientControl(\n    pubkey mintAuthorityPubKey,\n    bytes authorizedRecipientBytecode,  // Only this address can receive minted tokens\n    int maxSupply,                       // Maximum total supply allowed\n    int currentSupply                    // Current minted supply (tracked in covenant)\n) {\n    // SECURE: Validates authority, recipient, amount, and supply limits\n    function mint(sig authSig, int mintAmount) {\n        // Step 1: Validate minting authority\n        require(checkSig(authSig, mintAuthorityPubKey));\n        \n        // Step 2: Validate mint amount\n        require(mintAmount > 0);\n        require(mintAmount <= 1000000);  // Maximum per-mint limit (prevent abuse)\n        \n        // Step 3: CRITICAL - Validate total supply doesn't exceed maximum\n        int newSupply = currentSupply + mintAmount;\n        require(newSupply <= maxSupply);\n        \n        // Step 4: CRITICAL - Enforce exactly 2 outputs\n        // [0] Minting contract continuation (with updated supply)",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-6",
    "content": "// [1] Minted tokens to authorized recipient ONLY\n        require(tx.outputs.length == 2);\n        \n        // Step 5: CRITICAL - Validate output[0] is covenant continuation\n        bytes thisLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == thisLockingBytecode);\n        \n        // Step 6: CRITICAL - Validate output[0] preserves minting capability\n        bytes thisTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        require(tx.outputs[0].tokenCategory == thisTokenCategory);\n        \n        // Step 7: CRITICAL - Validate output[0] updates supply tracking\n        // The new contract must have updated currentSupply parameter\n        // This requires contract bytecode to encode the new supply value\n        // (Implementation detail: contract template updated with newSupply)\n        \n        // Step 8: CRITICAL - Validate output[1] recipient is AUTHORIZED\n        // Only the pre-approved recipient address can receive minted tokens\n        require(tx.outputs[1].lockingBytecode == authorizedRecipientBytecode);\n        \n        // Step 9: CRITICAL - Validate output[1] receives correct token category\n        require(tx.outputs[1].tokenCategory == thisTokenCategory);\n        \n        // Step 10: CRITICAL - Validate output[1] receives exact mint amount\n        require(tx.outputs[1].tokenAmount == mintAmount);\n        \n        // Step 11: Validate output[1] has no minting capability\n        // Minted tokens should be immutable (no further minting from them)",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-7",
    "content": "require(tx.outputs[1].nftCommitment == 0x);\n        require(tx.outputs[1].tokenCapability == 0x);  // No capability = immutable\n        \n        // RESULT: Minting is now FULLY CONTROLLED\n        // - Only authorized signer can trigger minting\n        // - Only authorized recipient can receive tokens\n        // - Only specific amount can be minted per transaction\n        // - Total supply is tracked and limited\n        // - No unauthorized outputs possible\n        // - Minted tokens cannot mint further (no capability leak)\n    }\n}\n\n// ============================================================================\n// ADVANCED PATTERN: Multi-Recipient Minting with Explicit Distribution\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ADVANCED: Controlled minting to multiple recipients with explicit validation\n// USE CASE: Airdrops, vesting schedules, multi-party distribution\ncontract SecureMintingMultiRecipient(\n    pubkey mintAuthorityPubKey,\n    bytes recipient1Bytecode,\n    bytes recipient2Bytecode,\n    bytes recipient3Bytecode,\n    int maxSupply,\n    int currentSupply\n) {\n    // Pattern: Mint to multiple recipients with ALL recipients validated\n    function mintToMultiple(\n        sig authSig,\n        int amount1,\n        int amount2,\n        int amount3\n    ) {\n        // Step 1: Validate authority\n        require(checkSig(authSig, mintAuthorityPubKey));\n        \n        // Step 2: Validate all amounts are positive",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-8",
    "content": "require(amount1 > 0);\n        require(amount2 > 0);\n        require(amount3 > 0);\n        \n        // Step 3: CRITICAL - Validate total minted amount\n        int totalMinted = amount1 + amount2 + amount3;\n        int newSupply = currentSupply + totalMinted;\n        require(newSupply <= maxSupply);\n        \n        // Step 4: CRITICAL - Enforce exactly 4 outputs\n        // [0] Minting contract continuation\n        // [1] Tokens to recipient 1\n        // [2] Tokens to recipient 2\n        // [3] Tokens to recipient 3\n        require(tx.outputs.length == 4);\n        \n        // Step 5: Validate covenant continuation (output[0])\n        bytes thisLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == thisLockingBytecode);\n        \n        bytes thisTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        require(tx.outputs[0].tokenCategory == thisTokenCategory);\n        \n        // Step 6: CRITICAL - Validate output[1] recipient and amount\n        require(tx.outputs[1].lockingBytecode == recipient1Bytecode);\n        require(tx.outputs[1].tokenCategory == thisTokenCategory);\n        require(tx.outputs[1].tokenAmount == amount1);\n        require(tx.outputs[1].tokenCapability == 0x);  // No minting capability\n        \n        // Step 7: CRITICAL - Validate output[2] recipient and amount\n        require(tx.outputs[2].lockingBytecode == recipient2Bytecode);\n        require(tx.outputs[2].tokenCategory == thisTokenCategory);",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-9",
    "content": "require(tx.outputs[2].tokenAmount == amount2);\n        require(tx.outputs[2].tokenCapability == 0x);\n        \n        // Step 8: CRITICAL - Validate output[3] recipient and amount\n        require(tx.outputs[3].lockingBytecode == recipient3Bytecode);\n        require(tx.outputs[3].tokenCategory == thisTokenCategory);\n        require(tx.outputs[3].tokenAmount == amount3);\n        require(tx.outputs[3].tokenCapability == 0x);\n        \n        // RESULT: Multi-recipient minting is SECURE\n        // - All recipients are pre-authorized\n        // - All amounts are explicit and validated\n        // - Total supply is tracked\n        // - No unauthorized recipients possible\n        // - No capability leak to minted tokens\n    }\n}\n\n// ============================================================================\n// BEST PRACTICE: Supply-Tracking Minting Covenant\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// BEST PRACTICE: Full supply tracking with NFT commitment\n// This pattern stores supply in NFT commitment rather than contract parameters\ncontract SecureMintingSupplyTracking(\n    pubkey mintAuthorityPubKey,\n    bytes authorizedRecipientBytecode,\n    int maxSupply\n) {\n    // Pattern: Track minted supply in NFT commitment for accurate on-chain state\n    function mint(sig authSig, int mintAmount) {\n        // Step 1: Validate authority\n        require(checkSig(authSig, mintAuthorityPubKey));\n        \n        // Step 2: Validate mint amount",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-10",
    "content": "require(mintAmount > 0);\n        \n        // Step 3: CRITICAL - Read current supply from NFT commitment\n        // NFT commitment contains 8-byte integer representing total minted supply\n        bytes currentSupplyCommitment = tx.inputs[this.activeInputIndex].nftCommitment;\n        require(currentSupplyCommitment.length == 8);\n        int currentSupply = int(bytes8(currentSupplyCommitment));\n        \n        // Step 4: CRITICAL - Calculate and validate new supply\n        int newSupply = currentSupply + mintAmount;\n        require(newSupply <= maxSupply);\n        require(newSupply > currentSupply);  // Overflow protection\n        \n        // Step 5: CRITICAL - Enforce exactly 2 outputs\n        require(tx.outputs.length == 2);\n        \n        // Step 6: Validate covenant continuation (output[0])\n        bytes thisLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == thisLockingBytecode);\n        \n        bytes thisTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        require(tx.outputs[0].tokenCategory == thisTokenCategory);\n        \n        // Step 7: CRITICAL - Validate output[0] updates supply in commitment\n        // New commitment must contain updated supply value\n        bytes newSupplyCommitment = bytes8(newSupply);\n        require(tx.outputs[0].nftCommitment == newSupplyCommitment);\n        \n        // Step 8: Validate output[0] preserves minting capability\n        bytes thisCapability = tx.inputs[this.activeInputIndex].tokenCapability;",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-11",
    "content": "require(tx.outputs[0].tokenCapability == thisCapability);\n        \n        // Step 9: CRITICAL - Validate output[1] recipient\n        require(tx.outputs[1].lockingBytecode == authorizedRecipientBytecode);\n        \n        // Step 10: CRITICAL - Validate output[1] token properties\n        require(tx.outputs[1].tokenCategory == thisTokenCategory);\n        require(tx.outputs[1].tokenAmount == mintAmount);\n        require(tx.outputs[1].tokenCapability == 0x);  // No minting capability\n        require(tx.outputs[1].nftCommitment == 0x);    // No commitment needed\n        \n        // RESULT: Supply tracking is ON-CHAIN and ENFORCEABLE\n        // - Current supply stored in NFT commitment (verifiable)\n        // - New supply validated against maximum\n        // - Supply updated atomically with minting\n        // - No way to mint beyond maximum supply\n        // - Supply history trackable on blockchain\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Minting Output Control Is Critical\n// ============================================================================\n\n// MINTING CAPABILITY MECHANICS\n// -----------------------------\n// In Bitcoin Cash CashToken protocol:\n// - NFTs can have a \"minting\" capability\n// - An input with minting capability can create NEW tokens in outputs\n// - Tokens can be created in ANY output (not just covenant continuation)\n// - Minting capability persists until explicitly removed or not passed forward",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-12",
    "content": "//\n// Without Output Control:\n// - Contract validates WHO can mint (signature check)\n// - Contract does NOT validate WHERE tokens are minted\n// - Attacker creates outputs minting to their own address\n// - Token distribution completely uncontrolled\n//\n// With Output Control:\n// - Contract validates WHO can mint (signature check)\n// - Contract validates WHERE tokens go (output lockingBytecode)\n// - Contract validates HOW MANY tokens minted (output tokenAmount)\n// - Contract enforces supply limits and distribution rules\n\n// THE AUTHORIZATION VS DISTRIBUTION CONFUSION\n// --------------------------------------------\n// Common mistake: Confusing authorization with distribution control\n//\n// WRONG ASSUMPTION:\n// \"If only authorized signer can call mint(), tokens are controlled\"\n//\n// REALITY:\n// - Signature proves WHO triggered the mint\n// - Signature does NOT prove WHERE tokens go\n// - Signer can create ANY outputs they want\n// - Contract must explicitly validate outputs\n//\n// CORRECT PATTERN:\n// 1. Validate WHO can mint (signature)\n// 2. Validate WHERE tokens go (output lockingBytecode)\n// 3. Validate HOW MANY tokens created (output tokenAmount)\n// 4. Validate supply limits (currentSupply + mintAmount <= maxSupply)\n\n// SUPPLY TRACKING CHALLENGES\n// ---------------------------\n// Problem: Covenants are stateless (each validation is independent)\n// Solution: Store state in NFT commitment or contract parameters\n//\n// Pattern A: Supply in Contract Parameters (Parameterized Covenant)\n//   - Contract deployed with currentSupply parameter",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-13",
    "content": "//   - Each mint creates new contract instance with updated supply\n//   - Requires re-deploying contract code with new parameters\n//   - More complex but keeps all state in bytecode\n//\n// Pattern B: Supply in NFT Commitment (Recommended)\n//   - Contract reads currentSupply from NFT commitment\n//   - Each mint updates commitment with new supply\n//   - Simpler, more efficient, cleaner separation of code and state\n//   - State is easily readable on-chain\n//\n// Pattern C: Off-Chain Supply Tracking (Weak)\n//   - Track supply in external database\n//   - Contract validates against off-chain data\n//   - Vulnerable to database manipulation\n//   - NOT RECOMMENDED for critical supply limits\n\n// CAPABILITY LEAK PREVENTION\n// ---------------------------\n// Critical: Minted tokens must NOT receive minting capability\n//\n// WRONG:\n//   // Output[1] receives tokens with minting capability\n//   require(tx.outputs[1].tokenCapability == tx.inputs[this.activeInputIndex].tokenCapability);\n//\n// WHY WRONG:\n// - Recipient receives minting capability\n// - Recipient can mint MORE tokens themselves\n// - Minting authority proliferates uncontrollably\n// - Supply limits become unenforceable\n//\n// CORRECT:\n//   // Output[1] receives immutable tokens (no capability)\n//   require(tx.outputs[1].tokenCapability == 0x);\n//\n// Only the minting COVENANT should hold minting capability.\n// All minted tokens to users should be immutable (no capability).\n\n// ============================================================================",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-14",
    "content": "// SECURITY PRINCIPLES FOR MINTING CONTRACTS\n// ============================================================================\n\n// PRINCIPLE 1: VALIDATE ALL MINTING OUTPUTS\n// ------------------------------------------\n// Every output that receives minted tokens MUST be validated:\n// - lockingBytecode (recipient address)\n// - tokenCategory (correct token type)\n// - tokenAmount (correct quantity)\n// - tokenCapability (must be 0x / immutable)\n// - nftCommitment (usually 0x for fungible tokens)\n\n// PRINCIPLE 2: ENFORCE OUTPUT COUNT\n// ----------------------------------\n// Always: require(tx.outputs.length == N);\n// Where N is the EXACT expected count\n// Prevents unauthorized additional minting outputs\n\n// PRINCIPLE 3: TRACK TOTAL SUPPLY\n// --------------------------------\n// Maintain cumulative supply counter\n// Validate: newSupply = currentSupply + mintAmount\n// Enforce: newSupply <= maxSupply\n// Update: Store newSupply in commitment or parameters\n\n// PRINCIPLE 4: PREVENT CAPABILITY LEAK\n// -------------------------------------\n// Minting capability must NEVER leak to minted tokens\n// Always: require(tx.outputs[N].tokenCapability == 0x);\n// Only covenant continuation should have capability\n\n// PRINCIPLE 5: EXPLICIT RECIPIENT AUTHORIZATION\n// ----------------------------------------------\n// Never mint to arbitrary addresses\n// Always validate: tx.outputs[N].lockingBytecode == authorizedBytecode\n// Pre-authorize recipients in contract or via governance\n\n// PRINCIPLE 6: PER-MINT LIMITS",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-15",
    "content": "// -----------------------------\n// Even with total supply limits, enforce per-mint maximums\n// Prevents: Single transaction minting entire supply\n// Example: require(mintAmount <= maxPerMint);\n\n// PRINCIPLE 7: SEPARATE AUTHORITY FROM DISTRIBUTION\n// --------------------------------------------------\n// Authority to TRIGGER mint ≠ Authority to RECEIVE tokens\n// Validate both independently\n// Don't assume signer should receive tokens\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Signature-Only Validation\n// -------------------------------------\n// WRONG:\n//   function mint(sig authSig, int amount) {\n//       require(checkSig(authSig, mintAuthorityPubKey));\n//       // No output validation\n//   }\n//\n// CORRECT:\n//   function mint(sig authSig, int amount) {\n//       require(checkSig(authSig, mintAuthorityPubKey));\n//       require(tx.outputs.length == 2);\n//       require(tx.outputs[1].lockingBytecode == authorizedRecipient);\n//       require(tx.outputs[1].tokenAmount == amount);\n//   }\n\n// MISTAKE 2: No Supply Tracking\n// ------------------------------\n// WRONG:\n//   function mint(sig authSig, int amount) {\n//       require(checkSig(authSig, mintAuthorityPubKey));\n//       require(amount > 0);\n//       // Can be called infinite times\n//   }\n//\n// CORRECT:\n//   function mint(sig authSig, int amount) {\n//       int currentSupply = int(bytes8(tx.inputs[this.activeInputIndex].nftCommitment));",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-16",
    "content": "//       int newSupply = currentSupply + amount;\n//       require(newSupply <= maxSupply);\n//       require(tx.outputs[0].nftCommitment == bytes8(newSupply));\n//   }\n\n// MISTAKE 3: Capability Leak\n// ---------------------------\n// WRONG:\n//   // Minted tokens receive minting capability\n//   require(tx.outputs[1].tokenCapability == tx.inputs[this.activeInputIndex].tokenCapability);\n//\n// CORRECT:\n//   // Minted tokens are immutable\n//   require(tx.outputs[1].tokenCapability == 0x);\n//   // Only covenant keeps capability\n//   require(tx.outputs[0].tokenCapability == tx.inputs[this.activeInputIndex].tokenCapability);\n\n// MISTAKE 4: Unconstrained Output Count\n// --------------------------------------\n// WRONG:\n//   require(tx.outputs[1].lockingBytecode == recipient);\n//   // But outputs[2], [3], [4]... could exist with unauthorized minting\n//\n// CORRECT:\n//   require(tx.outputs.length == 2);  // EXACTLY 2 outputs\n//   require(tx.outputs[1].lockingBytecode == recipient);\n\n// MISTAKE 5: No Per-Mint Maximum\n// -------------------------------\n// WRONG:\n//   require(newSupply <= maxSupply);\n//   // But mintAmount could be = maxSupply in one transaction\n//\n// CORRECT:\n//   require(mintAmount <= maxPerMint);  // E.g., 1M per mint\n//   require(newSupply <= maxSupply);\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR MINTING CONTRACTS\n// ============================================================================\n//\n// Before deploying a minting contract, verify:",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-17",
    "content": "//\n// [ ] Minting authority validated via signature check\n// [ ] Output count enforced: require(tx.outputs.length == N)\n// [ ] Every minting output recipient validated (lockingBytecode)\n// [ ] Every minting output amount validated (tokenAmount)\n// [ ] Every minting output has NO capability (tokenCapability == 0x)\n// [ ] Covenant continuation preserves minting capability\n// [ ] Total supply tracked (in commitment or parameters)\n// [ ] Total supply limit enforced (newSupply <= maxSupply)\n// [ ] Per-mint limit enforced (mintAmount <= maxPerMint)\n// [ ] Supply overflow protection (newSupply > currentSupply check)\n// [ ] Token category preserved across all outputs\n// [ ] No unauthorized outputs possible\n// [ ] Supply tracking mechanism tested (commitment update)\n// [ ] Governance integration if applicable\n// [ ] Emergency pause mechanism considered\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================\n//\n// Test Cases for VULNERABLE version (demonstrates vulnerability):\n// 1. Mint to authorized recipient\n//    Expected: SUCCEEDS (normal operation)\n//\n// 2. Mint to ATTACKER address (unauthorized)\n//    Expected: SUCCEEDS (VULNERABILITY - should fail but doesn't)\n//\n// 3. Mint multiple times beyond intended supply\n//    Expected: SUCCEEDS (VULNERABILITY - no supply tracking)\n//\n// 4. Mint to multiple unauthorized recipients in one transaction\n//    Expected: SUCCEEDS (VULNERABILITY - no output count limit)",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-18",
    "content": "//\n// Test Cases for SECURE version (should PASS):\n// 1. Mint to authorized recipient with valid amount\n//    Expected: SUCCEEDS (valid minting)\n//\n// 2. Mint to unauthorized recipient\n//    Expected: FAILS (output[1].lockingBytecode validation rejects)\n//\n// 3. Mint beyond maximum supply\n//    Expected: FAILS (newSupply > maxSupply check rejects)\n//\n// 4. Mint with extra outputs\n//    Expected: FAILS (tx.outputs.length != 2 check rejects)\n//\n// 5. Mint with capability leak to recipient\n//    Expected: FAILS (tokenCapability validation rejects)\n//\n// 6. Mint without updating supply commitment\n//    Expected: FAILS (commitment validation rejects)\n//\n// 7. Multiple mints reaching exactly maxSupply\n//    Expected: Last valid mint SUCCEEDS, next mint FAILS\n\n// ============================================================================\n// REAL-WORLD IMPACT\n// ============================================================================\n//\n// Historical Lessons (adapted from other blockchain incidents):\n//\n// Scenario: DAO Token without recipient control\n// - Intended: 100M token supply for governance\n// - Attack: Insider with mint key mints 900M tokens to self\n// - Result: Attacker has 90% voting power, controls DAO\n// - Impact: Governance compromised, project destroyed\n//\n// Scenario: Stablecoin without supply tracking\n// - Intended: 1:1 backed stablecoin with collateral\n// - Attack: Repeated minting without limit enforcement\n// - Result: 10x more tokens than collateral exists\n// - Impact: De-pegging, bank run, total collapse",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/minting_authority_leak.cash-19",
    "content": "//\n// Scenario: NFT project with capability leak\n// - Intended: Limited edition NFT collection (1000 max)\n// - Attack: Minted NFTs retain minting capability\n// - Result: NFT holders mint more NFTs, flooding market\n// - Impact: Scarcity destroyed, value collapse\n//\n// LESSON: Minting control is not just authorization.\n// It requires explicit validation of recipients, amounts, and capabilities.\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/minting_authority_leak.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-0",
    "content": "// ANTI-PATTERN: Missing Output Count Validation\r\n// VULNERABILITY: Unbounded output creation enables multiple attack vectors\r\n// ATTACK VECTOR: Unauthorized minting, output spam, fee manipulation, multi-output extraction\r\n//\r\n// This file demonstrates the critical vulnerability of missing output count limits.\r\n// Without explicit `tx.outputs.length` validation, attackers can create arbitrary\r\n// additional outputs beyond those validated by the covenant logic.\r\n//\r\n// CashScript Version: ^0.13.0\r\n// Network: Bitcoin Cash (BCH)\r\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\r\n\r\n// ============================================================================\r\n// VULNERABLE CODE: Missing Output Count Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// VULNERABLE: This covenant validates output[0] but allows unlimited additional outputs\r\n// RISK: Attacker can create extra outputs to mint tokens, spam outputs, or extract value\r\ncontract VulnerableCovenantNoOutputLimit(\r\n    pubkey ownerPubKey\r\n) {\r\n    // VULNERABILITY: Only validates output[0], assumes no other outputs exist\r\n    // MISSING: tx.outputs.length check (allows arbitrary extra outputs)\r\n    function spend(sig ownerSig) {\r\n        // Validate authorization\r\n        require(checkSig(ownerSig, ownerPubKey));\r\n        \r\n        // Validate output[0] - covenant continuation\r\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-1",
    "content": "bytes outputLockingBytecode = tx.outputs[0].lockingBytecode;\r\n        require(outputLockingBytecode == inputLockingBytecode);\r\n        \r\n        // Validate output[0] preserves token category\r\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        bytes outputTokenCategory = tx.outputs[0].tokenCategory;\r\n        require(outputTokenCategory == inputTokenCategory);\r\n        \r\n        // Validate output[0] preserves value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        int outputValue = tx.outputs[0].value;\r\n        require(outputValue == inputValue);\r\n        \r\n        // CRITICAL FLAW: No validation of tx.outputs.length\r\n        // Attacker can add outputs[1], outputs[2], outputs[3], etc.\r\n        // The contract only checks output[0], ignoring all others\r\n        // This allows:\r\n        // - Unauthorized token minting (creating new tokens)\r\n        // - Value extraction via additional outputs\r\n        // - Output spam attacks\r\n        // - Fee manipulation via output splitting\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 1: Unauthorized Token Minting\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds NFT with minting capability\r\n// - tokenCategory: 0xAABBCCDD...\r\n// - capability: \"minting\"\r\n// - Intended behavior: Only authorized minting allowed\r\n//\r\n// Attack Transaction:",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-2",
    "content": "// Input:\r\n//   - VulnerableCovenantNoOutputLimit UTXO (NFT with minting capability)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Outputs:\r\n//   - Output 0: Covenant continuation (passes all checks)\r\n//     - Same lockingBytecode ✓\r\n//     - Same tokenCategory ✓\r\n//     - Same value ✓\r\n//     - NFT with minting capability preserved\r\n//   \r\n//   - Output 1: NEWLY MINTED tokens to attacker's address\r\n//     - tokenCategory: 0xAABBCCDD... (same category!)\r\n//     - tokenAmount: 1,000,000 fungible tokens\r\n//     - capability: none (immutable tokens)\r\n//     - Recipient: Attacker's P2PKH address\r\n//   \r\n//   - Output 2: ANOTHER NEWLY MINTED token batch\r\n//     - tokenCategory: 0xAABBCCDD...\r\n//     - tokenAmount: 500,000 fungible tokens\r\n//     - Recipient: Attacker's second address\r\n//\r\n// Result:\r\n// - Covenant continues correctly in output[0]\r\n// - Attacker minted 1,500,000 unauthorized tokens in outputs[1] and [2]\r\n// - Token supply inflated without authorization\r\n// - Minting control BYPASSED\r\n//\r\n// Why it works:\r\n// - Contract never checks: require(tx.outputs.length == 1);\r\n// - Minting capability in output[0] allows creating tokens in other outputs\r\n// - Contract validates output[0] but ignores outputs[1], [2], [3], etc.\r\n// - BCH allows unlimited outputs in a transaction\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 2: Multi-Output Value Extraction\r\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "p2pkh"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-3",
    "content": "//\r\n// Initial State:\r\n// - Contract holds 100,000 sats\r\n// - No tokens involved\r\n// - Intended behavior: Preserve all value in covenant\r\n//\r\n// Attack Transaction:\r\n// Input:\r\n//   - VulnerableCovenantNoOutputLimit UTXO (100,000 sats)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Outputs:\r\n//   - Output 0: Covenant continuation (passes all checks)\r\n//     - Same lockingBytecode ✓\r\n//     - Same tokenCategory ✓ (both empty/none)\r\n//     - value: 100,000 sats ✓\r\n//   \r\n//   - Output 1: Value extraction to attacker\r\n//     - value: 50,000 sats\r\n//     - Recipient: Attacker's address\r\n//   \r\n//   - Output 2: More value extraction\r\n//     - value: 30,000 sats\r\n//     - Recipient: Attacker's second address\r\n//   \r\n//   - Output 3: Even more extraction\r\n//     - value: 19,000 sats\r\n//     - Recipient: Attacker's third address\r\n//\r\n// Wait, how does this work? Output[0] has 100,000 sats but total outputs = 199,000 sats?\r\n//\r\n// Answer: This attack requires ADDITIONAL INPUTS\r\n// \r\n// Modified Attack with Multiple Inputs:\r\n// Inputs:\r\n//   - Input 0: VulnerableCovenantNoOutputLimit UTXO (100,000 sats)\r\n//   - Input 1: Attacker's UTXO (100,000 sats) - provides extra value\r\n//\r\n// Outputs:\r\n//   - Output 0: 100,000 sats to covenant (validates correctly)\r\n//   - Output 1: 99,000 sats to attacker (extracting from Input 1)\r\n//\r\n// Result:\r\n// - Covenant check passes (output[0] preserves input value)\r\n// - But attacker used the transaction to move their own funds\r\n// - This enables fee manipulation and covenant bloating",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-4",
    "content": "//\r\n// More dangerous version - NFT duplication attempt:\r\n// If the covenant holds an NFT, attacker might try:\r\n//   - Output 0: NFT to covenant continuation\r\n//   - Output 1: DUPLICATE NFT to attacker (INVALID - would fail consensus)\r\n//\r\n// However, without output count limits, attacker CAN:\r\n//   - Output 0: NFT to covenant continuation  \r\n//   - Output 1: Different token/BCH to attacker from other inputs\r\n// This allows using covenant transactions as cover for other transfers\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 3: Output Spam / Bloat Attack\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds 10,000 sats\r\n// - Attacker wants to bloat the blockchain\r\n//\r\n// Attack Transaction:\r\n// Input:\r\n//   - VulnerableCovenantNoOutputLimit UTXO (10,000 sats)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Outputs:\r\n//   - Output 0: Covenant continuation (10,000 sats) ✓\r\n//   - Output 1: Dust (546 sats) to random address\r\n//   - Output 2: Dust (546 sats) to random address\r\n//   - Output 3: Dust (546 sats) to random address\r\n//   ... (repeat)\r\n//   - Output 100: Dust (546 sats) to random address\r\n//\r\n// Total outputs: 101\r\n// Total dust outputs: 100\r\n// Additional BCH needed: 100 * 546 = 54,600 sats (from attacker's inputs)\r\n//\r\n// Result:\r\n// - Covenant continues correctly\r\n// - 100 dust outputs created (blockchain spam)\r\n// - Transaction size significantly increased",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-5",
    "content": "// - Network resources wasted\r\n// - UTXO set bloated\r\n//\r\n// Why it works:\r\n// - Contract doesn't limit output count\r\n// - Attacker can add unlimited outputs using additional inputs\r\n// - Covenant transaction used as spam vehicle\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 4: Fee Manipulation via Output Splitting\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds 5,000 sats\r\n// - Transaction fee expected: ~200 sats\r\n//\r\n// Legitimate Transaction (what contract expects):\r\n// Inputs:\r\n//   - Input 0: Covenant UTXO (5,000 sats)\r\n// Outputs:\r\n//   - Output 0: Covenant continuation (4,800 sats)\r\n// Fee: 200 sats (5,000 - 4,800)\r\n//\r\n// Malicious Transaction (output splitting):\r\n// Inputs:\r\n//   - Input 0: Covenant UTXO (5,000 sats)\r\n//   - Input 1: Attacker UTXO (10,000 sats)\r\n// Outputs:\r\n//   - Output 0: Covenant continuation (5,000 sats) ✓ (passes check)\r\n//   - Output 1: 9,000 sats to attacker\r\n//   - Output 2: 500 sats to attacker\r\n//   - Output 3: 300 sats to attacker\r\n// Fee: 200 sats (15,000 - 14,800)\r\n//\r\n// Result:\r\n// - Covenant preserved at 5,000 sats (check passes)\r\n// - Attacker used covenant transaction to split their own funds\r\n// - Multiple outputs created for attacker's purposes\r\n// - Covenant transaction used as a \"free\" transaction builder\r\n//\r\n// Impact:\r\n// - Covenant transactions can be hijacked for unrelated purposes\r\n// - Output count inflation without cost to attacker",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-6",
    "content": "// - Transaction graph analysis becomes misleading\r\n\r\n// ============================================================================\r\n// SECURE VERSION: Explicit Output Count Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// SECURE: This covenant enforces strict output count limits\r\n// PROTECTION: Prevents unauthorized minting, spam, and output manipulation\r\ncontract SecureCovenantWithOutputLimit(\r\n    pubkey ownerPubKey\r\n) {\r\n    // SECURE: Validates signature, output properties, AND output count\r\n    // INCLUDES: Explicit tx.outputs.length validation\r\n    function spend(sig ownerSig) {\r\n        // Step 1: Validate authorization\r\n        require(checkSig(ownerSig, ownerPubKey));\r\n        \r\n        // Step 2: CRITICAL - Validate output count FIRST\r\n        // This prevents ALL unauthorized output creation attacks\r\n        // Only exactly 1 output is allowed (the covenant continuation)\r\n        require(tx.outputs.length == 1);\r\n        \r\n        // WHY CHECK OUTPUT COUNT FIRST?\r\n        // - Prevents wasted computation on output[0] validation if extra outputs exist\r\n        // - Makes attack impossible before validating individual output properties\r\n        // - Clear fail-fast security principle\r\n        \r\n        // Step 3: Validate output[0] lockingBytecode (prevents code injection)\r\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        bytes outputLockingBytecode = tx.outputs[0].lockingBytecode;",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-7",
    "content": "require(outputLockingBytecode == inputLockingBytecode);\r\n        \r\n        // Step 4: Validate output[0] tokenCategory (prevents token substitution)\r\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        bytes outputTokenCategory = tx.outputs[0].tokenCategory;\r\n        require(outputTokenCategory == inputTokenCategory);\r\n        \r\n        // Step 5: Validate output[0] value (prevents value extraction)\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        int outputValue = tx.outputs[0].value;\r\n        require(outputValue == inputValue);\r\n        \r\n        // RESULT: All output-based attacks are now IMPOSSIBLE\r\n        // - Unauthorized minting: BLOCKED (no output[1] for new tokens)\r\n        // - Multi-output extraction: BLOCKED (only 1 output allowed)\r\n        // - Output spam: BLOCKED (cannot create extra outputs)\r\n        // - Fee manipulation: BLOCKED (no output splitting possible)\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// ALTERNATIVE PATTERN: Multiple Outputs with Explicit Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// ALTERNATIVE: Covenant that intentionally allows multiple outputs\r\n// USE CASE: Covenant + change output, or covenant + withdrawal\r\n// CRITICAL: Must validate EVERY output explicitly\r\ncontract SecureCovenantMultipleOutputs(\r\n    pubkey ownerPubKey,\r\n    pubkey recipientPubKey  // Authorized withdrawal recipient",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-8",
    "content": ") {\r\n    // Pattern: Covenant continuation + withdrawal output\r\n    // REQUIREMENT: Validate ALL outputs, not just some\r\n    function spendWithWithdrawal(sig ownerSig, int withdrawalAmount) {\r\n        // Step 1: Validate authorization\r\n        require(checkSig(ownerSig, ownerPubKey));\r\n        \r\n        // Step 2: CRITICAL - Validate EXACT output count\r\n        // This covenant intentionally creates 2 outputs\r\n        // Must enforce exactly 2, no more, no less\r\n        require(tx.outputs.length == 2);\r\n        \r\n        // Step 3: Validate output[0] - covenant continuation\r\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);\r\n        \r\n        // Step 4: Validate output[0] preserves tokens\r\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(tx.outputs[0].tokenCategory == inputTokenCategory);\r\n        \r\n        // Step 5: Validate output[0] value accounts for withdrawal\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        int remainingValue = inputValue - withdrawalAmount;\r\n        require(tx.outputs[0].value == remainingValue);\r\n        \r\n        // Step 6: Validate output[1] - withdrawal to authorized recipient\r\n        // Build the expected P2PKH locking bytecode for recipient\r\n        bytes20 recipientPkh = hash160(recipientPubKey);\r\n        bytes expectedWithdrawalBytecode = new LockingBytecodeP2PKH(recipientPkh);",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "covenant",
      "p2pkh",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-9",
    "content": "require(tx.outputs[1].lockingBytecode == expectedWithdrawalBytecode);\r\n        \r\n        // Step 7: Validate output[1] receives exactly the withdrawal amount\r\n        require(tx.outputs[1].value == withdrawalAmount);\r\n        \r\n        // Step 8: Validate output[1] has no tokens (BCH only withdrawal)\r\n        require(tx.outputs[1].tokenCategory == 0x);\r\n        \r\n        // Step 9: Validate withdrawal amount is reasonable\r\n        require(withdrawalAmount > 0);  // Must withdraw something\r\n        require(withdrawalAmount < inputValue);  // Cannot withdraw everything\r\n        require(remainingValue >= 1000);  // Covenant must retain minimum balance\r\n        \r\n        // RESULT: Two-output pattern is SECURE\r\n        // - Output count: FIXED at 2\r\n        // - Output[0]: Fully validated covenant continuation\r\n        // - Output[1]: Fully validated withdrawal to authorized recipient\r\n        // - No additional outputs possible (would fail tx.outputs.length check)\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// EXPLANATION: Why Output Count Validation Is Critical\r\n// ============================================================================\r\n\r\n// OUTPUT COUNT VALIDATION PRINCIPLE\r\n// ----------------------------------\r\n// The tx.outputs array in Bitcoin Cash can contain 0 to N outputs (practical limit ~1000s).\r\n// Without explicit length validation, a covenant that checks output[0] has NO CONTROL\r\n// over outputs[1], [2], [3], etc.",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-10",
    "content": "//\r\n// This creates multiple attack vectors:\r\n//\r\n// 1. UNAUTHORIZED MINTING\r\n//    - If covenant holds minting capability NFT\r\n//    - Output[0] preserves the minting NFT (passes validation)\r\n//    - Outputs[1..N] create unlimited new tokens using that capability\r\n//    - Token supply inflated without authorization\r\n//\r\n// 2. VALUE EXTRACTION VIA ADDITIONAL INPUTS\r\n//    - Attacker adds their own UTXOs as additional inputs\r\n//    - Output[0] satisfies covenant validation\r\n//    - Outputs[1..N] send attacker's funds wherever they want\r\n//    - Covenant transaction hijacked for unrelated purposes\r\n//\r\n// 3. BLOCKCHAIN SPAM\r\n//    - Output[0] satisfies covenant\r\n//    - Outputs[1..100] are dust outputs to random addresses\r\n//    - UTXO set bloated\r\n//    - Network resources wasted\r\n//\r\n// 4. FEE MANIPULATION\r\n//    - Multiple outputs change transaction size\r\n//    - Can affect fee calculations if covenant attempts fee validation\r\n//    - Output splitting used to manipulate transaction structure\r\n\r\n// IMPLEMENTATION REQUIREMENTS\r\n// ----------------------------\r\n// Every covenant MUST include ONE of these patterns:\r\n//\r\n// Pattern A: Fixed Output Count (most common)\r\n//   require(tx.outputs.length == 1);  // Single output only\r\n//   require(tx.outputs.length == 2);  // Exactly two outputs\r\n//   require(tx.outputs.length == 3);  // Exactly three outputs\r\n//\r\n// Pattern B: Maximum Output Count (rare, usually wrong)\r\n//   require(tx.outputs.length <= 2);  // At most two outputs\r\n//   WARNING: Usually you want EXACT count, not maximum",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-11",
    "content": "//   Maximum allows attacker to omit expected outputs\r\n//\r\n// Pattern C: Conditional Output Count (complex use cases)\r\n//   if (withdrawalMode) {\r\n//       require(tx.outputs.length == 2);  // Covenant + withdrawal\r\n//   } else {\r\n//       require(tx.outputs.length == 1);  // Covenant only\r\n//   }\r\n\r\n// VALIDATION ORDER MATTERS\r\n// -------------------------\r\n// Check output count BEFORE validating individual outputs:\r\n//\r\n// CORRECT ORDER:\r\n//   require(tx.outputs.length == 1);  // Check count first\r\n//   require(tx.outputs[0].value == inputValue);  // Then validate output\r\n//\r\n// WHY?\r\n// - Fail fast if wrong output count\r\n// - Avoid wasting gas/computation on output validation\r\n// - Clear security boundary\r\n//\r\n// INCORRECT ORDER:\r\n//   require(tx.outputs[0].value == inputValue);  // Validates output[0]\r\n//   require(tx.outputs.length == 1);  // But output[1], [2] already exist!\r\n//\r\n// While this still works (transaction fails), it's less clear and wastes computation.\r\n\r\n// COMMON MISTAKES\r\n// ----------------\r\n// MISTAKE 1: Assuming output count\r\n//   // No output count check\r\n//   require(tx.outputs[0].value == inputValue);\r\n//   // WRONG: Allows unlimited additional outputs\r\n//\r\n// MISTAKE 2: Using >= instead of ==\r\n//   require(tx.outputs.length >= 1);\r\n//   // WRONG: Allows unlimited outputs beyond first one\r\n//\r\n// MISTAKE 3: Using <= without validating all outputs\r\n//   require(tx.outputs.length <= 2);\r\n//   require(tx.outputs[0].value == inputValue);\r\n//   // WRONG: If 2 outputs exist, output[1] is unvalidated",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-12",
    "content": "//   // If 1 output exists, might be missing expected output\r\n//\r\n// MISTAKE 4: Off-by-one errors\r\n//   require(tx.outputs.length == 2);\r\n//   require(tx.outputs[0].lockingBytecode == ...);\r\n//   require(tx.outputs[2].lockingBytecode == ...);\r\n//   // WRONG: outputs[2] doesn't exist (0-indexed, only 0 and 1 exist)\r\n//   // Should be: tx.outputs[1]\r\n\r\n// SPECIAL CASE: Minting Capability NFTs\r\n// --------------------------------------\r\n// Covenants holding NFTs with \"minting\" capability require EXTRA vigilance:\r\n//\r\n// DANGER: Minting capability allows creating new tokens in ANY output\r\n//   - Output[0]: Covenant continuation with minting NFT ✓\r\n//   - Output[1]: Newly minted tokens (UNAUTHORIZED)\r\n//\r\n// PROTECTION: Strict output count validation\r\n//   require(tx.outputs.length == 1);\r\n//\r\n// ALTERNATIVE: If minting is intended, validate the minting output explicitly\r\n//   require(tx.outputs.length == 2);\r\n//   require(tx.outputs[0].lockingBytecode == ...);  // Covenant continuation\r\n//   require(tx.outputs[1].lockingBytecode == ...);  // Authorized mint recipient\r\n//   require(tx.outputs[1].tokenCategory == ...);    // Correct category\r\n//   require(tx.outputs[1].tokenAmount == ...);      // Authorized amount\r\n\r\n// ============================================================================\r\n// DEPLOYMENT CHECKLIST FOR OUTPUT COUNT VALIDATION\r\n// ============================================================================\r\n//\r\n// Before deploying a covenant contract, verify:\r\n//",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-13",
    "content": "// [ ] Output count validation is present: require(tx.outputs.length == N)\r\n// [ ] Output count uses == (equality), not >= or <= unless specifically needed\r\n// [ ] Output count check occurs BEFORE individual output validation\r\n// [ ] If using <= or >=, ALL possible outputs are validated\r\n// [ ] Output indices match output count (0-indexed, no off-by-one errors)\r\n// [ ] Every output in the count is fully validated:\r\n//     [ ] lockingBytecode\r\n//     [ ] value\r\n//     [ ] tokenCategory (if tokens involved)\r\n//     [ ] tokenAmount (if fungible tokens)\r\n//     [ ] nftCommitment (if NFTs with data)\r\n//     [ ] tokenCapability (if minting/mutable NFTs)\r\n// [ ] Special case: If covenant holds minting capability, minting is controlled\r\n// [ ] Test case: Transaction with extra outputs beyond count (should FAIL)\r\n// [ ] Test case: Transaction with fewer outputs than count (should FAIL)\r\n// [ ] Test case: Transaction with exact output count (should SUCCEED)\r\n\r\n// ============================================================================\r\n// TESTING RECOMMENDATIONS\r\n// ============================================================================\r\n//\r\n// Test Cases for VULNERABLE version (demonstrates vulnerability):\r\n// 1. Transaction with 1 output (covenant continuation)\r\n//    Expected: SUCCEEDS (normal operation)\r\n//\r\n// 2. Transaction with 2 outputs (covenant + unauthorized output)\r\n//    Expected: SUCCEEDS (VULNERABILITY - should fail but doesn't)\r\n//\r\n// 3. Transaction with 10 outputs (covenant + spam outputs)",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-14",
    "content": "//    Expected: SUCCEEDS (VULNERABILITY - spam allowed)\r\n//\r\n// 4. If covenant holds minting NFT: Transaction with unauthorized minting\r\n//    Expected: SUCCEEDS (VULNERABILITY - unauthorized minting)\r\n//\r\n// Test Cases for SECURE version (should PASS):\r\n// 1. Transaction with 1 output (covenant continuation)\r\n//    Expected: SUCCEEDS (valid transaction)\r\n//\r\n// 2. Transaction with 2 outputs (covenant + unauthorized output)\r\n//    Expected: FAILS (output count validation rejects it)\r\n//\r\n// 3. Transaction with 0 outputs\r\n//    Expected: FAILS (output count validation rejects it)\r\n//\r\n// 4. Transaction with 10 outputs\r\n//    Expected: FAILS (output count validation rejects it)\r\n//\r\n// Test Cases for MULTI-OUTPUT version:\r\n// 1. Transaction with exactly 2 outputs (both validated)\r\n//    Expected: SUCCEEDS (valid transaction)\r\n//\r\n// 2. Transaction with 1 output (missing withdrawal output)\r\n//    Expected: FAILS (output count is wrong)\r\n//\r\n// 3. Transaction with 3 outputs (extra unauthorized output)\r\n//    Expected: FAILS (output count is wrong)\r\n//\r\n// 4. Transaction with 2 outputs but wrong withdrawal recipient\r\n//    Expected: FAILS (output[1] validation fails)\r\n\r\n// ============================================================================\r\n// REAL-WORLD IMPACT\r\n// ============================================================================\r\n//\r\n// Historical Examples (hypothetical for demonstration):\r\n//\r\n// Scenario: DAO-style covenant without output count validation\r\n// - Covenant holds 1,000,000 sats + minting capability NFT",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_output_limit.cash-15",
    "content": "// - Intended: Controlled token distribution\r\n// - Attack: Attacker creates 100 outputs, minting 10,000 tokens each\r\n// - Result: 1,000,000 unauthorized tokens minted\r\n// - Impact: Token value destroyed, governance compromised\r\n//\r\n// Scenario: Escrow covenant without output count validation  \r\n// - Covenant holds 500,000 sats for conditional release\r\n// - Intended: Single release to authorized party\r\n// - Attack: Attacker adds 50 dust outputs in the release transaction\r\n// - Result: UTXO set bloated, covenant transaction used for spam\r\n// - Impact: Network degradation, covenant reputation damaged\r\n//\r\n// LESSON: Output count validation is NOT optional.\r\n// It is a CRITICAL security requirement for ALL covenants.\r\n\r\n// ============================================================================\r\n// END OF FILE\r\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_output_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-0",
    "content": "// ANTI-PATTERN: Missing Token Amount Validation\n// VULNERABILITY: Unvalidated tokenAmount enables token duplication and value extraction\n// ATTACK VECTOR: Token inflation, amount manipulation, accounting bypass, supply violation\n//\n// This file demonstrates the critical vulnerability of failing to validate\n// tokenAmount on transaction outputs. While developers often validate tokenCategory\n// (which token), they frequently forget to validate tokenAmount (how many tokens).\n// This oversight enables attackers to duplicate tokens, inflate amounts, and\n// violate supply constraints without any minting authority.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Missing Token Amount Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract validates token category but NOT token amount\n// RISK: Attackers can change tokenAmount values to duplicate or extract tokens\ncontract VulnerableTokenTransferNoAmountValidation(\n    pubkey ownerPubKey,\n    bytes tokenCategory,\n    bytes recipientBytecode\n) {\n    // VULNERABILITY: Validates category and recipient but not amount\n    // MISSING: Explicit tokenAmount validation\n    // MISSING: Token conservation check (input amount == output amount)\n    function transfer(sig ownerSig) {\n        // Validate authorization",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-1",
    "content": "require(checkSig(ownerSig, ownerPubKey));\n        \n        // Validate output recipient\n        require(tx.outputs[0].lockingBytecode == recipientBytecode);\n        \n        // Validate output has correct token category\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        \n        // CRITICAL FLAW: Never validates tx.outputs[0].tokenAmount\n        // Contract assumes:\n        // - \"If category is correct, amount must be correct\"\n        // - \"Consensus will enforce amount conservation\"\n        // - \"Tokens can't be duplicated without minting capability\"\n        //\n        // Reality:\n        // - Category check only validates WHICH token\n        // - Amount can be ANY value attacker chooses\n        // - Consensus does NOT enforce amount conservation across inputs/outputs\n        // - Tokens CAN be duplicated by manipulating output amounts\n        //\n        // Attacker can:\n        // - Inflate output tokenAmount beyond input amount\n        // - Split tokens across multiple outputs (if no output count check)\n        // - Create tokens from nothing (if no input tracking)\n        // - Violate supply constraints\n    }\n}\n\n// ============================================================================\n// UNDERSTANDING THE VULNERABILITY: Consensus vs Covenant Validation\n// ============================================================================\n//\n// CRITICAL CONCEPT: What BCH Consensus DOES and DOES NOT Validate\n// ----------------------------------------------------------------",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-2",
    "content": "// \n// BCH Consensus Rules for CashTokens:\n// ✓ DOES validate: Sum of input tokenAmounts >= Sum of output tokenAmounts (per category)\n// ✓ DOES validate: Cannot create tokens without minting capability\n// ✓ DOES validate: tokenCategory matches genesis transaction\n// ✓ DOES validate: Minting capability is properly transferred\n//\n// ✗ DOES NOT validate: Output tokenAmount matches contract expectations\n// ✗ DOES NOT validate: Specific distribution of tokens across outputs\n// ✗ DOES NOT validate: Individual output amounts (only total conservation)\n//\n// THE VULNERABILITY:\n// If contract has: Input with 1000 tokens\n// Consensus allows:\n//   - Output[0]: 1000 tokens ✓ (total = 1000)\n//   - Output[0]: 500 tokens + Output[1]: 500 tokens ✓ (total = 1000)\n//   - Output[0]: 0 tokens + Output[1]: 1000 tokens ✓ (total = 1000)\n//   - Output[0]: 10,000 tokens ✗ (total = 10,000 > input, INVALID)\n//\n// But if contract only checks tokenCategory on output[0]:\n//   - Attacker can set output[0].tokenAmount = 0\n//   - Attacker routes all 1000 tokens to output[1] (unvalidated)\n//   - Contract sees: output[0].tokenCategory == expected ✓\n//   - Contract never checks: output[0].tokenAmount\n//   - Result: Recipient gets 0 tokens instead of 1000!\n\n// ============================================================================\n// ATTACK SCENARIO 1: Token Amount Inflation via Multi-Output Distribution\n// ============================================================================\n//\n// Setup:\n// - Contract holds 1,000 fungible tokens",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-3",
    "content": "// - Intended: Transfer 1,000 tokens to authorized recipient\n// - Contract validates tokenCategory but not tokenAmount\n//\n// Legitimate Transaction (intended):\n// Inputs:\n//   [0] Contract UTXO (5,000 sats + 1,000 tokens of category 0xAABB...)\n//\n// Outputs:\n//   [0] 5,000 sats + 1,000 tokens to recipient (0xAABB...)\n//\n// ATTACK: Inflate Recipient Amount, Steal Remainder\n// Inputs:\n//   [0] Contract UTXO (5,000 sats + 1,000 tokens of category 0xAABB...)\n//   [1] Attacker's UTXO (1,000 sats, no tokens)\n//\n// Outputs:\n//   [0] 5,000 sats + 100 tokens to recipient (0xAABB...) ← REDUCED\n//       - lockingBytecode: recipientBytecode ✓ (passes check)\n//       - tokenCategory: 0xAABB... ✓ (passes check)\n//       - tokenAmount: 100 ✗ (NOT CHECKED - reduced from 1,000!)\n//   \n//   [1] 1,000 sats + 900 tokens to attacker's address (0xAABB...)\n//       - Attacker steals remaining 900 tokens\n//       - Contract never validates this output\n//\n// Result:\n// - Consensus validates: 1,000 input tokens = 100 + 900 output tokens ✓\n// - Contract validates: output[0] has correct category ✓\n// - Contract NEVER validates: output[0] has correct amount\n// - Recipient receives only 100 tokens instead of 1,000\n// - Attacker steals 900 tokens (90% theft)\n//\n// Why it works:\n// - Contract only checks: tx.outputs[0].tokenCategory == tokenCategory\n// - Never checks: tx.outputs[0].tokenAmount == expectedAmount\n// - Never checks: tx.outputs.length (allows extra outputs)\n// - Attacker freely distributes tokens across outputs",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-4",
    "content": "// ============================================================================\n// ATTACK SCENARIO 2: Complete Token Theft via Zero-Amount Output\n// ============================================================================\n//\n// Setup:\n// - DeFi vault holds 100,000 fungible tokens\n// - Withdrawal function checks category but not amount\n// - User entitled to withdraw their tokens\n//\n// Vulnerable Vault Contract:\n//\n// contract VulnerableVault(pubkey userPubKey, bytes tokenCategory) {\n//     function withdraw(sig userSig, bytes userAddress) {\n//         require(checkSig(userSig, userPubKey));\n//         require(tx.outputs[0].lockingBytecode == userAddress);\n//         require(tx.outputs[0].tokenCategory == tokenCategory);\n//         // MISSING: tokenAmount validation\n//         // MISSING: output count validation\n//     }\n// }\n//\n// Attack Transaction:\n// Inputs:\n//   [0] Vault UTXO (10,000 sats + 100,000 tokens)\n//\n// Outputs:\n//   [0] 546 sats + 0 tokens to user address (category 0xAABB...)\n//       - lockingBytecode: userAddress ✓\n//       - tokenCategory: 0xAABB... ✓\n//       - tokenAmount: 0 ✗ (ZERO - but not checked!)\n//   \n//   [1] 9,454 sats + 100,000 tokens to attacker's address\n//       - All tokens stolen\n//\n// Result:\n// - User receives 0 tokens (just dust BCH)\n// - Attacker receives all 100,000 tokens\n// - Vault drained completely\n// - User has no recourse\n//\n// Consensus Validation:\n// - Input: 100,000 tokens\n// - Outputs: 0 + 100,000 = 100,000 tokens ✓ (conservation holds)",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-5",
    "content": "// - Transaction valid from consensus perspective\n//\n// Why it works:\n// - tokenCategory check passes (output[0] has correct category)\n// - But tokenAmount = 0 (empty token output, just has category set)\n// - BCH allows outputs with category but zero amount\n// - Contract never validates amount > 0 or amount == expected\n\n// ============================================================================\n// ATTACK SCENARIO 3: Accounting Bypass in Token Escrow\n// ============================================================================\n//\n// Setup:\n// - Escrow holds tokens for atomic swap\n// - Party A deposits 5,000 tokens\n// - Party B should receive 5,000 tokens after conditions met\n// - Contract tracks expected amount but doesn't validate output\n//\n// Vulnerable Escrow:\n//\n// contract VulnerableEscrow(\n//     pubkey partyAPubKey,\n//     pubkey partyBPubKey,\n//     bytes tokenCategory,\n//     int expectedAmount  // 5,000 tokens\n// ) {\n//     function release(sig partyASig, bytes partyBAddress) {\n//         require(checkSig(partyASig, partyAPubKey));\n//         require(tx.outputs[0].lockingBytecode == partyBAddress);\n//         require(tx.outputs[0].tokenCategory == tokenCategory);\n//         // Contract KNOWS expectedAmount = 5,000\n//         // But never validates: tx.outputs[0].tokenAmount == expectedAmount\n//     }\n// }\n//\n// Attack by Party A (malicious depositor):\n// Inputs:\n//   [0] Escrow UTXO (5,000 sats + 5,000 tokens)\n//\n// Outputs:\n//   [0] 546 sats + 1,000 tokens to Party B (category correct)",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-6",
    "content": "//   [1] 4,454 sats + 4,000 tokens to Party A (refund)\n//\n// Result:\n// - Party B receives only 1,000 tokens (instead of 5,000)\n// - Party A recovers 4,000 tokens (80% refund)\n// - Escrow guarantee violated\n// - Atomic swap fails (Party B loses 80% of value)\n//\n// Impact:\n// - Trust in escrow destroyed\n// - Party B suffers financial loss\n// - Reputation damage\n// - Legal liability\n\n// ============================================================================\n// ATTACK SCENARIO 4: NFT vs Fungible Token Confusion\n// ============================================================================\n//\n// Setup:\n// - Contract intended for NFT transfer (tokenAmount should be 0 for NFTs)\n// - Attacker converts to fungible token representation\n//\n// NFT Properties:\n// - tokenCategory: 0xNFT... (specific NFT collection)\n// - tokenAmount: 0 (NFTs have no \"amount\", just commitment/capability)\n// - nftCommitment: <NFT data>\n// - tokenCapability: varies\n//\n// Fungible Token Properties:\n// - tokenCategory: 0xFUNG... (fungible token)\n// - tokenAmount: N (quantity of tokens)\n// - nftCommitment: 0x (empty)\n// - tokenCapability: 0x (immutable)\n//\n// Vulnerable NFT Contract:\n//\n// contract VulnerableNFT(pubkey ownerPubKey, bytes nftCategory) {\n//     function transfer(sig ownerSig, bytes recipient) {\n//         require(checkSig(ownerSig, ownerPubKey));\n//         require(tx.outputs[0].lockingBytecode == recipient);\n//         require(tx.outputs[0].tokenCategory == nftCategory);\n//         // Assumes NFT (tokenAmount = 0)",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-7",
    "content": "//         // But never validates tokenAmount == 0\n//     }\n// }\n//\n// Attack: Convert NFT to Fungible Tokens\n// If attacker has minting capability for the category:\n// Inputs:\n//   [0] Contract UTXO (NFT with category 0xNFT..., amount 0)\n//   [1] Minting UTXO (same category, minting capability)\n//\n// Outputs:\n//   [0] NFT to recipient (category 0xNFT..., amount 0)\n//   [1] 1,000,000 fungible tokens (category 0xNFT..., amount 1,000,000)\n//\n// Result:\n// - NFT transferred correctly (output[0] validated)\n// - But 1,000,000 fungible tokens also created\n// - Same tokenCategory, different tokenAmount\n// - NFT collection polluted with fungible tokens\n// - Category semantics violated\n//\n// Note: This requires minting capability, but demonstrates why\n// tokenAmount validation matters even for \"NFT-only\" contracts\n\n// ============================================================================\n// SECURE VERSION: Explicit Token Amount Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract validates tokenCategory AND tokenAmount\n// PROTECTION: Prevents token duplication, amount manipulation, and theft\ncontract SecureTokenTransferWithAmountValidation(\n    pubkey ownerPubKey,\n    bytes tokenCategory,\n    bytes recipientBytecode,\n    int expectedAmount  // Exact number of tokens to transfer\n) {\n    // SECURE: Validates category, amount, recipient, and output count\n    function transfer(sig ownerSig) {\n        // Step 1: Validate authorization",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-8",
    "content": "require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 1 output\n        // Prevents token splitting across multiple outputs\n        // Ensures all tokens go to validated recipient\n        require(tx.outputs.length == 1);\n        \n        // Step 3: Validate output recipient\n        require(tx.outputs[0].lockingBytecode == recipientBytecode);\n        \n        // Step 4: CRITICAL - Validate token category\n        // Ensures correct token type (which token)\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        \n        // Step 5: CRITICAL - Validate token amount\n        // Ensures correct token quantity (how many tokens)\n        // This is the key protection against amount manipulation\n        require(tx.outputs[0].tokenAmount == expectedAmount);\n        \n        // Step 6: Validate no minting capability leak\n        // Tokens transferred should be immutable\n        require(tx.outputs[0].tokenCapability == 0x);\n        \n        // RESULT: Complete token transfer validation\n        // - Category validated (correct token type)\n        // - Amount validated (correct quantity)\n        // - Recipient validated (correct destination)\n        // - Output count validated (no splitting)\n        // - Capability validated (no minting leak)\n        //\n        // Attacks now IMPOSSIBLE:\n        // - Token amount inflation: BLOCKED (amount check)\n        // - Token theft via zero-amount: BLOCKED (amount check)\n        // - Token splitting: BLOCKED (output count check)",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-9",
    "content": "// - Wrong token type: BLOCKED (category check)\n        // - Capability leak: BLOCKED (capability check)\n    }\n}\n\n// ============================================================================\n// ADVANCED PATTERN: Input-Output Amount Conservation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ADVANCED: Covenant that preserves exact token amounts from input to output\n// USE CASE: Token covenants, vesting, escrow, custody\ncontract SecureTokenCovenantAmountConservation(\n    pubkey ownerPubKey\n) {\n    // Pattern: Preserve exact token amounts across covenant transitions\n    function transfer(sig ownerSig) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Enforce exactly 1 output\n        require(tx.outputs.length == 1);\n        \n        // Step 3: Read input token properties\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        int inputTokenAmount = tx.inputs[this.activeInputIndex].tokenAmount;\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        \n        // Step 4: CRITICAL - Validate output preserves token category\n        require(tx.outputs[0].tokenCategory == inputTokenCategory);\n        \n        // Step 5: CRITICAL - Validate output preserves token amount\n        // This enforces conservation: output amount MUST equal input amount\n        // No tokens can be created, destroyed, or stolen",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-10",
    "content": "require(tx.outputs[0].tokenAmount == inputTokenAmount);\n        \n        // Step 6: Validate covenant continuation\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);\n        \n        // Step 7: Validate BCH amount preservation\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        require(tx.outputs[0].value == inputValue);\n        \n        // RESULT: Perfect token and BCH conservation\n        // - Input tokenAmount = Output tokenAmount (exact preservation)\n        // - Input tokenCategory = Output tokenCategory (no substitution)\n        // - Input value = Output value (BCH preserved)\n        // - Covenant continues with identical state\n        // - No value leakage possible\n    }\n}\n\n// ============================================================================\n// BEST PRACTICE: Multi-Output with Explicit Amount Distribution\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// BEST PRACTICE: Contract distributing tokens to multiple recipients\n// Validates EVERY output amount explicitly\ncontract SecureTokenDistributionMultiOutput(\n    pubkey ownerPubKey,\n    bytes tokenCategory,\n    bytes recipient1Bytecode,\n    bytes recipient2Bytecode,\n    int amount1,  // Exact amount for recipient 1\n    int amount2   // Exact amount for recipient 2\n) {\n    // Pattern: Split tokens across multiple outputs with full validation\n    function distribute(sig ownerSig) {\n        // Step 1: Validate authorization",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-11",
    "content": "require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 2 outputs\n        require(tx.outputs.length == 2);\n        \n        // Step 3: Calculate total tokens being distributed\n        int totalDistributed = amount1 + amount2;\n        \n        // Step 4: Validate output[0] - First recipient\n        require(tx.outputs[0].lockingBytecode == recipient1Bytecode);\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n        require(tx.outputs[0].tokenAmount == amount1);  // Exact amount\n        require(tx.outputs[0].tokenCapability == 0x);\n        \n        // Step 5: Validate output[1] - Second recipient\n        require(tx.outputs[1].lockingBytecode == recipient2Bytecode);\n        require(tx.outputs[1].tokenCategory == tokenCategory);\n        require(tx.outputs[1].tokenAmount == amount2);  // Exact amount\n        require(tx.outputs[1].tokenCapability == 0x);\n        \n        // Step 6: OPTIONAL - Validate against input amount\n        // Ensure we're not distributing more than we have\n        int inputTokenAmount = tx.inputs[this.activeInputIndex].tokenAmount;\n        require(totalDistributed <= inputTokenAmount);\n        \n        // Step 7: STRICT VERSION - Require exact conservation\n        // require(totalDistributed == inputTokenAmount);\n        // This ensures no tokens are lost or destroyed\n        \n        // RESULT: Controlled multi-output distribution\n        // - Each output amount explicitly validated\n        // - Total distribution tracked",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-12",
    "content": "// - No unauthorized recipients\n        // - No amount manipulation\n        // - Full accounting transparency\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Token Amount Validation Is Critical\n// ============================================================================\n\n// THE CATEGORY vs AMOUNT DISTINCTION\n// -----------------------------------\n// Many developers think: \"If I validate tokenCategory, tokens are secured\"\n//\n// WRONG ASSUMPTION:\n// - tokenCategory only identifies WHICH token (like checking coin type)\n// - tokenAmount specifies HOW MANY tokens (like checking coin quantity)\n// - Category check alone is like verifying \"yes, these are dollars\"\n// - But not checking if it's $1 or $1,000,000\n//\n// CORRECT UNDERSTANDING:\n// - tokenCategory: \"This output contains XYZ tokens\" (identity)\n// - tokenAmount: \"This output contains 1,000 XYZ tokens\" (quantity)\n// - BOTH must be validated for complete security\n//\n// Analogy:\n// - Checking only category = checking the currency type (USD vs EUR)\n// - Checking only amount = checking the number (1000) but not currency\n// - Need both = checking \"1000 USD\" (complete specification)\n\n// WHY CONSENSUS DOESN'T PROTECT YOU\n// ----------------------------------\n// BCH consensus validates token conservation ACROSS THE ENTIRE TRANSACTION:\n//   Sum(input amounts) >= Sum(output amounts) per category\n//\n// But consensus does NOT validate:\n// - How tokens are DISTRIBUTED across outputs",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-13",
    "content": "// - Which SPECIFIC output gets which amount\n// - Whether amounts match CONTRACT EXPECTATIONS\n//\n// Example:\n// Input: 1000 tokens\n// Valid consensus scenarios:\n//   - Output[0]: 1000 → OK\n//   - Output[0]: 500, Output[1]: 500 → OK\n//   - Output[0]: 0, Output[1]: 1000 → OK (but probably wrong for contract!)\n//   - Output[0]: 999, Output[1]: 1 → OK (but probably theft!)\n//\n// Contract MUST specify which output gets which amount\n// Consensus won't enforce contract's intent\n\n// FUNGIBLE vs NON-FUNGIBLE TOKENS\n// --------------------------------\n// Fungible Tokens (FT):\n// - tokenAmount > 0 (represents quantity)\n// - Divisible and interchangeable\n// - Amount matters (1000 tokens vs 1 token)\n// - MUST validate tokenAmount\n//\n// Non-Fungible Tokens (NFT):\n// - tokenAmount == 0 (always zero for NFTs)\n// - Unique, identified by commitment and capability\n// - Amount doesn't vary (always 0)\n// - Should validate tokenAmount == 0 to prevent FT pollution\n//\n// Edge Case: Categories can have BOTH FTs and NFTs\n// - Same category can have NFTs (amount=0) and FTs (amount>0)\n// - Contract must specify which type expected\n// - Validate amount accordingly\n\n// TOKEN AMOUNT VALIDATION LAYERS\n// -------------------------------\n// Layer 1: Category Check (which token)\n//   require(tx.outputs[N].tokenCategory == expectedCategory);\n//\n// Layer 2: Amount Check (how many tokens)\n//   require(tx.outputs[N].tokenAmount == expectedAmount);\n//\n// Layer 3: Conservation Check (total preserved)\n//   require(sumOutputAmounts == sumInputAmounts);",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-14",
    "content": "//\n// Layer 4: Distribution Check (correct allocation)\n//   require(output[0].amount == amount1);\n//   require(output[1].amount == amount2);\n//\n// For security, implement ALL applicable layers\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR TOKEN AMOUNT VALIDATION\n// ============================================================================\n\n// PRINCIPLE 1: ALWAYS VALIDATE BOTH CATEGORY AND AMOUNT\n// ------------------------------------------------------\n// Never validate category without amount (for fungible tokens)\n// Both are required for complete token specification\n// Example:\n//   require(tx.outputs[0].tokenCategory == expectedCategory);\n//   require(tx.outputs[0].tokenAmount == expectedAmount);\n\n// PRINCIPLE 2: VALIDATE EVERY OUTPUT\n// -----------------------------------\n// If transaction has N outputs with tokens, validate all N\n// Partial validation (e.g., only output[0]) allows theft via others\n// Use output count enforcement + individual validation\n\n// PRINCIPLE 3: ENFORCE CONSERVATION FOR COVENANTS\n// ------------------------------------------------\n// For token covenants, input amount should equal output amount\n// Prevents value leakage across covenant transitions\n// Example:\n//   int inputAmount = tx.inputs[this.activeInputIndex].tokenAmount;\n//   require(tx.outputs[0].tokenAmount == inputAmount);\n\n// PRINCIPLE 4: ZERO-AMOUNT CHECK FOR NFTS\n// ----------------------------------------\n// For NFT-only contracts, explicitly require amount == 0",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-15",
    "content": "// Prevents fungible token pollution\n// Example:\n//   require(tx.outputs[0].tokenAmount == 0);  // NFT, not FT\n\n// PRINCIPLE 5: VALIDATE TOTAL DISTRIBUTION\n// -----------------------------------------\n// For multi-output distributions, validate sum equals input\n// Prevents over-distribution or under-distribution\n// Example:\n//   int total = amount1 + amount2 + amount3;\n//   require(total == inputAmount);\n\n// PRINCIPLE 6: USE EXACT EQUALITY, NOT RANGES\n// --------------------------------------------\n// Use == for amount checks, not >= or <=\n// Ranges allow manipulation within bounds\n// Example:\n//   require(tx.outputs[0].tokenAmount == 1000);  // Exact\n//   // NOT: require(tx.outputs[0].tokenAmount >= 1000);  // Allows >1000\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Validating Category Without Amount\n// ----------------------------------------------\n// WRONG:\n//   function transfer(sig ownerSig) {\n//       require(checkSig(ownerSig, ownerPubKey));\n//       require(tx.outputs[0].tokenCategory == tokenCategory);\n//       // Missing: tokenAmount validation\n//   }\n//\n// CORRECT:\n//   function transfer(sig ownerSig) {\n//       require(checkSig(ownerSig, ownerPubKey));\n//       require(tx.outputs[0].tokenCategory == tokenCategory);\n//       require(tx.outputs[0].tokenAmount == expectedAmount);\n//   }\n\n// MISTAKE 2: Using >= Instead of == for Amount",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-16",
    "content": "// ---------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenAmount >= 1000);\n//\n// WHY WRONG:\n// - Allows output to have MORE than expected (e.g., 10,000 tokens)\n// - If multiple outputs, attacker can inflate one, reduce another\n// - Breaks accounting invariants\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenAmount == 1000);  // Exact amount\n\n// MISTAKE 3: Not Checking Output Count\n// -------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenAmount == 1000);\n//   // Output[1], [2], [3] could exist with more tokens\n//\n// CORRECT:\n//   require(tx.outputs.length == 1);  // Enforce single output\n//   require(tx.outputs[0].tokenAmount == 1000);\n\n// MISTAKE 4: Forgetting Conservation in Multi-Output\n// ---------------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenAmount == 500);\n//   require(tx.outputs[1].tokenAmount == 500);\n//   // But input might have 2000 tokens!\n//\n// CORRECT:\n//   int total = 500 + 500;\n//   int inputAmount = tx.inputs[this.activeInputIndex].tokenAmount;\n//   require(total == inputAmount);\n//   require(tx.outputs[0].tokenAmount == 500);\n//   require(tx.outputs[1].tokenAmount == 500);\n\n// MISTAKE 5: Not Validating Zero for NFTs\n// ----------------------------------------\n// WRONG (for NFT contract):\n//   require(tx.outputs[0].tokenCategory == nftCategory);\n//   // Assumes amount is 0, but doesn't check\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenCategory == nftCategory);\n//   require(tx.outputs[0].tokenAmount == 0);  // Explicitly NFT",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-17",
    "content": "// MISTAKE 6: Overflow in Amount Arithmetic\n// -----------------------------------------\n// WRONG:\n//   int total = amount1 + amount2 + amount3;\n//   // Could overflow if amounts are very large\n//\n// CORRECT:\n//   int total = amount1 + amount2 + amount3;\n//   require(total >= amount1);  // Overflow check\n//   require(total >= amount2);\n//   require(total >= amount3);\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR TOKEN AMOUNT VALIDATION\n// ============================================================================\n//\n// Before deploying a token contract, verify:\n//\n// [ ] Output count validation: require(tx.outputs.length == N)\n// [ ] Every token output has tokenCategory validation\n// [ ] Every token output has tokenAmount validation\n// [ ] For fungible tokens: Amount is exact value (use ==, not >=)\n// [ ] For NFTs: Amount is explicitly 0\n// [ ] For multi-output: Sum of amounts validated against input\n// [ ] Conservation enforced for covenants (input == output amounts)\n// [ ] No capability leak: require(tokenCapability == 0x)\n// [ ] Overflow protection for amount arithmetic\n// [ ] Test with zero-amount outputs (theft scenario)\n// [ ] Test with inflated amounts (duplication scenario)\n// [ ] Test with multi-output splitting (distribution scenario)\n// [ ] Test with wrong amounts (< or > expected)\n// [ ] Document expected amounts clearly in contract/UI\n\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-18",
    "content": "// TESTING RECOMMENDATIONS\n// ============================================================================\n//\n// Test Cases for VULNERABLE version (no amount validation):\n// 1. Transfer with correct category and amount\n//    Expected: SUCCEEDS (normal operation)\n//\n// 2. Transfer with correct category but ZERO amount\n//    Expected: SUCCEEDS (VULNERABILITY - theft)\n//\n// 3. Transfer with correct category but REDUCED amount\n//    Expected: SUCCEEDS (VULNERABILITY - partial theft)\n//\n// 4. Multi-output with tokens split (extra output)\n//    Expected: SUCCEEDS (VULNERABILITY - splitting attack)\n//\n// 5. Transfer with inflated amount (if possible via other inputs)\n//    Expected: SUCCEEDS or FAILS (depends on inputs)\n//\n// Test Cases for SECURE version (with amount validation):\n// 1. Transfer with correct category and amount\n//    Expected: SUCCEEDS (valid transfer)\n//\n// 2. Transfer with correct category but ZERO amount\n//    Expected: FAILS (amount validation rejects)\n//\n// 3. Transfer with correct category but WRONG amount\n//    Expected: FAILS (amount validation rejects)\n//\n// 4. Multi-output attempt (extra outputs)\n//    Expected: FAILS (output count validation rejects)\n//\n// 5. Conservation test: input=1000, outputs sum to 999\n//    Expected: FAILS (conservation check rejects)\n//\n// 6. Conservation test: input=1000, outputs sum to 1001\n//    Expected: FAILS (consensus rejects - can't create tokens)\n//\n// 7. NFT with amount > 0\n//    Expected: FAILS (amount validation rejects)",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-19",
    "content": "// ============================================================================\n// REAL-WORLD IMPACT EXAMPLES\n// ============================================================================\n//\n// Example 1: DEX Token Theft via Zero-Amount Output\n// --------------------------------------------------\n// Platform: Decentralized exchange for BCH tokens\n// Vulnerability: Swap contract validates category but not amount\n// Attack: User swaps 1000 TokenA for TokenB, receives 0 TokenB\n// Steps:\n//   1. User deposits 1000 TokenA\n//   2. Attacker crafts swap transaction\n//   3. Output[0]: 0 TokenB to user (category correct, amount=0)\n//   4. Output[1]: 1000 TokenB to attacker (from swap reserves)\n// Impact:\n//   - User loses 1000 TokenA, receives nothing\n//   - DEX loses 1000 TokenB from reserves\n//   - Reputation destroyed\n//   - Financial loss: $50,000+ (if token valuable)\n//\n// Example 2: Vesting Contract Amount Manipulation\n// ------------------------------------------------\n// Scenario: Employee token vesting (4-year schedule)\n// Vulnerability: Vesting release validates category but not amount\n// Attack: Employee claims full vesting early with reduced amounts\n// Steps:\n//   1. Vesting contract holds 40,000 tokens (1000/month for 40 months)\n//   2. After month 1, employee should claim 1,000 tokens\n//   3. Employee crafts transaction:\n//      - Output[0]: 100 tokens to self (reduced)\n//      - Output[1]: 39,900 tokens to employee's second address\n//   4. Vesting contract validates category ✓, never checks amount",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_amount_validation.cash-20",
    "content": "// Impact:\n//   - Employee claims 40,000 tokens after 1 month\n//   - Company loses 39,000 tokens of unvested equity\n//   - Vesting schedule completely bypassed\n//\n// Example 3: NFT Marketplace Fungible Token Pollution\n// ----------------------------------------------------\n// Platform: NFT marketplace (NFT-only)\n// Vulnerability: Transfer validates category, assumes amount=0\n// Attack: Attacker creates fungible tokens with same category\n// Steps:\n//   1. Attacker has minting capability for NFT category\n//   2. Creates 1,000,000 fungible tokens (amount>0, same category)\n//   3. Lists on marketplace as \"NFT\" (category matches)\n//   4. Buyers expect NFT (amount=0), receive fungible tokens (amount=1M)\n// Impact:\n//   - NFT collection polluted with fungible tokens\n//   - Buyers confused (expected NFT, got FT)\n//   - Collection semantics violated\n//   - Marketplace trust destroyed\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_token_amount_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-0",
    "content": "// ANTI-PATTERN: Missing Token Category Validation\n// VULNERABILITY: Unvalidated outputs allow token attachment/substitution attacks\n// ATTACK VECTOR: Token attachment to BCH-only outputs, token substitution, token theft\n//\n// This file demonstrates the critical vulnerability of failing to validate\n// tokenCategory on transaction outputs. Without explicit validation, attackers\n// can attach unwanted tokens to outputs, substitute valuable tokens with\n// worthless ones, or break BCH-only output assumptions.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Missing Token Category Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract validates BCH value but not token category\n// RISK: Outputs can receive unexpected tokens, breaking BCH-only assumptions\ncontract VulnerableBCHOnlyNoTokenValidation(\n    pubkey ownerPubKey,\n    bytes recipientBytecode  // Intended BCH-only recipient\n) {\n    // VULNERABILITY: Validates value and recipient but not tokenCategory\n    // MISSING: Explicit tokenCategory validation\n    // MISSING: Enforcement that output has NO tokens\n    function sendBCH(sig ownerSig, int amount) {\n        // Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Validate amount is positive",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-1",
    "content": "require(amount > 0);\n        \n        // Validate output recipient\n        require(tx.outputs[0].lockingBytecode == recipientBytecode);\n        \n        // Validate output value\n        require(tx.outputs[0].value == amount);\n        \n        // CRITICAL FLAW: Never validates tx.outputs[0].tokenCategory\n        // Attacker can:\n        // - Attach tokens to the BCH-only output\n        // - Send unwanted/spam tokens to recipient\n        // - Break recipient's BCH-only assumption\n        // - Cause recipient wallet to reject/mishandle output\n        // - Create UTXO pollution\n    }\n}\n\n// ============================================================================\n// ATTACK SCENARIO 1: Token Attachment to BCH-Only Output\n// ============================================================================\n//\n// Setup:\n// - Contract intended to send pure BCH (no tokens)\n// - Recipient expects BCH-only UTXO\n// - Recipient's wallet/system only handles BCH (no token support)\n//\n// Legitimate Transaction (intended):\n// Inputs:\n//   [0] Contract UTXO (10,000 sats, no tokens)\n//   [1] User's signature input\n//\n// Outputs:\n//   [0] 5,000 sats to recipient (BCH only, no tokens) ✓\n//   [1] Change back to user\n//\n// ATTACK: Attach Tokens to BCH Output\n// Inputs:\n//   [0] Contract UTXO (10,000 sats, no tokens)\n//   [1] Attacker's UTXO (1,000 sats + 1,000,000 SPAM tokens)\n//\n// Outputs:\n//   [0] 5,000 sats + 1,000,000 SPAM tokens to recipient ✗\n//       - lockingBytecode: recipientBytecode ✓ (passes check)",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-2",
    "content": "//       - value: 5,000 ✓ (passes check)\n//       - tokenCategory: 0xAABBCCDD... (SPAM token) ✗ (NOT CHECKED!)\n//       - tokenAmount: 1,000,000\n//\n// Result:\n// - Contract validates: recipient and amount are correct ✓\n// - Contract NEVER checks: tokenCategory\n// - Output receives unwanted tokens\n// - Recipient's BCH-only wallet may:\n//   - Reject the UTXO (unspendable funds)\n//   - Miscount balance (counts only BCH, ignores tokens)\n//   - Crash/error on token-containing UTXO\n//   - Require manual intervention to handle\n//\n// Impact:\n// - Recipient cannot use funds (wallet incompatibility)\n// - UTXO pollution (unwanted tokens attached)\n// - Potential loss of BCH (if wallet rejects UTXO entirely)\n// - Denial of service (recipient cannot receive clean BCH)\n\n// ============================================================================\n// ATTACK SCENARIO 2: Token Substitution Attack\n// ============================================================================\n//\n// Setup:\n// - Contract intended to send specific valuable NFT\n// - NFT category: 0x1111... (valuable digital art, worth $10,000)\n// - Recipient expects this specific NFT\n//\n// Vulnerable Contract (assumes token preservation but doesn't validate):\n//\n// contract VulnerableNFTTransfer(pubkey ownerPubKey, bytes recipientBytecode) {\n//     function transfer(sig ownerSig) {\n//         require(checkSig(ownerSig, ownerPubKey));\n//         require(tx.outputs[0].lockingBytecode == recipientBytecode);\n//         require(tx.outputs[0].value >= 1000);  // Minimum BCH",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-3",
    "content": "//         \n//         // CRITICAL FLAW: Never validates tokenCategory\n//         // Assumes input NFT will go to output, but doesn't enforce it\n//     }\n// }\n//\n// Legitimate Transaction (intended):\n// Inputs:\n//   [0] Contract UTXO (1,000 sats + NFT category 0x1111...)\n//\n// Outputs:\n//   [0] 1,000 sats + NFT category 0x1111... to recipient ✓\n//\n// ATTACK: Substitute with Worthless Token\n// Inputs:\n//   [0] Contract UTXO (1,000 sats + valuable NFT 0x1111...)\n//   [1] Attacker's UTXO (1,000 sats + worthless token 0x2222...)\n//\n// Outputs:\n//   [0] 1,000 sats + worthless token 0x2222... to recipient ✗\n//       - lockingBytecode: recipientBytecode ✓ (passes check)\n//       - value: 1,000 ✓ (passes check)\n//       - tokenCategory: 0x2222... ✗ (NOT CHECKED - wrong token!)\n//   \n//   [1] 1,000 sats + valuable NFT 0x1111... to attacker's address\n//       - Attacker keeps the valuable NFT\n//\n// Result:\n// - Recipient receives worthless token instead of valuable NFT\n// - Attacker steals valuable NFT worth $10,000\n// - Recipient has no recourse (transaction is \"valid\")\n//\n// Impact:\n// - Direct theft of valuable digital asset\n// - Recipient loses $10,000 NFT, receives worthless token\n// - Trust in contract destroyed\n// - Legal/financial liability for contract deployer\n\n// ============================================================================\n// ATTACK SCENARIO 3: UTXO Pollution Attack\n// ============================================================================\n//\n// Setup:\n// - Payment processor sends BCH to merchants",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-4",
    "content": "// - Merchants expect clean BCH UTXOs\n// - Processor handles high volume (1000s of payments/day)\n//\n// Attack: Spam Token Distribution\n// - Attacker creates worthless spam token (category 0xSPAM...)\n// - Mints 100,000,000 spam tokens (costs ~546 sats)\n// - For each payment processed:\n//   - Payment to merchant includes spam tokens\n//   - Merchant receives: expected BCH + unwanted spam tokens\n//\n// Impact on 1000 merchants:\n// - Each merchant receives 100,000 spam tokens\n// - Each merchant's UTXO set polluted\n// - Wallets slow down (must track spam tokens)\n// - Database bloat (storing spam token data)\n// - User confusion (\"what are these tokens?\")\n// - Support burden (explaining/removing spam)\n// - Potential wallet crashes (poor token handling)\n//\n// Economic Impact:\n// - Merchants must spend extra fees to \"clean\" UTXOs\n// - Loss of customer trust (payments contain spam)\n// - Development time fixing token filtering\n// - Potential service downtime\n//\n// Attacker Cost: ~546 sats + transaction fees\n// Victim Cost: 1000s of dollars in cleanup, lost productivity\n\n// ============================================================================\n// ATTACK SCENARIO 4: Wallet Compatibility Breaking\n// ============================================================================\n//\n// Setup:\n// - Mobile wallet only supports BCH (no token support)\n// - User expects to receive clean BCH\n// - Contract sends \"BCH payment\"\n//\n// Attack: Force Token on Non-Compatible Wallet\n// Inputs:\n//   [0] Contract UTXO (10,000 sats)",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-5",
    "content": "//   [1] Attacker's token UTXO (tokens)\n//\n// Outputs:\n//   [0] 10,000 sats + tokens to user's mobile wallet address\n//\n// Result:\n// - Mobile wallet sees UTXO with tokens\n// - Wallet doesn't understand token format\n// - Possible outcomes:\n//   1. Wallet crashes when parsing UTXO\n//   2. Wallet ignores UTXO (funds appear lost)\n//   3. Wallet shows error state\n//   4. Wallet counts BCH but cannot spend UTXO (token handling issue)\n//\n// Impact:\n// - User cannot access their BCH\n// - Funds effectively locked (until wallet upgrade)\n// - Poor user experience\n// - Support tickets, refund requests\n// - Damage to merchant/service reputation\n\n// ============================================================================\n// SECURE VERSION: Explicit Token Category Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract explicitly validates tokenCategory\n// PROTECTION: Prevents token attachment, substitution, and pollution attacks\ncontract SecureBCHOnlyWithTokenValidation(\n    pubkey ownerPubKey,\n    bytes recipientBytecode\n) {\n    // SECURE: Validates recipient, value, AND tokenCategory\n    function sendBCH(sig ownerSig, int amount) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Validate amount\n        require(amount > 0);\n        \n        // Step 3: CRITICAL - Enforce exactly 1 output\n        // Prevents attacker from adding extra outputs to siphon value",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-6",
    "content": "// Ensures single-output intent matches validation\n        require(tx.outputs.length == 1);\n        \n        // Step 4: Validate recipient\n        require(tx.outputs[0].lockingBytecode == recipientBytecode);\n        \n        // Step 5: Validate value\n        require(tx.outputs[0].value == amount);\n        \n        // Step 6: CRITICAL - Validate NO tokens on output\n        // tokenCategory == 0x means NO tokens are attached to this output\n        // This enforces a strict BCH-only UTXO\n        // For BCH-only outputs, tokenCategory MUST be empty (0x)\n        // This prevents any tokens from being attached\n        require(tx.outputs[0].tokenCategory == 0x);\n        \n        // ALTERNATIVE: Explicitly check for no token fields\n        // require(tx.outputs[0].tokenAmount == 0);  // No fungible tokens\n        // require(tx.outputs[0].nftCommitment == 0x);  // No NFT data\n        // require(tx.outputs[0].tokenCapability == 0x);  // No capabilities\n        //\n        // However, checking tokenCategory == 0x is sufficient because:\n        // - Empty category means NO tokens at all\n        // - If category is 0x, other token fields are irrelevant/empty\n        // - Single check is cleaner and equally secure\n        \n        // RESULT: Token attachment and output manipulation are now IMPOSSIBLE\n        // - Output count enforced (exactly 1 output)\n        // - Output must have tokenCategory == 0x (empty/no tokens)\n        // - Any transaction with tokens attached to output[0] will FAIL",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-7",
    "content": "// - Any transaction with extra outputs will FAIL\n        // - Recipient guaranteed to receive pure BCH\n        // - UTXO pollution prevented\n        // - Wallet compatibility preserved\n    }\n}\n\n// ============================================================================\n// SECURE PATTERN: Token-Aware Contract with Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: Contract that handles tokens and validates category explicitly\n// USE CASE: NFT transfer, token payment, multi-asset covenant\ncontract SecureTokenTransferWithCategoryValidation(\n    pubkey ownerPubKey,\n    bytes recipientBytecode,\n    bytes expectedTokenCategory  // The specific token this contract handles\n) {\n    // SECURE: Validates both BCH and token properties\n    function transferToken(sig ownerSig, int bchAmount, int tokenAmount) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Validate amounts\n        require(bchAmount > 0);\n        require(tokenAmount > 0);\n        \n        // Step 3: Validate recipient\n        require(tx.outputs[0].lockingBytecode == recipientBytecode);\n        \n        // Step 4: Validate BCH amount\n        require(tx.outputs[0].value == bchAmount);\n        \n        // Step 5: CRITICAL - Validate token category is EXPECTED category\n        // This prevents token substitution attacks\n        require(tx.outputs[0].tokenCategory == expectedTokenCategory);",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-8",
    "content": "// Step 6: CRITICAL - Validate token amount\n        // Ensures recipient receives exact expected quantity\n        require(tx.outputs[0].tokenAmount == tokenAmount);\n        \n        // Step 7: Validate token capability (for NFTs)\n        // For immutable tokens/NFTs, capability should be empty\n        require(tx.outputs[0].tokenCapability == 0x);\n        \n        // RESULT: Complete token validation\n        // - Correct token category (no substitution)\n        // - Correct token amount (no shortchanging)\n        // - No minting capability leak\n        // - Recipient receives exactly what's expected\n    }\n}\n\n// ============================================================================\n// ADVANCED PATTERN: Multi-Output Token and BCH Split\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ADVANCED: Contract splitting BCH and tokens to different recipients\n// USE CASE: Payment splitting, token sale, atomic swap preparation\ncontract SecureTokenBCHSplit(\n    pubkey ownerPubKey,\n    bytes bchRecipientBytecode,   // Receives only BCH\n    bytes tokenRecipientBytecode,  // Receives only tokens\n    bytes tokenCategory\n) {\n    function split(sig ownerSig, int bchAmount, int tokenAmount) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: CRITICAL - Enforce exactly 2 outputs\n        require(tx.outputs.length == 2);\n        \n        // Step 3: Validate output[0] - BCH only to first recipient",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-9",
    "content": "require(tx.outputs[0].lockingBytecode == bchRecipientBytecode);\n        require(tx.outputs[0].value == bchAmount);\n        require(tx.outputs[0].tokenCategory == 0x);  // NO tokens\n        \n        // Step 4: Validate output[1] - Tokens to second recipient\n        require(tx.outputs[1].lockingBytecode == tokenRecipientBytecode);\n        require(tx.outputs[1].value >= 1000);  // Minimum dust for token output\n        require(tx.outputs[1].tokenCategory == tokenCategory);  // CORRECT tokens\n        require(tx.outputs[1].tokenAmount == tokenAmount);\n        require(tx.outputs[1].tokenCapability == 0x);\n        \n        // RESULT: Clean separation guaranteed\n        // - Output[0]: Pure BCH (no tokens)\n        // - Output[1]: Correct tokens (with minimal BCH)\n        // - No mixing, no substitution, no pollution\n    }\n}\n\n// ============================================================================\n// BEST PRACTICE: Input-Output Token Consistency\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// BEST PRACTICE: Covenant that preserves token category from input to output\n// USE CASE: Token covenants, escrow, vesting\ncontract SecureTokenCovenant(\n    pubkey ownerPubKey\n) {\n    function transfer(sig ownerSig) {\n        // Step 1: Validate authorization\n        require(checkSig(ownerSig, ownerPubKey));\n        \n        // Step 2: Read input token category\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-10",
    "content": "// Step 3: CRITICAL - Enforce output preserves EXACT same category\n        // This prevents token substitution in covenant chains\n        require(tx.outputs[0].tokenCategory == inputTokenCategory);\n        \n        // Step 4: Optionally validate token amount preservation\n        int inputTokenAmount = tx.inputs[this.activeInputIndex].tokenAmount;\n        require(tx.outputs[0].tokenAmount == inputTokenAmount);\n        \n        // Step 5: Validate other output properties\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == inputLockingBytecode);\n        \n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        require(tx.outputs[0].value == inputValue);\n        \n        // RESULT: Complete token continuity\n        // - Token category preserved (no substitution)\n        // - Token amount preserved (no theft)\n        // - Covenant continues with exact same assets\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Token Category Validation Is Critical\n// ============================================================================\n\n// TOKEN CATEGORY IN BITCOIN CASH\n// -------------------------------\n// Bitcoin Cash CashTokens (BCMR / CHIP) allow UTXOs to contain:\n// 1. BCH (satoshi value) - Always present\n// 2. Tokens (optional) - Identified by tokenCategory\n//\n// Token Category:\n// - 32-byte identifier (transaction ID where token was created)",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-11",
    "content": "// - Empty (0x) means NO tokens\n// - Non-empty means tokens are present\n//\n// Output can contain:\n// - BCH only: tokenCategory = 0x\n// - BCH + Tokens: tokenCategory = <32-byte txid>\n// - Tokens only: BCH value = dust (546 sats), tokenCategory = <txid>\n\n// THE VALIDATION GAP\n// ------------------\n// Many contracts validate:\n// ✓ Output recipient (lockingBytecode)\n// ✓ Output BCH value (value)\n// ✗ Output token category (tokenCategory)\n//\n// Why developers miss this:\n// - Focus on BCH amount\n// - Assume \"no tokens means tokenCategory is automatically 0x\"\n// - Don't realize attacker can ADD tokens from other inputs\n// - Think \"my contract doesn't use tokens, so I don't need to check\"\n//\n// Reality:\n// - Outputs can receive tokens from ANY input\n// - If contract doesn't validate tokenCategory, ANY category can be attached\n// - Attacker controls which inputs are included\n// - Attacker can force tokens onto outputs\n\n// HOW TOKEN ATTACHMENT WORKS\n// ---------------------------\n// Transaction Structure:\n// Inputs: [Input0: 10k sats, Input1: 5k sats + 1M SPAM tokens]\n// Outputs: [Output0: 15k sats + 1M SPAM tokens]\n//\n// Bitcoin Cash consensus allows:\n// - Combining inputs (BCH sums)\n// - Routing tokens from any input to any output\n// - Attacker chooses token routing\n//\n// If contract only checks:\n//   require(tx.outputs[0].value == 15000);\n//\n// It does NOT prevent:\n//   tx.outputs[0].tokenCategory = SPAM_TOKEN\n//   tx.outputs[0].tokenAmount = 1000000\n//\n// Attacker can:\n// 1. Add their token UTXO as additional input",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-12",
    "content": "// 2. Route tokens to output[0]\n// 3. Contract sees: value is correct ✓\n// 4. Contract never checks: tokenCategory\n// 5. Output receives unwanted tokens\n\n// EMPTY CATEGORY CHECK: THE SOLUTION\n// ------------------------------------\n// For BCH-only outputs:\n//   require(tx.outputs[0].tokenCategory == 0x);\n//\n// This enforces:\n// - Output has NO tokens\n// - Empty category (0x = no tokens)\n// - Pure BCH output guaranteed\n//\n// For token outputs:\n//   require(tx.outputs[0].tokenCategory == expectedCategory);\n//\n// This enforces:\n// - Output has SPECIFIC token\n// - No substitution possible\n// - Correct asset transferred\n\n// TOKEN VALIDATION LAYERS\n// ------------------------\n// Complete token validation requires checking:\n//\n// Layer 1: Category (tokenCategory)\n//   - Is this the right token? (or no token?)\n//   - Prevents: Substitution, attachment\n//\n// Layer 2: Amount (tokenAmount)\n//   - How many fungible tokens?\n//   - Prevents: Shortchanging, inflation\n//\n// Layer 3: Commitment (nftCommitment)\n//   - What data does NFT carry?\n//   - Prevents: Data manipulation\n//\n// Layer 4: Capability (tokenCapability)\n//   - Can this token mint more?\n//   - Prevents: Capability leak\n//\n// Minimum validation for BCH-only: Layer 1 (category == 0x)\n// Minimum validation for tokens: Layers 1 + 2 + 4\n// Full validation for NFTs: All 4 layers\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR TOKEN VALIDATION\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-13",
    "content": "// PRINCIPLE 1: ALWAYS VALIDATE TOKEN CATEGORY\n// --------------------------------------------\n// Every output validation MUST include tokenCategory check\n// No exceptions, even for \"BCH-only\" contracts\n// Default: require(tx.outputs[N].tokenCategory == 0x);\n\n// PRINCIPLE 2: EXPLICIT IS BETTER THAN IMPLICIT\n// ----------------------------------------------\n// Don't assume outputs have no tokens\n// Don't assume tokens will \"naturally\" go to right output\n// Explicitly validate every token property\n\n// PRINCIPLE 3: BCH-ONLY REQUIRES TOKEN CHECKS\n// --------------------------------------------\n// If output should contain ONLY BCH:\n//   require(tx.outputs[N].tokenCategory == 0x);\n// This is NOT optional for BCH-only outputs\n\n// PRINCIPLE 4: TOKEN OUTPUTS NEED CATEGORY + AMOUNT\n// --------------------------------------------------\n// If output should contain tokens:\n//   require(tx.outputs[N].tokenCategory == expectedCategory);\n//   require(tx.outputs[N].tokenAmount == expectedAmount);\n// Both checks required (category AND amount)\n\n// PRINCIPLE 5: VALIDATE INPUT-OUTPUT CONSISTENCY\n// -----------------------------------------------\n// For covenants preserving tokens:\n//   bytes inputCat = tx.inputs[this.activeInputIndex].tokenCategory;\n//   require(tx.outputs[0].tokenCategory == inputCat);\n// Prevents token substitution in covenant chains\n\n// PRINCIPLE 6: PREVENT CAPABILITY LEAK\n// -------------------------------------\n// Unless explicitly intended, outputs should not have minting capability:",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-14",
    "content": "//   require(tx.outputs[N].tokenCapability == 0x);\n// Keeps minting authority contained\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Not Checking Token Category at All\n// ----------------------------------------------\n// WRONG:\n//   function sendBCH(sig ownerSig, int amount) {\n//       require(checkSig(ownerSig, ownerPubKey));\n//       require(tx.outputs[0].value == amount);\n//       // No tokenCategory check\n//       // No output count check\n//   }\n//\n// CORRECT:\n//   function sendBCH(sig ownerSig, int amount) {\n//       require(checkSig(ownerSig, ownerPubKey));\n//       require(tx.outputs.length == 1);  // Enforce single output\n//       require(tx.outputs[0].value == amount);\n//       require(tx.outputs[0].tokenCategory == 0x);  // No tokens allowed\n//   }\n\n// MISTAKE 2: Checking Token Amount Without Category\n// --------------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenAmount == 0);\n//\n// WHY WRONG:\n// - tokenAmount only applies to fungible tokens\n// - NFTs have tokenAmount = 0 but still have tokenCategory\n// - Attacker can attach NFT (amount = 0 but category != 0x)\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenCategory == 0x);\n\n// MISTAKE 3: Only Checking Category on Some Outputs\n// --------------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenCategory == 0x);",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-15",
    "content": "//   // Output[1] not checked - can receive tokens\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenCategory == 0x);\n//   require(tx.outputs[1].tokenCategory == 0x);\n//   // Check EVERY output that should be BCH-only\n\n// MISTAKE 4: Using Wrong Comparison for Empty Check\n// --------------------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenCategory == \"\");  // String comparison\n//   require(tx.outputs[0].tokenCategory == null);  // Null check\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenCategory == 0x);  // Empty bytes\n\n// MISTAKE 5: Not Validating Token Amount\n// ---------------------------------------\n// WRONG:\n//   require(tx.outputs[0].tokenCategory == expectedCategory);\n//   // Amount not checked - could be wrong quantity\n//\n// CORRECT:\n//   require(tx.outputs[0].tokenCategory == expectedCategory);\n//   require(tx.outputs[0].tokenAmount == expectedAmount);\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR TOKEN-AWARE CONTRACTS\n// ============================================================================\n//\n// Before deploying a contract handling tokens or BCH:\n//\n// [ ] Output count validation: require(tx.outputs.length == N)\n// [ ] Every output has tokenCategory validation\n// [ ] BCH-only outputs: require(tokenCategory == 0x)\n// [ ] Token outputs: require(tokenCategory == expectedCategory)\n// [ ] Token outputs: require(tokenAmount == expectedAmount)\n// [ ] Token outputs: require(tokenCapability == 0x) (unless minting intended)",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "string"
    ]
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-16",
    "content": "// [ ] NFT outputs: require(nftCommitment validation) (if data matters)\n// [ ] Input-output consistency for covenants\n// [ ] Test with attacker adding token inputs\n// [ ] Test with attacker adding extra outputs\n// [ ] Test with various token categories (spam, valuable, NFT)\n// [ ] Test wallet compatibility with outputs\n// [ ] Document expected token behavior clearly\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================\n//\n// Test Cases for VULNERABLE version (no token validation):\n// 1. Send BCH with no tokens (normal operation)\n//    Expected: SUCCEEDS\n//\n// 2. Send BCH + attach spam tokens from additional input\n//    Expected: SUCCEEDS (VULNERABILITY - should fail)\n//\n// 3. Send BCH + attach NFT from additional input\n//    Expected: SUCCEEDS (VULNERABILITY - should fail)\n//\n// 4. Substitute valuable token with worthless token\n//    Expected: SUCCEEDS (VULNERABILITY - should fail)\n//\n// Test Cases for SECURE version (with token validation):\n// 1. Send BCH with no tokens\n//    Expected: SUCCEEDS (valid clean BCH)\n//\n// 2. Attempt to attach spam tokens to BCH output\n//    Expected: FAILS (tokenCategory != 0x check rejects)\n//\n// 3. Attempt to attach NFT to BCH output\n//    Expected: FAILS (tokenCategory != 0x check rejects)\n//\n// 4. Send correct token category and amount\n//    Expected: SUCCEEDS (valid token transfer)\n//\n// 5. Attempt token substitution",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-17",
    "content": "//    Expected: FAILS (tokenCategory validation rejects)\n//\n// 6. Attempt wrong token amount\n//    Expected: FAILS (tokenAmount validation rejects)\n\n// ============================================================================\n// REAL-WORLD IMPACT EXAMPLES\n// ============================================================================\n//\n// Example 1: Payment Processor UTXO Pollution\n// --------------------------------------------\n// Company: BCH payment processor (1000+ merchants)\n// Vulnerability: No tokenCategory validation on merchant payouts\n// Attack: Spam token creator attaches worthless tokens to all payouts\n// Impact:\n//   - 1000 merchants receive spam tokens\n//   - Merchant wallets slow down/crash\n//   - Customer support overwhelmed\n//   - Trust in processor destroyed\n//   - $50k+ in cleanup costs, lost business\n//\n// Example 2: NFT Marketplace Theft\n// ---------------------------------\n// Platform: NFT marketplace for digital art\n// Vulnerability: NFT transfer doesn't validate tokenCategory\n// Attack: Seller substitutes valuable NFT with worthless token\n// Impact:\n//   - Buyer pays $10,000 for NFT\n//   - Receives worthless token instead\n//   - Seller keeps valuable NFT\n//   - Marketplace liable, reputation destroyed\n//   - Legal action, platform shutdown\n//\n// Example 3: Mobile Wallet BCH Lockup\n// ------------------------------------\n// Scenario: Mobile wallet receives BCH payment\n// Vulnerability: Sender doesn't validate tokenCategory == 0x\n// Attack: Sender attaches tokens to BCH payment",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/missing_token_validation.cash-18",
    "content": "// Impact:\n//   - User's wallet doesn't support tokens\n//   - UTXO appears but cannot be spent\n//   - User thinks they lost BCH\n//   - Support costs, bad reviews, user churn\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/missing_token_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-0",
    "content": "// ANTI-PATTERN: Time Validation Boundary Error\n// VULNERABILITY: Incorrect comparison operator enables premature unlocking\n// ATTACK VECTOR: Boundary condition exploitation, off-by-one timing attack\n//\n// This file demonstrates the critical vulnerability of using incorrect comparison\n// operators in time-lock validation. A single character difference (> vs >=) can\n// enable attackers to unlock funds one block/second early, breaking time-lock\n// guarantees and potentially causing significant security failures.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Incorrect Time Comparison Operator\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract uses > instead of >= for time validation\n// RISK: Funds can be unlocked one block/second before intended unlock time\ncontract VulnerableTimeLockWrongOperator(\n    pubkey beneficiaryPubKey,\n    int unlockTime  // Block height or Unix timestamp\n) {\n    // VULNERABILITY: Uses > (greater than) instead of >= (greater than or equal)\n    // MISSING: Correct boundary condition handling\n    function unlock(sig beneficiarySig) {\n        // Validate beneficiary signature\n        require(checkSig(beneficiarySig, beneficiaryPubKey));\n        \n        // CRITICAL FLAW: Incorrect comparison operator",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-1",
    "content": "// This checks: tx.locktime > unlockTime\n        // Should be:    tx.locktime >= unlockTime\n        require(tx.locktime > unlockTime);\n        \n        // WHY THIS IS WRONG:\n        // If unlockTime = 1000:\n        // - Intended: Can unlock when tx.locktime >= 1000 (at or after block 1000)\n        // - Actual:   Can unlock when tx.locktime > 1000 (only after block 1000)\n        //\n        // Wait, that seems MORE restrictive, not less?\n        // \n        // THE REAL VULNERABILITY:\n        // The logic is BACKWARDS. Developer meant:\n        // \"Current time must be greater than unlock time\"\n        // But wrote it as:\n        // \"Locktime (user-provided) must be greater than unlock time\"\n        //\n        // Attacker can set tx.locktime = unlockTime + 1\n        // Even if current block height is unlockTime - 100!\n        //\n        // The fundamental error: Not validating tx.locktime against CURRENT time\n    }\n}\n\n// ============================================================================\n// UNDERSTANDING THE VULNERABILITY: tx.locktime vs tx.time\n// ============================================================================\n//\n// CRITICAL CONCEPT: What is tx.locktime?\n// --------------------------------------\n// tx.locktime is a TRANSACTION FIELD set by the transaction creator\n// It is NOT the current block height or current time\n// It is a USER-CONTROLLED VALUE\n//\n// Two interpretations:\n// 1. If tx.locktime < 500,000,000: Interpreted as block height\n// 2. If tx.locktime >= 500,000,000: Interpreted as Unix timestamp (seconds)",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-2",
    "content": "//\n// Consensus Rules:\n// - If tx.locktime is set, transaction is ONLY valid if:\n//   - Block height >= tx.locktime (for block-height locktime)\n//   - Block timestamp >= tx.locktime (for timestamp locktime)\n// - Transaction creator can set ANY value for tx.locktime\n// - But miners will reject if current time hasn't reached tx.locktime\n//\n// THE CONFUSION:\n// Developer thinks: tx.locktime = \"current time\"\n// Reality: tx.locktime = \"earliest time this tx can be mined\"\n// Attacker controls: tx.locktime value (subject to consensus validation)\n\n// ============================================================================\n// CORRECT APPROACH: Using tx.time (CashScript)\n// ============================================================================\n//\n// In CashScript, there are TWO time introspection methods:\n//\n// 1. tx.locktime\n//    - User-controlled transaction field\n//    - Can be set to any value\n//    - Miners validate it against current time\n//    - NOT reliable for covenant time checks\n//\n// 2. tx.time (CashScript introspection)\n//    - Returns the CURRENT block's timestamp\n//    - NOT user-controlled\n//    - Reliable for covenant time validation\n//    - Available in CashScript for proper time checks\n//\n// WRONG: require(tx.locktime > unlockTime);\n// RIGHT: require(tx.time >= unlockTime);\n\n// ============================================================================\n// ATTACK SCENARIO 1: Premature Unlock via Locktime Manipulation\n// ============================================================================",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant",
      "introspection"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-3",
    "content": "//\n// Setup:\n// - Time-locked escrow holding 1,000,000 sats\n// - unlockTime = block height 800,000 (some future block)\n// - Current block height = 750,000 (50,000 blocks early)\n// - Beneficiary wants to unlock early\n//\n// Vulnerable Contract Logic:\n//   require(tx.locktime > unlockTime);\n//   // Checks if tx.locktime > 800,000\n//\n// Attack Transaction:\n// - Beneficiary creates transaction with tx.locktime = 800,001\n// - Contract checks: 800,001 > 800,000 ✓ (passes)\n// - Transaction is broadcast\n//\n// What Happens:\n// - Miners see tx.locktime = 800,001\n// - Current block height = 750,000\n// - Consensus rule: tx.locktime must be <= current block height to mine\n// - 800,001 > 750,000, so transaction is INVALID\n// - Transaction rejected by miners\n//\n// Wait, so the attack fails?\n// YES - but for the WRONG reasons!\n//\n// THE REAL ISSUE:\n// The contract CANNOT be unlocked at exactly block 800,000\n// It can only be unlocked at block 800,001 or later\n// This is an off-by-one error that breaks the intended lock semantics\n\n// ============================================================================\n// ATTACK SCENARIO 2: The Actual Exploitable Vulnerability\n// ============================================================================\n//\n// The real vulnerability is when contract uses tx.locktime incorrectly\n// and allows premature unlock by setting locktime to bypass check.\n//\n// More Dangerous Vulnerable Pattern:\n//\n// contract VulnerableTimeLockConfused(pubkey beneficiaryPubKey, int unlockTime) {",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-4",
    "content": "//     function unlock(sig beneficiarySig) {\n//         require(checkSig(beneficiarySig, beneficiaryPubKey));\n//         \n//         // WRONG: Validates locktime is set, but not against current time\n//         require(tx.locktime >= unlockTime);\n//         \n//         // This checks that USER SET tx.locktime >= unlockTime\n//         // Does NOT check current time >= unlockTime\n//     }\n// }\n//\n// Attack:\n// - Current block height: 750,000\n// - unlockTime: 800,000\n// - Attacker sets tx.locktime = 800,000\n// - Contract checks: tx.locktime >= unlockTime → 800,000 >= 800,000 ✓\n// - But consensus checks: current_height >= tx.locktime → 750,000 >= 800,000 ✗\n// - Transaction invalid (rejected)\n//\n// Still fails? Yes, because consensus protects against this.\n//\n// BUT CONSIDER: What if contract is checking TIMESTAMP not block height?\n//\n// Timestamp Exploit:\n// - Current timestamp: 1700000000 (Nov 2023)\n// - unlockTime: 1800000000 (May 2027) - 4 years in future\n// - Attacker sets tx.locktime = 1800000000\n// - Contract checks: 1800000000 >= 1800000000 ✓\n// - Consensus checks: current_timestamp >= tx.locktime\n// - Miner's block timestamp: Miners can set timestamp up to 2 hours in future!\n// - If miner cooperates (or is bribed), they timestamp block as 1800000000\n// - Transaction becomes valid 4 years early!\n//\n// This is the REAL attack: Bribing miners to timestamp blocks in the future\n\n// ============================================================================\n// ATTACK SCENARIO 3: Off-By-One Block Boundary Exploit",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-5",
    "content": "// ============================================================================\n//\n// Even with correct time introspection, wrong operator causes issues:\n//\n// Vulnerable Pattern:\n//   require(tx.time > unlockTime);  // Should be >=\n//\n// Setup:\n// - unlockTime = block height 1000\n// - Intended: Unlock at block 1000 or later\n// - Actual: Unlock only AFTER block 1000 (at block 1001+)\n//\n// Impact:\n// - Block 1000 arrives\n// - User tries to unlock\n// - Contract rejects: tx.time = 1000, but needs > 1000\n// - User must wait for block 1001\n// - Off-by-one block delay\n//\n// Why This Matters:\n// - Breaks time-lock guarantees (1 block = ~10 minutes delay)\n// - In time-sensitive scenarios (auction, liquidation), 1 block matters\n// - Front-running opportunities in that 1-block window\n// - User frustration and potential financial loss\n//\n// Example Impact Scenario:\n// - Collateralized loan with unlockTime = block 1000\n// - At block 1000, collateral price crashes\n// - User cannot withdraw due to off-by-one error\n// - Must wait for block 1001\n// - By block 1001, position liquidated (should have been safe)\n\n// ============================================================================\n// SECURE VERSION: Correct Time Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract uses correct time introspection and comparison\n// PROTECTION: Prevents premature unlock and off-by-one boundary errors\ncontract SecureTimeLockCorrectOperator(",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "introspection"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-6",
    "content": "pubkey beneficiaryPubKey,\n    int unlockTime  // Block height or Unix timestamp\n) {\n    // SECURE: Uses tx.time (current block time) with >= operator\n    function unlock(sig beneficiarySig) {\n        // Step 1: Validate beneficiary authorization\n        require(checkSig(beneficiarySig, beneficiaryPubKey));\n        \n        // Step 2: CRITICAL - Use tx.time, NOT tx.locktime\n        // tx.time returns the current block's timestamp/height\n        // This is consensus-validated and NOT user-controlled\n        \n        // Step 3: CRITICAL - Use >= (greater than or equal)\n        // Unlocking is allowed AT the unlock time, not only AFTER\n        // This correctly handles the boundary condition\n        require(tx.time >= unlockTime);\n        \n        // EXPLANATION OF CORRECTNESS:\n        // - If unlockTime = 1000 (block height)\n        // - At block 999: tx.time = 999, check fails (999 >= 1000 = false) ✓\n        // - At block 1000: tx.time = 1000, check passes (1000 >= 1000 = true) ✓\n        // - At block 1001: tx.time = 1001, check passes (1001 >= 1000 = true) ✓\n        //\n        // Boundary condition correctly handled:\n        // - Funds locked BEFORE block 1000\n        // - Funds unlocked AT block 1000 (inclusive)\n        // - Funds unlocked AFTER block 1000\n        //\n        // No off-by-one error, no premature unlock, no timing ambiguity\n    }\n}\n\n// ============================================================================\n// ALTERNATIVE PATTERN: Minimum Lock Duration\n// ============================================================================",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-7",
    "content": "pragma cashscript ^0.13.0;\n\n// ALTERNATIVE: Lock for a minimum duration from a reference time\n// USE CASE: Vesting schedules, escrow periods\ncontract SecureTimeLockWithDuration(\n    pubkey beneficiaryPubKey,\n    int lockStartTime,   // When lock period begins\n    int lockDuration     // How long to lock (in blocks or seconds)\n) {\n    function unlock(sig beneficiarySig) {\n        // Validate beneficiary\n        require(checkSig(beneficiarySig, beneficiaryPubKey));\n        \n        // Calculate unlock time\n        int unlockTime = lockStartTime + lockDuration;\n        \n        // CRITICAL: Ensure current time has reached unlock time\n        require(tx.time >= unlockTime);\n        \n        // CORRECTNESS:\n        // - lockStartTime = 1000, lockDuration = 100\n        // - unlockTime = 1100\n        // - At block 1099: Locked\n        // - At block 1100: Unlocked (inclusive boundary)\n        // - At block 1101: Unlocked\n        \n        // BONUS: Overflow protection\n        // Ensure unlockTime calculation doesn't overflow\n        require(unlockTime > lockStartTime);  // Duration is positive\n    }\n}\n\n// ============================================================================\n// ADVANCED PATTERN: Multi-Stage Time Lock\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ADVANCED: Multiple unlocking stages with different conditions\n// USE CASE: Vesting with cliff and gradual release\ncontract SecureTimeLockMultiStage(\n    pubkey beneficiaryPubKey,",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-8",
    "content": "int cliffTime,        // Before this: 0% unlocked\n    int vestingEndTime    // After this: 100% unlocked\n) {\n    // Stage 1: Before cliff - cannot unlock\n    function unlockAfterCliff(sig beneficiarySig) {\n        require(checkSig(beneficiarySig, beneficiaryPubKey));\n        \n        // CRITICAL: Must be at or after cliff time\n        require(tx.time >= cliffTime);\n        \n        // Additional logic: Calculate vested amount based on time\n        // This is a simplified example\n        \n        // BOUNDARY HANDLING:\n        // - Before cliffTime: Transaction invalid (fails require)\n        // - At cliffTime: Transaction valid (>= handles boundary)\n        // - After cliffTime: Transaction valid\n    }\n    \n    // Stage 2: Full unlock after vesting period\n    function unlockFull(sig beneficiarySig) {\n        require(checkSig(beneficiarySig, beneficiaryPubKey));\n        \n        // CRITICAL: Must be at or after vesting end\n        require(tx.time >= vestingEndTime);\n        \n        // Full amount available\n    }\n}\n\n// ============================================================================\n// EXPLANATION: Why Boundary Conditions Matter\n// ============================================================================\n\n// BOUNDARY CONDITION DEFINITION\n// ------------------------------\n// A boundary condition is the exact moment when a state transition occurs.\n// For time locks: The exact block/timestamp when locking ends.\n//\n// Example: unlockTime = 1000\n// - Boundary: Block 1000 is the exact transition point",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-9",
    "content": "// - Before boundary: Blocks 0-999 (locked)\n// - At boundary: Block 1000 (should this be locked or unlocked?)\n// - After boundary: Blocks 1001+ (unlocked)\n//\n// The Question: Is the boundary inclusive or exclusive?\n// - Inclusive (>=): Unlocked AT and AFTER block 1000\n// - Exclusive (>): Unlocked only AFTER block 1000 (block 1001+)\n\n// WHY >= IS CORRECT FOR TIME LOCKS\n// ---------------------------------\n// Semantic Expectation:\n// - \"Unlock at block 1000\" means \"unlocking becomes AVAILABLE at block 1000\"\n// - Users expect to be able to unlock AS SOON AS block 1000 arrives\n// - Block 1000 should be the FIRST block where unlocking works\n//\n// Mathematical Correctness:\n// - Lock period: [0, unlockTime)\n// - Unlock period: [unlockTime, ∞)\n// - The boundary (unlockTime) should be in the unlock period (inclusive)\n//\n// User Experience:\n// - User waits until block 1000\n// - Block 1000 arrives at 10:00:00 AM\n// - User immediately tries to unlock\n// - With >=: Success ✓ (works at 10:00:00)\n// - With >:  Failure ✗ (must wait until block 1001 at 10:10:00)\n// - Off-by-one errors create bad UX and potential financial loss\n\n// WHEN TO USE > VS >=\n// --------------------\n// Use >= (Greater Than or Equal):\n// - Time locks (unlock AT specified time)\n// - Vesting schedules (vest AT maturity)\n// - Embargo periods (allowed AT end time)\n// - Escrow releases (release AT deadline)\n//\n// Use > (Greater Than):\n// - Countdown periods (must EXCEED count)\n// - Increasing sequences (next must be LARGER than previous)",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-10",
    "content": "// - Comparative validations (value must be STRICTLY greater)\n//\n// Rule of Thumb:\n// - If boundary value should be VALID: Use >=\n// - If boundary value should be INVALID: Use >\n//\n// For time locks, boundary should be VALID, so use >=\n\n// THE tx.locktime vs tx.time DISTINCTION\n// ---------------------------------------\n// CRITICAL: These are DIFFERENT values with DIFFERENT meanings\n//\n// tx.locktime:\n// - Transaction field set by user\n// - USER-CONTROLLED (attacker can set any value)\n// - Validated by consensus (miners check against current time)\n// - Purpose: Prevent transaction from being mined too early\n// - NOT suitable for covenant time validation\n//\n// tx.time:\n// - Current block's timestamp (for timestamp locks)\n// - Current block's height (for height locks)\n// - CONSENSUS-VALIDATED (miners cannot fake beyond 2-hour limit)\n// - Purpose: Provide current time to smart contracts\n// - Suitable for covenant time validation\n//\n// NEVER use tx.locktime for covenant time checks\n// ALWAYS use tx.time for covenant time checks\n\n// TIMESTAMP MANIPULATION RISKS\n// -----------------------------\n// Block timestamps are not perfectly accurate:\n// - Miners can set timestamp up to 2 hours in the future\n// - Timestamps can go slightly backward (clock drift)\n// - ~10 minute average per block, but variance exists\n//\n// Mitigation:\n// - Use block HEIGHT for time locks when possible (more predictable)\n// - Accept ~2 hour uncertainty when using timestamps\n// - For critical time-sensitive operations, add safety buffer",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-11",
    "content": "// - Example: If deadline is critical, set unlockTime = deadline - 2 hours\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Using > Instead of >=\n// ---------------------------------\n// WRONG:\n//   require(tx.time > unlockTime);\n//\n// WHY WRONG:\n// - Excludes the boundary (unlockTime)\n// - Creates off-by-one delay\n// - Breaks user expectation\n// - Potential financial impact\n//\n// CORRECT:\n//   require(tx.time >= unlockTime);\n\n// MISTAKE 2: Using tx.locktime Instead of tx.time\n// ------------------------------------------------\n// WRONG:\n//   require(tx.locktime >= unlockTime);\n//\n// WHY WRONG:\n// - tx.locktime is user-controlled\n// - Does not reflect current time\n// - Creates confusion with consensus locktime\n// - Not suitable for covenant validation\n//\n// CORRECT:\n//   require(tx.time >= unlockTime);\n\n// MISTAKE 3: Reversed Logic\n// --------------------------\n// WRONG:\n//   require(unlockTime <= tx.time);\n//\n// WHY WRONG:\n// - Logically equivalent to correct form, but harder to read\n// - More prone to logic errors\n// - Convention is to put constant/expected value on right\n//\n// CORRECT:\n//   require(tx.time >= unlockTime);\n//\n// Note: While logically equivalent, consistency aids readability\n\n// MISTAKE 4: Not Considering Overflow\n// ------------------------------------\n// WRONG:\n//   int unlockTime = startTime + duration;",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-12",
    "content": "//   require(tx.time >= unlockTime);\n//\n// WHY WRONG (if no overflow check):\n// - If duration is very large, startTime + duration may overflow\n// - Overflow wraps to negative or small value\n// - Time lock becomes instantly unlockable\n//\n// CORRECT:\n//   int unlockTime = startTime + duration;\n//   require(unlockTime > startTime);  // Overflow check\n//   require(tx.time >= unlockTime);\n\n// MISTAKE 5: Mixing Block Height and Timestamp\n// ---------------------------------------------\n// WRONG:\n//   // unlockTime = 800000 (block height)\n//   // tx.time returns timestamp (1700000000+)\n//   require(tx.time >= unlockTime);\n//\n// WHY WRONG:\n// - Block heights are 6-7 digits (800000)\n// - Unix timestamps are 10 digits (1700000000)\n// - Comparison is nonsensical\n// - Lock will unlock immediately (timestamp > height always true)\n//\n// CORRECT:\n// - Use consistent units (all block heights OR all timestamps)\n// - Document which unit is expected\n// - CashScript convention: < 500000000 = height, >= 500000000 = timestamp\n// - Validate input is in expected range\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR TIME LOCKS\n// ============================================================================\n\n// PRINCIPLE 1: USE tx.time, NOT tx.locktime\n// ------------------------------------------\n// Always use tx.time for covenant time validation\n// Never use tx.locktime (it's user-controlled)\n\n// PRINCIPLE 2: USE >= FOR UNLOCK CONDITIONS\n// ------------------------------------------",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-13",
    "content": "// Boundary (unlockTime) should be INCLUDED in unlock period\n// Users should be able to unlock AT the specified time\n\n// PRINCIPLE 3: VALIDATE UNIT CONSISTENCY\n// ---------------------------------------\n// Ensure unlockTime and tx.time use same unit (height or timestamp)\n// Add checks if necessary:\n//   if (unlockTime < 500000000) {\n//       // Must be block height, check against block height\n//   } else {\n//       // Must be timestamp, check against timestamp\n//   }\n\n// PRINCIPLE 4: DOCUMENT TIME SEMANTICS\n// -------------------------------------\n// Clearly document whether using block height or timestamp\n// Specify timezone for timestamps (usually UTC)\n// Explain boundary handling to users\n\n// PRINCIPLE 5: ADD OVERFLOW PROTECTION\n// -------------------------------------\n// When calculating unlock times from duration:\n//   int unlockTime = startTime + duration;\n//   require(unlockTime > startTime);  // Prevents overflow\n\n// PRINCIPLE 6: CONSIDER MINER TIMESTAMP MANIPULATION\n// ---------------------------------------------------\n// Accept ~2 hour uncertainty for timestamp-based locks\n// For critical deadlines, add 2-hour safety buffer\n// Prefer block heights when possible (more predictable)\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR TIME-LOCKED CONTRACTS\n// ============================================================================\n//\n// Before deploying a time-locked contract, verify:\n//\n// [ ] Using tx.time (NOT tx.locktime) for time validation",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-14",
    "content": "// [ ] Using >= operator for unlock conditions (NOT >)\n// [ ] unlockTime parameter clearly documented (block height or timestamp)\n// [ ] Unit consistency between unlockTime and tx.time validated\n// [ ] Overflow protection added for calculated unlock times\n// [ ] Boundary behavior tested (unlock exactly at unlockTime)\n// [ ] Off-by-one scenarios tested (block before, at, after unlockTime)\n// [ ] User documentation explains exact unlock semantics\n// [ ] If using timestamps, 2-hour miner manipulation risk accepted\n// [ ] If using block heights, block time variance (~10 min avg) accepted\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================\n//\n// Test Cases for VULNERABLE version (wrong operator):\n// 1. Current time = unlockTime - 1\n//    Expected: Transaction REJECTED (still locked)\n//    Result: REJECTED ✓\n//\n// 2. Current time = unlockTime (BOUNDARY)\n//    Expected: Transaction ACCEPTED (should unlock at boundary)\n//    Result: REJECTED ✗ (VULNERABILITY - off-by-one error)\n//\n// 3. Current time = unlockTime + 1\n//    Expected: Transaction ACCEPTED\n//    Result: ACCEPTED ✓\n//\n// Test Cases for SECURE version (correct operator):\n// 1. Current time = unlockTime - 1\n//    Expected: Transaction REJECTED\n//    Result: REJECTED ✓\n//\n// 2. Current time = unlockTime (BOUNDARY)\n//    Expected: Transaction ACCEPTED\n//    Result: ACCEPTED ✓ (correctly handles boundary)",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-15",
    "content": "//\n// 3. Current time = unlockTime + 1\n//    Expected: Transaction ACCEPTED\n//    Result: ACCEPTED ✓\n//\n// Additional Tests:\n// 4. Overflow test: startTime + duration overflows\n//    Expected: Transaction REJECTED (overflow protection)\n//\n// 5. Unit mismatch: unlockTime (height) vs tx.time (timestamp)\n//    Expected: Logic error caught in testing\n//\n// 6. Edge case: unlockTime = 0\n//    Expected: Immediately unlockable (valid use case)\n\n// ============================================================================\n// REAL-WORLD IMPACT EXAMPLES\n// ============================================================================\n//\n// Example 1: Off-By-One in Escrow\n// --------------------------------\n// Scenario: Escrow contract with 30-day hold period\n// - Start: Block 800,000\n// - Intended unlock: Block 804,320 (30 days * 144 blocks/day)\n// - Vulnerable: require(tx.time > 804320)\n// - User tries to unlock at block 804,320\n// - Rejected: Must wait for block 804,321\n// - Impact: 10-minute delay, potential missed deadline\n//\n// Example 2: Liquidation Time Window\n// -----------------------------------\n// Scenario: Collateralized debt position\n// - Liquidation becomes available at block 900,000\n// - Vulnerable: require(tx.time > 900000)\n// - Block 900,000: Liquidator tries to liquidate underwater position\n// - Rejected: Must wait for block 900,001\n// - By 900,001: Position recovered, no longer underwater\n// - Impact: Failed liquidation, protocol insolvency risk\n//\n// Example 3: Auction Sniper Protection",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/time_validation_error.cash-16",
    "content": "// -------------------------------------\n// Scenario: NFT auction with anti-snipe extension\n// - Bid extends auction by 100 blocks if placed in last 10 blocks\n// - Original end: Block 1000\n// - Vulnerable: require(tx.time > 1000) for claiming\n// - Winner tries to claim at block 1000\n// - Rejected due to off-by-one\n// - Another bidder places bid at block 1000 (still allowed)\n// - Auction extended to block 1100\n// - Impact: Unintended auction extension, winner confusion\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/time_validation_error.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-0",
    "content": "// ANTI-PATTERN: Unvalidated Input Position\n// VULNERABILITY: Missing activeInputIndex validation enables input reordering attacks\n// ATTACK VECTOR: Oracle manipulation, input substitution, validation bypass\n//\n// This file demonstrates the critical vulnerability of assuming input position\n// without explicit validation. In Bitcoin Cash's UTXO model, transaction inputs\n// can be ordered arbitrarily. Without validating `this.activeInputIndex`, attackers\n// can reorder inputs to bypass security checks or manipulate contract behavior.\n//\n// CashScript Version: ^0.13.0\n// Network: Bitcoin Cash (BCH)\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\n\n// ============================================================================\n// VULNERABLE CODE: Missing Input Position Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// VULNERABLE: This contract assumes it's always at input position 0\n// RISK: Attacker can reorder inputs to manipulate which UTXO provides validation\ncontract VulnerableContractAssumedPosition(\n    pubkey oraclePubKey,\n    int minimumValue\n) {\n    // VULNERABILITY: Assumes oracle data comes from input[0]\n    // MISSING: Validation that oracle input is at specific position\n    // MISSING: Validation of this.activeInputIndex\n    function spendWithOracle(sig oracleSig) {\n        // Validate oracle signature\n        require(checkSig(oracleSig, oraclePubKey));\n        \n        // CRITICAL FLAW: Assumes THIS contract is at input[0]",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-1",
    "content": "// and oracle data is at input[1]\n        // But attacker can swap input positions!\n        bytes oracleData = tx.inputs[1].lockingBytecode;\n        \n        // Extract value from assumed oracle position\n        // This extracts 8 bytes starting at position 10 from the bytecode\n        // Assumes specific oracle contract structure\n        bytes8 oracleValueBytes = bytes8(oracleData.split(10)[1].split(8)[0]);\n        int oracleValue = int(oracleValueBytes);\n        \n        // Validate against minimum\n        require(oracleValue >= minimumValue);\n        \n        // DANGER: Never validates which input is the oracle\n        // Never validates which input is THIS contract\n        // Attacker can swap positions to use malicious oracle data\n        \n        // NOTE ON ORACLE DATA ENCODING:\n        // This vulnerable example uses lockingBytecode parsing for illustration ONLY.\n        // Real-world oracle designs encode data via:\n        // - NFT commitments (recommended)\n        // - Token amounts\n        // - Structured output data\n        // NOT by parsing another contract's bytecode (brittle and unsafe).\n    }\n}\n\n// ============================================================================\n// ATTACK SCENARIO 1: Input Reordering to Bypass Oracle Validation\n// ============================================================================\n//\n// Intended Transaction Structure:\n// Inputs:\n//   [0] Main contract UTXO (VulnerableContractAssumedPosition)\n//   [1] Oracle contract UTXO (contains price data: 1000)",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-2",
    "content": "//\n// Outputs:\n//   [0] Withdrawal to user (if oracle price >= minimumValue)\n//\n// Contract logic assumes:\n// - THIS contract is at input[0]\n// - Oracle is at input[1]\n// - Reads oracle value from tx.inputs[1]\n//\n// ATTACK: Swap Input Positions\n//\n// Malicious Transaction Structure:\n// Inputs:\n//   [0] Attacker's FAKE oracle UTXO (contains manipulated data: 9999)\n//   [1] Main contract UTXO (VulnerableContractAssumedPosition) ← THIS contract\n//\n// What happens:\n// - Contract executes at input[1] (not input[0]!)\n// - this.activeInputIndex = 1\n// - Code reads: tx.inputs[1].lockingBytecode\n// - But tx.inputs[1] is ITSELF (the main contract)\n// - Contract reads its own bytecode as \"oracle data\"\n// - Extracts garbage value or manipulated value\n// - Validation bypassed!\n//\n// Alternative Attack:\n// Inputs:\n//   [0] Oracle contract UTXO (real oracle: price = 500, below minimum)\n//   [1] Attacker's fake oracle UTXO (fake data: price = 9999)\n//   [2] Main contract UTXO (VulnerableContractAssumedPosition) ← THIS contract\n//\n// What happens:\n// - Contract executes at input[2]\n// - Code reads: tx.inputs[1].lockingBytecode (attacker's fake oracle!)\n// - Real oracle at input[0] is ignored\n// - Attacker's fake oracle at input[1] provides manipulated data\n// - Contract accepts fake oracle value\n//\n// Result:\n// - Oracle validation BYPASSED\n// - Contract makes decisions based on attacker-controlled data\n// - Price oracle manipulation successful\n\n// ============================================================================",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-3",
    "content": "// ATTACK SCENARIO 2: Self-Reference Attack\n// ============================================================================\n//\n// Setup:\n// - Contract requires oracle value >= 1000\n// - Real oracle shows value = 500 (below threshold)\n// - Attacker wants to execute despite low oracle value\n//\n// Attack Transaction:\n// Inputs:\n//   [0] Attacker's dummy UTXO (any UTXO with enough value)\n//   [1] Main contract UTXO (VulnerableContractAssumedPosition) ← THIS contract\n//\n// Execution Flow:\n// - Contract executes at input[1] (this.activeInputIndex = 1)\n// - Code executes: bytes oracleData = tx.inputs[1].lockingBytecode;\n// - tx.inputs[1] is the contract ITSELF\n// - Contract reads its own lockingBytecode as oracle data\n//\n// Bytecode Structure of VulnerableContractAssumedPosition:\n// - Contains oraclePubKey (33 bytes)\n// - Contains minimumValue (8 bytes)\n// - Contains contract code\n//\n// ⚠️ ILLUSTRATIVE SCENARIO ONLY:\n// This attack describes bytecode parsing for demonstration purposes.\n// Real oracles use NFT commitments or token amounts, not bytecode parsing.\n// The vulnerability (missing position validation) remains the same regardless\n// of how oracle data is encoded.\n//\n// If contract tried to extract data from its own bytecode:\n// - Attacker can extract minimumValue from contract's own bytecode\n// - Contract compares: minimumValue >= minimumValue (always true!)\n// - Validation passes with no real oracle involved\n//\n// Result:\n// - Oracle check completely bypassed\n// - Contract validates against its own parameters",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-4",
    "content": "// - Security model destroyed\n\n// ============================================================================\n// ATTACK SCENARIO 3: Multi-Contract Input Confusion\n// ============================================================================\n//\n// Complex DeFi scenario with multiple contracts:\n//\n// Intended Structure:\n// Inputs:\n//   [0] Price Oracle Contract (BTC price: $45,000)\n//   [1] Liquidation Contract (checks if position underwater)\n//   [2] Collateral Vault (holds user's collateral)\n//\n// Contract at input[1] (Liquidation Contract) assumes:\n// - Oracle is at input[0]\n// - Vault is at input[2]\n// - Reads price from tx.inputs[0]\n// - Reads collateral from tx.inputs[2]\n//\n// Attack via Reordering:\n// Inputs:\n//   [0] Attacker's Fake Oracle (BTC price: $1,000,000) ← Malicious\n//   [1] Collateral Vault (holds user's collateral)\n//   [2] Liquidation Contract (checks position) ← THIS contract\n//\n// Execution:\n// - Liquidation contract executes at input[2]\n// - Code reads: tx.inputs[0] (attacker's fake oracle!)\n// - Code reads: tx.inputs[2] (itself - wrong data!)\n// - Price is manipulated (shows impossibly high)\n// - Collateral calculation uses wrong input\n// - Liquidation decision corrupted\n//\n// Result:\n// - Legitimate liquidation prevented (price shows \"safe\")\n// - Or malicious liquidation enabled (if reversed)\n// - Multi-contract coordination exploited\n\n// ============================================================================\n// WHY THIS VULNERABILITY EXISTS\n// ============================================================================",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-5",
    "content": "//\n// Bitcoin Cash UTXO Model Properties:\n// 1. Transaction inputs are an ORDERED ARRAY: [input0, input1, input2, ...]\n// 2. Input order is ARBITRARY - wallet/attacker chooses the order\n// 3. Each input is evaluated INDEPENDENTLY by its locking script\n// 4. Scripts CANNOT assume their position without explicit validation\n//\n// CashScript Special Variables:\n// - this.activeInputIndex: The index of the CURRENT input being validated\n// - tx.inputs[N]: Array of ALL inputs in the transaction\n//\n// The Vulnerability:\n// - tx.inputs[N] provides absolute position access\n// - this.activeInputIndex tells you YOUR position\n// - If code uses tx.inputs[1] without checking this.activeInputIndex...\n// - ...it assumes input[1] is always some specific contract\n// - But attacker controls input ordering!\n//\n// Example:\n// Contract expects: [MainContract, Oracle, Vault]\n// Attacker creates: [FakeOracle, Vault, MainContract]\n// Contract at position[2] reads tx.inputs[1] expecting Oracle\n// But tx.inputs[1] is now Vault (wrong contract!)\n\n// ============================================================================\n// SECURE VERSION: Explicit Position Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// SECURE: This contract validates its position and oracle position explicitly\n// PROTECTION: Prevents input reordering attacks and position manipulation\ncontract SecureContractValidatedPosition(\n    pubkey oraclePubKey,\n    int minimumValue,",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-6",
    "content": "bytes expectedOracleBytecode  // Expected oracle contract bytecode\n) {\n    // SECURE: Explicitly validates input positions before using them\n    function spendWithOracle(sig oracleSig) {\n        // Step 1: Validate oracle signature\n        require(checkSig(oracleSig, oraclePubKey));\n        \n        // Step 2: CRITICAL - Validate THIS contract's position\n        // Enforce that this contract MUST be at input[0]\n        // This creates a predictable position for oracle validation\n        //\n        // ⚠️ UX WARNING:\n        // Enforcing a fixed input position requires wallets and tooling\n        // to construct transactions in this exact order.\n        // This pattern trades flexibility for security.\n        // Ensure your wallet/SDK can handle positional requirements.\n        require(this.activeInputIndex == 0);\n        \n        // Step 3: CRITICAL - Validate oracle is at expected position\n        // Since this contract is at input[0], oracle MUST be at input[1]\n        int expectedOraclePosition = 1;\n        \n        // Step 4: Validate transaction has enough inputs\n        // Need at least 2 inputs (this contract + oracle)\n        require(tx.inputs.length >= 2);\n        \n        // Step 5: CRITICAL - Validate oracle contract bytecode\n        // Ensure tx.inputs[1] is actually the expected oracle contract\n        // Not just any contract, not this contract, not attacker's contract\n        bytes oracleLockingBytecode = tx.inputs[expectedOraclePosition].lockingBytecode;\n        require(oracleLockingBytecode == expectedOracleBytecode);",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-7",
    "content": "// Step 6: NOW it's safe to read oracle data\n        // We've proven:\n        // - THIS contract is at input[0]\n        // - Oracle contract is at input[1]\n        // - Oracle contract is the CORRECT oracle (bytecode matches)\n        \n        // REAL-WORLD PATTERN: Oracle value encoded in NFT commitment\n        // This is the RECOMMENDED approach for oracle data\n        bytes oracleCommitment = tx.inputs[expectedOraclePosition].nftCommitment;\n        \n        // Step 7: Extract and validate oracle value from commitment\n        // NFT commitment contains structured data (e.g., price encoded as bytes)\n        // For demonstration: assume commitment is 8-byte integer (price in satoshis)\n        require(oracleCommitment.length == 8);\n        bytes8 oracleValueBytes = bytes8(oracleCommitment);\n        int oracleValue = int(oracleValueBytes);\n        require(oracleValue >= minimumValue);\n        \n        // RESULT: Input reordering attacks are now IMPOSSIBLE\n        // - Position validated: this.activeInputIndex == 0\n        // - Oracle position validated: input[1] exists\n        // - Oracle identity validated: bytecode matches expected\n        // - Attacker cannot swap inputs without failing validation\n    }\n}\n\n// ============================================================================\n// ALTERNATIVE PATTERN: Flexible Position with Explicit Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ALTERNATIVE: Contract that works at any position but validates relationships",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-8",
    "content": "// USE CASE: More flexible but requires careful relative position validation\ncontract SecureContractRelativePosition(\n    pubkey oraclePubKey,\n    int minimumValue,\n    bytes expectedOracleBytecode\n) {\n    // Pattern: Use relative positions based on this.activeInputIndex\n    function spendWithOracle(sig oracleSig, int oracleOffset) {\n        // Step 1: Validate oracle signature\n        require(checkSig(oracleSig, oraclePubKey));\n        \n        // Step 2: Calculate oracle position relative to this contract\n        // oracleOffset tells us where oracle is relative to this input\n        // Example: oracleOffset = -1 means oracle is one position before\n        //          oracleOffset = +1 means oracle is one position after\n        int oraclePosition = this.activeInputIndex + oracleOffset;\n        \n        // Step 3: Validate oracle position is within bounds\n        require(oraclePosition >= 0);\n        require(oraclePosition < tx.inputs.length);\n        \n        // Step 4: Validate oracle is not self-referencing\n        // Oracle must be a DIFFERENT input than this contract\n        require(oraclePosition != this.activeInputIndex);\n        \n        // Step 5: CRITICAL - Validate oracle contract bytecode\n        bytes oracleLockingBytecode = tx.inputs[oraclePosition].lockingBytecode;\n        require(oracleLockingBytecode == expectedOracleBytecode);\n        \n        // Step 6: Read and validate oracle data\n        // REAL-WORLD PATTERN: Use NFT commitment for oracle data\n        bytes oracleCommitment = tx.inputs[oraclePosition].nftCommitment;",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-9",
    "content": "require(oracleCommitment.length == 8);\n        bytes8 oracleValueBytes = bytes8(oracleCommitment);\n        int oracleValue = int(oracleValueBytes);\n        require(oracleValue >= minimumValue);\n        \n        // RESULT: Flexible positioning but still secure\n        // - Oracle position calculated relative to this.activeInputIndex\n        // - Oracle identity validated via bytecode\n        // - Self-reference prevented\n        // - Works regardless of this contract's position\n    }\n}\n\n// ============================================================================\n// ADVANCED PATTERN: Multiple Input Validation\n// ============================================================================\n\npragma cashscript ^0.13.0;\n\n// ADVANCED: Contract coordinating multiple inputs with strict validation\n// USE CASE: DeFi protocols with oracle, vault, and governance contracts\ncontract SecureMultiInputContract(\n    pubkey governancePubKey,\n    bytes expectedOracleBytecode,\n    bytes expectedVaultBytecode\n) {\n    // Pattern: Validate multiple contract inputs at fixed positions\n    function complexOperation(sig govSig) {\n        // Step 1: Validate authorization\n        require(checkSig(govSig, governancePubKey));\n        \n        // Step 2: CRITICAL - Enforce strict input structure\n        // This contract must be at position 0\n        //\n        // ⚠️ UX WARNING:\n        // Fixed position requirements mean wallets must construct\n        // transactions with inputs in exact order: [this, oracle, vault]",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-10",
    "content": "// This is a security vs flexibility tradeoff.\n        require(this.activeInputIndex == 0);\n        \n        // Step 3: Validate minimum input count\n        // Need: [this, oracle, vault] = 3 inputs minimum\n        require(tx.inputs.length >= 3);\n        \n        // Step 4: Define expected positions\n        int thisPosition = 0;      // Validated above\n        int oraclePosition = 1;    // Oracle must be at input[1]\n        int vaultPosition = 2;     // Vault must be at input[2]\n        \n        // Step 5: CRITICAL - Validate oracle contract identity\n        bytes oracleBytecode = tx.inputs[oraclePosition].lockingBytecode;\n        require(oracleBytecode == expectedOracleBytecode);\n        \n        // Step 6: CRITICAL - Validate vault contract identity\n        bytes vaultBytecode = tx.inputs[vaultPosition].lockingBytecode;\n        require(vaultBytecode == expectedVaultBytecode);\n        \n        // Step 7: Validate all inputs are DIFFERENT contracts\n        // Prevent using same contract in multiple positions\n        require(oracleBytecode != vaultBytecode);\n        require(tx.inputs[thisPosition].lockingBytecode != oracleBytecode);\n        require(tx.inputs[thisPosition].lockingBytecode != vaultBytecode);\n        \n        // Step 8: Now safe to read data from each input\n        // REAL-WORLD PATTERN: Use NFT commitments for structured data\n        \n        // Read oracle price from NFT commitment\n        bytes oracleCommitment = tx.inputs[oraclePosition].nftCommitment;",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-11",
    "content": "require(oracleCommitment.length >= 8);\n        bytes8 priceBytes = bytes8(oracleCommitment.split(8)[0]);\n        int oraclePrice = int(priceBytes);\n        \n        // Read vault balance from NFT commitment\n        bytes vaultCommitment = tx.inputs[vaultPosition].nftCommitment;\n        require(vaultCommitment.length >= 8);\n        bytes8 balanceBytes = bytes8(vaultCommitment.split(8)[0]);\n        int vaultBalance = int(balanceBytes);\n        \n        // Step 9: Business logic using validated data\n        require(oraclePrice > 0);\n        require(vaultBalance >= 1000);\n        \n        // RESULT: Multi-input coordination is SECURE\n        // - All positions explicitly validated\n        // - All contract identities verified\n        // - No duplicate inputs allowed\n        // - Input reordering cannot bypass checks\n    }\n}\n\n// ============================================================================\n// ORACLE DATA ENCODING: REAL-WORLD PATTERNS\n// ============================================================================\n\n// CRITICAL KNOWLEDGE: How Oracle Data Should Be Encoded\n// -------------------------------------------------------\n// This file demonstrates input position validation, NOT oracle design.\n// Real-world BCH oracles use these patterns for data encoding:\n//\n// ✅ RECOMMENDED: NFT Commitment\n//   - Oracle holds an NFT with data in the commitment field\n//   - Commitment contains structured price/data (e.g., 8-byte integer)\n//   - Example: bytes oracleCommitment = tx.inputs[oraclePos].nftCommitment;",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-12",
    "content": "//   - Advantages: Structured, tamper-proof, updatable via covenant\n//\n// ✅ RECOMMENDED: Token Amount\n//   - Fungible token amount represents the oracle value\n//   - Example: int price = tx.inputs[oraclePos].tokenAmount;\n//   - Advantages: Simple, efficient, works with existing token infrastructure\n//\n// ✅ ALTERNATIVE: Structured Output Data\n//   - Oracle creates specific output pattern with embedded data\n//   - Data in OP_RETURN or structured locking bytecode\n//   - Requires careful parsing of output scripts\n//\n// ❌ NOT RECOMMENDED: Parsing Contract Bytecode\n//   - DO NOT extract data by slicing lockingBytecode (brittle, unsafe)\n//   - Contract bytecode is code, not data storage\n//   - Changes to contract structure break parsing\n//   - This pattern appears in this file ONLY for position validation demonstration\n//\n// For production oracle systems:\n// 1. Use NFT commitments or token amounts for data\n// 2. Validate oracle contract identity via bytecode comparison\n// 3. Validate input position to prevent reordering attacks\n// 4. Combine all three validations for secure oracle consumption\n\n// ============================================================================\n// EXPLANATION: Understanding this.activeInputIndex\n// ============================================================================\n\n// WHAT IS this.activeInputIndex?\n// -------------------------------\n// - Special variable in CashScript\n// - Contains the index (position) of the CURRENT input being validated\n// - 0-indexed: first input is 0, second is 1, third is 2, etc.",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-13",
    "content": "// - Changes for each input in the transaction\n//\n// Example Transaction:\n// Inputs:\n//   [0] ContractA.cash\n//   [1] ContractB.cash  \n//   [2] ContractC.cash\n//\n// When evaluating input[0]: this.activeInputIndex = 0\n// When evaluating input[1]: this.activeInputIndex = 1\n// When evaluating input[2]: this.activeInputIndex = 2\n\n// WHY VALIDATE this.activeInputIndex?\n// ------------------------------------\n// Bitcoin Cash allows arbitrary input ordering. Attacker controls:\n// 1. Which UTXOs become inputs\n// 2. The ORDER of those inputs\n// 3. Which input positions contain which contracts\n//\n// Without validation:\n// - Code assumes \"oracle is at input[1]\"\n// - But attacker puts malicious oracle at input[1]\n// - Or swaps positions entirely\n// - Contract reads wrong data\n//\n// With validation:\n// - Code checks: require(this.activeInputIndex == 0)\n// - Enforces: \"I must be at position 0\"\n// - Then safely reads: tx.inputs[1] (knowing 1 is adjacent)\n// - Attacker cannot reorder without failing the check\n\n// COMMON PATTERNS FOR POSITION VALIDATION\n// ----------------------------------------\n//\n// Pattern 1: Fixed Absolute Position\n//   require(this.activeInputIndex == 0);\n//   // This contract MUST be first input\n//   // Use when: strict ordering required\n//\n// Pattern 2: Fixed Relative Positions  \n//   require(this.activeInputIndex == 0);\n//   int oraclePos = this.activeInputIndex + 1;  // Oracle is next\n//   // Use when: contracts must be adjacent\n//\n// Pattern 3: Flexible Position (Advanced)",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-14",
    "content": "//   int myPos = this.activeInputIndex;\n//   int oraclePos = myPos + oracleOffset;  // Offset provided by user\n//   require(oraclePos != myPos);           // Prevent self-reference\n//   // Use when: flexibility needed but validation still required\n//\n// Pattern 4: No Position Assumptions\n//   // Don't read other inputs at all\n//   // Only read from this.activeInputIndex\n//   bytes myData = tx.inputs[this.activeInputIndex].lockingBytecode;\n//   // Use when: contract is self-contained\n\n// THE SELF-REFERENCE TRAP\n// ------------------------\n// Dangerous code:\n//   bytes oracleData = tx.inputs[1].lockingBytecode;\n//\n// If this contract is at input[1]:\n//   - tx.inputs[1] is THIS CONTRACT\n//   - Contract reads its own bytecode as \"oracle\"\n//   - May extract its own parameters as \"oracle data\"\n//   - Creates circular validation (always passes)\n//\n// Prevention:\n//   require(this.activeInputIndex == 0);  // Can't be at position 1\n//   bytes oracleData = tx.inputs[1].lockingBytecode;  // Now safe\n\n// ============================================================================\n// SECURITY PRINCIPLES FOR INPUT POSITION VALIDATION\n// ============================================================================\n\n// PRINCIPLE 1: NEVER ASSUME INPUT POSITION\n// -----------------------------------------\n// WRONG: bytes oracle = tx.inputs[1].lockingBytecode;\n// RIGHT: \n//   require(this.activeInputIndex == 0);\n//   bytes oracle = tx.inputs[1].lockingBytecode;\n\n// PRINCIPLE 2: VALIDATE IDENTITY, NOT JUST POSITION",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-15",
    "content": "// --------------------------------------------------\n// Position validation alone is insufficient:\n//   require(this.activeInputIndex == 0);\n//   bytes oracle = tx.inputs[1].lockingBytecode;  // Could be ANY contract!\n//\n// Must also validate bytecode:\n//   require(this.activeInputIndex == 0);\n//   require(tx.inputs[1].lockingBytecode == expectedOracleBytecode);\n\n// PRINCIPLE 3: PREVENT SELF-REFERENCE\n// ------------------------------------\n// Always ensure you're not reading from your own input:\n//   int oraclePos = this.activeInputIndex + offset;\n//   require(oraclePos != this.activeInputIndex);\n\n// PRINCIPLE 4: VALIDATE INPUT COUNT\n// ----------------------------------\n// Before accessing tx.inputs[N], verify it exists:\n//   require(tx.inputs.length > N);\n\n// PRINCIPLE 5: EXPLICIT IS BETTER THAN IMPLICIT\n// ----------------------------------------------\n// Don't rely on \"convention\" or \"expected structure\"\n// Write explicit validation for every assumption\n\n// ============================================================================\n// COMMON MISTAKES AND HOW TO AVOID THEM\n// ============================================================================\n\n// MISTAKE 1: Hardcoded Position Without Validation\n// -------------------------------------------------\n// WRONG:\n//   bytes oracle = tx.inputs[1].lockingBytecode;\n//\n// WHY WRONG:\n// - Assumes input[1] exists\n// - Assumes input[1] is oracle\n// - Assumes this contract is NOT at input[1]\n//\n// CORRECT:\n//   require(this.activeInputIndex == 0);",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-16",
    "content": "//   require(tx.inputs.length >= 2);\n//   require(tx.inputs[1].lockingBytecode == expectedOracleBytecode);\n//   bytes oracle = tx.inputs[1].lockingBytecode;\n\n// MISTAKE 2: Relative Positions Without Self-Reference Check\n// -----------------------------------------------------------\n// WRONG:\n//   int oraclePos = this.activeInputIndex - 1;\n//   bytes oracle = tx.inputs[oraclePos].lockingBytecode;\n//\n// WHY WRONG:\n// - If this.activeInputIndex == 0, oraclePos = -1 (invalid!)\n// - No bounds checking\n//\n// CORRECT:\n//   int oraclePos = this.activeInputIndex - 1;\n//   require(oraclePos >= 0);\n//   require(tx.inputs[oraclePos].lockingBytecode == expectedOracleBytecode);\n\n// MISTAKE 3: Assuming Input Count\n// --------------------------------\n// WRONG:\n//   bytes input2 = tx.inputs[2].lockingBytecode;\n//\n// WHY WRONG:\n// - Transaction might only have 2 inputs (indices 0, 1)\n// - Accessing tx.inputs[2] would fail\n//\n// CORRECT:\n//   require(tx.inputs.length >= 3);\n//   bytes input2 = tx.inputs[2].lockingBytecode;\n\n// MISTAKE 4: Not Validating Contract Identity\n// --------------------------------------------\n// WRONG:\n//   require(this.activeInputIndex == 0);\n//   bytes oracle = tx.inputs[1].lockingBytecode;\n//   // Assumes input[1] is oracle, but doesn't check!\n//\n// WHY WRONG:\n// - Attacker can put ANY contract at input[1]\n// - Position is correct, but identity is wrong\n//\n// CORRECT:\n//   require(this.activeInputIndex == 0);\n//   require(tx.inputs[1].lockingBytecode == expectedOracleBytecode);",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-17",
    "content": "//   bytes oracle = tx.inputs[1].lockingBytecode;\n\n// ============================================================================\n// DEPLOYMENT CHECKLIST FOR INPUT POSITION VALIDATION\n// ============================================================================\n//\n// Before deploying a contract that reads other inputs:\n//\n// [ ] If reading tx.inputs[N], validate this.activeInputIndex\n// [ ] Validate tx.inputs.length is sufficient for all accessed indices\n// [ ] Validate bytecode of all external inputs (identity check)\n// [ ] Prevent self-reference (ensure N != this.activeInputIndex)\n// [ ] Document expected transaction structure clearly\n// [ ] Test with inputs in different orders (reordering attacks)\n// [ ] Test with malicious contracts at expected positions\n// [ ] Test with insufficient inputs (out of bounds)\n// [ ] Test with this contract at different positions\n// [ ] Verify no assumptions about input ordering remain\n\n// ============================================================================\n// TESTING RECOMMENDATIONS\n// ============================================================================\n//\n// Test Cases for VULNERABLE version:\n// 1. Normal structure: [MainContract, Oracle]\n//    Expected: SUCCEEDS (works as intended)\n//\n// 2. Swapped: [Oracle, MainContract]\n//    Expected: SUCCEEDS (VULNERABILITY - should fail)\n//    Result: Contract reads itself as oracle\n//\n// 3. Fake oracle: [FakeOracle, MainContract]  \n//    Expected: SUCCEEDS (VULNERABILITY - should fail)",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-18",
    "content": "//    Result: Contract reads fake oracle data\n//\n// 4. Multiple positions: [Oracle, FakeOracle, MainContract]\n//    Expected: SUCCEEDS (VULNERABILITY - should fail)\n//    Result: Contract reads FakeOracle instead of real Oracle\n//\n// Test Cases for SECURE version:\n// 1. Normal structure: [MainContract, Oracle]\n//    Expected: SUCCEEDS (valid transaction)\n//\n// 2. Swapped: [Oracle, MainContract]\n//    Expected: FAILS (this.activeInputIndex != 0)\n//\n// 3. Fake oracle: [MainContract, FakeOracle]\n//    Expected: FAILS (bytecode doesn't match expectedOracleBytecode)\n//\n// 4. Wrong position: [Something, MainContract, Oracle]\n//    Expected: FAILS (this.activeInputIndex == 1, not 0)\n//\n// 5. Insufficient inputs: [MainContract]\n//    Expected: FAILS (tx.inputs.length < 2)\n\n// ============================================================================\n// REAL-WORLD APPLICATIONS\n// ============================================================================\n//\n// Use Cases Requiring Position Validation:\n//\n// 1. ORACLE-DEPENDENT CONTRACTS\n//    - Price oracles for DeFi\n//    - Data feeds for conditional execution\n//    - Time-locked contracts with timestamp validation\n//\n// 2. MULTI-SIGNATURE COORDINATION\n//    - Multiple contracts must sign in specific order\n//    - Governance + treasury + execution contracts\n//    - Layered approval systems\n//\n// 3. ATOMIC SWAPS\n//    - Party A contract at position 0\n//    - Party B contract at position 1\n//    - Must validate both positions and identities",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/anti_pattern/unvalidated_position.cash-19",
    "content": "//\n// 4. DEFI PROTOCOLS\n//    - Collateral vault + price oracle + liquidation engine\n//    - Each component at specific position\n//    - Input ordering critical for correct valuation\n//\n// 5. COVENANT CHAINS\n//    - Parent covenant at position 0\n//    - Child covenant at position 1\n//    - Inheritance and state validation requires position awareness\n\n// ============================================================================\n// END OF FILE\n// ============================================================================",
    "source": "NexKB/anti_pattern/unvalidated_position.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-0",
    "content": "// ANTI-PATTERN: Vulnerable Covenant\r\n// VULNERABILITY: Missing output validation allows multiple critical attacks\r\n// ATTACK VECTOR: Code injection, token category substitution, value extraction\r\n//\r\n// This file demonstrates THREE critical covenant vulnerabilities:\r\n// 1. Missing lockingBytecode validation (code injection)\r\n// 2. Missing tokenCategory validation (token substitution)\r\n// 3. Missing value validation (value extraction)\r\n//\r\n// CashScript Version: ^0.13.0\r\n// Network: Bitcoin Cash (BCH)\r\n// Security Level: VULNERABLE - DO NOT USE IN PRODUCTION\r\n\r\n// ============================================================================\r\n// VULNERABLE CODE: Missing Critical Output Validations\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// VULNERABLE: This covenant fails to validate output properties\r\n// RISK: Attackers can modify outputs to steal funds or inject malicious code\r\ncontract VulnerableCovenantNoValidation(\r\n    pubkey ownerPubKey\r\n) {\r\n    // VULNERABILITY: Only verifies signature, assumes output will be correct\r\n    // MISSING: lockingBytecode check (allows code injection)\r\n    // MISSING: tokenCategory check (allows token substitution)\r\n    // MISSING: value check (allows value extraction)\r\n    function spend(sig ownerSig) {\r\n        // Only validates the signature\r\n        require(checkSig(ownerSig, ownerPubKey));\r\n        \r\n        // CRITICAL FLAW: No validation of tx.outputs[0]\r\n        // Attacker can create ANY output they want:",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-1",
    "content": "// - Different contract code (code injection)\r\n        // - Different token category (token theft)\r\n        // - Different BCH amount (value extraction)\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 1: Code Injection via Missing lockingBytecode Validation\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds 1000 sats\r\n// - lockingBytecode: <VulnerableCovenantNoValidation bytecode>\r\n//\r\n// Attack Transaction:\r\n// Input:\r\n//   - VulnerableCovenantNoValidation UTXO (1000 sats)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Output:\r\n//   - 950 sats to ATTACKER-CONTROLLED contract with different bytecode\r\n//   - Attacker's contract has backdoor: allows unrestricted withdrawal\r\n//\r\n// Result:\r\n// - Covenant \"continues\" but code is now malicious\r\n// - Attacker can drain all funds from new contract\r\n// - Original covenant security guarantees DESTROYED\r\n//\r\n// Why it works:\r\n// - Contract never checks: tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode\r\n// - Any bytecode is accepted as long as signature is valid\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 2: Token Category Substitution\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds NFT with category: 0xAABBCCDD... (valuable NFT)",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-2",
    "content": "// - Contract enforces covenant pattern\r\n//\r\n// Attack Transaction:\r\n// Input:\r\n//   - VulnerableCovenantNoValidation UTXO (valuable NFT)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Output:\r\n//   - Different tokenCategory: 0x11223344... (worthless token attacker created)\r\n//   - Attacker keeps the valuable NFT category: 0xAABBCCDD...\r\n//\r\n// Result:\r\n// - Covenant continues with worthless token\r\n// - Attacker extracted valuable NFT\r\n// - Token custody guarantees VIOLATED\r\n//\r\n// Why it works:\r\n// - Contract never checks: tx.outputs[0].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory\r\n// - Any category (or no category) is accepted\r\n\r\n// ============================================================================\r\n// ATTACK SCENARIO 3: Value Extraction Attack\r\n// ============================================================================\r\n//\r\n// Initial State:\r\n// - Contract holds 10,000 sats\r\n// - Intended behavior: preserve value in covenant\r\n//\r\n// Attack Transaction:\r\n// Input:\r\n//   - VulnerableCovenantNoValidation UTXO (10,000 sats)\r\n//   - Valid signature from ownerPubKey\r\n//\r\n// Outputs:\r\n//   - Output 0: 546 sats (dust) to same contract\r\n//   - Output 1: 9,400 sats to attacker's address\r\n//\r\n// Result:\r\n// - Covenant continues with only dust amount\r\n// - Attacker extracted 94% of the value\r\n// - Value preservation FAILED\r\n//\r\n// Why it works:\r\n// - Contract never checks: tx.outputs[0].value == tx.inputs[this.activeInputIndex].value\r\n// - Any value is accepted (even dust amounts)",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-3",
    "content": "// ============================================================================\r\n// SECURE VERSION: Explicit Output Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// SECURE: This covenant validates ALL critical output properties\r\n// PROTECTION: Prevents code injection, token substitution, and value extraction\r\ncontract SecureCovenantWithValidation(\r\n    pubkey ownerPubKey\r\n) {\r\n    // SECURE: Validates signature AND enforces output constraints\r\n    // INCLUDES: lockingBytecode, tokenCategory, and value validation\r\n    function spend(sig ownerSig) {\r\n        // Step 1: Validate authorization (signature check)\r\n        require(checkSig(ownerSig, ownerPubKey));\r\n        \r\n        // Step 2: CRITICAL - Validate lockingBytecode (prevents code injection)\r\n        // Ensures output[0] uses the EXACT SAME contract code as this input\r\n        // This prevents attackers from replacing contract logic with malicious code\r\n        bytes inputLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        bytes outputLockingBytecode = tx.outputs[0].lockingBytecode;\r\n        require(outputLockingBytecode == inputLockingBytecode);\r\n        \r\n        // Step 3: CRITICAL - Validate tokenCategory (prevents token substitution)\r\n        // Ensures output[0] preserves the EXACT SAME token category as this input\r\n        // This prevents attackers from swapping valuable tokens with worthless ones\r\n        bytes inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-4",
    "content": "bytes outputTokenCategory = tx.outputs[0].tokenCategory;\r\n        require(outputTokenCategory == inputTokenCategory);\r\n        \r\n        // Step 4: CRITICAL - Validate value (prevents value extraction)\r\n        // Ensures output[0] preserves the EXACT SAME BCH amount as this input\r\n        // This prevents attackers from draining value while maintaining covenant\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        int outputValue = tx.outputs[0].value;\r\n        require(outputValue == inputValue);\r\n        \r\n        // RESULT: All three attack vectors are now IMPOSSIBLE\r\n        // - Code injection: BLOCKED by lockingBytecode check\r\n        // - Token substitution: BLOCKED by tokenCategory check\r\n        // - Value extraction: BLOCKED by value check\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// EXPLANATION: Why Each Validation Is Critical\r\n// ============================================================================\r\n\r\n// 1. LOCKINGBYTECODE VALIDATION\r\n// ------------------------------\r\n// What it protects:\r\n// - Ensures covenant contract code cannot be changed mid-chain\r\n// - Prevents attacker from injecting backdoors or malicious logic\r\n// - Maintains immutability guarantee of smart contract rules\r\n//\r\n// Without this check:\r\n// - Attacker can replace contract with one that allows unrestricted withdrawal\r\n// - Covenant security model is completely destroyed\r\n// - All downstream transactions inherit the malicious code",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-5",
    "content": "//\r\n// Implementation:\r\n// require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);\r\n//\r\n// This MUST compare the EXACT bytecode, not just contract type or template.\r\n// Even one byte difference could introduce a critical vulnerability.\r\n\r\n// 2. TOKENCATEGORY VALIDATION\r\n// ----------------------------\r\n// What it protects:\r\n// - Ensures NFTs and fungible tokens remain in the covenant\r\n// - Prevents token category swapping attacks\r\n// - Maintains custody of valuable digital assets\r\n//\r\n// Without this check:\r\n// - Attacker can swap valuable NFT category with worthless token\r\n// - Token-based access controls can be bypassed\r\n// - Multi-token covenants can have categories mixed/stolen\r\n//\r\n// Implementation:\r\n// require(tx.outputs[0].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory);\r\n//\r\n// Note: This checks the CATEGORY (transaction ID of token genesis).\r\n// For NFTs, you may also need to validate commitment and capability.\r\n// For fungible tokens, you may need to validate amount.\r\n\r\n// 3. VALUE VALIDATION\r\n// -------------------\r\n// What it protects:\r\n// - Ensures BCH satoshi amount is preserved in covenant\r\n// - Prevents gradual or sudden value extraction\r\n// - Maintains economic value of the contract\r\n//\r\n// Without this check:\r\n// - Attacker can reduce output to dust (546 sats) and pocket the rest\r\n// - Covenant continues but with negligible value\r\n// - Economic security guarantees are violated\r\n//\r\n// Implementation:\r\n// require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value);",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-6",
    "content": "//\r\n// Alternative patterns:\r\n// - Allow value to decrease by exactly tx fee amount\r\n// - Allow value to increase (deposits)\r\n// - Require minimum value threshold\r\n//\r\n// Choose based on your specific covenant requirements.\r\n\r\n// ============================================================================\r\n// CRITICAL SECURITY PRINCIPLES\r\n// ============================================================================\r\n\r\n// PRINCIPLE 1: VALIDATE EVERYTHING\r\n// ---------------------------------\r\n// Never assume outputs will be correct just because inputs are authorized.\r\n// Signature validation (checkSig) only proves WHO created the transaction.\r\n// It does NOT prove WHAT the transaction does.\r\n// You must EXPLICITLY check every output property that matters.\r\n\r\n// PRINCIPLE 2: COMPARE AGAINST INPUT STATE\r\n// -----------------------------------------\r\n// Use tx.inputs[this.activeInputIndex] to access the CURRENT contract state.\r\n// Compare output properties against THIS input, not hardcoded values.\r\n// This ensures the covenant adapts to its current state correctly.\r\n\r\n// PRINCIPLE 3: EXPLICIT IS BETTER THAN IMPLICIT\r\n// ----------------------------------------------\r\n// Do not rely on \"default behavior\" or \"assumed properties.\"\r\n// Write out every check explicitly, even if it seems redundant.\r\n// Code clarity prevents security bugs.\r\n\r\n// PRINCIPLE 4: FAIL CLOSED, NOT OPEN\r\n// -----------------------------------\r\n// If a validation cannot be performed (e.g., missing field), REJECT.",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-7",
    "content": "// Use require() statements that MUST pass for transaction to be valid.\r\n// Never use optional checks or \"best effort\" validation.\r\n\r\n// PRINCIPLE 5: ONE OUTPUT, MANY CHECKS\r\n// -------------------------------------\r\n// Even a single covenant output needs multiple validations:\r\n// - lockingBytecode (code integrity)\r\n// - tokenCategory (asset custody)\r\n// - value (economic preservation)\r\n// - tokenAmount (for fungible tokens)\r\n// - nftCommitment (for NFTs with data)\r\n// - tokenCapability (for mutable/minting NFTs)\r\n//\r\n// Missing ANY of these can create an exploitable vulnerability.\r\n\r\n// ============================================================================\r\n// DEPLOYMENT CHECKLIST\r\n// ============================================================================\r\n//\r\n// Before deploying a covenant contract, verify:\r\n//\r\n// [ ] lockingBytecode validation is present and correct\r\n// [ ] tokenCategory validation matches covenant requirements\r\n// [ ] value validation prevents extraction attacks\r\n// [ ] All tx.outputs[N] indices are correct (0-indexed)\r\n// [ ] All tx.inputs[this.activeInputIndex] references are correct\r\n// [ ] Comparison operators are correct (== not = or !=)\r\n// [ ] require() statements will revert on failure\r\n// [ ] No assumptions about output ordering beyond what's checked\r\n// [ ] No assumptions about fee handling beyond what's checked\r\n// [ ] Test with malicious transactions attempting each attack vector\r\n//\r\n// REMEMBER: One missing check can compromise the entire covenant security model.",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/anti_pattern/vulnerable_covenant.cash-8",
    "content": "// ============================================================================\r\n// TESTING RECOMMENDATIONS\r\n// ============================================================================\r\n//\r\n// Test Cases for VULNERABLE version (should FAIL in production):\r\n// 1. Transaction with different lockingBytecode in output[0]\r\n//    Expected: Transaction succeeds (VULNERABILITY DEMONSTRATED)\r\n//\r\n// 2. Transaction with different tokenCategory in output[0]\r\n//    Expected: Transaction succeeds (VULNERABILITY DEMONSTRATED)\r\n//\r\n// 3. Transaction with reduced value in output[0]\r\n//    Expected: Transaction succeeds (VULNERABILITY DEMONSTRATED)\r\n//\r\n// Test Cases for SECURE version (should PASS):\r\n// 1. Transaction with different lockingBytecode in output[0]\r\n//    Expected: Transaction REJECTED\r\n//\r\n// 2. Transaction with different tokenCategory in output[0]\r\n//    Expected: Transaction REJECTED\r\n//\r\n// 3. Transaction with reduced value in output[0]\r\n//    Expected: Transaction REJECTED\r\n//\r\n// 4. Transaction with EXACT lockingBytecode, tokenCategory, and value\r\n//    Expected: Transaction succeeds (valid covenant continuation)\r\n\r\n// ============================================================================\r\n// END OF FILE\r\n// ============================================================================",
    "source": "NexKB/anti_pattern/vulnerable_covenant.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// SECURITY PATTERN: Covenant Continuation Validation\r\n// PURPOSE: Enforce covenant continuation safety and prevent contract escape\r\n// CATEGORY: Covenant Safety\r\n// USE CASE: Any contract that must recreate itself with preserved or updated state\r\n\r\n// PATTERN DESCRIPTION:\r\n// This pattern demonstrates how to cryptographically enforce that a covenant\r\n// continues with the same contract logic, preventing attackers from redirecting\r\n// funds to arbitrary contracts or addresses. It validates both the structure\r\n// (lockingBytecode) and value constraints of covenant continuations.\r\n\r\n// SECURITY GUARANTEES:\r\n// ✓ Prevents covenant escape (funds cannot leave the covenant)\r\n// ✓ Prevents contract substitution (output must be same contract)\r\n// ✓ Prevents value drain (output value explicitly validated)\r\n// ✓ Prevents token injection (BCH-only enforcement)\r\n// ✓ Prevents output manipulation (exact output count enforced)\r\n// ✓ Ensures contract structure preservation across transactions\r\n\r\n// WHEN TO USE THIS PATTERN:\r\n// - Contracts that must preserve their logic across multiple transactions\r\n// - Stateful covenants (counters, vaults, DAOs)\r\n// - Recursive contracts (each transaction creates next instance)\r\n// - Value preservation contracts (funds stay in covenant)\r\n// - Any contract implementing \"covenant continuation\"\r\n\r\n// WHEN NOT TO USE THIS PATTERN:\r\n// - Final settlement contracts (funds leave covenant intentionally)\r\n// - One-time-use contracts (no continuation needed)",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-1",
    "content": "// - Contracts with intentional value extraction (withdrawals)\r\n// - In those cases, use partial validation or skip continuation check\r\n\r\ncontract CovenantValidation(\r\n    int minValue  // Minimum value that must remain in covenant\r\n) {\r\n    // COVENANT CONTINUATION FUNCTION\r\n    // Demonstrates how to safely enforce covenant continuation\r\n    // No signatures required - pure covenant logic\r\n    function continue(\r\n        int outputValue  // Value for continuation output (must be validated)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for BCH-only validation\r\n        // SEMANTIC CONSTANT: This represents the absence of any token category\r\n        // NexOps should recognize this as a well-known constant pattern\r\n        // Variations: 0x00...00, bytes32(0), or pre-defined constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // NEXOPS NOTE: NO_TOKEN is a semantic constant, not a magic value\r\n        // Pattern recognition: Any bytes32 of all zeros represents \"no tokens\"\r\n        // Alternative representations are semantically equivalent\r\n        // Should be validated at compile-time for correctness\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 1: ACTIVE INPUT VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Verify that THIS contract is the input being validated",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-2",
    "content": "// PREVENTS: UTXO position attacks, wrong contract validation\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: Without this, an attacker could place this contract at a\r\n        // different input index and spend a completely different UTXO\r\n        // while this contract validates the wrong input.\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n        \r\n        // SECURITY NOTE: this.lockingBytecode is the bytecode of THIS contract\r\n        // tx.inputs[this.activeInputIndex].lockingBytecode is the input being spent\r\n        // These MUST match to ensure we're validating the correct input\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 2: INPUT TOKEN VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Ensure covenant only holds BCH, not tokens\r\n        // PREVENTS: Token injection, token-layer confusion\r\n        // SEVERITY: High\r\n        \r\n        // WHY: If tokens enter the covenant, they could:\r\n        // - Complicate value calculations\r\n        // - Introduce token-layer attack vectors\r\n        // - Violate covenant assumptions (BCH-only)\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n        \r\n        // SECURITY NOTE: This is a design choice - if your covenant\r\n        // should handle tokens, remove this check and add token validation\r\n\r\n        // ═══════════════════════════════════════════════════════════════",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-3",
    "content": "// STEP 3: OUTPUT COUNT VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Enforce exact output structure\r\n        // PREVENTS: Output injection, shadow outputs, batching attacks\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: Without this, an attacker could:\r\n        // - Add extra outputs to drain funds\r\n        // - Batch multiple operations in one transaction\r\n        // - Create outputs we don't validate\r\n        require(tx.outputs.length == 1);\r\n        \r\n        // DESIGN DECISION: We require EXACTLY 1 output\r\n        // - This is the strictest form (most secure)\r\n        // - Alternative: >= 1 if you need flexibility\r\n        // - Trade-off: Strict = secure but less flexible\r\n        \r\n        // JUSTIFICATION FOR == 1:\r\n        // - Simplest to reason about (one continuation output)\r\n        // - No possibility of unvalidated outputs\r\n        // - Clear semantics (one in, one out)\r\n        // - Reduces attack surface maximally\r\n        \r\n        // FEE MODEL IMPLICATION:\r\n        // By requiring tx.outputs.length == 1, we enforce:\r\n        // - Mining fee CANNOT come from this input\r\n        // - Fee MUST be paid by other inputs in the transaction\r\n        // - inputValue - outputValue = 0 (no fee deduction here)\r\n        // \r\n        // NEXOPS NOTE: This is an EXTERNAL FEE model\r\n        // - Transaction builder must add separate input for fees\r\n        // - This input's full value goes to continuation output",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-4",
    "content": "// - Alternative: Allow tx.outputs.length >= 2 for change output\r\n        // - Alternative: Use fee-tolerant value validation\r\n        // \r\n        // If this fee model is NOT intended, use fee-tolerant pattern:\r\n        // - Replace: require(outputValue >= minValue)\r\n        // - With: require(outputValue >= inputValue - maxFee)\r\n        // - And: require(tx.outputs.length >= 1)\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 4: COVENANT CONTINUATION VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Cryptographically enforce contract structure preservation\r\n        // PREVENTS: Covenant escape, contract substitution\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: This is the CORE of covenant continuation safety\r\n        // Without this, attacker can redirect funds to ANY contract/address\r\n        // With this, funds MUST stay in the same contract structure\r\n        require(\r\n            tx.outputs[0].lockingBytecode ==\r\n            tx.inputs[this.activeInputIndex].lockingBytecode\r\n        );\r\n        \r\n        // WHAT THIS MEANS:\r\n        // - Output contract MUST have identical bytecode to input contract\r\n        // - Contract logic is preserved across transactions\r\n        // - Contract parameters are preserved (same constructor args)\r\n        // - Funds cannot escape to different contract or address\r\n        \r\n        // SECURITY PROPERTY: Covenant Immutability",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-5",
    "content": "// The covenant structure is immutable across all transactions\r\n        // Funds can only move between instances of THIS EXACT contract\r\n        \r\n        // KNOWN LIMITATION:\r\n        // This validates structure but NOT state changes\r\n        // If your contract has state parameters (e.g., counter, hash)\r\n        // you cannot update them on-chain with this exact check\r\n        // Solutions:\r\n        // - Use external state tracking (oracle, database)\r\n        // - Use state commitment patterns (hash validation)\r\n        // - Accept exact structure preservation (no parameter updates)\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 5: OUTPUT VALUE VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Prevent value drain from covenant\r\n        // PREVENTS: Fund theft, gradual draining, fee attacks\r\n        // SEVERITY: Critical\r\n        \r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // DESIGN DECISION: Use >= for value validation\r\n        // We validate: outputValue >= minValue\r\n        require(outputValue >= minValue);\r\n        \r\n        // JUSTIFICATION FOR >=:\r\n        // - Allows value to remain constant or increase\r\n        // - Prevents draining below minimum threshold\r\n        // - Permits users to \"top up\" the covenant (add value)\r\n        // - Flexible for various use cases (donations, accumulation)\r\n        \r\n        // ALTERNATIVE: Use == for strict value preservation",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-6",
    "content": "// require(outputValue == inputValue);\r\n        // - Enforces exact value preservation\r\n        // - No value can be added or removed\r\n        // - More restrictive but simpler to reason about\r\n        // - Use this if covenant should never gain/lose value\r\n        \r\n        // ALTERNATIVE: Use inputValue - maxFee for fee tolerance\r\n        // require(outputValue >= inputValue - maxFee);\r\n        // - Allows small value decrease for mining fees\r\n        // - More realistic for real-world usage\r\n        // - Requires careful maxFee selection (not too high)\r\n        \r\n        // WHY WE CHOSE >= minValue:\r\n        // - Most flexible for various use cases\r\n        // - Prevents value from dropping below threshold\r\n        // - Allows covenant to accumulate value over time\r\n        // - Simple and clear invariant\r\n        \r\n        // CRITICAL: Bind outputValue to actual output\r\n        // outputValue is UNTRUSTED INPUT from the caller\r\n        // Safety relies ENTIRELY on this equality check\r\n        // Without this, attacker could pass outputValue=1000000\r\n        // while actual output.value=1\r\n        require(tx.outputs[0].value == outputValue);\r\n        \r\n        // TRUST MODEL FOR outputValue:\r\n        // - outputValue parameter: UNTRUSTED (caller-provided)\r\n        // - tx.outputs[0].value: TRUSTED (consensus-enforced)\r\n        // - Validation: outputValue is validated SOLELY by equality with tx.outputs[0].value\r\n        // - Security: If equality holds, outputValue accurately represents output",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-7",
    "content": "// - Warning: Do NOT use outputValue in other checks before this equality\r\n        // - Pattern: Always bind untrusted parameters to consensus data\r\n        \r\n        // NEXOPS NOTE: Caller-provided value parameters\r\n        // Any function parameter representing an output value should:\r\n        // 1. Be validated against actual tx.outputs[N].value\r\n        // 2. Not be trusted until equality is proven\r\n        // 3. Be flagged if used before binding to output\r\n        // This prevents parameter/output mismatch attacks\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 6: OUTPUT TOKEN VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Ensure continuation output is BCH-only\r\n        // PREVENTS: Token injection into continuation\r\n        // SEVERITY: High\r\n        \r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        \r\n        // WHY: Ensures the continuation output maintains BCH-only property\r\n        // This complements the input token validation\r\n        // Together they ensure the entire covenant chain is token-free\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // VALIDATION COMPLETE\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // At this point, we have guaranteed:\r\n        // ✓ We're validating the correct input (this contract)\r\n        // ✓ Input contains no tokens (BCH-only)",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-8",
    "content": "// ✓ Exactly one output exists (no extra outputs)\r\n        // ✓ Output is the same contract (covenant continuation)\r\n        // ✓ Output value meets minimum threshold (value preservation)\r\n        // ✓ Output value matches caller claim (parameter binding)\r\n        // ✓ Output contains no tokens (BCH-only)\r\n        // ✓ Mining fee is paid externally (external fee model)\r\n        \r\n        // SECURITY PROPERTY: Covenant Loop\r\n        // This contract can only be spent by creating another instance\r\n        // of itself with value >= minValue. Funds are \"trapped\" in the\r\n        // covenant structure and can only move between identical instances.\r\n        \r\n        // USE CASES FOR THIS PATTERN:\r\n        // - Perpetual vaults (funds stay locked in covenant)\r\n        // - DAO treasuries (funds managed by covenant rules)\r\n        // - Recursive contracts (each TX creates next instance)\r\n        // - Time-locked savings (covenant prevents early withdrawal)\r\n    }\r\n}\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// PATTERN SUMMARY\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// VALIDATION SEQUENCE (ALWAYS IN THIS ORDER):\r\n// 1. Active input validation (verify we're checking the right input)\r\n// 2. Input token validation (BCH-only enforcement)\r\n// 3. Output count validation (prevent output manipulation)\r\n// 4. Covenant continuation validation (preserve contract structure)\r\n// 5. Output value validation (prevent value drain)",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-9",
    "content": "// 6. Parameter binding validation (bind outputValue to actual output)\r\n// 7. Output token validation (BCH-only continuation)\r\n\r\n// WHY THIS ORDER MATTERS:\r\n// - Active input first: Everything else depends on checking correct input\r\n// - Token validation early: Prevents token-layer confusion\r\n// - Output count before continuation: Ensures we know what we're validating\r\n// - Continuation before value: Structure matters more than amount\r\n// - Value validation before binding: Check threshold before equality\r\n// - Parameter binding: Ensure untrusted input matches consensus data\r\n// - Token validation last: Final check on validated structure\r\n\r\n// SECURITY PROPERTIES GUARANTEED:\r\n// ✓ Covenant immutability: Contract structure cannot change\r\n// ✓ Value preservation: Funds stay above minimum threshold\r\n// ✓ Output integrity: No extra or missing outputs\r\n// ✓ Token exclusion: No token injection possible\r\n// ✓ Position safety: Correct input validated\r\n// ✓ Escape prevention: Funds cannot leave covenant\r\n// ✓ Parameter binding: Untrusted inputs bound to consensus data\r\n// ✓ Fee externality: Mining fees paid by other inputs\r\n\r\n// ATTACK VECTORS PREVENTED:\r\n// ✗ Covenant escape: Cannot redirect to different contract\r\n// ✗ Contract substitution: Cannot change contract logic\r\n// ✗ Value drain: Cannot reduce value below threshold\r\n// ✗ Output injection: Cannot add extra outputs\r\n// ✗ Token injection: Cannot add tokens to covenant\r\n// ✗ Position attack: Cannot validate wrong input\r\n// ✗ Parameter mismatch: Cannot claim false output values",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-10",
    "content": "// ✗ Internal fee theft: Cannot deduct fee from this input\r\n\r\n// FEE MODELS EXPLAINED:\r\n\r\n// Model A: EXTERNAL FEE (this pattern)\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue >= minValue);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Fee MUST come from other inputs\r\n// Use when: Covenant should never lose value to fees\r\n\r\n// Model B: FEE-TOLERANT\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue >= inputValue - maxFee);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Small fee can be deducted (up to maxFee)\r\n// Use when: Covenant allows fee deduction within limits\r\n\r\n// Model C: EXACT PRESERVATION\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue == inputValue);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Value must be exactly preserved, fee external\r\n// Use when: Covenant must maintain exact value\r\n\r\n// NEXOPS ENFORCEMENT FOR FEE MODELS:\r\n// NexOps should detect the fee model and flag if unexpected:\r\n// - If tx.outputs.length == 1 AND no fee tolerance → EXTERNAL FEE\r\n// - If outputValue >= inputValue - X → FEE-TOLERANT (flag X value)\r\n// - If outputValue == inputValue → EXACT PRESERVATION\r\n// Flag as WARNING if fee model seems unintentional\r\n\r\n// PARAMETER TRUST MODEL:\r\n\r\n// UNTRUSTED PARAMETERS (caller-provided):\r\n// - outputValue: Claimed output value\r\n// - userIndex: User-specified array index\r\n// - claimAmount: Claimed withdrawal amount\r\n// - Any parameter representing consensus data",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-11",
    "content": "// VALIDATION PATTERN:\r\n// require(untrustedParam == consensusData);\r\n// Examples:\r\n// - require(outputValue == tx.outputs[0].value)\r\n// - require(claimAmount == calculatedAmount)\r\n// - require(userIndex < tx.inputs.length)\r\n\r\n// NEXOPS ENFORCEMENT:\r\n// Flag if untrusted parameter is used before binding:\r\n// ❌ if (outputValue > 0) { ... } require(tx.outputs[0].value == outputValue);\r\n// ✅ require(tx.outputs[0].value == outputValue); if (outputValue > 0) { ... }\r\n\r\n// VARIATIONS OF THIS PATTERN:\r\n\r\n// Variation 1: Exact value preservation\r\n// Replace: require(outputValue >= minValue);\r\n// With:    require(outputValue == inputValue);\r\n// Use when: Value must never change\r\n\r\n// Variation 2: Fee-tolerant validation\r\n// Replace: require(outputValue >= minValue);\r\n// With:    require(outputValue >= inputValue - maxFee);\r\n//          require(maxFee <= MAX_REASONABLE_FEE);\r\n// Use when: Mining fees should be deducted from covenant\r\n\r\n// Variation 3: Multiple outputs\r\n// Replace: require(tx.outputs.length == 1);\r\n// With:    require(tx.outputs.length == 2);\r\n// Add:     Validation for output[1]\r\n// Use when: Covenant needs auxiliary outputs (change, notifications)\r\n\r\n// Variation 4: Token-aware covenant\r\n// Remove:  Input/output token validation (NO_TOKEN checks)\r\n// Add:     Specific token category and amount validation\r\n// Use when: Covenant should handle specific tokens\r\n\r\n// Variation 5: State-updating covenant\r\n// Keep:    Structure validation (lockingBytecode check)\r\n// Add:     NexOps build-time validation of state parameters",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-12",
    "content": "// Use when: Contract has state that needs updating\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// NEXOPS ENFORCEMENT CHECKLIST\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// NexOps SHOULD verify:\r\n// [ ] Active input lockingBytecode validation exists\r\n// [ ] Input token validation exists (if BCH-only pattern)\r\n// [ ] Output count validation exists (detect == vs >=)\r\n// [ ] Covenant continuation lockingBytecode validation exists\r\n// [ ] Output value validation exists with appropriate constraint\r\n// [ ] Untrusted parameters are bound to consensus data\r\n// [ ] Parameter binding happens before parameter usage\r\n// [ ] Output token validation exists (if BCH-only pattern)\r\n// [ ] All validations use tx.inputs[this.activeInputIndex]\r\n// [ ] Validations occur in recommended order\r\n// [ ] NO_TOKEN constant matches semantic meaning (all zeros)\r\n// [ ] Fee model is intentional (flag if ambiguous)\r\n\r\n// NexOps SHOULD flag:\r\n// - Missing continuation validation: CRITICAL\r\n// - Missing value validation: HIGH\r\n// - Missing parameter binding: HIGH\r\n// - Missing output count validation: HIGH\r\n// - Untrusted parameter used before binding: HIGH\r\n// - Missing token validation: MEDIUM (if BCH-only expected)\r\n// - Ambiguous fee model: WARNING\r\n// - Non-standard NO_TOKEN value: WARNING\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// COMMON MISTAKES WHEN USING THIS PATTERN\r\n// ═══════════════════════════════════════════════════════════════════════",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/covenant_validation.cash-13",
    "content": "// Mistake 1: Forgetting active input validation\r\n// Impact: Validates wrong input, allows position attacks\r\n// Fix: Always start with activeInputIndex lockingBytecode check\r\n\r\n// Mistake 2: Using >= for output count when == is needed\r\n// Impact: Allows output injection attacks\r\n// Fix: Use == unless you explicitly need flexibility\r\n\r\n// Mistake 3: Not validating output value\r\n// Impact: Allows value drain from covenant\r\n// Fix: Always validate output value with appropriate constraint\r\n\r\n// Mistake 4: Trusting caller-provided continuation bytecode\r\n// Impact: Allows covenant escape\r\n// Fix: Use tx.inputs[this.activeInputIndex].lockingBytecode\r\n\r\n// Mistake 5: Forgetting token validation\r\n// Impact: Allows token injection\r\n// Fix: Validate tokenCategory on both inputs and outputs\r\n\r\n// Mistake 6: Using outputValue before binding\r\n// Impact: Logic operates on unvalidated data\r\n// Fix: Bind outputValue to tx.outputs[0].value first\r\n\r\n// Mistake 7: Unintentional external fee model\r\n// Impact: Transaction fails (no fee input provided)\r\n// Fix: Explicitly choose and document fee modeld",
    "source": "NexKB/patterns/covenant_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// SECURITY PATTERN: Covenant Continuation Validation\r\n// PURPOSE: Enforce covenant continuation safety and prevent contract escape\r\n// CATEGORY: Covenant Safety\r\n// USE CASE: Any contract that must recreate itself with preserved or updated state\r\n\r\n// PATTERN DESCRIPTION:\r\n// This pattern demonstrates how to cryptographically enforce that a covenant\r\n// continues with the same contract logic, preventing attackers from redirecting\r\n// funds to arbitrary contracts or addresses. It validates both the structure\r\n// (lockingBytecode) and value constraints of covenant continuations.\r\n\r\n// SECURITY GUARANTEES:\r\n// ✓ Prevents covenant escape (funds cannot leave the covenant)\r\n// ✓ Prevents contract substitution (output must be same contract)\r\n// ✓ Prevents value drain (output value explicitly validated)\r\n// ✓ Prevents token injection (BCH-only enforcement)\r\n// ✓ Prevents output manipulation (exact output count enforced)\r\n// ✓ Ensures contract structure preservation across transactions\r\n\r\n// WHEN TO USE THIS PATTERN:\r\n// - Contracts that must preserve their logic across multiple transactions\r\n// - Stateful covenants (counters, vaults, DAOs)\r\n// - Recursive contracts (each transaction creates next instance)\r\n// - Value preservation contracts (funds stay in covenant)\r\n// - Any contract implementing \"covenant continuation\"\r\n\r\n// WHEN NOT TO USE THIS PATTERN:\r\n// - Final settlement contracts (funds leave covenant intentionally)\r\n// - One-time-use contracts (no continuation needed)",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-1",
    "content": "// - Contracts with intentional value extraction (withdrawals)\r\n// - In those cases, use partial validation or skip continuation check\r\n\r\ncontract CovenantValidation(\r\n    int minValue  // Minimum value that must remain in covenant\r\n) {\r\n    // COVENANT CONTINUATION FUNCTION\r\n    // Demonstrates how to safely enforce covenant continuation\r\n    // No signatures required - pure covenant logic\r\n    function continue(\r\n        int outputValue  // Value for continuation output (must be validated)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for BCH-only validation\r\n        // SEMANTIC CONSTANT: This represents the absence of any token category\r\n        // NexOps should recognize this as a well-known constant pattern\r\n        // Variations: 0x00...00, bytes32(0), or pre-defined constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // NEXOPS NOTE: NO_TOKEN is a semantic constant, not a magic value\r\n        // Pattern recognition: Any bytes32 of all zeros represents \"no tokens\"\r\n        // Alternative representations are semantically equivalent\r\n        // Should be validated at compile-time for correctness\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 1: ACTIVE INPUT VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Verify that THIS contract is the input being validated",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-2",
    "content": "// PREVENTS: UTXO position attacks, wrong contract validation\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: Without this, an attacker could place this contract at a\r\n        // different input index and spend a completely different UTXO\r\n        // while this contract validates the wrong input.\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n        \r\n        // SECURITY NOTE: this.lockingBytecode is the bytecode of THIS contract\r\n        // tx.inputs[this.activeInputIndex].lockingBytecode is the input being spent\r\n        // These MUST match to ensure we're validating the correct input\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 2: INPUT TOKEN VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Ensure covenant only holds BCH, not tokens\r\n        // PREVENTS: Token injection, token-layer confusion\r\n        // SEVERITY: High\r\n        \r\n        // WHY: If tokens enter the covenant, they could:\r\n        // - Complicate value calculations\r\n        // - Introduce token-layer attack vectors\r\n        // - Violate covenant assumptions (BCH-only)\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n        \r\n        // SECURITY NOTE: This is a design choice - if your covenant\r\n        // should handle tokens, remove this check and add token validation\r\n\r\n        // ═══════════════════════════════════════════════════════════════",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-3",
    "content": "// STEP 3: OUTPUT COUNT VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Enforce exact output structure\r\n        // PREVENTS: Output injection, shadow outputs, batching attacks\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: Without this, an attacker could:\r\n        // - Add extra outputs to drain funds\r\n        // - Batch multiple operations in one transaction\r\n        // - Create outputs we don't validate\r\n        require(tx.outputs.length == 1);\r\n        \r\n        // DESIGN DECISION: We require EXACTLY 1 output\r\n        // - This is the strictest form (most secure)\r\n        // - Alternative: >= 1 if you need flexibility\r\n        // - Trade-off: Strict = secure but less flexible\r\n        \r\n        // JUSTIFICATION FOR == 1:\r\n        // - Simplest to reason about (one continuation output)\r\n        // - No possibility of unvalidated outputs\r\n        // - Clear semantics (one in, one out)\r\n        // - Reduces attack surface maximally\r\n        \r\n        // FEE MODEL IMPLICATION:\r\n        // By requiring tx.outputs.length == 1, we enforce:\r\n        // - Mining fee CANNOT come from this input\r\n        // - Fee MUST be paid by other inputs in the transaction\r\n        // - inputValue - outputValue = 0 (no fee deduction here)\r\n        // \r\n        // NEXOPS NOTE: This is an EXTERNAL FEE model\r\n        // - Transaction builder must add separate input for fees\r\n        // - This input's full value goes to continuation output",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-4",
    "content": "// - Alternative: Allow tx.outputs.length >= 2 for change output\r\n        // - Alternative: Use fee-tolerant value validation\r\n        // \r\n        // If this fee model is NOT intended, use fee-tolerant pattern:\r\n        // - Replace: require(outputValue >= minValue)\r\n        // - With: require(outputValue >= inputValue - maxFee)\r\n        // - And: require(tx.outputs.length >= 1)\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 4: COVENANT CONTINUATION VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Cryptographically enforce contract structure preservation\r\n        // PREVENTS: Covenant escape, contract substitution\r\n        // SEVERITY: Critical\r\n        \r\n        // WHY: This is the CORE of covenant continuation safety\r\n        // Without this, attacker can redirect funds to ANY contract/address\r\n        // With this, funds MUST stay in the same contract structure\r\n        require(\r\n            tx.outputs[0].lockingBytecode ==\r\n            tx.inputs[this.activeInputIndex].lockingBytecode\r\n        );\r\n        \r\n        // WHAT THIS MEANS:\r\n        // - Output contract MUST have identical bytecode to input contract\r\n        // - Contract logic is preserved across transactions\r\n        // - Contract parameters are preserved (same constructor args)\r\n        // - Funds cannot escape to different contract or address\r\n        \r\n        // SECURITY PROPERTY: Covenant Immutability",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-5",
    "content": "// The covenant structure is immutable across all transactions\r\n        // Funds can only move between instances of THIS EXACT contract\r\n        \r\n        // KNOWN LIMITATION:\r\n        // This validates structure but NOT state changes\r\n        // If your contract has state parameters (e.g., counter, hash)\r\n        // you cannot update them on-chain with this exact check\r\n        // Solutions:\r\n        // - Use external state tracking (oracle, database)\r\n        // - Use state commitment patterns (hash validation)\r\n        // - Accept exact structure preservation (no parameter updates)\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 5: OUTPUT VALUE VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Prevent value drain from covenant\r\n        // PREVENTS: Fund theft, gradual draining, fee attacks\r\n        // SEVERITY: Critical\r\n        \r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // DESIGN DECISION: Use >= for value validation\r\n        // We validate: outputValue >= minValue\r\n        require(outputValue >= minValue);\r\n        \r\n        // JUSTIFICATION FOR >=:\r\n        // - Allows value to remain constant or increase\r\n        // - Prevents draining below minimum threshold\r\n        // - Permits users to \"top up\" the covenant (add value)\r\n        // - Flexible for various use cases (donations, accumulation)\r\n        \r\n        // ALTERNATIVE: Use == for strict value preservation",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-6",
    "content": "// require(outputValue == inputValue);\r\n        // - Enforces exact value preservation\r\n        // - No value can be added or removed\r\n        // - More restrictive but simpler to reason about\r\n        // - Use this if covenant should never gain/lose value\r\n        \r\n        // ALTERNATIVE: Use inputValue - maxFee for fee tolerance\r\n        // require(outputValue >= inputValue - maxFee);\r\n        // - Allows small value decrease for mining fees\r\n        // - More realistic for real-world usage\r\n        // - Requires careful maxFee selection (not too high)\r\n        \r\n        // WHY WE CHOSE >= minValue:\r\n        // - Most flexible for various use cases\r\n        // - Prevents value from dropping below threshold\r\n        // - Allows covenant to accumulate value over time\r\n        // - Simple and clear invariant\r\n        \r\n        // CRITICAL: Bind outputValue to actual output\r\n        // outputValue is UNTRUSTED INPUT from the caller\r\n        // Safety relies ENTIRELY on this equality check\r\n        // Without this, attacker could pass outputValue=1000000\r\n        // while actual output.value=1\r\n        require(tx.outputs[0].value == outputValue);\r\n        \r\n        // TRUST MODEL FOR outputValue:\r\n        // - outputValue parameter: UNTRUSTED (caller-provided)\r\n        // - tx.outputs[0].value: TRUSTED (consensus-enforced)\r\n        // - Validation: outputValue is validated SOLELY by equality with tx.outputs[0].value\r\n        // - Security: If equality holds, outputValue accurately represents output",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-7",
    "content": "// - Warning: Do NOT use outputValue in other checks before this equality\r\n        // - Pattern: Always bind untrusted parameters to consensus data\r\n        \r\n        // NEXOPS NOTE: Caller-provided value parameters\r\n        // Any function parameter representing an output value should:\r\n        // 1. Be validated against actual tx.outputs[N].value\r\n        // 2. Not be trusted until equality is proven\r\n        // 3. Be flagged if used before binding to output\r\n        // This prevents parameter/output mismatch attacks\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // STEP 6: OUTPUT TOKEN VALIDATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Ensure continuation output is BCH-only\r\n        // PREVENTS: Token injection into continuation\r\n        // SEVERITY: High\r\n        \r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        \r\n        // WHY: Ensures the continuation output maintains BCH-only property\r\n        // This complements the input token validation\r\n        // Together they ensure the entire covenant chain is token-free\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // VALIDATION COMPLETE\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // At this point, we have guaranteed:\r\n        // ✓ We're validating the correct input (this contract)\r\n        // ✓ Input contains no tokens (BCH-only)",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-8",
    "content": "// ✓ Exactly one output exists (no extra outputs)\r\n        // ✓ Output is the same contract (covenant continuation)\r\n        // ✓ Output value meets minimum threshold (value preservation)\r\n        // ✓ Output value matches caller claim (parameter binding)\r\n        // ✓ Output contains no tokens (BCH-only)\r\n        // ✓ Mining fee is paid externally (external fee model)\r\n        \r\n        // SECURITY PROPERTY: Covenant Loop\r\n        // This contract can only be spent by creating another instance\r\n        // of itself with value >= minValue. Funds are \"trapped\" in the\r\n        // covenant structure and can only move between identical instances.\r\n        \r\n        // USE CASES FOR THIS PATTERN:\r\n        // - Perpetual vaults (funds stay locked in covenant)\r\n        // - DAO treasuries (funds managed by covenant rules)\r\n        // - Recursive contracts (each TX creates next instance)\r\n        // - Time-locked savings (covenant prevents early withdrawal)\r\n    }\r\n}\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// PATTERN SUMMARY\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// VALIDATION SEQUENCE (ALWAYS IN THIS ORDER):\r\n// 1. Active input validation (verify we're checking the right input)\r\n// 2. Input token validation (BCH-only enforcement)\r\n// 3. Output count validation (prevent output manipulation)\r\n// 4. Covenant continuation validation (preserve contract structure)\r\n// 5. Output value validation (prevent value drain)",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-9",
    "content": "// 6. Parameter binding validation (bind outputValue to actual output)\r\n// 7. Output token validation (BCH-only continuation)\r\n\r\n// WHY THIS ORDER MATTERS:\r\n// - Active input first: Everything else depends on checking correct input\r\n// - Token validation early: Prevents token-layer confusion\r\n// - Output count before continuation: Ensures we know what we're validating\r\n// - Continuation before value: Structure matters more than amount\r\n// - Value validation before binding: Check threshold before equality\r\n// - Parameter binding: Ensure untrusted input matches consensus data\r\n// - Token validation last: Final check on validated structure\r\n\r\n// SECURITY PROPERTIES GUARANTEED:\r\n// ✓ Covenant immutability: Contract structure cannot change\r\n// ✓ Value preservation: Funds stay above minimum threshold\r\n// ✓ Output integrity: No extra or missing outputs\r\n// ✓ Token exclusion: No token injection possible\r\n// ✓ Position safety: Correct input validated\r\n// ✓ Escape prevention: Funds cannot leave covenant\r\n// ✓ Parameter binding: Untrusted inputs bound to consensus data\r\n// ✓ Fee externality: Mining fees paid by other inputs\r\n\r\n// ATTACK VECTORS PREVENTED:\r\n// ✗ Covenant escape: Cannot redirect to different contract\r\n// ✗ Contract substitution: Cannot change contract logic\r\n// ✗ Value drain: Cannot reduce value below threshold\r\n// ✗ Output injection: Cannot add extra outputs\r\n// ✗ Token injection: Cannot add tokens to covenant\r\n// ✗ Position attack: Cannot validate wrong input\r\n// ✗ Parameter mismatch: Cannot claim false output values",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-10",
    "content": "// ✗ Internal fee theft: Cannot deduct fee from this input\r\n\r\n// FEE MODELS EXPLAINED:\r\n\r\n// Model A: EXTERNAL FEE (this pattern)\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue >= minValue);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Fee MUST come from other inputs\r\n// Use when: Covenant should never lose value to fees\r\n\r\n// Model B: FEE-TOLERANT\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue >= inputValue - maxFee);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Small fee can be deducted (up to maxFee)\r\n// Use when: Covenant allows fee deduction within limits\r\n\r\n// Model C: EXACT PRESERVATION\r\n// require(tx.outputs.length == 1);\r\n// require(outputValue == inputValue);\r\n// require(tx.outputs[0].value == outputValue);\r\n// Implication: Value must be exactly preserved, fee external\r\n// Use when: Covenant must maintain exact value\r\n\r\n// NEXOPS ENFORCEMENT FOR FEE MODELS:\r\n// NexOps should detect the fee model and flag if unexpected:\r\n// - If tx.outputs.length == 1 AND no fee tolerance → EXTERNAL FEE\r\n// - If outputValue >= inputValue - X → FEE-TOLERANT (flag X value)\r\n// - If outputValue == inputValue → EXACT PRESERVATION\r\n// Flag as WARNING if fee model seems unintentional\r\n\r\n// PARAMETER TRUST MODEL:\r\n\r\n// UNTRUSTED PARAMETERS (caller-provided):\r\n// - outputValue: Claimed output value\r\n// - userIndex: User-specified array index\r\n// - claimAmount: Claimed withdrawal amount\r\n// - Any parameter representing consensus data",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-11",
    "content": "// VALIDATION PATTERN:\r\n// require(untrustedParam == consensusData);\r\n// Examples:\r\n// - require(outputValue == tx.outputs[0].value)\r\n// - require(claimAmount == calculatedAmount)\r\n// - require(userIndex < tx.inputs.length)\r\n\r\n// NEXOPS ENFORCEMENT:\r\n// Flag if untrusted parameter is used before binding:\r\n// ❌ if (outputValue > 0) { ... } require(tx.outputs[0].value == outputValue);\r\n// ✅ require(tx.outputs[0].value == outputValue); if (outputValue > 0) { ... }\r\n\r\n// VARIATIONS OF THIS PATTERN:\r\n\r\n// Variation 1: Exact value preservation\r\n// Replace: require(outputValue >= minValue);\r\n// With:    require(outputValue == inputValue);\r\n// Use when: Value must never change\r\n\r\n// Variation 2: Fee-tolerant validation\r\n// Replace: require(outputValue >= minValue);\r\n// With:    require(outputValue >= inputValue - maxFee);\r\n//          require(maxFee <= MAX_REASONABLE_FEE);\r\n// Use when: Mining fees should be deducted from covenant\r\n\r\n// Variation 3: Multiple outputs\r\n// Replace: require(tx.outputs.length == 1);\r\n// With:    require(tx.outputs.length == 2);\r\n// Add:     Validation for output[1]\r\n// Use when: Covenant needs auxiliary outputs (change, notifications)\r\n\r\n// Variation 4: Token-aware covenant\r\n// Remove:  Input/output token validation (NO_TOKEN checks)\r\n// Add:     Specific token category and amount validation\r\n// Use when: Covenant should handle specific tokens\r\n\r\n// Variation 5: State-updating covenant\r\n// Keep:    Structure validation (lockingBytecode check)\r\n// Add:     NexOps build-time validation of state parameters",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-12",
    "content": "// Use when: Contract has state that needs updating\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// NEXOPS ENFORCEMENT CHECKLIST\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// NexOps SHOULD verify:\r\n// [ ] Active input lockingBytecode validation exists\r\n// [ ] Input token validation exists (if BCH-only pattern)\r\n// [ ] Output count validation exists (detect == vs >=)\r\n// [ ] Covenant continuation lockingBytecode validation exists\r\n// [ ] Output value validation exists with appropriate constraint\r\n// [ ] Untrusted parameters are bound to consensus data\r\n// [ ] Parameter binding happens before parameter usage\r\n// [ ] Output token validation exists (if BCH-only pattern)\r\n// [ ] All validations use tx.inputs[this.activeInputIndex]\r\n// [ ] Validations occur in recommended order\r\n// [ ] NO_TOKEN constant matches semantic meaning (all zeros)\r\n// [ ] Fee model is intentional (flag if ambiguous)\r\n\r\n// NexOps SHOULD flag:\r\n// - Missing continuation validation: CRITICAL\r\n// - Missing value validation: HIGH\r\n// - Missing parameter binding: HIGH\r\n// - Missing output count validation: HIGH\r\n// - Untrusted parameter used before binding: HIGH\r\n// - Missing token validation: MEDIUM (if BCH-only expected)\r\n// - Ambiguous fee model: WARNING\r\n// - Non-standard NO_TOKEN value: WARNING\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// COMMON MISTAKES WHEN USING THIS PATTERN\r\n// ═══════════════════════════════════════════════════════════════════════",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/cross_contract_auth.cash-13",
    "content": "// Mistake 1: Forgetting active input validation\r\n// Impact: Validates wrong input, allows position attacks\r\n// Fix: Always start with activeInputIndex lockingBytecode check\r\n\r\n// Mistake 2: Using >= for output count when == is needed\r\n// Impact: Allows output injection attacks\r\n// Fix: Use == unless you explicitly need flexibility\r\n\r\n// Mistake 3: Not validating output value\r\n// Impact: Allows value drain from covenant\r\n// Fix: Always validate output value with appropriate constraint\r\n\r\n// Mistake 4: Trusting caller-provided continuation bytecode\r\n// Impact: Allows covenant escape\r\n// Fix: Use tx.inputs[this.activeInputIndex].lockingBytecode\r\n\r\n// Mistake 5: Forgetting token validation\r\n// Impact: Allows token injection\r\n// Fix: Validate tokenCategory on both inputs and outputs\r\n\r\n// Mistake 6: Using outputValue before binding\r\n// Impact: Logic operates on unvalidated data\r\n// Fix: Bind outputValue to tx.outputs[0].value first\r\n\r\n// Mistake 7: Unintentional external fee model\r\n// Impact: Transaction fails (no fee input provided)\r\n// Fix: Explicitly choose and document fee model",
    "source": "NexKB/patterns/cross_contract_auth.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-0",
    "content": "// SECURITY PATTERN: Input Validation\r\n// PURPOSE: Prevent UTXO position and value confusion attacks\r\n// PROTECTION: Explicit input identity, value, and token validation\r\n//\r\n// This file demonstrates secure patterns for validating input properties in\r\n// covenant contracts. It shows how to prevent input position attacks, value\r\n// confusion, and token manipulation by explicitly validating the active input's\r\n// identity, value, and token state against expected parameters.\r\n//\r\n// CashScript Version: ^0.13.0\r\n// Network: Bitcoin Cash (BCH)\r\n// Security Level: PRODUCTION-READY PATTERN\r\n\r\n// ============================================================================\r\n// SEMANTIC CONSTANTS\r\n// ============================================================================\r\n//\r\n// NO_TOKEN: Represents absence of CashTokens\r\n// - Type: bytes32\r\n// - Value: 0x0000000000000000000000000000000000000000000000000000000000000000\r\n// - Usage: Compare against tokenCategory to enforce pure BCH (no tokens)\r\n// - 32 bytes = 64 hexadecimal characters\r\n//\r\n// This constant must be defined inside each contract/function that uses it.\r\n// CashScript does not support global constants before pragma directive.\r\n\r\n// ============================================================================\r\n// PATTERN 1: Basic Input Identity Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate the active input is the expected contract",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-1",
    "content": "// USE CASE: Prevent input substitution in multi-input transactions\r\n// SECURITY: Ensures correct UTXO is being spent\r\ncontract BasicInputIdentity() {\r\n    // SECURE: Validates input lockingBytecode matches this contract\r\n    function validate() {\r\n        // CRITICAL: Validate active input IS this contract\r\n        // Prevents attacker from substituting different contract at activeInputIndex\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified (lockingBytecode match)\r\n        // ✓ Prevents wrong contract at activeInputIndex\r\n        // ✓ No input substitution possible\r\n        // ✓ Validates WHAT the input is, not WHERE it is\r\n        //\r\n        // WHY THIS IS SECURE:\r\n        // - this.lockingBytecode is the contract's own bytecode\r\n        // - tx.inputs[this.activeInputIndex] is the input being spent\r\n        // - Exact bytecode match proves input is this contract instance\r\n        // - Attacker cannot substitute different contract\r\n        //\r\n        // WHY THIS IS NECESSARY:\r\n        // In multi-input transactions, attacker controls:\r\n        // - Which inputs are included\r\n        // - Order of inputs\r\n        // - Which input spends which UTXO\r\n        //\r\n        // Without this check, attacker could:\r\n        // - Place this contract at input[2]\r\n        // - Place malicious contract at input[0]\r\n        // - If contract assumes input[0], validates wrong UTXO",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-2",
    "content": "//\r\n        // This check prevents position-based confusion\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 2: Input Value Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate input value matches expected amount\r\n// USE CASE: Prevent value confusion and dust attacks\r\n// SECURITY: Ensures correct value is being spent\r\ncontract InputValueValidation(\r\n    int expectedValue  // The exact value this UTXO should have\r\n) {\r\n    // SECURE: Validates input identity AND value\r\n    function validate() {\r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Capture input value explicitly\r\n        // Get the value of the input being spent\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // Step 3: CRITICAL - Validate value matches expectation\r\n        // Prevents value confusion and dust attacks\r\n        require(inputValue == expectedValue);\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Input value captured explicitly\r\n        // ✓ Value validated against expected amount\r\n        // ✓ Prevents value confusion attacks\r\n        // ✓ Prevents dust UTXO exploitation\r\n        //\r\n        // WHY THIS IS SECURE:",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-3",
    "content": "// - Input identity check ensures correct contract\r\n        // - Explicit value capture from activeInputIndex\r\n        // - Exact value match prevents substitution\r\n        // - Attacker cannot use wrong-value UTXO\r\n        //\r\n        // USE CASES:\r\n        // - Fixed-value covenants (e.g., 1,000,000 sat vault)\r\n        // - Prevent dust attacks (reject < minimum value)\r\n        // - Validate UTXO meets protocol requirements\r\n        // - Ensure sufficient value for operations\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 3: Input Value Range Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate input value is within acceptable range\r\n// USE CASE: Flexible value acceptance with bounds\r\n// SECURITY: Prevents value-based attacks while allowing variance\r\ncontract InputValueRange(\r\n    int minimumValue,  // Minimum acceptable input value\r\n    int maximumValue   // Maximum acceptable input value\r\n) {\r\n    // SECURE: Validates input identity and value range\r\n    function validate() {\r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Capture input value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // Step 3: CRITICAL - Validate value is within range",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-4",
    "content": "require(inputValue >= minimumValue);\r\n        require(inputValue <= maximumValue);\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Value bounded by minimum and maximum\r\n        // ✓ Rejects dust inputs (< minimum)\r\n        // ✓ Rejects excessive inputs (> maximum)\r\n        // ✓ Allows controlled variance\r\n        //\r\n        // WHY THIS IS SECURE:\r\n        // - Both bounds enforced (prevents edge cases)\r\n        // - Dust attacks rejected (minimum check)\r\n        // - Overflow attacks prevented (maximum check)\r\n        // - Clear acceptable value range\r\n        //\r\n        // USE CASES:\r\n        // - Accept UTXOs between 100k - 1M sats\r\n        // - Prevent dust (minimum > dust threshold)\r\n        // - Prevent overflow (maximum < int max)\r\n        // - Protocol-specific value requirements\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 4: Token-Free Validation (Enforce NO_TOKEN)\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Enforce input has no tokens (pure BCH)\r\n// USE CASE: Prevent token injection attacks\r\n// SECURITY: Validates input is pure BCH, no CashTokens\r\ncontract TokenFreeValidation(\r\n    int expectedValue\r\n) {\r\n    // SECURE: Validates input identity, value, and token absence\r\n    function validate() {\r\n        // Define NO_TOKEN constant (32 zero bytes)\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-5",
    "content": "// Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Capture input value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        require(inputValue == expectedValue);\r\n        \r\n        // Step 3: CRITICAL - Enforce NO_TOKEN\r\n        // Validates input has no CashTokens (fungible or NFT)\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Input value validated\r\n        // ✓ Token category enforced as empty (NO_TOKEN)\r\n        // ✓ Prevents token injection attacks\r\n        // ✓ Ensures pure BCH input\r\n        //\r\n        // WHY THIS IS SECURE:\r\n        // - tokenCategory == NO_TOKEN proves no tokens present\r\n        // - Rejects both fungible and NFT tokens\r\n        // - Prevents token-based attacks\r\n        // - Enforces pure BCH covenant\r\n        //\r\n        // WHY NO_TOKEN MATTERS:\r\n        // Without this check, attacker could:\r\n        // - Create UTXO with same bytecode and value\r\n        // - But include fungible tokens or NFT\r\n        // - Token presence could affect downstream logic\r\n        // - Token could be extracted in later operations\r\n        //\r\n        // This check ensures input is EXACTLY as expected:",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-6",
    "content": "// - Correct contract (bytecode)\r\n        // - Correct value (sats)\r\n        // - No tokens (pure BCH)\r\n        //\r\n        // IMPORTANT: NO_TOKEN constant\r\n        // - Must be 32 zero bytes (bytes32)\r\n        // - Represents absence of any token category\r\n        // - 0x0000...0000 (64 hex characters)\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 5: Explicit Parameter Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate input value matches function parameter\r\n// USE CASE: Ensure caller provides correct value information\r\n// SECURITY: Prevents parameter-value mismatch attacks\r\ncontract ExplicitParameterValidation() {\r\n    // SECURE: Function parameter MUST match actual input value\r\n    // This prevents caller from lying about input value\r\n    function validate(int declaredValue) {\r\n        // Define NO_TOKEN constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Capture actual input value\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // Step 3: CRITICAL - Validate parameter matches reality\r\n        // Prevents caller from providing false value information",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-7",
    "content": "require(declaredValue == actualValue);\r\n        \r\n        // Step 4: CRITICAL - Enforce NO_TOKEN\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // Now we can safely use declaredValue in logic\r\n        // We know it accurately represents the input value\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Declared value validated against actual value\r\n        // ✓ Parameter-value mismatch prevented\r\n        // ✓ No token injection possible\r\n        // ✓ Safe to use declaredValue in calculations\r\n        //\r\n        // WHY THIS IS SECURE:\r\n        // - Caller provides declaredValue as parameter\r\n        // - Contract reads actualValue from blockchain\r\n        // - Comparison ensures they match\r\n        // - If caller lies, transaction fails\r\n        // - Downstream logic can trust declaredValue\r\n        //\r\n        // WHY THIS IS NECESSARY:\r\n        // Function parameters are attacker-controlled\r\n        // Without validation, attacker could:\r\n        // - Provide declaredValue = 1,000,000\r\n        // - But actual input value = 100,000\r\n        // - Contract uses declaredValue in logic\r\n        // - Logic operates on false assumptions\r\n        //\r\n        // This pattern forces parameter honesty\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 6: Multi-Property Input Validation",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-8",
    "content": "// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate all input properties comprehensively\r\n// USE CASE: Maximum security for critical covenants\r\n// SECURITY: Complete input validation (identity, value, tokens)\r\ncontract ComprehensiveInputValidation(\r\n    int minimumValue,\r\n    int maximumValue\r\n) {\r\n    // SECURE: Validates every input property\r\n    function validate(int declaredValue) {\r\n        // Define NO_TOKEN constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // Step 1: CRITICAL - Validate input identity\r\n        // Ensures activeInputIndex is this contract\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Capture actual input value\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // Step 3: CRITICAL - Validate declared value matches actual\r\n        require(declaredValue == actualValue);\r\n        \r\n        // Step 4: CRITICAL - Validate value is within acceptable range\r\n        require(actualValue >= minimumValue);\r\n        require(actualValue <= maximumValue);\r\n        \r\n        // Step 5: CRITICAL - Enforce NO_TOKEN\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-9",
    "content": "// Step 6: OPTIONAL - Validate no NFT commitment\r\n        // (tokenCategory == NO_TOKEN already ensures this, but explicit check available)\r\n        // bytes inputNftCommitment = tx.inputs[this.activeInputIndex].nftCommitment;\r\n        // bytes EMPTY_COMMITMENT = 0x;\r\n        // require(inputNftCommitment == EMPTY_COMMITMENT);\r\n        \r\n        // All input properties validated\r\n        // Safe to proceed with covenant logic\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified (lockingBytecode)\r\n        // ✓ Parameter honesty enforced (declared == actual)\r\n        // ✓ Value bounds validated (min/max range)\r\n        // ✓ Token presence rejected (NO_TOKEN)\r\n        // ✓ Complete input integrity guaranteed\r\n        //\r\n        // WHY THIS IS SECURE:\r\n        // - Every input property explicitly validated\r\n        // - No assumptions about input state\r\n        // - All attack vectors covered:\r\n        //   * Position confusion (identity check)\r\n        //   * Value confusion (parameter validation)\r\n        //   * Dust attacks (minimum value)\r\n        //   * Overflow attacks (maximum value)\r\n        //   * Token injection (NO_TOKEN enforcement)\r\n        // - Defense in depth approach\r\n        //\r\n        // USE WHEN:\r\n        // - High-value covenants (vaults, treasuries)\r\n        // - Critical protocol infrastructure\r\n        // - Maximum security required\r\n        // - Input properties affect behavior\r\n    }\r\n}\r\n\r\n// ============================================================================",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-10",
    "content": "// PATTERN 7: Input Validation with Position Awareness\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Validate input and optionally verify position\r\n// USE CASE: When input position has semantic meaning in protocol\r\n// SECURITY: Input identity + optional position validation\r\n//\r\n// ⚠️ SECURITY CAVEAT: Position validation adds CONSTRAINT, not SECURITY\r\n// The declaredPosition parameter is attacker-controlled\r\n// This check enforces protocol ordering but doesn't provide cryptographic security\r\ncontract InputValidationWithPosition(\r\n    int expectedValue\r\n) {\r\n    // SECURE: Validates input properties with optional position check\r\n    function validate(int declaredPosition) {\r\n        // Define NO_TOKEN constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: OPTIONAL - Validate position if needed\r\n        // ⚠️ CAVEAT: This is a CONSTRAINT, not cryptographic security\r\n        // - declaredPosition is attacker-controlled\r\n        // - Attacker sets declaredPosition = this.activeInputIndex\r\n        // - Check enforces protocol ordering, not authenticity\r\n        // - Only use when position has semantic meaning in protocol\r\n        require(this.activeInputIndex == declaredPosition);",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-11",
    "content": "// Step 3: CRITICAL - Validate value\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        require(actualValue == expectedValue);\r\n        \r\n        // Step 4: CRITICAL - Enforce NO_TOKEN\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ~ Position validated (constraint, not security)\r\n        // ✓ Value validated\r\n        // ✓ No tokens allowed\r\n        //\r\n        // ⚠️ POSITION VALIDATION CAVEAT:\r\n        // Position validation (Step 2) is only useful when:\r\n        // - Protocol specifies inputs must be in specific order\r\n        // - Position has semantic meaning (e.g., input[0] = pool A)\r\n        // - External tools depend on specific ordering\r\n        //\r\n        // WHAT IT DOES:\r\n        // - Enforces attacker places this input at declared position\r\n        // - Adds constraint to transaction construction\r\n        // - Does NOT provide cryptographic authentication\r\n        //\r\n        // WHAT IT DOES NOT DO:\r\n        // - Does NOT prevent attacker from controlling position\r\n        // - Does NOT validate position is \"correct\" independently\r\n        // - Attacker still controls declaredPosition parameter\r\n        //\r\n        // For most contracts, input IDENTITY is sufficient\r\n        // Position validation adds constraint but not security\r\n        //\r\n        // USE POSITION VALIDATION WHEN:",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-12",
    "content": "// - Protocol requires specific input order\r\n        // - Position maps to semantic roles\r\n        // - External indexers expect fixed positions\r\n        //\r\n        // SKIP POSITION VALIDATION WHEN:\r\n        // - Input identity is sufficient\r\n        // - Flexibility in input order desired\r\n        // - No semantic meaning to position\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 8: Pure Validation Contract (No Outputs)\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Pure input validation without output constraints\r\n// USE CASE: Validation-only contracts, testing, conditional gates\r\n// SECURITY: Validates inputs but allows any outputs\r\ncontract PureValidationContract(\r\n    int expectedValue\r\n) {\r\n    // SECURE: Validates input properties only\r\n    // Does NOT constrain outputs (by design)\r\n    function validate() {\r\n        // Define NO_TOKEN constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Validate input value\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        require(actualValue == expectedValue);\r\n        \r\n        // Step 3: CRITICAL - Enforce NO_TOKEN",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-13",
    "content": "bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // NO output validation\r\n        // Outputs can be anything (by design)\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Input value validated\r\n        // ✓ No tokens allowed\r\n        // ✗ Outputs unconstrained (intentional)\r\n        //\r\n        // WHY NO OUTPUT VALIDATION:\r\n        // This pattern is for pure validation scenarios:\r\n        // - Input must meet requirements\r\n        // - But outputs are flexible\r\n        // - Use case: conditional spending gate\r\n        //\r\n        // WHEN TO USE:\r\n        // - Validation-only contracts\r\n        // - Testing input properties\r\n        // - Conditional gates (if input valid, allow any output)\r\n        // - Burn contracts (validate input, outputs don't matter)\r\n        //\r\n        // WHEN NOT TO USE:\r\n        // - If covenant continuation needed\r\n        // - If value preservation required\r\n        // - If output destinations matter\r\n        //\r\n        // For most covenants, output validation IS required\r\n        // This pattern is special case for validation-only logic\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 9: Signature-Free Input Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Input validation without signature requirements",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-14",
    "content": "// USE CASE: Anyone-can-spend with input constraints\r\n// SECURITY: Validates input properties, no authorization needed\r\ncontract SignatureFreeValidation(\r\n    int expectedValue\r\n) {\r\n    // SECURE: Validates inputs without requiring signatures\r\n    // Anyone can spend IF input meets requirements\r\n    function validate() {\r\n        // Define NO_TOKEN constant\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        \r\n        // Step 1: CRITICAL - Validate input identity\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // Step 2: CRITICAL - Validate input value\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        require(actualValue == expectedValue);\r\n        \r\n        // Step 3: CRITICAL - Enforce NO_TOKEN\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // NO signature required (anyone-can-spend)\r\n        // As long as input is valid, spending is allowed\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified\r\n        // ✓ Input value validated\r\n        // ✓ No tokens allowed\r\n        // ✓ Anyone can spend (if input valid)\r\n        // ✗ No authorization (intentional)\r\n        //\r\n        // WHY NO SIGNATURES:\r\n        // This pattern enables anyone-can-spend scenarios:\r\n        // - Input constraints, not authorization",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-15",
    "content": "// - Use case: public goods, bounties, faucets\r\n        // - Anyone can claim IF requirements met\r\n        //\r\n        // SECURITY MODEL:\r\n        // - Protection is INPUT validation, not authorization\r\n        // - Anyone can spend CORRECT inputs\r\n        // - Cannot spend INCORRECT inputs\r\n        //\r\n        // USE CASES:\r\n        // - Faucets (anyone can claim fixed amount)\r\n        // - Bounties (anyone can claim if conditions met)\r\n        // - Public pools (anyone can interact)\r\n        // - Testing/development contracts\r\n        //\r\n        // WARNINGS:\r\n        // - Anyone CAN spend this UTXO\r\n        // - Do NOT use for private value\r\n        // - Input validation is ONLY protection\r\n        // - Consider adding authorization for most use cases\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// PATTERN 10: Complete Production Input Validation\r\n// ============================================================================\r\n\r\npragma cashscript ^0.13.0;\r\n\r\n// PATTERN: Production-ready comprehensive input validation\r\n// Combines all best practices for maximum security\r\ncontract ProductionInputValidation(\r\n    int minimumValue,\r\n    int maximumValue\r\n) {\r\n    // SECURE: Complete input validation with all checks\r\n    function validate(int declaredValue) {\r\n        // Define NO_TOKEN constant (32 zero bytes for bytes32)\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-16",
    "content": "// VALIDATION SEQUENCE (order matters for clarity):\r\n        \r\n        // 1. IDENTITY - Validate this is the correct contract\r\n        bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n        require(thisBytecode == this.lockingBytecode);\r\n        \r\n        // 2. VALUE CAPTURE - Get actual input value from blockchain\r\n        int actualValue = tx.inputs[this.activeInputIndex].value;\r\n        \r\n        // 3. PARAMETER HONESTY - Ensure declared value matches actual\r\n        require(declaredValue == actualValue);\r\n        \r\n        // 4. MINIMUM VALUE - Prevent dust attacks\r\n        require(actualValue >= minimumValue);\r\n        \r\n        // 5. MAXIMUM VALUE - Prevent overflow attacks\r\n        require(actualValue <= maximumValue);\r\n        \r\n        // 6. TOKEN ENFORCEMENT - Reject any tokens (pure BCH)\r\n        bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n        require(inputTokenCategory == NO_TOKEN);\r\n        \r\n        // All validations complete\r\n        // Input is guaranteed to be:\r\n        // - This contract instance (identity)\r\n        // - Within acceptable value range (bounds)\r\n        // - Correctly represented in parameters (honesty)\r\n        // - Free of tokens (pure BCH)\r\n        \r\n        // SECURITY PROPERTIES:\r\n        // ✓ Input identity verified (position attack prevention)\r\n        // ✓ Parameter-value match enforced (lying prevention)\r\n        // ✓ Value bounds validated (dust/overflow prevention)",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-17",
    "content": "// ✓ Token injection blocked (pure BCH enforcement)\r\n        // ✓ All input properties validated\r\n        // ✓ Zero assumptions about input state\r\n        //\r\n        // ATTACK VECTORS MITIGATED:\r\n        // ✗ Position confusion (identity check)\r\n        // ✗ Value confusion (parameter validation)\r\n        // ✗ Dust attacks (minimum value)\r\n        // ✗ Overflow attacks (maximum value)\r\n        // ✗ Token injection (NO_TOKEN enforcement)\r\n        // ✗ Parameter lying (declared == actual)\r\n        //\r\n        // PRODUCTION DEPLOYMENT:\r\n        // This pattern is suitable for:\r\n        // - High-value vaults\r\n        // - Protocol infrastructure\r\n        // - Critical financial contracts\r\n        // - Any covenant where input integrity is essential\r\n        //\r\n        // RECOMMENDED FOR:\r\n        // All production covenants should implement these checks\r\n        // Defense in depth - validate everything explicitly\r\n        // No assumptions - verify all properties\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// SECURITY PRINCIPLES FOR INPUT VALIDATION\r\n// ============================================================================\r\n\r\n// PRINCIPLE 1: ALWAYS VALIDATE INPUT IDENTITY\r\n// --------------------------------------------\r\n// CRITICAL: Every covenant must validate activeInputIndex is the expected contract\r\n//\r\n// REQUIRED:\r\n//   bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//   require(thisBytecode == this.lockingBytecode);",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-18",
    "content": "//\r\n// WHY:\r\n// - Prevents input position attacks\r\n// - Ensures correct UTXO is being spent\r\n// - Validates WHAT the input is, not WHERE it is\r\n// - Foundation for all other input validations\r\n//\r\n// WITHOUT THIS CHECK:\r\n// - Attacker can substitute different contract\r\n// - Wrong UTXO could be spent\r\n// - All downstream logic operates on wrong input\r\n\r\n// PRINCIPLE 2: CAPTURE INPUT VALUE EXPLICITLY\r\n// -------------------------------------------\r\n// CRITICAL: Always read input value from tx.inputs[this.activeInputIndex].value\r\n//\r\n// REQUIRED:\r\n//   int inputValue = tx.inputs[this.activeInputIndex].value;\r\n//\r\n// WHY:\r\n// - Explicit capture from blockchain state\r\n// - No assumptions about value\r\n// - Direct read from UTXO\r\n// - Foundation for value validation\r\n//\r\n// NEVER:\r\n// - Assume input value\r\n// - Use hardcoded values without validation\r\n// - Trust function parameters without verification\r\n\r\n// PRINCIPLE 3: VALIDATE PARAMETERS AGAINST REALITY\r\n// ------------------------------------------------\r\n// CRITICAL: If function takes value parameter, validate it matches actual value\r\n//\r\n// PATTERN:\r\n//   function f(int declaredValue) {\r\n//       int actualValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(declaredValue == actualValue);\r\n//   }\r\n//\r\n// WHY:\r\n// - Function parameters are attacker-controlled\r\n// - Without validation, attacker can lie about value\r\n// - Downstream logic trusts incorrect information\r\n// - Parameter-value mismatch enables attacks\r\n//\r\n// ENSURES:",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-19",
    "content": "// - Parameter honesty\r\n// - Safe to use declaredValue in calculations\r\n// - No parameter-based confusion attacks\r\n\r\n// PRINCIPLE 4: ENFORCE VALUE BOUNDS\r\n// ---------------------------------\r\n// RECOMMENDED: Validate input value is within acceptable range\r\n//\r\n// PATTERN:\r\n//   require(inputValue >= minimumValue);\r\n//   require(inputValue <= maximumValue);\r\n//\r\n// WHY:\r\n// - Prevents dust attacks (minimum)\r\n// - Prevents overflow attacks (maximum)\r\n// - Enforces protocol requirements\r\n// - Bounds acceptable variance\r\n//\r\n// CHOOSE BOUNDS BASED ON:\r\n// - Dust threshold (e.g., 546 sats minimum)\r\n// - Protocol requirements (e.g., 1M sats minimum)\r\n// - Overflow prevention (e.g., int max / 2 maximum)\r\n// - Economic security model\r\n\r\n// PRINCIPLE 5: ENFORCE NO_TOKEN WHEN APPLICABLE\r\n// ---------------------------------------------\r\n// CRITICAL: For pure BCH covenants, reject token inputs\r\n//\r\n// REQUIRED (if pure BCH):\r\n//   bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n//   bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n//   require(inputTokenCategory == NO_TOKEN);\r\n//\r\n// WHY:\r\n// - Prevents token injection attacks\r\n// - Ensures pure BCH input\r\n// - Blocks fungible token presence\r\n// - Blocks NFT presence\r\n//\r\n// IMPORTANT - NO_TOKEN CONSTANT:\r\n// - Must be bytes32 type (32 bytes)\r\n// - Value: 0x0000...0000 (64 hex characters = 32 bytes)\r\n// - Represents empty/absent token category\r\n// - Must be defined inside contract/function (no global constants allowed)",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-20",
    "content": "//\r\n// WHEN TO ENFORCE:\r\n// - Pure BCH covenants (no token logic)\r\n// - Value-only contracts\r\n// - When tokens would break assumptions\r\n//\r\n// WHEN TO SKIP:\r\n// - Token-aware covenants\r\n// - Contracts designed for CashTokens\r\n// - When token presence is expected\r\n\r\n// PRINCIPLE 6: VALIDATION ORDER MATTERS\r\n// -------------------------------------\r\n// RECOMMENDED: Validate in logical order for clarity\r\n//\r\n// OPTIMAL ORDER:\r\n// 1. Input identity (lockingBytecode)\r\n// 2. Value capture (get actual value)\r\n// 3. Parameter validation (if applicable)\r\n// 4. Value bounds (min/max)\r\n// 5. Token enforcement (if applicable)\r\n//\r\n// WHY THIS ORDER:\r\n// - Identity first (ensure correct input)\r\n// - Capture before validation (get truth from blockchain)\r\n// - Validate parameters against truth\r\n// - Apply bounds to validated value\r\n// - Token check last (property validation)\r\n//\r\n// BENEFITS:\r\n// - Clear logical flow\r\n// - Easy to audit\r\n// - Fail fast (identity check rejects early)\r\n// - Each step builds on previous\r\n\r\n// ============================================================================\r\n// COMMON MISTAKES AND HOW TO AVOID THEM\r\n// ============================================================================\r\n\r\n// MISTAKE 1: Not Validating Input Identity\r\n// -----------------------------------------\r\n// WRONG:\r\n//   function validate(int expectedValue) {\r\n//       int inputValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(inputValue == expectedValue);\r\n//       // Missing identity check!",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-21",
    "content": "//   }\r\n//\r\n// WHY WRONG:\r\n// - No validation that activeInputIndex is this contract\r\n// - Attacker could place different contract at activeInputIndex\r\n// - Value check passes but wrong UTXO spent\r\n//\r\n// CORRECT:\r\n//   function validate(int expectedValue) {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       int inputValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(inputValue == expectedValue);\r\n//   }\r\n\r\n// MISTAKE 2: Assuming Input Value\r\n// --------------------------------\r\n// WRONG:\r\n//   function validate() {\r\n//       // Assumes input value is 1,000,000 without checking\r\n//       int assumedValue = 1000000;\r\n//       // Uses assumedValue in logic without validation\r\n//   }\r\n//\r\n// WHY WRONG:\r\n// - No validation of actual input value\r\n// - Logic operates on assumption, not reality\r\n// - Attacker can use different value UTXO\r\n//\r\n// CORRECT:\r\n//   function validate(int expectedValue) {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       int actualValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(actualValue == expectedValue);\r\n//   }\r\n\r\n// MISTAKE 3: Trusting Function Parameters\r\n// ----------------------------------------\r\n// WRONG:\r\n//   function validate(int declaredValue) {\r\n//       // Uses declaredValue without verification\r\n//       require(declaredValue >= 100000);",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-22",
    "content": "//       // Assumes declaredValue is truthful\r\n//   }\r\n//\r\n// WHY WRONG:\r\n// - Function parameter is attacker-controlled\r\n// - No validation against actual input value\r\n// - Attacker can lie about value\r\n//\r\n// CORRECT:\r\n//   function validate(int declaredValue) {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       int actualValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(declaredValue == actualValue);  // Honesty check\r\n//       require(actualValue >= 100000);\r\n//   }\r\n\r\n// MISTAKE 4: Invalid NO_TOKEN Literal\r\n// ------------------------------------\r\n// WRONG:\r\n//   bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n//   require(inputTokenCategory == 0x);\r\n//   // 0x is ambiguous/invalid for bytes32!\r\n//\r\n// WHY WRONG:\r\n// - 0x is not a valid bytes32 literal\r\n// - May fail parsing or behave inconsistently\r\n// - Ambiguous type (could be bytes, bytes32, etc.)\r\n//\r\n// CORRECT:\r\n//   bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n//   bytes32 inputTokenCategory = tx.inputs[this.activeInputIndex].tokenCategory;\r\n//   require(inputTokenCategory == NO_TOKEN);\r\n//   // Explicit 32-byte constant (64 hex chars)\r\n\r\n// MISTAKE 5: Not Validating Value Bounds\r\n// ---------------------------------------\r\n// WRONG:\r\n//   function validate() {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-23",
    "content": "//       require(thisBytecode == this.lockingBytecode);\r\n//       // No value bounds - accepts any value including dust\r\n//   }\r\n//\r\n// WHY WRONG:\r\n// - Accepts dust inputs (e.g., 1 sat)\r\n// - No protection against extreme values\r\n// - Could affect economic security\r\n//\r\n// CORRECT:\r\n//   function validate() {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       int inputValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(inputValue >= 100000);  // Minimum 100k sats\r\n//       require(inputValue <= 10000000);  // Maximum 10M sats\r\n//   }\r\n\r\n// MISTAKE 6: Checking Input Position Instead of Identity\r\n// -------------------------------------------------------\r\n// WRONG:\r\n//   function validate(int expectedPosition) {\r\n//       require(this.activeInputIndex == expectedPosition);\r\n//       // Validates position, not identity!\r\n//   }\r\n//\r\n// WHY WRONG:\r\n// - expectedPosition is attacker-controlled\r\n// - Check is tautological (always passes)\r\n// - Doesn't validate WHAT the input is\r\n//\r\n// CORRECT:\r\n//   function validate() {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       // Validates IDENTITY, not position\r\n//   }\r\n\r\n// MISTAKE 7: Reading Wrong Input\r\n// -------------------------------\r\n// WRONG:\r\n//   function validate() {\r\n//       int inputValue = tx.inputs[0].value;  // WRONG INDEX!",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-24",
    "content": "//       require(inputValue == 1000000);\r\n//   }\r\n//\r\n// WHY WRONG:\r\n// - Reads input[0], not the active input\r\n// - If this UTXO is at input[1], checks wrong value\r\n// - Attacker can manipulate input[0] value\r\n//\r\n// CORRECT:\r\n//   function validate() {\r\n//       bytes thisBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\r\n//       require(thisBytecode == this.lockingBytecode);\r\n//       int inputValue = tx.inputs[this.activeInputIndex].value;\r\n//       require(inputValue == 1000000);\r\n//   }\r\n\r\n// ============================================================================\r\n// TESTING RECOMMENDATIONS\r\n// ============================================================================\r\n\r\n// Test Case 1: Valid Input (Identity Match)\r\n// ------------------------------------------\r\n// Setup: Input lockingBytecode matches contract\r\n// Expected: Transaction succeeds\r\n// Validates: Identity check works\r\n\r\n// Test Case 2: Invalid Input (Identity Mismatch)\r\n// -----------------------------------------------\r\n// Setup: Input lockingBytecode is different contract\r\n// Expected: Transaction FAILS\r\n// Validates: Identity check rejects wrong contract\r\n\r\n// Test Case 3: Valid Input (Correct Value)\r\n// -----------------------------------------\r\n// Setup: Input value matches expected value\r\n// Expected: Transaction succeeds\r\n// Validates: Value validation works\r\n\r\n// Test Case 4: Invalid Input (Wrong Value)\r\n// -----------------------------------------\r\n// Setup: Input value differs from expected",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-25",
    "content": "// Expected: Transaction FAILS\r\n// Validates: Value validation rejects\r\n\r\n// Test Case 5: Parameter Honesty (Truth)\r\n// ---------------------------------------\r\n// Setup: Declared value matches actual value\r\n// Expected: Transaction succeeds\r\n// Validates: Parameter validation accepts truth\r\n\r\n// Test Case 6: Parameter Dishonesty (Lie)\r\n// ----------------------------------------\r\n// Setup: Declared value differs from actual value\r\n// Expected: Transaction FAILS\r\n// Validates: Parameter validation catches lies\r\n\r\n// Test Case 7: Dust Attack (Below Minimum)\r\n// -----------------------------------------\r\n// Setup: Input value below minimum threshold\r\n// Expected: Transaction FAILS\r\n// Validates: Minimum value bound enforced\r\n\r\n// Test Case 8: Overflow Attack (Above Maximum)\r\n// ---------------------------------------------\r\n// Setup: Input value above maximum threshold\r\n// Expected: Transaction FAILS\r\n// Validates: Maximum value bound enforced\r\n\r\n// Test Case 9: Token Injection (Fungible)\r\n// ----------------------------------------\r\n// Setup: Input has fungible tokens\r\n// Expected: Transaction FAILS\r\n// Validates: NO_TOKEN enforcement rejects tokens\r\n\r\n// Test Case 10: Token Injection (NFT)\r\n// ------------------------------------\r\n// Setup: Input has NFT\r\n// Expected: Transaction FAILS\r\n// Validates: NO_TOKEN enforcement rejects NFTs\r\n\r\n// Test Case 11: Multi-Input Position\r\n// -----------------------------------\r\n// Setup: This contract at input[2], other inputs present\r\n// Expected: Transaction succeeds",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-26",
    "content": "// Validates: activeInputIndex correctly identifies input\r\n\r\n// Test Case 12: Pure BCH Input\r\n// -----------------------------\r\n// Setup: Input has correct identity, value, no tokens\r\n// Expected: Transaction succeeds\r\n// Validates: All validations pass for correct input\r\n\r\n// ============================================================================\r\n// DEPLOYMENT CHECKLIST\r\n// ============================================================================\r\n//\r\n// Before deploying input validation patterns:\r\n//\r\n// [ ] DOES validate input identity (lockingBytecode == this.lockingBytecode)\r\n// [ ] DOES capture input value explicitly (tx.inputs[this.activeInputIndex].value)\r\n// [ ] DOES validate parameters match actual values (if using parameters)\r\n// [ ] DOES enforce value bounds (minimum and maximum)\r\n// [ ] DOES enforce NO_TOKEN correctly (bytes32 with 32-byte constant)\r\n// [ ] DOES define NO_TOKEN inside each contract/function (no global constants)\r\n// [ ] Does NOT use invalid 0x literal for NO_TOKEN comparison\r\n// [ ] Does NOT assume input value without validation\r\n// [ ] Does NOT trust function parameters without verification\r\n// [ ] Does NOT read from wrong input index\r\n// [ ] Does NOT validate position instead of identity\r\n// [ ] Test with correct input (all checks pass)\r\n// [ ] Test with wrong identity (must fail)\r\n// [ ] Test with wrong value (must fail)\r\n// [ ] Test with lying parameters (must fail)\r\n// [ ] Test with dust inputs (must fail if minimum enforced)\r\n// [ ] Test with token inputs (must fail if NO_TOKEN enforced)",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-27",
    "content": "// [ ] Verify activeInputIndex usage is correct throughout\r\n// [ ] Verify NO_TOKEN constant is 32 bytes (64 hex characters)\r\n\r\n// ============================================================================\r\n// USAGE EXAMPLES\r\n// ============================================================================\r\n\r\n// Example 1: Fixed-Value Vault\r\n// -----------------------------\r\n// Use Pattern 2: InputValueValidation\r\n// - Vault holds exactly 1,000,000 sats\r\n// - Validates input is correct contract\r\n// - Validates input value is exactly 1M sats\r\n// - Rejects any other value\r\n\r\n// Example 2: Flexible-Value Covenant\r\n// -----------------------------------\r\n// Use Pattern 3: InputValueRange\r\n// - Accept inputs between 100k - 10M sats\r\n// - Rejects dust (< 100k)\r\n// - Rejects excessive (> 10M)\r\n// - Allows variance within bounds\r\n\r\n// Example 3: Pure BCH Protocol\r\n// -----------------------------\r\n// Use Pattern 4: TokenFreeValidation\r\n// - Enforces pure BCH inputs\r\n// - Rejects any token presence\r\n// - Validates value and identity\r\n// - No token logic needed\r\n\r\n// Example 4: Parameter-Driven Covenant\r\n// -------------------------------------\r\n// Use Pattern 5: ExplicitParameterValidation\r\n// - Function takes declared value parameter\r\n// - Validates parameter matches actual\r\n// - Prevents parameter lying\r\n// - Safe to use parameter in logic\r\n\r\n// Example 5: High-Security Vault\r\n// -------------------------------\r\n// Use Pattern 10: ProductionInputValidation\r\n// - Maximum security for critical funds",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/input_validation.cash-28",
    "content": "// - All validations enabled\r\n// - Defense in depth\r\n// - Zero assumptions about input state\r\n\r\n// ============================================================================\r\n// END OF FILE\r\n// ============================================================================",
    "source": "NexKB/patterns/input_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/patterns/minting_control.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// SECURITY PATTERN: Minting Control and Token Authority Leakage Prevention\r\n// PURPOSE: Prevent unauthorized CashToken minting or mint authority propagation\r\n// CATEGORY: Token Safety\r\n// USE CASE: Any BCH-only contract that must defensively reject all token flows\r\n\r\n// PATTERN DESCRIPTION:\r\n// This pattern demonstrates how to explicitly and exhaustively prevent CashToken\r\n// minting operations from occurring in or through a contract. Even contracts that\r\n// do not intentionally handle tokens must defensively validate that no token\r\n// authority (minting, mutable, or immutable) can enter, propagate, or exit\r\n// through the contract. Failure to do so creates silent token injection vectors.\r\n\r\n// CASHTOKEN CAPABILITY MODEL (Background):\r\n// Every CashToken UTXO carries a capability field that defines its authority:\r\n// - NO CAPABILITY (0x00): Standard immutable NFT (fixed commitment, no authority)\r\n// - MUTABLE     (0x01): NFT can be updated (commitment can change)\r\n// - MINTING     (0x02): NFT can create new tokens of same category (highest authority)\r\n// - FUNGIBLE    (none): FT tokens carry no capability but carry tokenAmount > 0\r\n//\r\n// A MINTING token in a contract output means:\r\n// - The output can generate unlimited new tokens of that category\r\n// - This is equivalent to a central bank printing press\r\n// - If leaked into wrong contract, anyone can drain or corrupt the token supply\r\n//\r\n// A MUTABLE token in a contract output means:\r\n// - The output can change its NFT commitment data",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-1",
    "content": "// - Can corrupt state that relies on NFT commitment integrity\r\n//\r\n// RISK: If a BCH-only contract does not explicitly reject tokens, a malicious\r\n// builder can inject a minting-capable NFT into the contract, effectively\r\n// laundering mint authority through an unsuspecting contract.\r\n\r\n// LOCKING BYTECODE CONSTRUCTION MODEL:\r\n// NexOps prohibits raw bytes parameters for lockingBytecode destinations.\r\n// Reason: raw bytes allow caller to inject arbitrary destination scripts,\r\n// which is a covenant escape vector. All destinations must be constructed\r\n// from typed primitives using CashScript's LockingBytecode constructors:\r\n//\r\n// ✅ new LockingBytecodeP2PKH(pubkeyhash)   — pay to public key hash\r\n// ✅ new LockingBytecodeP2SH(bytes32)        — pay to script hash\r\n// ✅ tx.inputs[this.activeInputIndex].lockingBytecode — self-reference (covenant)\r\n//\r\n// ❌ bytes rawBytecode                       — FORBIDDEN (covenant escape)\r\n// ❌ bytes expectedOutput                    — FORBIDDEN (covenant escape)\r\n//\r\n// This applies to ALL covenant destination parameters in NexOps contracts.\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract EXPLICITLY rejects ALL token inputs (any category)\r\n// - This contract EXPLICITLY rejects ALL token outputs (any category)\r\n// - This contract does NOT handle minting, mutable, or immutable NFTs\r\n// - This contract does NOT handle fungible tokens (any tokenAmount > 0)\r\n// - Defensive validation applies even if contract has no other token logic\r\n// - This is a BCH-only contract by design and enforcement",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-2",
    "content": "// - All output destinations are constructed from typed primitives (no raw bytes)\r\n\r\n// ATTACK VECTORS BLOCKED:\r\n// ✗ Minting NFT injection: Cannot inject minting authority into contract\r\n// ✗ Mutable NFT injection: Cannot inject mutable authority into contract\r\n// ✗ Token laundering: Cannot route mint authority through this contract\r\n// ✗ Silent token acceptance: Cannot add tokens to inputs without detection\r\n// ✗ Token output injection: Cannot create token outputs from this contract\r\n// ✗ Category confusion: Cannot use any non-zero token category\r\n// ✗ Token amount smuggling: Cannot carry fungible tokens through contract\r\n// ✗ Covenant escape via raw bytes: Cannot inject arbitrary destination scripts\r\n\r\ncontract MintingControl() {\r\n    // PRIMARY VALIDATION FUNCTION (P2PKH DESTINATION)\r\n    // Demonstrates complete minting control with typed P2PKH destination\r\n    // Recipient is a pubkeyhash — not raw bytes — preventing covenant escape\r\n    function validateP2PKH(\r\n        pubkeyhash recipient,  // Typed recipient hash — NOT raw bytes\r\n        int outputValue        // Expected output value (BCH only)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" — canonical all-zeros value\r\n        // SEMANTIC CONSTANT: The ONLY acceptable token category for BCH-only contracts\r\n        // Any non-zero value represents a CashToken category and MUST be rejected\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "p2pkh",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-3",
    "content": "// ═══════════════════════════════════════════════════════════════\r\n        // SECTION 1: ACTIVE INPUT IDENTIFICATION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Establish which input belongs to this contract\r\n        // PREVENTS: Position attacks, wrong input validation\r\n        // SEVERITY: Critical\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 2: INPUT TOKEN CATEGORY REJECTION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Reject any token-carrying input to this contract\r\n        // PREVENTS: Token injection, minting authority import, token laundering\r\n        // SEVERITY: Critical\r\n\r\n        // WHY THIS EXISTS:\r\n        // A malicious transaction builder could construct a transaction where:\r\n        // - This contract's UTXO was previously injected with a minting NFT\r\n        // - The builder then spends this UTXO to \"use\" the minting authority\r\n        // - Without this check, the contract silently validates token spending\r\n        // By explicitly requiring NO_TOKEN, we ensure the contract UTXO was\r\n        // never used to hold any token authority\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 3: INPUT TOKEN AMOUNT REJECTION",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-4",
    "content": "// ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Reject fungible tokens even if category check somehow passes\r\n        // PREVENTS: Fungible token smuggling, amount-based attacks\r\n        // SEVERITY: High\r\n        // NOTE: Defensive redundancy — if tokenCategory == NO_TOKEN then\r\n        // tokenAmount must also be 0 by protocol rules. However, explicit\r\n        // validation makes intent clear and guards against future edge cases.\r\n        require(tx.inputs[this.activeInputIndex].tokenAmount == 0);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 4: OUTPUT COUNT ENFORCEMENT\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Bound the output space to prevent unvalidated outputs\r\n        // PREVENTS: Hidden token outputs, output injection attacks\r\n        // SEVERITY: Critical\r\n\r\n        // WHY EXACT COUNT MATTERS FOR MINTING CONTROL:\r\n        // Minting attacks often work by adding extra unvalidated outputs\r\n        // An attacker could add a minting NFT output AFTER the validated output\r\n        // By requiring exactly 1 output, every output is explicitly validated\r\n        // There is NO unvalidated output space where tokens can hide\r\n        require(tx.outputs.length == 1);\r\n\r\n        // NEXOPS NOTE: If your contract requires more outputs (N > 1),\r\n        // you MUST explicitly validate tokenCategory == NO_TOKEN on EVERY\r\n        // output individually. Never leave an output unvalidated.",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-5",
    "content": "// FEE MODEL: EXTERNAL\r\n        // tx.outputs.length == 1 implies no fee output from this contract\r\n        // Mining fee MUST be provided by other inputs in the transaction\r\n        // NEXOPS NOTE: This is an intentional design choice (external fee model)\r\n        // If unintentional, use fee-tolerant pattern with >= 2 outputs\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 5: OUTPUT DESTINATION VALIDATION (TYPED P2PKH)\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Validate output goes to typed P2PKH destination\r\n        // PREVENTS: Redirection attacks, covenant escape via raw bytes\r\n        // SEVERITY: Critical\r\n\r\n        // WHY WE USE new LockingBytecodeP2PKH(recipient) NOT raw bytes:\r\n        // - raw bytes parameter = caller controls destination = covenant escape\r\n        // - pubkeyhash parameter = caller provides hash, destination is CONSTRUCTED\r\n        // - LockingBytecodeP2PKH wraps hash in the correct P2PKH script template\r\n        // - The script template itself is enforced by the constructor (not caller)\r\n        // - Attacker can only influence WHICH P2PKH address, not the script TYPE\r\n        // This is the NexOps-required pattern for all payment destinations\r\n        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipient));\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 6: OUTPUT VALUE VALIDATION",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant",
      "p2pkh",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-6",
    "content": "// ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Bind caller-provided value to actual output value\r\n        // PREVENTS: Value mismatch attacks, parameter spoofing\r\n        // SEVERITY: High\r\n\r\n        // TRUST MODEL: outputValue is UNTRUSTED (caller-provided)\r\n        // Safety relies ENTIRELY on equality with tx.outputs[0].value\r\n        // outputValue is validated SOLELY by this equality check\r\n        // Do NOT use outputValue in any logic before this binding\r\n        require(tx.outputs[0].value == outputValue);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 7: OUTPUT TOKEN CATEGORY REJECTION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Prevent any token from being created in the output\r\n        // PREVENTS: Minting through this contract, token output injection\r\n        // SEVERITY: Critical\r\n\r\n        // WHY THIS IS THE MOST IMPORTANT CHECK:\r\n        // Even if no tokens entered via inputs, a malicious builder could:\r\n        // - Construct a transaction that creates NEW tokens in the output\r\n        // - Use this contract's validation as \"cover\" for a minting operation\r\n        // - The minting UTXO would then exist at the output address\r\n        //\r\n        // By requiring NO_TOKEN on the output, we guarantee:\r\n        // - This contract CANNOT be used as a minting vehicle\r\n        // - No token category can appear in any output we validate",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-7",
    "content": "// - Mint authority CANNOT propagate through this contract\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // SECTION 8: OUTPUT TOKEN AMOUNT REJECTION\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // PURPOSE: Explicit fungible token rejection on output\r\n        // PREVENTS: Fungible token creation, FT smuggling in outputs\r\n        // SEVERITY: High\r\n        // NOTE: Defensive redundancy — if tokenCategory == NO_TOKEN then\r\n        // tokenAmount must be 0. Explicit check documents intent clearly.\r\n        require(tx.outputs[0].tokenAmount == 0);\r\n\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // VALIDATION COMPLETE\r\n        // ═══════════════════════════════════════════════════════════════\r\n        // At this point, we have guaranteed:\r\n        // ✓ This contract is the active input being validated\r\n        // ✓ Input carries no token category (not even immutable NFT)\r\n        // ✓ Input carries no fungible token amount\r\n        // ✓ Exactly one output exists (no hidden output space)\r\n        // ✓ Output destination is a typed P2PKH (no raw bytes injection)\r\n        // ✓ Output value matches caller claim (parameter binding)\r\n        // ✓ Output carries no token category (no minting possible)\r\n        // ✓ Output carries no fungible token amount\r\n        // ✓ Mint authority CANNOT enter or exit through this contract",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "p2pkh",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-8",
    "content": "// ✓ Fee is paid externally (external fee model, intentional)\r\n    }\r\n\r\n    // SECONDARY VALIDATION FUNCTION (P2SH DESTINATION)\r\n    // Same minting control guarantees with typed P2SH destination\r\n    // scriptHash is bytes32 — NOT raw bytes — still prevents covenant escape\r\n    // Caller provides hash of a script, not the script itself\r\n    function validateP2SH(\r\n        bytes32 scriptHash,    // Typed script hash — NOT raw lockingBytecode\r\n        int outputValue        // Expected output value (BCH only)\r\n    ) {\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // Active input validation\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n        require(tx.inputs[this.activeInputIndex].tokenAmount == 0);\r\n\r\n        // Output count bounding\r\n        require(tx.outputs.length == 1);\r\n\r\n        // TYPED P2SH DESTINATION\r\n        // new LockingBytecodeP2SH(scriptHash) constructs the P2SH wrapper\r\n        // Caller provides the script hash, not the raw destination bytecode\r\n        // The P2SH script template is enforced by the constructor\r\n        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2SH(scriptHash));\r\n\r\n        // Value binding (outputValue is untrusted — bound to consensus data)\r\n        require(tx.outputs[0].value == outputValue);\r\n\r\n        // Output token rejection",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-9",
    "content": "require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        require(tx.outputs[0].tokenAmount == 0);\r\n    }\r\n\r\n    // COVENANT CONTINUATION VARIANT\r\n    // Minting control for self-referential covenant continuation\r\n    // Uses self-reference pattern — no destination parameter needed at all\r\n    // This is the most restrictive form: output MUST be this exact contract\r\n    function validateContinuation(\r\n        int outputValue        // Expected continuation value (BCH only)\r\n    ) {\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // Active input validation\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n        require(tx.inputs[this.activeInputIndex].tokenAmount == 0);\r\n\r\n        // Output count bounding\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SELF-REFERENCE DESTINATION\r\n        // No destination parameter — output MUST be this exact contract\r\n        // This is the strongest form: caller has zero influence over destination\r\n        // Covenant escape is impossible by construction\r\n        require(\r\n            tx.outputs[0].lockingBytecode ==\r\n            tx.inputs[this.activeInputIndex].lockingBytecode\r\n        );\r\n\r\n        // Value binding (outputValue is untrusted — bound to consensus data)\r\n        require(tx.outputs[0].value == outputValue);\r\n\r\n        // Output token rejection",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-10",
    "content": "require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        require(tx.outputs[0].tokenAmount == 0);\r\n    }\r\n}\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// PATTERN: EXHAUSTIVE OUTPUT TOKEN REJECTION (N OUTPUTS)\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// When a contract requires multiple outputs, EVERY output must be\r\n// individually validated. This pattern shows the required structure.\r\n//\r\n// MANDATORY RULE: No output may be left unvalidated for token category.\r\n// If tx.outputs.length == N, then outputs [0..N-1] must ALL be checked.\r\n\r\ncontract MintingControlMultiOutput() {\r\n    function validate(\r\n        pubkeyhash recipient0,    // Typed destination — output 0\r\n        pubkeyhash recipient1,    // Typed destination — output 1\r\n        int output0Value,\r\n        int output1Value\r\n    ) {\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // Active input validation\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n        require(tx.inputs[this.activeInputIndex].tokenAmount == 0);\r\n\r\n        // Exact output count: 2 outputs, both fully validated\r\n        // NEXOPS INVARIANT: outputs.length == N must be followed by\r\n        // tokenCategory == NO_TOKEN check on ALL N outputs\r\n        require(tx.outputs.length == 2);\r\n\r\n        // OUTPUT 0: Full token rejection with typed P2PKH destination",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "p2pkh",
      "int"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-11",
    "content": "require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(recipient0));\r\n        require(tx.outputs[0].value == output0Value);\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        require(tx.outputs[0].tokenAmount == 0);\r\n\r\n        // OUTPUT 1: Full token rejection with typed P2PKH destination\r\n        // CRITICAL: Every output MUST be validated individually\r\n        // Skipping even one output creates a token injection vector\r\n        require(tx.outputs[1].lockingBytecode == new LockingBytecodeP2PKH(recipient1));\r\n        require(tx.outputs[1].value == output1Value);\r\n        require(tx.outputs[1].tokenCategory == NO_TOKEN);\r\n        require(tx.outputs[1].tokenAmount == 0);\r\n    }\r\n}\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// LOCKING BYTECODE CONSTRUCTION RULES (NEXOPS CANONICAL)\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// RULE: All output destinations must be constructed from typed primitives.\r\n// NEVER use raw bytes parameters for lockingBytecode destinations.\r\n\r\n// ALLOWED DESTINATION PATTERNS:\r\n//\r\n// Pattern A: P2PKH (most common, recommended for individual recipients)\r\n// Parameter type: pubkeyhash recipient\r\n// Construction:   new LockingBytecodeP2PKH(recipient)\r\n// Security:       Caller controls WHICH address, not the script type\r\n//\r\n// Pattern B: P2SH (for script-hash destinations)\r\n// Parameter type: bytes32 scriptHash\r\n// Construction:   new LockingBytecodeP2SH(scriptHash)",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "p2pkh",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-12",
    "content": "// Security:       Caller controls WHICH script hash, not the wrapper type\r\n//\r\n// Pattern C: Self-reference (for covenant continuation)\r\n// Parameter type: (none needed)\r\n// Construction:   tx.inputs[this.activeInputIndex].lockingBytecode\r\n// Security:       Caller has zero influence over destination (strongest)\r\n//\r\n// FORBIDDEN DESTINATION PATTERNS:\r\n//\r\n// ❌ Pattern X: Raw bytes parameter\r\n// Parameter type: bytes destination\r\n// Usage:          require(tx.outputs[0].lockingBytecode == destination)\r\n// Risk:           Caller injects arbitrary script — covenant escape\r\n//\r\n// ❌ Pattern Y: Raw bytes32 used as lockingBytecode directly\r\n// Parameter type: bytes32 rawScript\r\n// Usage:          require(tx.outputs[0].lockingBytecode == rawScript)\r\n// Risk:           Caller constructs arbitrary 32-byte script fragments\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// MINTING CONTROL SEVERITY CLASSIFICATION\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// SEVERITY: Critical (Minting Authority Leakage)\r\n// - Missing input tokenCategory validation\r\n// - Missing output tokenCategory validation\r\n// - Consequence: Minting authority can enter/exit via contract\r\n// - Detection: AST-level — tokenCategory comparison absence\r\n// - Prevention: Mandatory NO_TOKEN check on all inputs/outputs\r\n\r\n// SEVERITY: Critical (Covenant Escape via Raw Bytes)\r\n// - Using bytes parameter for lockingBytecode destination\r\n// - Consequence: Caller controls output destination arbitrarily",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-13",
    "content": "// - Detection: AST-level — lockingBytecode == bytes_parameter pattern\r\n// - Prevention: Use typed constructors (P2PKH, P2SH, self-reference)\r\n\r\n// SEVERITY: Critical (Unvalidated Output Space)\r\n// - tx.outputs.length not bounded\r\n// - Consequence: Hidden token output can bypass all checks\r\n// - Detection: AST-level — outputs.length validation absence\r\n// - Prevention: Exact output count with per-output validation\r\n\r\n// SEVERITY: High (Fungible Token Smuggling)\r\n// - Missing tokenAmount == 0 validation\r\n// - Consequence: FT tokens can pass through BCH-only contract\r\n// - Detection: AST-level — tokenAmount comparison absence\r\n// - Prevention: Explicit tokenAmount == 0 on all inputs/outputs\r\n\r\n// SEVERITY: Medium (Incomplete Coverage)\r\n// - Some but not all outputs validated for token category\r\n// - Consequence: Token injection through unvalidated output\r\n// - Detection: Coverage analysis — outputs checked vs total count\r\n// - Prevention: All outputs validated when count is bounded\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// STRUCTURAL INVARIANT FOR NEXOPS\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// AST-Level Rule: Minting Control Invariant\r\n// For any contract classified as BCH-only (no token parameters):\r\n//\r\n// 1. INPUT TOKEN REJECTION INVARIANT:\r\n//    For the active input, ALL of these must exist:\r\n//    - require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN)\r\n//    - require(tx.inputs[this.activeInputIndex].tokenAmount == 0)",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "p2pkh"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-14",
    "content": "//    Both must dominate any covenant logic\r\n//\r\n// 2. OUTPUT BOUNDING INVARIANT:\r\n//    - require(tx.outputs.length == N) must exist\r\n//    - N must be a specific literal (not a variable)\r\n//    - Exact count is preferred over minimum count for BCH-only\r\n//\r\n// 3. OUTPUT TOKEN REJECTION INVARIANT:\r\n//    For each output index i in [0..N-1]:\r\n//    - require(tx.outputs[i].tokenCategory == NO_TOKEN)\r\n//    - require(tx.outputs[i].tokenAmount == 0)\r\n//    Coverage must be COMPLETE: every output validated\r\n//\r\n// 4. NO_TOKEN CONSTANT INVARIANT:\r\n//    - NO_TOKEN must equal bytes32 of all zeros\r\n//    - NexOps should recognize and verify this canonical value\r\n//    - Any other value is semantically incorrect\r\n//\r\n// 5. DESTINATION CONSTRUCTION INVARIANT:\r\n//    - All output lockingBytecode destinations must use typed constructors\r\n//    - Permitted: new LockingBytecodeP2PKH(pubkeyhash)\r\n//    - Permitted: new LockingBytecodeP2SH(bytes32)\r\n//    - Permitted: tx.inputs[this.activeInputIndex].lockingBytecode\r\n//    - Forbidden: any bytes or bytes32 parameter used directly as destination\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// NEXOPS ENFORCEMENT CHECKLIST\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// NexOps MUST verify for every BCH-only contract:\r\n// [ ] Input tokenCategory == NO_TOKEN exists for active input\r\n// [ ] Input tokenAmount == 0 exists for active input\r\n// [ ] tx.outputs.length is bounded with exact count",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-15",
    "content": "// [ ] Output tokenCategory == NO_TOKEN exists for EVERY output\r\n// [ ] Output tokenAmount == 0 exists for EVERY output\r\n// [ ] NO_TOKEN constant equals 0x0000...0000 (32 zero bytes)\r\n// [ ] Coverage is complete (no output left without token check)\r\n// [ ] Token checks use == NO_TOKEN (not != someCategory)\r\n// [ ] All lockingBytecode destinations use typed constructors\r\n// [ ] No raw bytes parameters used for destination scripts\r\n// [ ] outputValue is bound to tx.outputs[N].value before use\r\n\r\n// NexOps MUST flag:\r\n// - Missing input tokenCategory check: CRITICAL\r\n// - Missing output tokenCategory check: CRITICAL\r\n// - Incomplete output coverage: CRITICAL\r\n// - Unbounded output count: CRITICAL\r\n// - Raw bytes used as lockingBytecode destination: CRITICAL\r\n// - Missing tokenAmount check: HIGH\r\n// - outputValue used before binding: HIGH\r\n// - Incorrect NO_TOKEN value: ERROR\r\n// - Partial coverage (some outputs checked): HIGH\r\n// - Ambiguous fee model: WARNING\r\n\r\n// ═══════════════════════════════════════════════════════════════════════\r\n// TESTING CHECKLIST\r\n// ═══════════════════════════════════════════════════════════════════════\r\n\r\n// [ ] Test with input tokenCategory = immutable NFT category (should fail)\r\n// [ ] Test with input tokenCategory = mutable NFT category (should fail)\r\n// [ ] Test with input tokenCategory = minting NFT category (should fail)\r\n// [ ] Test with input tokenAmount > 0 (should fail)\r\n// [ ] Test with extra outputs beyond N (should fail — length check)",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/minting_control.cash-16",
    "content": "// [ ] Test with output tokenCategory = any non-zero value (should fail)\r\n// [ ] Test with output tokenAmount > 0 (should fail)\r\n// [ ] Test with valid BCH-only inputs and outputs (should succeed)\r\n// [ ] Test that minting NFT cannot propagate through contract\r\n// [ ] Test that mutable NFT cannot propagate through contract\r\n// [ ] Test all three destination variants (P2PKH, P2SH, self-reference)\r\n// [ ] Verify NO_TOKEN constant is exactly 32 zero bytes\r\n// [ ] Test with boundary output count (N-1, N, N+1)\r\n// [ ] Verify outputValue binding prevents parameter spoofing",
    "source": "NexKB/patterns/minting_control.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "p2pkh",
      "bytes"
    ]
  },
  {
    "id": "NexKB/patterns/output_count_limit.cash-0",
    "content": "// PATTERN: Output Count Security\r\n// CRITICAL: Include as FIRST validation in EVERY function\r\n\r\ncontract SecureContract() {\r\n    function anyOperation() {\r\n        // CRITICAL: ALWAYS include this FIRST\r\n        require(tx.outputs.length <= 5);\r\n        \r\n        // ... rest of logic\r\n    }\r\n}\r\n\r\n// Standard Output Limits:\r\n// Simple transfer: 3-4\r\n// Swap/exchange: 5-6\r\n// Complex DeFi: 7-10\r\n// Batch operations: 15-20\r\n// Maximum: 50",
    "source": "NexKB/patterns/output_count_limit.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function"
    ]
  },
  {
    "id": "NexKB/patterns/position_validation.cash-0",
    "content": "// PATTERN: Input Position Validation\r\n// ALWAYS validate your own position and other contracts' positions\r\n\r\nfunction myOperation() {\r\n    // ALWAYS validate your own position first\r\n    require(this.activeInputIndex == 2);\r\n    \r\n    // Define expected positions\r\n    // Index 0: Price oracle\r\n    // Index 1: Main contract\r\n    // Index 2: This function contract (self)\r\n    // Index 3: User BCH\r\n    \r\n    // Validate each position\r\n    require(tx.inputs[0].tokenCategory == oracleCategory + 0x01);\r\n    require(tx.inputs[1].tokenCategory == mainCategory + 0x01);\r\n    require(tx.inputs[3].tokenCategory == 0x); // Pure BCH\r\n    \r\n    // Now safe to use these indices\r\n}",
    "source": "NexKB/patterns/position_validation.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function"
    ]
  },
  {
    "id": "NexKB/patterns/sidecar_attach.cash-0",
    "content": "// PATTERN: Sidecar Attachment\r\n// Proves sidecar belongs to main contract\r\n\r\ncontract TokenSidecar() {\r\n    function attach() {\r\n        int mainIndex = this.activeInputIndex - 1;\r\n        \r\n        // CRITICAL: Prove same-transaction origin\r\n        require(tx.inputs[this.activeInputIndex].outpointTransactionHash ==\r\n                tx.inputs[mainIndex].outpointTransactionHash);\r\n        \r\n        // CRITICAL: Prove sequential output indices\r\n        require(tx.inputs[this.activeInputIndex].outpointIndex ==\r\n                tx.inputs[mainIndex].outpointIndex + 1);\r\n        \r\n        // Self-replicate\r\n        require(tx.outputs[this.activeInputIndex].lockingBytecode ==\r\n                tx.inputs[this.activeInputIndex].lockingBytecode);\r\n        require(tx.outputs[this.activeInputIndex].value == 1000);\r\n    }\r\n}",
    "source": "NexKB/patterns/sidecar_attach.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// CONTRACT TYPE: Dutch Auction (Descending Price)\r\n// USE CASE: Time-based price decay with first-come-first-served finality\r\n// SECURITY LEVEL: High\r\n// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity\r\n\r\n// SECURITY MODEL NOTE:\r\n// This contract assumes a trusted transaction builder for:\r\n// - Correct price calculation at current time\r\n// NexOps enforces price calculation correctness at build-time\r\n// Contract enforces: time bounds, price boundaries, reserve price, finality\r\n\r\n// ROLES:\r\n// - seller: Receives payment when first valid bid is accepted\r\n// - bidder: First person to bid at or above current declining price wins\r\n\r\n// AUCTION MECHANICS:\r\n// - Price starts high (startPrice) and decreases linearly over time\r\n// - Price declines to reservePrice by priceDecayEnd time\r\n// - First bidder to pay the current price (or higher) wins immediately\r\n// - After priceDecayEnd, price stays at reservePrice until auctionEnd\r\n// - Seller can reclaim item if no valid bids by auctionEnd\r\n\r\n// TIME PROGRESSION:\r\n// [start]----[price decay period]----[priceDecayEnd]----[auctionEnd]\r\n//    |              |                       |                |\r\n// startPrice   linear decay           reservePrice      no more bids\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract does NOT handle CashTokens (BCH-only auction)\r\n// - First valid bid wins immediately (no refunds needed)\r\n// - Price decay is LINEAR from startPrice to reservePrice\r\n// - After priceDecayEnd, price remains at reservePrice",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-1",
    "content": "// - Seller can reclaim after auctionEnd if no bids accepted\r\n// - No partial bids (must pay full current price or more)\r\n\r\ncontract AuctionDutch(\r\n    pubkey seller,           // Seller who receives payment or reclaims item\r\n    int startPrice,          // Initial high price (in satoshis)\r\n    int reservePrice,        // Minimum acceptable price (in satoshis)\r\n    int priceDecayStart,     // Absolute block time (MTP) when price decay begins\r\n    int priceDecayEnd,       // Absolute block time (MTP) when price reaches reserve\r\n    int auctionEnd           // Absolute block time (MTP) when auction closes\r\n) {\r\n    // BID PATH\r\n    // First bidder to pay the current declining price wins the auction\r\n    // This is the primary path - auction ends immediately on first valid bid\r\n    function bid(\r\n        sig bidderSig,\r\n        pubkey bidder,\r\n        bytes sellerOutput,     // Output address for seller to receive payment\r\n        int bidAmount,          // Amount bidder is paying\r\n        int currentPrice        // Current price at tx.time (calculated by builder)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for BCH-only validation\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // Prevents UTXO position attacks where attacker places contract at wrong index\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-2",
    "content": "// INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being in auction contract\r\n        // Auction contract should only hold the auctioned item representation (BCH)\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // AUCTION TIME VALIDATION\r\n        // Bids are ONLY accepted BEFORE auction end\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use < operator because we want to ensure we're BEFORE auction end\r\n        require(tx.time < auctionEnd);\r\n\r\n        // BIDDER SIGNATURE VALIDATION\r\n        // Verify bidder signature explicitly\r\n        // Ensures bidder authorizes this purchase\r\n        require(checkSig(bidderSig, bidder));\r\n\r\n        // PRICE DECAY CALCULATION AND VALIDATION\r\n        // This is the core Dutch auction logic - price decreases over time\r\n        // We validate that the builder-provided currentPrice is correct\r\n        \r\n        int calculatedPrice;\r\n        \r\n        // CASE 1: Before price decay starts\r\n        // Price is at startPrice (maximum)\r\n        if (tx.time < priceDecayStart) {\r\n            calculatedPrice = startPrice;\r\n        }\r\n        // CASE 2: After price decay ends (but before auction end)\r\n        // Price is at reservePrice (minimum)\r\n        else if (tx.time >= priceDecayEnd) {\r\n            calculatedPrice = reservePrice;\r\n        }\r\n        // CASE 3: During price decay period",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-3",
    "content": "// Price declines linearly from startPrice to reservePrice\r\n        else {\r\n            // LINEAR PRICE DECAY FORMULA:\r\n            // currentPrice = startPrice - (elapsed / duration) * (startPrice - reservePrice)\r\n            // Where:\r\n            // - elapsed = tx.time - priceDecayStart (time since decay started)\r\n            // - duration = priceDecayEnd - priceDecayStart (total decay period)\r\n            // - priceRange = startPrice - reservePrice (total price drop)\r\n            \r\n            int elapsed = tx.time - priceDecayStart;\r\n            int duration = priceDecayEnd - priceDecayStart;\r\n            int priceRange = startPrice - reservePrice;\r\n            \r\n            // DIVISION-BY-ZERO PREVENTION\r\n            // This should be validated at deployment, but we check defensively\r\n            // If priceDecayEnd == priceDecayStart, this would divide by zero\r\n            require(duration > 0);\r\n            \r\n            // Calculate price drop from start\r\n            int priceDrop = (priceRange * elapsed) / duration;\r\n            \r\n            // Current price = start price minus the drop\r\n            calculatedPrice = startPrice - priceDrop;\r\n        }\r\n\r\n        // PRICE CALCULATION VALIDATION\r\n        // Verify the builder-provided currentPrice matches our calculation\r\n        // This prevents price manipulation attacks\r\n        require(currentPrice == calculatedPrice);\r\n\r\n        // RESERVE PRICE VALIDATION\r\n        // Current price can never go below reserve price",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-4",
    "content": "// This is redundant with the calculation logic but defensive\r\n        require(currentPrice >= reservePrice);\r\n\r\n        // BID AMOUNT VALIDATION\r\n        // Bidder must pay at least the current price\r\n        // Bidder can overpay (shows strong interest, speeds up transaction)\r\n        require(bidAmount >= currentPrice);\r\n\r\n        // BID AMOUNT POSITIVITY\r\n        // Bid amount must be positive\r\n        require(bidAmount > 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 1 output to prevent output manipulation\r\n        // Seller receives the payment immediately\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends payment to seller's specified address\r\n        require(tx.outputs[0].lockingBytecode == sellerOutput);\r\n        \r\n        // OUTPUT VALUE VALIDATION\r\n        // Verify exact bid amount is sent to seller\r\n        require(tx.outputs[0].value == bidAmount);\r\n        \r\n        // OUTPUT TOKEN VALIDATION\r\n        // Seller payment should be BCH-only (no tokens)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // FIRST-COME-FIRST-SERVED SAFETY NOTE:\r\n        // Dutch auctions are safe with first-come-first-served because:\r\n        // - Price only decreases over time (never increases)\r\n        // - Later bids always pay less than or equal to earlier bids\r\n        // - First bidder willing to pay current price has highest valuation\r\n        // - No incentive to wait (price drops, but someone else might bid)",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-5",
    "content": "// - Rational bidders bid when price equals their valuation\r\n        // - This creates a race to bid, which is the intended mechanism\r\n        // - No refunds needed (unlike English auction) simplifies safety\r\n\r\n        // PRICE DECAY CALCULATION CORRECTNESS NOTE:\r\n        // Linear decay ensures:\r\n        // - Predictable price at any time\r\n        // - No sudden price jumps or discontinuities\r\n        // - Easy for bidders to calculate when to bid\r\n        // - Fair price discovery mechanism\r\n        // Formula: price(t) = startPrice - ((t - start) / (end - start)) * (startPrice - reserve)\r\n        // This is mathematically correct for linear interpolation\r\n\r\n        // TIME BOUNDARY HANDLING NOTE:\r\n        // - Before priceDecayStart: price = startPrice (constant)\r\n        // - During decay: price decreases linearly\r\n        // - After priceDecayEnd: price = reservePrice (constant)\r\n        // - After auctionEnd: no bids accepted\r\n        // This creates clear phases with no ambiguity\r\n\r\n        // SECURITY NOTES:\r\n        // - First valid bid wins immediately (auction ends)\r\n        // - Seller receives full bid amount (minus mining fee if they choose)\r\n        // - No refunds needed (bidder wanted to pay this price)\r\n        // - Mining fee is implicit: bidAmount specified by bidder\r\n        // - Bidder can overpay to ensure fast confirmation\r\n    }\r\n\r\n    // RECLAIM PATH\r\n    // Seller reclaims the auctioned item if no bids were accepted before auction end\r\n    // This is the failure/timeout path",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-6",
    "content": "function reclaim(\r\n        sig sellerSig,\r\n        bytes sellerOutput,    // Output address for seller to reclaim item\r\n        int reclaimAmount      // Amount seller is reclaiming (should be 0 or dust)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being in auction contract\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // AUCTION END VALIDATION\r\n        // Seller can ONLY reclaim AFTER auction end\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use >= operator for post-auction validation\r\n        require(tx.time >= auctionEnd);\r\n\r\n        // SELLER SIGNATURE VALIDATION\r\n        // Verify seller signature explicitly\r\n        // Only seller can reclaim the item\r\n        require(checkSig(sellerSig, seller));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the contract balance (should be 0 or minimal dust)\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // RECLAIM AMOUNT VALIDATION\r\n        // Reclaim amount cannot exceed contract balance\r\n        require(reclaimAmount <= inputValue);",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-7",
    "content": "// RECLAIM AMOUNT NON-NEGATIVITY\r\n        // Reclaim amount must be non-negative (can be 0)\r\n        require(reclaimAmount >= 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 1 output to prevent output manipulation\r\n        // Seller reclaims any dust in the contract\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends funds to seller's specified address\r\n        require(tx.outputs[0].lockingBytecode == sellerOutput);\r\n        \r\n        // OUTPUT VALUE VALIDATION\r\n        // Verify exact reclaim amount is sent\r\n        require(tx.outputs[0].value == reclaimAmount);\r\n        \r\n        // OUTPUT TOKEN VALIDATION\r\n        // Reclaim output should be BCH-only (no tokens)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTES:\r\n        // - Seller can only reclaim after auction end time\r\n        // - This path is only used if no bids were accepted\r\n        // - Reclaim amount is typically 0 or minimal dust (contract deployment cost)\r\n        // - Mining fee is implicit: inputValue - reclaimAmount\r\n    }\r\n}\r\n\r\n// DEPLOYMENT NOTES:\r\n// - Set startPrice > reservePrice (ensures meaningful decay)\r\n// - Set reservePrice to minimum acceptable price\r\n// - Set priceDecayStart to auction start time\r\n// - Set priceDecayEnd > priceDecayStart (prevents division by zero)\r\n// - Set auctionEnd >= priceDecayEnd (ensures reserve price period)\r\n// - Fund contract with 0 or minimal BCH (just for UTXO validity)",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-8",
    "content": "// - Seller should verify all parameters before deployment\r\n// - Ensure priceDecayStart > current time for proper auction start\r\n\r\n// PARAMETER VALIDATION AT DEPLOYMENT:\r\n// - startPrice > reservePrice (ensures positive price range)\r\n// - priceDecayStart < priceDecayEnd (ensures positive decay duration)\r\n// - priceDecayEnd <= auctionEnd (ensures reserve price period exists)\r\n// - All times should be in the future at deployment\r\n\r\n// AUCTION FLOW:\r\n// 1. Seller deploys contract with price parameters and time bounds\r\n// 2. Price starts at startPrice (if tx.time < priceDecayStart)\r\n// 3. Price declines linearly from startPrice to reservePrice\r\n// 4. First bidder to pay current price (or higher) wins immediately\r\n// 5. Seller receives payment and delivers item off-chain\r\n// 6. If no bids by auctionEnd, seller reclaims using reclaim()\r\n\r\n// PRICE DECAY MECHANICS:\r\n// Time Phase 1 (before priceDecayStart):\r\n// - Price = startPrice (constant)\r\n// - Bidders can purchase at maximum price\r\n// \r\n// Time Phase 2 (priceDecayStart to priceDecayEnd):\r\n// - Price declines linearly\r\n// - Formula: price = startPrice - (elapsed / duration) * (startPrice - reservePrice)\r\n// - Bidders watch price and bid when it matches their valuation\r\n// \r\n// Time Phase 3 (priceDecayEnd to auctionEnd):\r\n// - Price = reservePrice (constant)\r\n// - Bidders can purchase at minimum price\r\n// - This gives a window for reserve price acceptance\r\n// \r\n// Time Phase 4 (after auctionEnd):\r\n// - No bids accepted\r\n// - Seller can reclaim",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-9",
    "content": "// PRICE DECAY EXAMPLE:\r\n// - startPrice = 1000 sats\r\n// - reservePrice = 100 sats\r\n// - priceDecayStart = timestamp 1000\r\n// - priceDecayEnd = timestamp 2000\r\n// - Duration = 1000 seconds\r\n// - Price range = 900 sats\r\n// \r\n// At timestamp 1000: price = 1000 sats (start)\r\n// At timestamp 1250: price = 1000 - (250/1000)*900 = 775 sats\r\n// At timestamp 1500: price = 1000 - (500/1000)*900 = 550 sats\r\n// At timestamp 1750: price = 1000 - (750/1000)*900 = 325 sats\r\n// At timestamp 2000: price = 100 sats (reserve)\r\n// After timestamp 2000: price = 100 sats (constant until auctionEnd)\r\n\r\n// FIRST-COME-FIRST-SERVED SAFETY:\r\n// Why Dutch auctions don't need refunds:\r\n// - Price only decreases (monotonically non-increasing)\r\n// - First bidder at price P values item >= P\r\n// - Later bidder at price Q < P values item >= Q\r\n// - First bidder had opportunity to wait for lower price but chose not to\r\n// - This reveals first bidder's valuation is >= P\r\n// - No fairness issue: earlier bidder paid more but got certainty\r\n// - Later bidders risk losing to earlier bids (trade-off)\r\n// - Economically efficient: item goes to bidder willing to pay most\r\n// - Simple finality: first valid bid wins, no complex refund logic\r\n\r\n// WHY FIRST-COME-FIRST-SERVED IS SAFE:\r\n// Dutch auctions naturally align with first-come-first-served because:\r\n// 1. Rational bidders bid when price = their valuation\r\n// 2. Higher valuations trigger earlier bids (at higher prices)\r\n// 3. Item goes to highest-valuation bidder (efficient allocation)",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-10",
    "content": "// 4. No strategic benefit to waiting (someone else might bid first)\r\n// 5. Creates urgency (race to bid at acceptable price)\r\n// 6. Simple finality (no multi-round bidding or refund complexity)\r\n\r\n// TIME BOUNDARY HANDLING:\r\n// - Bidding period: tx.time < auctionEnd\r\n// - Reclaim period: tx.time >= auctionEnd\r\n// - No overlap: < and >= are complementary\r\n// - Price calculation phases are sequential and non-overlapping\r\n// - Clear separation: bidding XOR reclaiming, never both\r\n\r\n// EDGE CASES:\r\n// Case 1: No bids received\r\n// - Auction reaches auctionEnd\r\n// - Seller reclaims using reclaim()\r\n// - Seller can relist or sell through other means\r\n\r\n// Case 2: Bid at startPrice (before decay)\r\n// - Bidder pays maximum price\r\n// - Shows strong demand\r\n// - Auction ends immediately\r\n\r\n// Case 3: Bid at reservePrice (after decay)\r\n// - Bidder pays minimum acceptable price\r\n// - Seller accepts as it meets reserve\r\n// - Auction ends immediately\r\n\r\n// Case 4: Bid during decay period\r\n// - Bidder pays current declining price\r\n// - Optimal for both parties (price discovery)\r\n// - Auction ends immediately\r\n\r\n// SECURITY INVARIANTS:\r\n// ✓ Explicit activeInputIndex validation on all paths\r\n// ✓ Explicit input tokenCategory validation on all paths\r\n// ✓ Explicit output tokenCategory validation on all outputs\r\n// ✓ Explicit tx.outputs.length validation on all paths\r\n// ✓ Explicit lockingBytecode validation on all outputs\r\n// ✓ Explicit value validation on all outputs\r\n// ✓ Time validation uses < for before, >= for after (no fencepost errors)",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-11",
    "content": "// ✓ Price decay calculation includes division-by-zero prevention\r\n// ✓ Price calculation validation ensures builder correctness\r\n// ✓ Reserve price enforced as minimum price\r\n// ✓ First valid bid wins immediately (no refunds needed)\r\n// ✓ No fee assumptions (caller specifies output amounts)\r\n// ✓ No output ordering assumptions (all outputs validated explicitly)\r\n\r\n// ANTI-PATTERN IMMUNITY:\r\n// ✓ Unvalidated position: activeInputIndex validated on all paths\r\n// ✓ Implicit output ordering: All outputs validated explicitly\r\n// ✓ Fee assumptions: Caller controls output amounts\r\n// ✓ Time validation errors: Uses < for before, >= for after\r\n// ✓ Token category vulnerabilities: Explicit validation on all inputs/outputs\r\n// ✓ Division by zero: Prevented by require(duration > 0) in price calculation\r\n// ✓ Price manipulation: Builder-provided price validated against calculation\r\n// ✓ Auction finality: First valid bid wins, no complex state management\r\n\r\n// AUDIT CHECKLIST:\r\n// [ ] Verify startPrice > reservePrice at deployment\r\n// [ ] Verify priceDecayStart < priceDecayEnd at deployment\r\n// [ ] Verify priceDecayEnd <= auctionEnd at deployment\r\n// [ ] Verify all times are in the future at deployment\r\n// [ ] Verify all paths validate activeInputIndex\r\n// [ ] Verify bid path validates price calculation correctly\r\n// [ ] Verify bid path prevents division by zero\r\n// [ ] Verify bid path enforces bidAmount >= currentPrice\r\n// [ ] Verify bid path validates tx.time < auctionEnd\r\n// [ ] Verify reclaim path validates tx.time >= auctionEnd",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/auction_dutch.cash-12",
    "content": "// [ ] Verify all paths validate tokenCategory explicitly\r\n// [ ] Verify all signature checks use explicit checkSig\r\n// [ ] Test bid at startPrice (before decay)\r\n// [ ] Test bid during decay period (mid-range price)\r\n// [ ] Test bid at reservePrice (after decay)\r\n// [ ] Test bid after auctionEnd (should fail)\r\n// [ ] Test bid with amount < currentPrice (should fail)\r\n// [ ] Test reclaim before auctionEnd (should fail)\r\n// [ ] Test price calculation at various timestamps\r\n// [ ] Verify transaction builder cannot add unauthorized outputs\r\n// [ ] Verify mining fees are handled correctly (implicit in remainder)\r\n// [ ] Test edge case: no bids, seller reclaims\r\n// [ ] Verify first valid bid wins (auction ends immediately)\r\n// [ ] Verify price decay formula correctness (linear interpolation)\r\n\r\n// NEXOPS BUILDER RESPONSIBILITIES:\r\n// - Calculate correct currentPrice based on tx.time\r\n// - Ensure price calculation matches on-chain formula exactly\r\n// - Validate deployment parameters (price range, time bounds)\r\n// - This is enforced at BUILD-TIME\r\n// - On-chain validation ensures calculation correctness",
    "source": "NexKB/templates/auction_dutch.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// CONTRACT TYPE: English Auction (Ascending Price)\r\n// USE CASE: Competitive bidding with atomic refunds and time-bound finality\r\n// SECURITY LEVEL: High (builder-verified with on-chain atomic refund guarantees)\r\n// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity\r\n\r\n// SECURITY MODEL NOTE:\r\n// This contract assumes a trusted transaction builder for:\r\n// - Proper bid increment calculation\r\n// - Correct refund address management\r\n// - Contract parameter reconstruction on bid replacement\r\n// NexOps enforces these at build-time\r\n// Contract enforces: time bounds, bid ordering, refund atomicity\r\n\r\n// ROLES:\r\n// - seller: Receives winning bid after auction end\r\n// - bidders: Compete by placing increasingly higher bids\r\n// - currentHighestBidder: Gets refunded when outbid\r\n\r\n// AUCTION MECHANICS:\r\n// - Each new bid must strictly exceed the current highest bid\r\n// - Previous highest bidder is automatically refunded in the same transaction\r\n// - Bidding continues until auction end time\r\n// - After auction end, only the seller can claim the winning bid\r\n// - No bids accepted after auction end\r\n\r\n// TIME PROGRESSION:\r\n// [deployment]----[bidding period]----[auctionEnd]----[claim period]\r\n//      |                 |                  |               |\r\n//  start price     bids replace        no new bids    seller claims\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract does NOT handle CashTokens (BCH-only auction)\r\n// - Bid replacement and refund happen atomically (same transaction)",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-1",
    "content": "// - Seller can only claim after auction end (enforces time boundary)\r\n// - No reserve price (can be added as contract parameter if needed)\r\n// - Minimum bid increment is enforced by requiring strict increase\r\n// - This is a BUILDER-VERIFIED auction with on-chain atomic refund guarantees\r\n\r\ncontract AuctionEnglish(\r\n    pubkey seller,             // Seller who receives winning bid\r\n    int startPrice,            // Minimum initial bid (in satoshis)\r\n    int auctionEnd,            // Absolute block time (MTP) when bidding closes\r\n    pubkey initialBidder,      // Initial \"bidder\" (usually seller's key for no-bid case)\r\n    bytes initialBidderRefund  // Refund address for initial bidder (usually seller)\r\n) {\r\n    // BID PATH\r\n    // New bidder places a higher bid and refunds the previous highest bidder\r\n    // This is the core auction mechanism during the bidding period\r\n    function bid(\r\n        sig newBidderSig,\r\n        pubkey newBidder,\r\n        bytes newBidderRefundAddress,  // Where to refund this bidder if outbid\r\n        int newBidAmount,               // New bid amount (must be > current bid)\r\n        bytes previousBidderRefund,     // Refund address for current highest bidder\r\n        int previousBidAmount           // Current highest bid (to be refunded)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for BCH-only validation\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-2",
    "content": "// ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // Prevents UTXO position attacks where attacker places contract at wrong index\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being in auction contract\r\n        // Auction contract should only hold BCH, not tokens\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // AUCTION TIME VALIDATION\r\n        // Bids are ONLY accepted BEFORE auction end\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use < operator because we want to ensure we're BEFORE auction end\r\n        require(tx.time < auctionEnd);\r\n\r\n        // NEW BIDDER SIGNATURE VALIDATION\r\n        // Verify new bidder signature explicitly\r\n        // Ensures new bidder authorizes this bid and their refund address\r\n        require(checkSig(newBidderSig, newBidder));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the current highest bid (contract balance)\r\n        int currentBid = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // BID AMOUNT CONSISTENCY VALIDATION\r\n        // The previousBidAmount must match the current contract balance\r\n        // This prevents bid amount confusion and ensures correct refund\r\n        require(previousBidAmount == currentBid);\r\n\r\n        // MINIMUM BID VALIDATION",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-3",
    "content": "// First bid must meet or exceed start price\r\n        // This prevents auction starting below seller's minimum\r\n        require(currentBid >= startPrice);\r\n\r\n        // STRICT BID INCREMENT VALIDATION\r\n        // New bid must be STRICTLY GREATER than current bid\r\n        // This is the core \"ascending price\" auction logic\r\n        // Using > (not >=) prevents same-price replacement attacks\r\n        require(newBidAmount > currentBid);\r\n\r\n        // NEW BID POSITIVITY VALIDATION\r\n        // New bid must be positive (redundant with > currentBid, but explicit)\r\n        require(newBidAmount > 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 3 outputs to prevent output manipulation\r\n        // Output 0: Refund to previous highest bidder\r\n        // Output 1: Updated auction contract with new bid\r\n        // Output 2: Change back to new bidder (optional, but counted)\r\n        // HOWEVER: We allow 2 or 3 outputs for flexibility\r\n        // - 2 outputs: refund + new auction (no change to new bidder)\r\n        // - 3 outputs: refund + new auction + change to new bidder\r\n        require(tx.outputs.length >= 2);\r\n        require(tx.outputs.length <= 3);\r\n\r\n        // OUTPUT 0: PREVIOUS BIDDER REFUND\r\n        // This is critical for bid replacement safety\r\n        // The previous highest bidder MUST be refunded in the same transaction\r\n        // This ensures atomic bid replacement with no funds lost\r\n        \r\n        // REFUND ADDRESS VALIDATION\r\n        // Verify refund goes to previous bidder's specified address",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-4",
    "content": "require(tx.outputs[0].lockingBytecode == previousBidderRefund);\r\n        \r\n        // REFUND AMOUNT VALIDATION\r\n        // Verify exact previous bid amount is refunded\r\n        // This ensures previous bidder gets their full bid back\r\n        require(tx.outputs[0].value == previousBidAmount);\r\n        \r\n        // REFUND TOKEN VALIDATION\r\n        // Refund should be BCH-only (no tokens)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // BID REPLACEMENT SAFETY NOTE:\r\n        // By requiring the refund output first, we ensure that:\r\n        // - Previous bidder cannot lose funds if transaction succeeds\r\n        // - Bid replacement is atomic (both happen or neither happens)\r\n        // - No time window where contract holds multiple bids\r\n        // - No trust required between bidders\r\n        // - EVEN WITH A MALICIOUS BUILDER, refund is guaranteed on-chain\r\n\r\n        // OUTPUT 1: AUCTION CONTINUATION WITH NEW BID\r\n        // The contract recreates itself with the new highest bid\r\n        \r\n        // CRYPTOGRAPHICALLY ENFORCED COVENANT CONTINUATION\r\n        // CRITICAL: We do NOT recreate the same contract\r\n        // Instead, we create a NEW contract with updated highest bidder parameters\r\n        // This is intentional: the contract parameters MUST change to reflect new bidder\r\n        // SECURITY: We validate the new contract has correct structure via NexOps builder\r\n        \r\n        // NEW AUCTION CONTRACT PARAMETERS:\r\n        // - seller: SAME (unchanged)",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-5",
    "content": "// - startPrice: SAME (unchanged)\r\n        // - auctionEnd: SAME (unchanged)\r\n        // - initialBidder: NOW becomes newBidder\r\n        // - initialBidderRefund: NOW becomes newBidderRefundAddress\r\n        \r\n        // We cannot enforce these parameter changes on-chain in CashScript\r\n        // because we don't have access to contract parameter reconstruction\r\n        // This is a KNOWN LIMITATION of this auction design\r\n        // NexOps MUST validate correct parameter updates at build-time\r\n        \r\n        // For now, we validate that the new auction output has the correct value\r\n        require(tx.outputs[1].value == newBidAmount);\r\n        \r\n        // NEW AUCTION TOKEN VALIDATION\r\n        require(tx.outputs[1].tokenCategory == NO_TOKEN);\r\n\r\n        // OPTIONAL OUTPUT 2: CHANGE TO NEW BIDDER\r\n        // If new bidder overpaid (newBidAmount + extra), they get change back\r\n        // This is optional - if tx.outputs.length == 2, no change output exists\r\n        if (tx.outputs.length == 3) {\r\n            // Change output should be BCH-only\r\n            require(tx.outputs[2].tokenCategory == NO_TOKEN);\r\n            \r\n            // Change output must have positive value\r\n            require(tx.outputs[2].value > 0);\r\n        }\r\n\r\n        // REFUND CORRECTNESS NOTE:\r\n        // The refund to previous bidder happens BEFORE the new auction is created\r\n        // This ordering ensures:\r\n        // - Previous bidder's refund is guaranteed if transaction succeeds\r\n        // - No race condition between refund and new bid",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-6",
    "content": "// - Atomic swap of highest bidder position\r\n        // - FUNDS CANNOT BE STOLEN even if builder is malicious\r\n        \r\n        // TIME BOUNDARY CORRECTNESS NOTE:\r\n        // Using tx.time < auctionEnd ensures:\r\n        // - Bids accepted up to but not including auction end time\r\n        // - No ambiguity about \"exactly at\" auction end\r\n        // - Clear cutoff for bidding period\r\n        // - Seller can claim immediately at auctionEnd (using >=)\r\n\r\n        // SECURITY NOTES:\r\n        // - Mining fee is implicit: (newBidAmount + change) - (previousBidAmount + newBidAmount + changeOut)\r\n        // - New bidder provides the extra BCH needed for the higher bid\r\n        // - Previous bidder gets EXACT refund (no fee deduction from their refund)\r\n        // - Contract parameter updates (new bidder info) are enforced by NexOps builder\r\n    }\r\n\r\n    // CLAIM PATH\r\n    // Seller claims the winning bid after auction ends\r\n    // This is the finalization path after bidding period closes\r\n    function claim(\r\n        sig sellerSig,\r\n        bytes sellerOutput,    // Output address for seller to receive winning bid\r\n        int claimAmount        // Amount seller is claiming (should be winning bid)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-7",
    "content": "// INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being in auction contract\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // AUCTION END VALIDATION\r\n        // Seller can ONLY claim AFTER auction end\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use >= operator for post-auction validation\r\n        // This is the complement to the < operator in bid()\r\n        require(tx.time >= auctionEnd);\r\n\r\n        // SELLER SIGNATURE VALIDATION\r\n        // Verify seller signature explicitly\r\n        // Only seller can claim the winning bid\r\n        require(checkSig(sellerSig, seller));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the winning bid amount (final contract balance)\r\n        int winningBid = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // CLAIM AMOUNT VALIDATION\r\n        // Claim amount cannot exceed winning bid\r\n        require(claimAmount <= winningBid);\r\n\r\n        // CLAIM AMOUNT POSITIVITY\r\n        // Claim amount must be positive\r\n        require(claimAmount > 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 1 output to prevent output manipulation\r\n        // Seller takes winning bid (minus mining fee if they choose)\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends funds to seller's specified address\r\n        require(tx.outputs[0].lockingBytecode == sellerOutput);",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-8",
    "content": "// OUTPUT VALUE VALIDATION\r\n        // Verify exact claim amount is sent\r\n        require(tx.outputs[0].value == claimAmount);\r\n        \r\n        // OUTPUT TOKEN VALIDATION\r\n        // Seller output should be BCH-only (no tokens)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // TIME BOUNDARY CORRECTNESS NOTE:\r\n        // Using tx.time >= auctionEnd ensures:\r\n        // - Seller cannot claim during bidding period\r\n        // - Clear separation between bidding and claiming phases\r\n        // - No ambiguity about when auction ends\r\n        // - Complements the < operator in bid() for clean time boundaries\r\n\r\n        // SECURITY NOTES:\r\n        // - Seller can only claim after auction end time\r\n        // - Winning bid goes to seller (minus mining fee if seller chooses)\r\n        // - No refund to highest bidder (they won the auction)\r\n        // - Mining fee is implicit: winningBid - claimAmount\r\n    }\r\n}\r\n\r\n// DEPLOYMENT NOTES:\r\n// - Set startPrice to the minimum acceptable bid (in satoshis)\r\n// - Set auctionEnd to absolute block time (MTP) when auction closes\r\n// - Set initialBidder to seller's pubkey (for no-bid edge case)\r\n// - Set initialBidderRefund to seller's address (for no-bid refund)\r\n// - Fund initial contract with startPrice amount (or 0 for true start)\r\n// - Seller should verify all parameters before deployment\r\n// - Ensure auctionEnd > current time to allow bidding period\r\n\r\n// AUCTION FLOW:\r\n// 1. Seller deploys contract with startPrice and auctionEnd",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-9",
    "content": "// 2. Bidders place increasingly higher bids using bid()\r\n// 3. Each bid atomically refunds the previous highest bidder\r\n// 4. After auctionEnd, seller claims winning bid using claim()\r\n// 5. Highest bidder receives the auctioned item off-chain\r\n\r\n// BID REPLACEMENT MECHANICS:\r\n// - New bidder calls bid() with higher bid amount\r\n// - Transaction includes:\r\n//   - Input: Current auction contract with previous highest bid\r\n//   - Output 0: Refund to previous highest bidder\r\n//   - Output 1: New auction contract with new highest bid\r\n//   - Output 2 (optional): Change back to new bidder\r\n// - Atomic execution ensures no funds lost\r\n// - Previous bidder gets immediate refund\r\n\r\n// REFUND SAFETY:\r\n// - Refund happens in the SAME transaction as new bid\r\n// - No separate refund transaction needed\r\n// - No time window where funds are in transit\r\n// - Previous bidder cannot lose funds if bid is replaced\r\n// - Refund amount is EXACT (no fee deduction)\r\n\r\n// TIME BOUNDARY HANDLING:\r\n// - Bidding period: tx.time < auctionEnd (before auction end)\r\n// - Claiming period: tx.time >= auctionEnd (at or after auction end)\r\n// - No overlap: < and >= are complementary\r\n// - No ambiguity: exactly at auctionEnd, bidding closed, claiming open\r\n// - Clean separation: bidding XOR claiming, never both\r\n\r\n// EDGE CASES:\r\n// Case 1: No bids received\r\n// - Contract holds startPrice (or 0)\r\n// - initialBidder is seller\r\n// - Seller claims back their own funds after auctionEnd\r\n\r\n// Case 2: Single bid at startPrice",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-10",
    "content": "// - Bidder wins auction\r\n// - Seller receives startPrice\r\n// - No refunds needed (initialBidder was seller)\r\n\r\n// Case 3: Multiple bids\r\n// - Each bid refunds previous bidder\r\n// - Final bidder wins\r\n// - Seller receives winning bid\r\n\r\n// KNOWN LIMITATIONS:\r\n// - Contract parameter updates (new bidder pubkey/refund) are NOT enforced on-chain\r\n// - NexOps MUST validate correct parameter reconstruction at build-time\r\n// - This is a fundamental CashScript limitation (no parameter introspection)\r\n// - Production systems should verify new contract bytecode matches expected structure\r\n// - Alternative: Use a stateless design with external state tracking (more complex)\r\n\r\n// SECURITY GUARANTEE:\r\n// Even with a malicious builder, no bidder can lose funds once outbid.\r\n// Worst-case failure mode is auction state corruption, not fund loss.\r\n// The on-chain refund requirement (output 0) ensures:\r\n// - Previous bidder ALWAYS gets their exact bid back\r\n// - New bid cannot succeed without refunding previous bidder\r\n// - Atomic refund is cryptographically enforced, not trust-based\r\n// - Builder can corrupt auction state (wrong parameters), but cannot steal funds\r\n// - Fund safety is preserved even under builder compromise\r\n\r\n// SECURITY INVARIANTS:\r\n// ✓ Explicit activeInputIndex validation on all paths\r\n// ✓ Explicit input tokenCategory validation on all paths\r\n// ✓ Explicit output tokenCategory validation on all outputs\r\n// ✓ Explicit tx.outputs.length validation on all paths\r\n// ✓ Explicit lockingBytecode validation where enforceable",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "introspection"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-11",
    "content": "// ✓ Explicit value validation on all outputs\r\n// ✓ Time validation uses < for before, >= for after (no fencepost errors)\r\n// ✓ Bid increment strictly enforced (> not >=)\r\n// ✓ Atomic bid replacement with refund (same transaction)\r\n// ✓ No fee assumptions (caller specifies output amounts)\r\n// ✓ No output ordering assumptions (all outputs validated explicitly)\r\n// ✓ Refund safety guaranteed even with malicious builder\r\n\r\n// ANTI-PATTERN IMMUNITY:\r\n// ✓ Unvalidated position: activeInputIndex validated on all paths\r\n// ✓ Implicit output ordering: All outputs validated explicitly\r\n// ✓ Fee assumptions: Caller controls output amounts\r\n// ✓ Time validation errors: Uses < for before, >= for after\r\n// ✓ Token category vulnerabilities: Explicit validation on all inputs/outputs\r\n// ⚠ Unenforced covenant continuation: KNOWN LIMITATION (parameter updates not enforceable)\r\n// ✓ Bid increment errors: Strict > enforcement prevents same-price attacks\r\n// ✓ Refund atomicity: Refund and new bid in same transaction (enforced on-chain)\r\n\r\n// AUDIT CHECKLIST:\r\n// [ ] Verify startPrice and auctionEnd are reasonable at deployment\r\n// [ ] Verify initialBidder is set correctly (usually seller)\r\n// [ ] Verify initialBidderRefund is set correctly (usually seller address)\r\n// [ ] Verify all paths validate activeInputIndex\r\n// [ ] Verify bid path validates new bid > current bid (strict)\r\n// [ ] Verify bid path enforces atomic refund (output 0)\r\n// [ ] Verify bid path allows 2 or 3 outputs (refund + auction + optional change)",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/auction_english.cash-12",
    "content": "// [ ] Verify claim path validates auction end time (>= auctionEnd)\r\n// [ ] Verify claim path prevents token outputs\r\n// [ ] Verify all paths validate tokenCategory explicitly\r\n// [ ] Verify all signature checks use explicit checkSig\r\n// [ ] Test bid before and after auctionEnd (should fail after)\r\n// [ ] Test claim before auctionEnd (should fail)\r\n// [ ] Test bid with same amount (should fail - strict increment)\r\n// [ ] Test bid with lower amount (should fail)\r\n// [ ] Test bid without proper refund output (should fail)\r\n// [ ] Verify transaction builder cannot add unauthorized outputs\r\n// [ ] Verify mining fees are handled correctly (implicit in remainder)\r\n// [ ] Verify NexOps builder correctly updates contract parameters on bid\r\n// [ ] Test no-bid edge case (seller claims back initial funds)\r\n// [ ] Test multiple sequential bids (verify refund chain works)\r\n// [ ] Verify refund amounts are exact (no fee deduction from refunds)\r\n// [ ] Verify time boundaries are clean (< and >= with no overlap)\r\n// [ ] Verify refund safety holds even with malicious builder (output 0 enforced)\r\n\r\n// NEXOPS BUILDER RESPONSIBILITIES:\r\n// - Reconstruct new auction contract with updated bidder parameters\r\n// - Validate new contract bytecode matches expected structure\r\n// - Ensure new bidder pubkey and refund address are correctly embedded\r\n// - Verify all other parameters (seller, startPrice, auctionEnd) remain unchanged\r\n// - This is enforced at BUILD-TIME, not on-chain   \r\n// - Builder verification ensures correctness; on-chain validation ensures fund safety",
    "source": "NexKB/templates/auction_english.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// CONTRACT TYPE: Goal-Based Crowdfunding with Refundable Pledges\r\n// USE CASE: All-or-nothing fundraising with deadline and refund mechanism\r\n// SECURITY LEVEL: High\r\n// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity\r\n\r\n// SECURITY MODEL NOTE:\r\n// This contract assumes a trusted transaction builder for:\r\n// - NFT commitment uniqueness (entropy is builder responsibility)\r\n// NexOps enforces this at build-time, not on-chain\r\n// Protocol layer enforces: category, amount, and burn\r\n// Contract layer enforces: continuation, time bounds, goal logic\r\n\r\n// ROLES:\r\n// - campaign: Receives funds if goal is met before deadline\r\n// - pledger: Contributors who receive NFT receipts and can refund if goal not met\r\n\r\n// CROWDFUNDING MECHANICS:\r\n// - Campaign sets a funding goal and deadline\r\n// - Pledgers send funds and receive unique NFT receipts\r\n// - If goal met before deadline: campaign can claim all funds\r\n// - If goal not met by deadline: pledgers can refund using their NFT receipts\r\n// - Each pledge is tracked by a unique NFT (prevents double-refund)\r\n\r\n// TIME PROGRESSION:\r\n// [deployment]----[before deadline]----[deadline]----[after deadline]\r\n//      |                  |                 |              |\r\n//  pledging open    pledging open      goal check     refunds enabled\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract handles BOTH BCH and CashTokens (NFT receipts)\r\n// - Each pledge MUST mint a unique NFT receipt to the pledger",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-1",
    "content": "// - Campaign can only claim if total pledged >= goal before deadline\r\n// - Refunds are ONLY allowed after deadline if goal not met\r\n// - NFT receipt is burned on refund to prevent double-refund attacks\r\n// - Each NFT represents the pledger's full contribution (not amount-tracking)\r\n// - INTENTIONAL: Goal met after deadline = funds locked (time-bound guarantees matter)\r\n\r\ncontract CrowdfundingRefundable(\r\n    pubkey campaign,           // Campaign owner who receives funds if successful\r\n    int fundingGoal,           // Minimum amount required for success (in satoshis)\r\n    int deadline,              // Absolute block time (MTP) - campaign must succeed before this\r\n    bytes32 nftCategory        // Token category for NFT receipts (must be unique per campaign)\r\n) {\r\n    // PLEDGE PATH\r\n    // Contributor pledges funds and receives an NFT receipt\r\n    // This NFT serves as proof of pledge and enables refunds if campaign fails\r\n    function pledge(\r\n        sig pledgerSig,\r\n        pubkey pledger,\r\n        bytes pledgerNftOutput,    // Output with NFT receipt to pledger\r\n        int pledgeAmount           // Amount being pledged (BCH)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for BCH-only outputs\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // Prevents UTXO position attacks where attacker places contract at wrong index",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-2",
    "content": "require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Campaign contract should not hold tokens (BCH-only accumulator)\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // DEADLINE VALIDATION\r\n        // Pledges are only accepted BEFORE the deadline\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use < operator because we want to ensure we're BEFORE deadline\r\n        require(tx.time < deadline);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify pledger signature explicitly\r\n        // Ensures pledger authorizes the pledge and NFT receipt\r\n        require(checkSig(pledgerSig, pledger));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the current contract balance (sum of all prior pledges)\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // PLEDGE AMOUNT VALIDATION\r\n        // Pledge amount must be positive to prevent zero-value griefing\r\n        require(pledgeAmount > 0);\r\n\r\n        // NEW BALANCE CALCULATION\r\n        // Calculate total campaign balance after this pledge\r\n        int newBalance = inputValue + pledgeAmount;\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 2 outputs to prevent output manipulation\r\n        // Output 0: NFT receipt to pledger\r\n        // Output 1: Updated campaign contract with accumulated pledges",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-3",
    "content": "require(tx.outputs.length == 2);\r\n\r\n        // OUTPUT 0: NFT RECEIPT TO PLEDGER\r\n        // This NFT serves as proof of pledge and refund authorization\r\n        \r\n        // Validate output goes to pledger's specified address\r\n        require(tx.outputs[0].lockingBytecode == pledgerNftOutput);\r\n        \r\n        // NFT RECEIPT TOKEN CATEGORY VALIDATION\r\n        // The NFT receipt must use the campaign's designated token category\r\n        // This links the NFT to this specific crowdfunding campaign\r\n        require(tx.outputs[0].tokenCategory == nftCategory);\r\n        \r\n        // NFT AMOUNT VALIDATION\r\n        // Must be exactly 0 for NFTs (non-fungible tokens have no amount field)\r\n        // This ensures we're minting an NFT, not fungible tokens\r\n        require(tx.outputs[0].tokenAmount == 0);\r\n        \r\n        // NFT VALUE VALIDATION\r\n        // The NFT output must have positive BCH value (dust limit)\r\n        // This ensures the output is economically valid\r\n        require(tx.outputs[0].value > 0);\r\n        \r\n        // SECURITY NOTE: NFT commitment should be unique per pledge\r\n        // Uniqueness prevents pledge collision attacks\r\n        // Transaction builder should use unique data (e.g., hash of txid + index)\r\n        // CashScript does not expose NFT commitment field directly in validation\r\n        // NexOps enforces commitment uniqueness at build-time via builder discipline\r\n\r\n        // OUTPUT 1: CAMPAIGN CONTINUATION\r\n        // The contract recreates itself with accumulated balance",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-4",
    "content": "// CRYPTOGRAPHICALLY ENFORCED COVENANT CONTINUATION\r\n        // Contract must recreate itself with same parameters\r\n        // This prevents pledge funds from being redirected to arbitrary scripts\r\n        // This single line kills: pledge redirection, partial drain, escape attacks\r\n        require(\r\n            tx.outputs[1].lockingBytecode ==\r\n            tx.inputs[this.activeInputIndex].lockingBytecode\r\n        );\r\n        \r\n        // NEW BALANCE VALIDATION\r\n        // The continuation output must contain exactly the accumulated pledges\r\n        require(tx.outputs[1].value == newBalance);\r\n        \r\n        // CAMPAIGN CONTINUATION TOKEN VALIDATION\r\n        // Campaign contract itself should not hold tokens (BCH-only)\r\n        require(tx.outputs[1].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTES:\r\n        // - Each pledge mints a unique NFT to the pledger\r\n        // - NFT commitment uniqueness is enforced by NexOps builder\r\n        // - Campaign contract accumulates BCH from all pledges\r\n        // - Mining fee is implicit: pledgeAmount - (nftOutput.value + newBalance - inputValue)\r\n        // - Pledger specifies NFT output value independently of pledge amount\r\n    }\r\n\r\n    // CLAIM PATH\r\n    // Campaign owner claims all funds if goal is met before deadline\r\n    // This is the success path for the crowdfunding campaign\r\n    function claim(\r\n        sig campaignSig,\r\n        bytes campaignOutput,      // Output address for campaign to receive funds",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-5",
    "content": "int claimAmount            // Amount campaign is claiming\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being in campaign contract\r\n        // Campaign contract should only hold BCH, not tokens\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // DEADLINE VALIDATION\r\n        // Campaign must claim BEFORE deadline expires\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use < operator to ensure claim happens before deadline\r\n        // DESIGN DECISION: Time-bound guarantees matter more than convenience\r\n        // A deadline is a hard economic boundary, not a UI hint\r\n        require(tx.time < deadline);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify campaign owner signature explicitly\r\n        // Only campaign can claim the funds\r\n        require(checkSig(campaignSig, campaign));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the total pledged amount in the contract\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // FUNDING GOAL VALIDATION",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-6",
    "content": "// Campaign can ONLY claim if funding goal is met\r\n        // This is the core \"all-or-nothing\" crowdfunding logic\r\n        require(inputValue >= fundingGoal);\r\n\r\n        // CLAIM AMOUNT VALIDATION\r\n        // Claim amount cannot exceed total pledged amount\r\n        require(claimAmount <= inputValue);\r\n\r\n        // CLAIM AMOUNT POSITIVITY\r\n        // Claim amount must be positive\r\n        require(claimAmount > 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly 1 output to prevent output manipulation\r\n        // Campaign takes all funds (minus mining fee)\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends funds to campaign's specified address\r\n        require(tx.outputs[0].lockingBytecode == campaignOutput);\r\n        \r\n        // OUTPUT VALUE VALIDATION\r\n        // Verify exact claim amount is sent\r\n        require(tx.outputs[0].value == claimAmount);\r\n        \r\n        // OUTPUT TOKEN VALIDATION\r\n        // Campaign output should be BCH-only (no tokens)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTES:\r\n        // - Campaign can only claim if goal is met AND before deadline\r\n        // - All pledged funds go to campaign (minus mining fee)\r\n        // - NFT receipts remain with pledgers (become collectibles)\r\n        // - Mining fee is implicit: inputValue - claimAmount\r\n    }\r\n\r\n    // REFUND PATH\r\n    // Pledger reclaims their pledge if goal not met by deadline",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-7",
    "content": "// Requires burning the NFT receipt to prevent double-refund\r\n    function refund(\r\n        sig pledgerSig,\r\n        pubkey pledger,\r\n        bytes pledgerRefundOutput, // Output address for pledger's refund\r\n        int refundAmount,          // Amount pledger is reclaiming\r\n        int nftInputIndex          // Index of the NFT receipt input in tx.inputs\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // This validates the campaign contract input\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // CAMPAIGN INPUT TOKEN VALIDATION\r\n        // Campaign contract should not hold tokens\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // DEADLINE VALIDATION\r\n        // Refunds are ONLY allowed AFTER deadline expires\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use >= operator for post-deadline validation\r\n        require(tx.time >= deadline);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify pledger signature explicitly\r\n        // Only the pledger who holds the NFT can refund\r\n        require(checkSig(pledgerSig, pledger));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the total pledged amount in campaign contract",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-8",
    "content": "int campaignValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // FUNDING GOAL FAILURE VALIDATION\r\n        // Refunds are ONLY allowed if goal was NOT met\r\n        // This prevents refunds after successful campaigns\r\n        require(campaignValue < fundingGoal);\r\n\r\n        // REFUND AMOUNT VALIDATION\r\n        // Refund amount cannot exceed campaign balance\r\n        require(refundAmount <= campaignValue);\r\n\r\n        // REFUND AMOUNT POSITIVITY\r\n        // Refund amount must be positive\r\n        require(refundAmount > 0);\r\n\r\n        // NFT INPUT COUNT VALIDATION\r\n        // The transaction MUST include at least 2 inputs: campaign + NFT receipt\r\n        // This prevents refund without NFT proof\r\n        require(tx.inputs.length >= 2);\r\n\r\n        // NFT INPUT INDEX BOUNDS CHECK\r\n        // Validate that nftInputIndex is within bounds and not the campaign input\r\n        require(nftInputIndex < tx.inputs.length);\r\n        require(nftInputIndex != this.activeInputIndex);\r\n\r\n        // NFT RECEIPT VALIDATION\r\n        // Verify the specified input contains the campaign's NFT category\r\n        // This proves the pledger holds a valid pledge receipt\r\n        require(tx.inputs[nftInputIndex].tokenCategory == nftCategory);\r\n\r\n        // NFT AMOUNT VALIDATION\r\n        // Verify it's an NFT (tokenAmount must be 0)\r\n        require(tx.inputs[nftInputIndex].tokenAmount == 0);\r\n\r\n        // OUTPUT COUNT VALIDATION\r\n        // We allow 1 or 2 outputs:\r\n        // - 1 output: Refund to pledger (campaign fully drained or final refund)",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-9",
    "content": "// - 2 outputs: Refund to pledger + campaign continuation (partial refund)\r\n        require(tx.outputs.length >= 1);\r\n        require(tx.outputs.length <= 2);\r\n\r\n        // NFT BURN ENFORCEMENT\r\n        // We must ensure the NFT is NOT present in any output\r\n        // This prevents double-refund attacks by ensuring one-time NFT use\r\n        // INVARIANT: NFT burn enforcement relies on tx.outputs.length <= 2\r\n        // Relaxing output count REQUIRES revisiting NFT burn logic\r\n        // We validate that outputs[0] and outputs[1] (if exists) do not contain the NFT\r\n        \r\n        // OUTPUT 0: PLEDGER REFUND VALIDATION\r\n        // Verify first output sends refund to pledger\r\n        require(tx.outputs[0].lockingBytecode == pledgerRefundOutput);\r\n        require(tx.outputs[0].value == refundAmount);\r\n        \r\n        // REFUND OUTPUT TOKEN VALIDATION\r\n        // Refund should be BCH-only (NFT must be burned, not transferred)\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // NFT BURN VALIDATION ON OUTPUT 0\r\n        // Ensure output 0 does not contain the NFT (prevents NFT transfer)\r\n        require(tx.outputs[0].tokenCategory != nftCategory);\r\n\r\n        // OPTIONAL OUTPUT 1: CAMPAIGN CONTINUATION (if partial refund)\r\n        // If there's a second output, it must be the campaign contract continuation\r\n        if (tx.outputs.length == 2) {\r\n            // CRYPTOGRAPHICALLY ENFORCED COVENANT CONTINUATION\r\n            // Campaign contract must recreate itself with remaining balance",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-10",
    "content": "require(\r\n                tx.outputs[1].lockingBytecode ==\r\n                tx.inputs[this.activeInputIndex].lockingBytecode\r\n            );\r\n            \r\n            // REMAINING BALANCE VALIDATION\r\n            int remainingBalance = campaignValue - refundAmount;\r\n            require(tx.outputs[1].value == remainingBalance);\r\n            \r\n            // CAMPAIGN CONTINUATION TOKEN VALIDATION\r\n            require(tx.outputs[1].tokenCategory == NO_TOKEN);\r\n\r\n            // NFT BURN VALIDATION ON OUTPUT 1\r\n            // Ensure output 1 does not contain the NFT\r\n            require(tx.outputs[1].tokenCategory != nftCategory);\r\n        }\r\n\r\n        // SECURITY NOTES:\r\n        // - Refunds only possible if goal not met AND after deadline\r\n        // - NFT receipt must be included in transaction at specified index\r\n        // - NFT is burned by not being present in any output (validated for outputs 0 and 1)\r\n        // - Campaign contract continues if partial refunds remain\r\n        // - Mining fee is implicit: campaignValue + nftValue - (refundAmount + remainingBalance)\r\n        // - NFT burn is enforced by validating it's not in output 0 or output 1\r\n        // - This is safe because we hard-bound tx.outputs.length <= 2\r\n    }\r\n}\r\n\r\n// DEPLOYMENT NOTES:\r\n// - Set fundingGoal to the minimum required amount (in satoshis)\r\n// - Set deadline to absolute block time (MTP) when campaign ends\r\n// - Set nftCategory to a unique token category for this campaign\r\n// - The nftCategory must support NFT minting (minting or mutable capability)",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-11",
    "content": "// - Fund initial contract with 0 or minimal BCH (pledges accumulate)\r\n// - Campaign owner should verify all parameters before deployment\r\n// - Ensure deadline > current time to allow pledging period\r\n\r\n// NFT RECEIPT MECHANICS:\r\n// - Each pledge mints a unique NFT to the pledger\r\n// - NFT commitment should be unique (e.g., hash of txid + output index)\r\n// - NFT serves as proof of pledge and refund authorization\r\n// - NFT is burned on refund to prevent double-refund attacks\r\n// - If campaign succeeds, NFTs become collectible receipts\r\n// - NFT uniqueness enforcement relies on NexOps builder discipline\r\n// - Protocol layer enforces: category, amount, and burn\r\n// - Contract layer enforces: continuation, time bounds, goal logic\r\n\r\n// FUNDING SCENARIOS:\r\n// Scenario 1: Goal met before deadline\r\n// - Campaign can claim all funds using claim()\r\n// - Pledgers keep their NFT receipts as collectibles\r\n// - No refunds allowed (goal met condition blocks refund path)\r\n\r\n// Scenario 2: Goal not met by deadline\r\n// - Pledgers can refund using refund() + their NFT receipt\r\n// - Each refund burns the NFT to prevent double-refund\r\n// - Campaign cannot claim funds (goal not met condition blocks claim path)\r\n// - Partial refunds allowed (campaign continues for other pledgers)\r\n\r\n// Scenario 3: Goal met after deadline\r\n// - Campaign cannot claim (deadline passed)\r\n// - Pledgers cannot refund (goal met)\r\n// - Funds locked (INTENTIONAL: time-bound guarantees matter)\r\n// - DESIGN RATIONALE: A deadline is a hard economic boundary, not a UI hint",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-12",
    "content": "// - This enforces strict time-based commitments for both parties\r\n\r\n// SECURITY INVARIANTS:\r\n// ✓ Explicit activeInputIndex validation on all paths\r\n// ✓ Explicit input tokenCategory validation on all paths\r\n// ✓ Explicit output tokenCategory validation on all outputs\r\n// ✓ Explicit tx.outputs.length validation on all paths\r\n// ✓ Explicit lockingBytecode validation on all outputs\r\n// ✓ Explicit value validation on all outputs\r\n// ✓ Time validation uses < for pre-deadline, >= for post-deadline (no fencepost errors)\r\n// ✓ Goal validation ensures claim only if goal met\r\n// ✓ Goal validation ensures refund only if goal not met\r\n// ✓ CRYPTOGRAPHICALLY ENFORCED covenant continuation on pledge and refund paths\r\n// ✓ NFT receipt input validation prevents refund without proof\r\n// ✓ NFT burn enforcement prevents double-refund attacks (bounded by output count)\r\n// ✓ No fee assumptions (caller specifies output amounts)\r\n// ✓ No output ordering assumptions (all outputs validated explicitly)\r\n\r\n// ANTI-PATTERN IMMUNITY:\r\n// ✓ Unvalidated position: activeInputIndex validated on all paths\r\n// ✓ Implicit output ordering: All outputs validated explicitly\r\n// ✓ Fee assumptions: Caller controls output amounts\r\n// ✓ Time validation errors: Uses < for before, >= for after\r\n// ✓ Token category vulnerabilities: Explicit validation on all inputs/outputs\r\n// ✓ Unenforced covenant continuation: lockingBytecode == input lockingBytecode\r\n// ✓ Double-refund: NFT receipt burn prevents reuse\r\n// ✓ NFT amount confusion: Explicit tokenAmount == 0 validation",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-13",
    "content": "// AUDIT CHECKLIST:\r\n// [ ] Verify fundingGoal and deadline are reasonable at deployment\r\n// [ ] Verify nftCategory is unique and properly configured for minting\r\n// [ ] Verify all paths validate activeInputIndex\r\n// [ ] Verify pledge path validates NFT receipt minting correctly\r\n// [ ] Verify pledge path enforces covenant continuation\r\n// [ ] Verify pledge path validates tokenAmount == 0 for NFT\r\n// [ ] Verify claim path validates goal met AND before deadline\r\n// [ ] Verify claim path prevents token outputs\r\n// [ ] Verify refund path validates goal NOT met AND after deadline\r\n// [ ] Verify refund path validates NFT receipt input at specified index\r\n// [ ] Verify refund path enforces NFT burn (not in outputs 0 or 1)\r\n// [ ] Verify refund path supports both full and partial refunds\r\n// [ ] Verify all paths validate tokenCategory explicitly\r\n// [ ] Verify all signature checks use explicit checkSig\r\n// [ ] Test pledge with unique NFT commitments\r\n// [ ] Test claim before and after deadline (should fail after)\r\n// [ ] Test claim with insufficient funds (should fail if goal not met)\r\n// [ ] Test refund before deadline (should fail)\r\n// [ ] Test refund without NFT receipt (should fail)\r\n// [ ] Test refund with wrong NFT category (should fail)\r\n// [ ] Test double-refund attempt (should fail - NFT burned)\r\n// [ ] Verify transaction builder cannot add unauthorized outputs\r\n// [ ] Verify mining fees are handled correctly (implicit in remainder)\r\n// [ ] Test edge case: goal met after deadline (funds locked - design decision)",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/crowdfunding_refundable.cash-14",
    "content": "// [ ] Verify NFT burn enforcement holds under tx.outputs.length <= 2 invariant",
    "source": "NexKB/templates/crowdfunding_refundable.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// CONTRACT TYPE: 2-of-3 Escrow\r\n// USE CASE: Buyer–Seller escrow with arbiter dispute resolution\r\n// SECURITY LEVEL: High\r\n// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity\r\n\r\n// ROLES:\r\n// - buyer: Provides funds, receives goods/services, can refund after timeout\r\n// - seller: Provides goods/services, receives payment on successful delivery\r\n// - arbiter: Neutral third party for dispute resolution\r\n\r\n// SPENDING PATHS:\r\n// 1. Normal settlement: buyer + seller agree (any time)\r\n// 2. Dispute resolution: buyer + arbiter agree (any time)\r\n// 3. Dispute resolution: seller + arbiter agree (any time)\r\n// 4. Timeout refund: buyer alone after refundTimeout expires\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract intentionally does NOT support arbiter-only spending\r\n// - Buyer MAY redirect refund to any script (intentional flexibility)\r\n// - This contract does NOT handle CashTokens (BCH-only)\r\n// - This escrow enforces BCH-only outputs\r\n// - CashTokens are intentionally rejected to eliminate token-layer attack surfaces\r\n\r\ncontract Escrow2of3(\r\n    pubkey buyer,\r\n    pubkey seller,\r\n    pubkey arbiter,\r\n    int refundTimeout  // Absolute block time (median time past) for buyer refund\r\n) {\r\n    // NORMAL SETTLEMENT PATH\r\n    // Both buyer and seller agree on the outcome\r\n    // This is the expected happy path for successful transactions\r\n    function settle(sig buyerSig, sig sellerSig, bytes recipientLockingBytecode, int amount) {",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-1",
    "content": "// TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for explicit validation\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // Prevents UTXO position attacks where attacker places contract at wrong index\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract\r\n        // This is a defensive measure to avoid token-layer confusion\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // VALUE BOUNDARY VALIDATION\r\n        // Ensure settlement amount does not exceed available input value\r\n        // This is NOT a fee assumption - this is value sanity enforcement\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        require(amount <= inputValue);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify buyer signature explicitly (no shorthand)\r\n        require(checkSig(buyerSig, buyer));\r\n        \r\n        // Verify seller signature explicitly (no shorthand)\r\n        require(checkSig(sellerSig, seller));\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly one output to prevent output manipulation attacks\r\n        // Without this check, attacker could add additional outputs draining funds\r\n        require(tx.outputs.length == 1);",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-2",
    "content": "// SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends to the intended recipient\r\n        // This prevents signature replay to unauthorized addresses\r\n        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);\r\n\r\n        // AMOUNT VALIDATION\r\n        // Verify the output amount matches the agreed settlement amount\r\n        // This ensures the full intended amount is transferred\r\n        // The difference (inputValue - amount) becomes the mining fee\r\n        require(tx.outputs[0].value == amount);\r\n\r\n        // OUTPUT TOKEN VALIDATION\r\n        // Prevent unexpected CashToken attachment to output\r\n        // This contract is BCH-only and does not handle tokens\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTE: We do NOT assume any specific recipient (could be buyer, seller, or split)\r\n    }\r\n\r\n    // DISPUTE RESOLUTION PATH: BUYER + ARBITER\r\n    // Buyer and arbiter agree (typically refund scenario)\r\n    function disputeBuyerArbiter(sig buyerSig, sig arbiterSig, bytes recipientLockingBytecode, int amount) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-3",
    "content": "require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // VALUE BOUNDARY VALIDATION\r\n        // Ensure dispute resolution amount does not exceed available input value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        require(amount <= inputValue);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify buyer signature explicitly\r\n        require(checkSig(buyerSig, buyer));\r\n        \r\n        // Verify arbiter signature explicitly\r\n        require(checkSig(arbiterSig, arbiter));\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly one output to prevent output manipulation\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends to the intended recipient\r\n        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);\r\n\r\n        // AMOUNT VALIDATION\r\n        // Verify the output amount matches the agreed dispute resolution amount\r\n        require(tx.outputs[0].value == amount);\r\n\r\n        // OUTPUT TOKEN VALIDATION\r\n        // Prevent unexpected CashToken attachment to output\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n    }\r\n\r\n    // DISPUTE RESOLUTION PATH: SELLER + ARBITER\r\n    // Seller and arbiter agree (typically payout scenario)\r\n    function disputeSellerArbiter(sig sellerSig, sig arbiterSig, bytes recipientLockingBytecode, int amount) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-4",
    "content": "// ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // VALUE BOUNDARY VALIDATION\r\n        // Ensure dispute resolution amount does not exceed available input value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        require(amount <= inputValue);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify seller signature explicitly\r\n        require(checkSig(sellerSig, seller));\r\n        \r\n        // Verify arbiter signature explicitly\r\n        require(checkSig(arbiterSig, arbiter));\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly one output to prevent output manipulation\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends to the intended recipient\r\n        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);\r\n\r\n        // AMOUNT VALIDATION\r\n        // Verify the output amount matches the agreed dispute resolution amount\r\n        require(tx.outputs[0].value == amount);\r\n\r\n        // OUTPUT TOKEN VALIDATION\r\n        // Prevent unexpected CashToken attachment to output\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n    }\r\n\r\n    // TIMEOUT REFUND PATH",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-5",
    "content": "// Buyer can reclaim funds if seller is unresponsive after timeout\r\n    // This protects buyer from seller abandonment\r\n    function refund(sig buyerSig, bytes buyerRefundLockingBytecode, int refundAmount) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // TIMELOCK VALIDATION\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use >= operator (never >) for time comparisons to match consensus rules\r\n        // This must be >= refundTimeout for the refund to be valid\r\n        require(tx.time >= refundTimeout);\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // VALUE BOUNDARY VALIDATION\r\n        // Ensure refund amount does not exceed available input value\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n        require(refundAmount <= inputValue);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify buyer signature explicitly\r\n        // Only the buyer can claim refund (unilateral after timeout)\r\n        require(checkSig(buyerSig, buyer));",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-6",
    "content": "// OUTPUT VALIDATION\r\n        // Require exactly one output to prevent output manipulation\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the refund goes to buyer's specified address\r\n        // INTENTIONAL DESIGN: Buyer MAY redirect refund to any script they control\r\n        // This is NOT a vulnerability - it provides legitimate flexibility\r\n        // Buyer can refund to a different address, multisig, or covenant as needed\r\n        require(tx.outputs[0].lockingBytecode == buyerRefundLockingBytecode);\r\n\r\n        // AMOUNT VALIDATION\r\n        // Verify the refund amount is as specified\r\n        // Buyer can choose to take less (leaving more for fees) but not more\r\n        require(tx.outputs[0].value == refundAmount);\r\n\r\n        // OUTPUT TOKEN VALIDATION\r\n        // Prevent unexpected CashToken attachment to output\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTE: refundTimeout must be set to a future time when contract is created\r\n        // SECURITY NOTE: Buyer must wait until block time >= refundTimeout\r\n        // SECURITY NOTE: Transaction nLocktime must be set to a value >= refundTimeout\r\n    }\r\n}\r\n\r\n// DEPLOYMENT NOTES:\r\n// - Set refundTimeout to a reasonable future time (e.g., current time + 30 days)\r\n// - Use median time past (MTP) for time calculations, not block header time\r\n// - All three parties should verify contract parameters before funding\r\n// - Buyer funds the contract after all parties agree on parameters",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-7",
    "content": "// - Mining fees are implicit: inputValue - outputValue = fee\r\n// - Always verify recipientLockingBytecode matches intended recipient's address\r\n\r\n// SECURITY INVARIANTS:\r\n// ✓ Explicit activeInputIndex validation on all paths\r\n// ✓ Explicit input tokenCategory validation on all paths\r\n// ✓ Explicit amount ≤ inputValue validation on all paths\r\n// ✓ No implicit output ordering assumptions\r\n// ✓ Explicit tx.outputs.length validation on all paths\r\n// ✓ Explicit lockingBytecode validation on all paths\r\n// ✓ Explicit amount validation on all paths\r\n// ✓ Explicit signature validation (no checkMultiSig shorthand)\r\n// ✓ Timelock uses >= operator (consensus-compliant)\r\n// ✓ Explicit output token category validation (NO_TOKEN)\r\n// ✓ No fee assumptions (caller specifies output amount)\r\n// ✓ No hidden state or side effects\r\n// ✓ Adversarial transaction builder cannot bypass validations\r\n\r\n// AUDIT CHECKLIST:\r\n// [ ] Verify all paths validate activeInputIndex\r\n// [ ] Verify all paths validate input tokenCategory == NO_TOKEN\r\n// [ ] Verify all paths validate amount ≤ inputValue\r\n// [ ] Verify all signature checks use explicit checkSig\r\n// [ ] Verify all paths validate tx.outputs.length == 1\r\n// [ ] Verify all paths validate lockingBytecode semantically\r\n// [ ] Verify all paths validate output amount\r\n// [ ] Verify all paths validate output tokenCategory == NO_TOKEN\r\n// [ ] Verify timeout path uses >= operator for tx.time\r\n// [ ] Verify no implicit assumptions about fees or recipients\r\n// [ ] Verify contract parameters are immutable",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/escrow_2of3.cash-8",
    "content": "// [ ] Test each spending path independently\r\n// [ ] Verify transaction builder cannot add unauthorized outputs\r\n// [ ] Verify no signature reuse across different spending paths\r\n// [ ] Verify no arbiter-only spending path exists\r\n// [ ] Verify tx.time comment correctly describes MTP (not nLocktime)",
    "source": "NexKB/templates/escrow_2of3.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// CONTRACT TYPE: Linear Vesting with Optional Cliff\r\n// USE CASE: Token or BCH vesting over time with partial withdrawal support\r\n// SECURITY LEVEL: High\r\n// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity\r\n\r\n// ROLES:\r\n// - beneficiary: Receives vested funds over time, can claim any vested amount\r\n// - issuer: Optional role that can revoke unvested funds BEFORE cliff only\r\n\r\n// VESTING MECHANICS:\r\n// - Linear vesting from vestingStart to vestingEnd\r\n// - Optional cliff: No funds available until cliffTime is reached\r\n// - After cliff: Beneficiary can claim any portion of vested amount\r\n// - Partial claims: Contract recreates itself with remaining unvested balance\r\n// - Revocation: Issuer can reclaim unvested funds ONLY before cliff\r\n\r\n// TIME PROGRESSION:\r\n// [vestingStart]----[cliffTime]----[vestingEnd]\r\n//      |                |               |\r\n//   0% vested      cliff unlocks    100% vested\r\n\r\n// EXPLICIT DESIGN DECISIONS:\r\n// - This contract does NOT handle CashTokens (BCH-only)\r\n// - Issuer revocation is ONLY allowed before cliffTime\r\n// - After cliffTime, beneficiary has irrevocable rights to vested funds\r\n// - Beneficiary can claim partial amounts (does not need to claim all)\r\n// - Contract self-replication is CRYPTOGRAPHICALLY ENFORCED (non-bypassable)\r\n// - totalAmount defines vesting schedule, not balance guarantee\r\n// - Underfunding is safe (vesting slows), overfunding becomes fee slack\r\n\r\ncontract VestingLinear(",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-1",
    "content": "pubkey beneficiary,\r\n    pubkey issuer,\r\n    int vestingStart,    // Absolute block time (MTP) when vesting begins\r\n    int cliffTime,       // Absolute block time (MTP) when cliff unlocks (must be >= vestingStart)\r\n    int vestingEnd,      // Absolute block time (MTP) when 100% vested (must be > cliffTime)\r\n    int totalAmount      // Total amount being vested (immutable)\r\n) {\r\n    // BENEFICIARY CLAIM PATH\r\n    // Beneficiary withdraws vested funds (partial or full)\r\n    // Contract continues with remaining unvested balance\r\n    function claim(\r\n        sig beneficiarySig,\r\n        bytes beneficiaryOutput,       // Lockingbytecode for beneficiary's withdrawal\r\n        int claimAmount                // Amount beneficiary is claiming (must be <= vested)\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        // bytes32 representation of \"no token\" for explicit validation\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        // Prevents UTXO position attacks where attacker places contract at wrong index\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract\r\n        // This is a defensive measure to avoid token-layer confusion\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-2",
    "content": "// VESTING PARAMETER VALIDATION\r\n        // Prevent division by zero in vesting calculation\r\n        // This protects against deployment mistakes where vestingEnd == vestingStart\r\n        // Without this check, division by zero causes consensus failure\r\n        require(vestingEnd > vestingStart);\r\n\r\n        // CLIFF VALIDATION\r\n        // tx.time represents the current block's median time past (MTP)\r\n        // It is consensus-derived and NOT user-controlled\r\n        // Use >= operator (never >) for time comparisons to match consensus rules\r\n        // Beneficiary cannot claim until cliff time is reached\r\n        require(tx.time >= cliffTime);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify beneficiary signature explicitly\r\n        // Only beneficiary can initiate claims\r\n        require(checkSig(beneficiarySig, beneficiary));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the current contract balance\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // VESTED AMOUNT CALCULATION\r\n        // Calculate how much has vested based on current time\r\n        // Formula: vestedAmount = totalAmount * (currentTime - vestingStart) / (vestingEnd - vestingStart)\r\n        // Clamped to [0, totalAmount] to handle edge cases\r\n        int vestedAmount;\r\n        \r\n        // CASE 1: Before vesting start (should not happen due to cliff check, but defensive)\r\n        if (tx.time < vestingStart) {\r\n            vestedAmount = 0;\r\n        }\r\n        // CASE 2: After vesting end - fully vested",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-3",
    "content": "else if (tx.time >= vestingEnd) {\r\n            vestedAmount = totalAmount;\r\n        }\r\n        // CASE 3: During vesting period - linear interpolation\r\n        else {\r\n            // Calculate elapsed time since vesting start\r\n            int elapsed = tx.time - vestingStart;\r\n            \r\n            // Calculate total vesting duration\r\n            // Division by zero is impossible due to require(vestingEnd > vestingStart) above\r\n            int duration = vestingEnd - vestingStart;\r\n            \r\n            // Linear vesting calculation\r\n            // vestedAmount = totalAmount * elapsed / duration\r\n            vestedAmount = (totalAmount * elapsed) / duration;\r\n        }\r\n\r\n        // CLAIM AMOUNT VALIDATION\r\n        // Beneficiary can only claim up to the vested amount\r\n        // This prevents premature withdrawal of unvested funds\r\n        require(claimAmount <= vestedAmount);\r\n\r\n        // CLAIM AMOUNT SANITY CHECK\r\n        // Claim amount cannot exceed current contract balance\r\n        require(claimAmount <= inputValue);\r\n\r\n        // CLAIM AMOUNT POSITIVITY\r\n        // Claim amount must be positive (prevents zero-claim griefing)\r\n        require(claimAmount > 0);\r\n\r\n        // REMAINING BALANCE CALCULATION\r\n        // Calculate how much stays in the vesting contract\r\n        int remainingBalance = inputValue - claimAmount;\r\n\r\n        // OUTPUT COUNT VALIDATION\r\n        // Determine required number of outputs based on remaining balance\r\n        // If remainingBalance > 0: need 2 outputs (claim + continuation)",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-4",
    "content": "// If remainingBalance == 0: need 1 output (claim only, vesting complete)\r\n        \r\n        if (remainingBalance > 0) {\r\n            // TWO OUTPUT CASE: Partial claim with vesting continuation\r\n            \r\n            // OUTPUT COUNT VALIDATION\r\n            // Require exactly 2 outputs to prevent output manipulation\r\n            require(tx.outputs.length == 2);\r\n\r\n            // OUTPUT 0: BENEFICIARY CLAIM VALIDATION\r\n            // Verify first output sends claimed amount to beneficiary\r\n            require(tx.outputs[0].lockingBytecode == beneficiaryOutput);\r\n            require(tx.outputs[0].value == claimAmount);\r\n            require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n            // OUTPUT 1: CRYPTOGRAPHICALLY ENFORCED VESTING CONTINUATION\r\n            // This is the critical covenant continuation enforcement\r\n            // We do NOT trust caller-provided vestingContinuationOutput parameter\r\n            // Instead, we REQUIRE the continuation output to be THIS EXACT CONTRACT\r\n            // This prevents beneficiary from redirecting unvested funds to arbitrary scripts\r\n            // This prevents vesting escape attacks via partial claims\r\n            require(\r\n                tx.outputs[1].lockingBytecode ==\r\n                tx.inputs[this.activeInputIndex].lockingBytecode\r\n            );\r\n            require(tx.outputs[1].value == remainingBalance);\r\n            require(tx.outputs[1].tokenCategory == NO_TOKEN);\r\n\r\n            // SECURITY NOTE: Vesting continuation is now immutable and non-bypassable",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-5",
    "content": "// The contract recreates itself with:\r\n            // - Same beneficiary\r\n            // - Same issuer\r\n            // - Same vestingStart, cliffTime, vestingEnd\r\n            // - Same totalAmount\r\n            // - Reduced balance (remainingBalance)\r\n            // This guarantees future vesting schedule integrity\r\n            \r\n        } else {\r\n            // SINGLE OUTPUT CASE: Full claim, vesting complete\r\n            \r\n            // OUTPUT COUNT VALIDATION\r\n            // Require exactly 1 output (all funds claimed)\r\n            require(tx.outputs.length == 1);\r\n\r\n            // OUTPUT 0: FINAL BENEFICIARY CLAIM VALIDATION\r\n            // Verify output sends all remaining funds to beneficiary\r\n            require(tx.outputs[0].lockingBytecode == beneficiaryOutput);\r\n            require(tx.outputs[0].value == claimAmount);\r\n            require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n        }\r\n\r\n        // SECURITY NOTES:\r\n        // - Mining fee is implicit: inputValue - (claimAmount + remainingBalance)\r\n        // - Beneficiary controls claim timing and amount (up to vested limit)\r\n        // - Contract self-replication is cryptographically enforced (not trust-based)\r\n        // - No output ordering assumptions (we validate both outputs explicitly)\r\n        // - Division by zero is prevented by vestingEnd > vestingStart check\r\n    }\r\n\r\n    // ISSUER REVOCATION PATH\r\n    // Issuer can reclaim unvested funds ONLY before cliff time\r\n    // This allows issuer to cancel vesting if conditions are not met",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-6",
    "content": "// After cliff, this path is permanently disabled\r\n    function revoke(\r\n        sig issuerSig,\r\n        bytes issuerOutput,           // Lockingbytecode for issuer's reclaimed funds\r\n        int reclaimAmount             // Amount issuer is reclaiming\r\n    ) {\r\n        // TOKEN CATEGORY CONSTANT\r\n        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n        // ACTIVE INPUT VALIDATION\r\n        // Verify that THIS contract is the input being spent\r\n        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);\r\n\r\n        // INPUT TOKEN VALIDATION\r\n        // Prevent tokenized UTXO from being locked in this contract\r\n        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);\r\n\r\n        // TIME RESTRICTION VALIDATION\r\n        // Issuer can ONLY revoke BEFORE cliff time\r\n        // Use < operator here (not >=) because we want to ensure we're BEFORE cliff\r\n        // After cliff, beneficiary has irrevocable rights\r\n        require(tx.time < cliffTime);\r\n\r\n        // SIGNATURE VALIDATION\r\n        // Verify issuer signature explicitly\r\n        // Only issuer can revoke\r\n        require(checkSig(issuerSig, issuer));\r\n\r\n        // INPUT VALUE CAPTURE\r\n        // Get the current contract balance\r\n        int inputValue = tx.inputs[this.activeInputIndex].value;\r\n\r\n        // RECLAIM AMOUNT VALIDATION\r\n        // Issuer cannot reclaim more than current balance\r\n        require(reclaimAmount <= inputValue);",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-7",
    "content": "// RECLAIM AMOUNT POSITIVITY\r\n        // Reclaim amount must be positive\r\n        require(reclaimAmount > 0);\r\n\r\n        // OUTPUT VALIDATION\r\n        // Require exactly one output to prevent output manipulation\r\n        // Issuer reclaims all funds (or specifies amount with remainder as fee)\r\n        require(tx.outputs.length == 1);\r\n\r\n        // SEMANTIC OUTPUT VALIDATION\r\n        // Verify the output sends reclaimed funds to issuer\r\n        require(tx.outputs[0].lockingBytecode == issuerOutput);\r\n        require(tx.outputs[0].value == reclaimAmount);\r\n        require(tx.outputs[0].tokenCategory == NO_TOKEN);\r\n\r\n        // SECURITY NOTES:\r\n        // - This path is ONLY available before cliffTime\r\n        // - After cliff, beneficiary has permanent rights to vested funds\r\n        // - Issuer can reclaim partial or full balance before cliff\r\n        // - This is intentional design for conditional vesting scenarios\r\n    }\r\n}\r\n\r\n// DEPLOYMENT NOTES:\r\n// - Set vestingStart to the desired start time (can be in the past or future)\r\n// - Set cliffTime >= vestingStart (if no cliff wanted, set cliffTime = vestingStart)\r\n// - Set vestingEnd > cliffTime AND vestingEnd > vestingStart (CRITICAL: prevents division by zero)\r\n// - Set totalAmount to the total vesting amount (used for vested calculation)\r\n// - Fund contract with initial amount (can be >= totalAmount to account for fees)\r\n// - Beneficiary and issuer should verify all parameters before funding\r\n// - IMPORTANT: totalAmount defines the vesting schedule, not a balance guarantee",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-8",
    "content": "// - Underfunding is safe (vesting slows), overfunding becomes fee slack\r\n\r\n// VESTING MATH EXAMPLES:\r\n// Example 1: 1000 sats over 100 days, no cliff\r\n// - vestingStart = day 0, cliffTime = day 0, vestingEnd = day 100, totalAmount = 1000\r\n// - Day 0: 0 vested (but claimable since cliff = start)\r\n// - Day 50: 500 vested\r\n// - Day 100: 1000 vested\r\n\r\n// Example 2: 1000 sats over 100 days, 30 day cliff\r\n// - vestingStart = day 0, cliffTime = day 30, vestingEnd = day 100, totalAmount = 1000\r\n// - Day 0-29: Cannot claim (before cliff)\r\n// - Day 30: 300 vested and claimable\r\n// - Day 50: 500 vested and claimable\r\n// - Day 100: 1000 vested\r\n\r\n// SECURITY INVARIANTS:\r\n// ✓ Explicit activeInputIndex validation on all paths\r\n// ✓ Explicit input tokenCategory validation on all paths\r\n// ✓ Explicit division-by-zero prevention (vestingEnd > vestingStart)\r\n// ✓ Explicit amount validations (claim <= vested, reclaim <= input)\r\n// ✓ Explicit tx.outputs.length validation (1 or 2 based on context)\r\n// ✓ Explicit lockingBytecode validation on all outputs\r\n// ✓ CRYPTOGRAPHICALLY ENFORCED covenant continuation (not trust-based)\r\n// ✓ Explicit value validation on all outputs\r\n// ✓ Explicit output tokenCategory validation\r\n// ✓ Time validation uses >= for beneficiary, < for issuer\r\n// ✓ Vested amount calculation handles all time ranges correctly\r\n// ✓ No fee assumptions (caller specifies output amounts)\r\n// ✓ No output ordering assumptions (both outputs validated explicitly)\r\n// ✓ Contract self-replication prevents vesting escape attacks",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-9",
    "content": "// ✓ Issuer revocation restricted to pre-cliff period only\r\n\r\n// ANTI-PATTERN IMMUNITY:\r\n// ✓ Division by zero: Prevented by require(vestingEnd > vestingStart)\r\n// ✓ Unenforced covenant continuation: Fixed by lockingBytecode == input lockingBytecode\r\n// ✓ Implicit output ordering: Both outputs validated explicitly\r\n// ✓ Fee assumptions: Caller controls output amounts\r\n// ✓ Time validation errors: Uses >= for forward time checks, < for backward\r\n// ✓ Unvalidated position: activeInputIndex validated\r\n// ✓ Token category vulnerabilities: All outputs validate NO_TOKEN\r\n\r\n// AUDIT CHECKLIST:\r\n// [ ] Verify vestingStart <= cliffTime <= vestingEnd invariant at deployment\r\n// [ ] Verify vestingEnd > vestingStart (CRITICAL for division safety)\r\n// [ ] Verify all paths validate activeInputIndex\r\n// [ ] Verify all paths validate input tokenCategory == NO_TOKEN\r\n// [ ] Verify claim path validates claimAmount <= vestedAmount\r\n// [ ] Verify claim path validates claimAmount <= inputValue\r\n// [ ] Verify claim path handles both 1-output and 2-output cases\r\n// [ ] Verify vesting continuation enforces SAME lockingBytecode (cryptographic enforcement)\r\n// [ ] Verify revoke path only works when tx.time < cliffTime\r\n// [ ] Verify all signature checks use explicit checkSig\r\n// [ ] Verify all outputs validate lockingBytecode, value, and tokenCategory\r\n// [ ] Verify vested amount calculation handles edge cases (before start, after end)\r\n// [ ] Verify division by zero is impossible (vestingEnd > vestingStart check)",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/templates/vesting_linear.cash-10",
    "content": "// [ ] Test claim at vestingStart, cliffTime, mid-vesting, vestingEnd\r\n// [ ] Test revoke before and after cliffTime (should fail after)\r\n// [ ] Verify transaction builder cannot add unauthorized outputs\r\n// [ ] Verify mining fees are handled correctly (implicit in remainder)\r\n// [ ] Test partial claim cannot redirect unvested funds to arbitrary scripts",
    "source": "NexKB/templates/vesting_linear.cash",
    "tier": "tier_b_patterns_security",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-0",
    "content": "Topic: name\nContent: \"BCH Compilers FAQ\"",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-2",
    "content": "Topic: source\nContent: \"BCH Compilers Telegram 2025\"",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 34",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_compilers_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"CashScript Compiler\",\"count\":21,\"faqs\":[{\"q\":\"What is the proposed compileScript() function for CashScript?\",\"a\":\"A proposed function that compiles small CashScript code segments into CashASM without requiring a full contract wrapper. Example: compileScript('a + b', {a: 'int', b: 'int'}) would output '<a> <b> OP_ADD'. This enables easier template creation by allowing developers to write complex field calculations in CashScript and compile them to CashASM at build time.\"},{\"q\":\"What syntax is proposed for standalone CashScript function compilation?\",\"a\":\"Instead of requiring full contract definitions, the proposal suggests compiling standalone functions like: compileScript(`function checkLockingBytecode(bytes lockingBytecode) { require(lockingBytecode.length == 25); }`) or using arrow function syntax: `(int a, int b) => { return a + b }`. This skips the contract wrapper overhead while maintaining function parameter definitions.\"},{\"q\":\"Are standalone CashScript functions on the roadmap?\",\"a\":\"Yes, creating self-contained functions is on the CashScript roadmap. When implemented, they will be compilable independently for use cases like template field injection. Adding CashASM as an explicit compilation target (separate from regular hex bytecode/asm) is also planned to support template generation workflows.\"},{\"q\":\"Is there a Python version of the CashScript SDK?\",\"a\":\"CashScript-py is being developed and recently received funding. It will be feature-compatible with the JavaScript SDK. However, it's not a solution for OP_CHECKMULTISIG support since the Python version will have the same SDK limitations as the JS version (no collaborative transaction building).\"},{\"q\":\"What is Spedn and how does it compare to CashScript?\",\"a\":\"Spedn is an alternative BCH smart contract compiler with different syntax from CashScript. While CashScript is more widely adopted with active development and extensive ecosystem support, Spedn offers an alternative approach. Developers can experiment with Spedn using community test repositories, though tooling and documentation are less mature.\"},{\"q\":\"Should BCH templates use CashScript, CashASM, or bytecode?\",\"a\":\"Templates should use CashASM (assembly), not CashScript or bytecode. CashScript at build-time compiles to CashASM for the final template. CashASM is human-readable, syntactically simple to port across languages, and already supported by LibAuth-based wallets (Paytaca, Selene, Cashonize, ZapIt). Bytecode would save bandwidth but requires all wallets to implement assemblers.\"},{\"q\":\"Why not embed CashScript source code in final templates?\",\"a\":\"Embedding CashScript would force all wallets and dapps to incorporate a CashScript parser, creating version incompatibility issues when CashScript optimizations change the output CashASM. It also limits cross-platform adoption since non-JavaScript implementations would be difficult. Templates with only CashASM avoid these problems.\"},{\"q\":\"What are LibAuth WalletTemplates and how do they relate to BCH templates?\",\"a\":\"LibAuth WalletTemplates provide a standardized format for describing BCH transactions using CashASM. Templates leverage this by embedding sandboxed CashASM evaluation instructions that wallets execute, enabling dynamic field calculations like nested evaluations: '$($(<value> <1000> OP_SUB) <2> OP_DIV)'. This allows complex transaction templates without requiring CashScript runtime support.\"},{\"q\":\"What is the debug symbols approach for BCH smart contracts?\",\"a\":\"Similar to traditional compiled languages, contracts use external metadata files (debug symbols) that accompany compiled scripts. Production templates contain only CashASM/bytecode, keeping them lightweight. Debug symbols (\\\"byte N is variable A\\\") are stored separately for development/debugging only. This separates complexity from production requirements.\"},{\"q\":\"Why is CashASM evaluation executed within wallets in templates?\",\"a\":\"Templates embed CashASM evaluation instructions that wallets execute in a sandboxed environment. This allows templates to perform dynamic calculations (like computing leverage ratios or concatenating NFT commitments) without requiring pre-compiled values. The wallet evaluates the CashASM expressions using its BCH VM capabilities to build the final transaction.\"},{\"q\":\"Does the CashScript TransactionBuilder automatically add change outputs?\",\"a\":\"No, the advanced TransactionBuilder does nothing automatically - you must manually add satoshi change outputs and token change outputs. This design gives full control but requires developers to handle fee calculation and change output construction themselves.\"},{\"q\":\"What fee estimation utilities exist for CashScript transactions?\",\"a\":\"bch-js has getByteCount() for simple cases: `bchjs.BitcoinCash.getByteCount({ P2PKH: 1 }, { P2PKH: 1 })`. However, this is too simple for CashScript multi-contract spends. More sophisticated utilities to check bytecount for different transaction shapes with varying input/output types would be valuable.\"},{\"q\":\"What debugging capabilities does CashScript v0.11.0+ provide?\",\"a\":\"CashScript v0.11.0+ adds debugging support for the new transaction builder, allowing use with mocknet for local testing and integration with the Bitauth IDE. You can call .debug() on failed transactions or .bitauthUri() to manually inspect. The debugging works with the contract's optimized bytecode, so dev and prod contracts are identical, eliminating the dev/prod discrepancy that could hide bugs.\"},{\"q\":\"Can you debug transactions that spend from multiple different smart contracts?\",\"a\":\"Yes, in CashScript v0.11.0+. Use the new transaction builder to combine multiple contracts in a single transaction, then call .debug() or .bitauthUri() on it. The Bitauth IDE allows you to click through and debug each input individually, making multi-contract transaction debugging straightforward.\"},{\"q\":\"What is CashScript Arena?\",\"a\":\"CashScript Arena (arena.layer1.cash) is an interactive learning platform with challenges based on exploitable or broken smart contracts. It's designed for both complete beginners (first challenge just requires setting up the environment) and experienced developers to practice contract security and CashScript fundamentals.\"},{\"q\":\"What new features does CashScript v0.11.0 introduce?\",\"a\":\"v0.11.0's highlight is debugging capabilities for the new transaction builder, allowing use with mocknet for local testing and Bitauth IDE integration. The old simple transaction builder is deprecated. The release includes sourcemaps that work with optimized bytecode so dev and prod contracts are identical. See migration-notes in docs for breaking changes.\"},{\"q\":\"What new features does CashScript v0.11.4 include?\",\"a\":\"v0.11.4 includes a bug fix for P2PKH-only transactions and enhanced MockNetworkProvider functionality that allows simulating a real network more closely during testing. Both features were contributed by the community (mainnet_pat).\"},{\"q\":\"What new features does CashScript v0.12.0 introduce?\",\"a\":\"v0.12.0 removes the old deprecated transaction builder and adds: 1) getVmResourceUsage() function to measure VM resource consumption, 2) New TransactionBuilder safety options, 3) Several breaking changes requiring migration (see migration-notes in docs).\"},{\"q\":\"What new guides are available in the CashScript documentation?\",\"a\":\"The CashScript docs now include two essential BCH development guides that document assumed knowledge: 1) \\\"Transaction Lifecycle\\\" guide explaining how transactions are created, validated, and propagated, and 2) \\\"Adversarial Analysis\\\" guide covering security considerations and attack vectors in smart contract development.\"},{\"q\":\"Why does my CashScript transaction hang when using ElectrumNetworkProvider?\",\"a\":\"If using CashScript v0.10.0 with chipnet, the old default electrum server is down. Either pass a custom server like chipnet.bch.ninja when instantiating ElectrumNetworkProvider, or upgrade to the @next pre-release which has updated default servers.\"},{\"q\":\"Does the CashScript SDK support OP_CHECKMULTISIG?\",\"a\":\"No, the language supports it but the SDK does not. OP_CHECKMULTISIG requires collaborative transaction building support which isn't currently implemented. The recommended alternative is using NFTs for multisig authorization - for 1-of-M scenarios, NFT ownership proves authorization; for N-of-M, participants can merge NFTs non-interactively to accumulate the required N signatures.\"}]},{\"name\":\"Libauth & Templates\",\"count\":7,\"faqs\":[{\"q\":\"What is the trade-off between CashASM and bytecode in templates?\",\"a\":\"Bytecode advantages: smaller file size, bandwidth savings (important for NFC). CashASM advantages: human-readable, simpler parser implementation, easier cross-language porting, already supported in LibAuth wallets. The consensus is CashASM provides better versatility and portability while keeping complexity manageable, with bytecode reserved for specific use cases like NFC.\"},{\"q\":\"How does template design balance versatility vs simplicity?\",\"a\":\"CashASM is chosen as a mid-ground: syntactically simple enough to port to other languages but versatile enough for complex contract use-cases. Nested evaluation capabilities are needed for transaction shape definitions and signing operations. The philosophy is to handle complexity in tooling (build-time) rather than requiring wallets to support complicated features.\"},{\"q\":\"Which BCH wallets currently support CashASM?\",\"a\":\"At least four ecosystem wallets use LibAuth under the hood and thus support CashASM: Paytaca, Selene, Cashonize, and ZapIt. Electron Cash may have ported it with the new WalletConnect plugin. This existing support makes CashASM a practical choice for template standardization.\"},{\"q\":\"How do you calculate transaction fees when spending from multiple contracts?\",\"a\":\"Fee calculation is non-trivial for multi-contract spends because input sizes aren't known until unlockers are defined. Options include: 1) Use getCurrentByteSize() or build() then check rawTxHex.length/2 to get transaction size, 2) Create utility functions to estimate output sizes, 3) Build the transaction, parse with libauth to check sizes, then add balancing outputs (which may require extra inputs).\"},{\"q\":\"Can NFT inputs be auto-populated in transaction builders?\",\"a\":\"No elegant solution exists yet for auto-populating NFT inputs. NFTs must be explicitly passed in the template rather than populated automatically. Most transactions requiring NFTs need to specify a particular outpoint anyway (\\\"use this exact UTXO\\\"), making auto-selection less useful than with fungible assets.\"},{\"q\":\"Can you select specific inputs to debug in TransactionBuilder.debug()?\",\"a\":\"No, debug() automatically debugs the entire transaction. When you open the Bitauth URI (logged on debug failure or via bitauthUri()), you can click through different inputs one by one in the IDE. This allows inspecting each input individually even though debugging operates on the complete transaction.\"},{\"q\":\"What advantages does NFT-based multisig offer over traditional OP_CHECKMULTISIG?\",\"a\":\"NFT-based multisig provides better discoverability and easier backup recovery. Since NFT ownership is on-chain and queryable, wallets can discover multisig authorization tokens by scanning the blockchain. Traditional multisig requires coordinating public keys off-chain. For N-of-M scenarios, NFTs can be merged non-interactively to accumulate signatures.\"}]},{\"name\":\"Bytecode & Opcodes\",\"count\":1,\"faqs\":[{\"q\":\"Does Bitcoin Cash have MAST or Taproot?\",\"a\":\"No, BCH does not currently have MAST or Taproot. However, there's an ongoing CHIP proposal for OP_EVAL which would enable MAST-like constructions. Additionally, MAST functionality can be emulated today using BCH's native introspection opcodes, specifically OP_UTXOBYTECODE, without requiring a protocol upgrade.\"}]},{\"name\":\"Language Features\",\"count\":2,\"faqs\":[{\"q\":\"How is the CashConnect wallet transaction building API designed?\",\"a\":\"CashConnect uses a partial TransactionTemplate approach where users provide outputs (with lockingBytecode, valueSatoshis, and optional token data), and the wallet automatically appends required inputs and change outputs. The TransactionBuilder follows the tokens-first, satoshis-last pattern internally, handling fee calculation and change construction transparently.\"},{\"q\":\"What transaction builder utilities are proposed for fee management?\",\"a\":\"Proposals include: getCurrentByteSize() to get current transaction size, and calculateOutputSizes() to estimate change output sizes for different types (like P2PKH with tokens). The current method is building the transaction and checking rawTxHex.length/2, but more sophisticated utilities would help with multi-contract spends.\"}]},{\"name\":\"General Tooling\",\"count\":3,\"faqs\":[{\"q\":\"What is the correct order for handling tokens and satoshis when building transactions?\",\"a\":\"Tokens first, satoshis last. Correct sequence: addTokensFromUnspents() → addTokenChangeOutputs() → addSatoshisFromUnspents() → addSatoshiChangeOutput(). This is critical because satoshi change amount depends on the final transaction fee, which can only be calculated after token outputs are finalized.\"},{\"q\":\"How can you get intermediate transaction information before finalizing?\",\"a\":\"After adding contract spends with defined unlockers, you could extract intermediate information like input sizes from the prebuilt transaction. Since spending args are provided to unlockers, the final input shape is known. This would help calculate change outputs before fully building and sending the transaction.\"},{\"q\":\"What features does the Flowee API transaction builder provide?\",\"a\":\"The Flowee API transaction builder includes: automatic byte count calculation, output adjustment to achieve specific fee-per-byte targets, and BIP69 anonymity features (deterministic input/output ordering). These are reference implementations for transaction building best practices.\"}]}]",
    "source": "faq/telegram/bch_compilers_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-0",
    "content": "Topic: name\nContent: \"BCH Devs & Builders FAQ\"",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-2",
    "content": "Topic: source\nContent: \"BCH Devs & Builders Telegram 2025\"",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 305",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bch_devs_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"Smart Contracts & CashScript\",\"count\":171,\"faqs\":[{\"q\":\"Where can I find security guidelines for BCH application developers?\",\"a\":\"A developer guidelines document covering environmental risks and survival considerations for script developers and DeFi developers is available at bitcoincashresearch.org/t/bitcoin-application-developer-guidelines-environmental-risks-survival/1470. This covers important security considerations for building applications on BCH.\"},{\"q\":\"How can I implement rate limiting on my BCH infrastructure to prevent bandwidth abuse?\",\"a\":\"Several options exist depending on your setup: 1) Fulcrum has built-in rate limiting features you can enable in the configuration. 2) For nginx, use 'limit_rate 100k;' to cap bandwidth per connection. 3) For BCHN p2p connections, you can write a shell script that uses the RPC to check peer bandwidth usage and ban nodes consuming too much data - run this via cron every 15 minutes. 4) Consider hosting providers with 'unlimited' plans that throttle rather than cut off service when quotas are exceeded. These measures help protect public infrastructure like chipnet explorers from being overwhelmed by bots or scrapers.\"},{\"q\":\"Can ZK-STARKs or shielded addresses be implemented on BCH?\",\"a\":\"Shielded addresses that hide sender and receiver (but not UTXO amounts) are theoretically possible on BCH without consensus changes, thanks to BCH's powerful opcodes and math capabilities. However, there are practical challenges: the shielding makes it computationally expensive to find your money on-chain because you must test every output with a costly EC-mul operation. For a comprehensive discussion of advantages, disadvantages, and technical challenges, creating a topic on Bitcoin Cash Research (BCR) forum is recommended to track the conversation properly.\"},{\"q\":\"Does BCH need a special ZKP opcode for zero-knowledge proofs?\",\"a\":\"Not necessarily. ZKP ultimately boils down to math operations like polynomial arithmetic, which can be done using existing BCH opcodes on the stack. A specialized opcode could offer advantages (efficiency, simpler code), but would add complexity and risk to the consensus layer. BCH's powerful math capabilities after the VM limits upgrade make it possible to implement ZKP using existing opcodes without consensus changes.\"},{\"q\":\"Is there a CashScript VS Code extension?\",\"a\":\"Yes, there's an official CashScript VS Code extension that provides syntax highlighting and language support for all the latest CashScript functionality. It replaces the older unofficial extension. Search for 'CashScript' in the VS Code extension marketplace to install it.\"},{\"q\":\"What is the BCH/CashScript equivalent of Solidity's receive() function?\",\"a\":\"There is no direct equivalent in BCH Script. Solidity's receive() is triggered automatically when a contract receives ETH, but BCH contracts work differently - there's no automatic callback when funds are sent to a contract address. To detect incoming payments, you need to listen to an indexer for address receive events. This is a fundamental difference between EVM's account model and BCH's UTXO model.\"},{\"q\":\"How do I store user state (like deposits) in a BCH smart contract?\",\"a\":\"Unlike EVM contracts with storage slots, BCH uses the UTXO model where state is stored using NFT commitments. When a user deposits, the contract creates an NFT with the user's address and deposit amount stored in the NFT's commitment field. Think of each NFT output as containing: satoshi amount, token category (which includes any capability byte appended to the 32-byte category ID), and custom commitment data (user address, flags, etc.). To query user deposits, you interact with the contract using the relevant NFT. Example projects: BadgersStake and CashStarter on GitHub.\"},{\"q\":\"Are there public/private functions in BCH smart contracts like Solidity?\",\"a\":\"No, every function in a BCH smart contract can be called by anyone - there's no native public/private distinction like in Solidity. You need to explicitly lock down function capabilities within your contract logic, typically by checking signatures or other conditions before allowing sensitive operations to proceed.\"},{\"q\":\"How does Cauldron DEX create unique contract addresses per user?\",\"a\":\"Cauldron stores each user's pubkey as part of the contract code itself. Since the pubkey is part of the locking script, different users will have Cauldron contract addresses unique to them. The pubkey can then be used to authorize withdrawals. This is a common pattern in UTXO-based contracts for linking state to specific users without requiring separate NFT receipts.\"},{\"q\":\"Where is the CashScript Telegram community?\",\"a\":\"There's a dedicated Telegram channel for CashScript at t.me/CashScriptBCH. This is the main place to discuss CashScript development, ask questions, share learning resources, and discuss contract design.\"},{\"q\":\"Is OP_EVAL dangerous for BCH smart contracts?\",\"a\":\"No, OP_EVAL itself isn't inherently dangerous. BCH Script already has enough capability to write risky contracts without eval. OP_EVAL won't magically affect existing contracts that don't use it. The concern is more about compiler complexity when utilizing subroutines. If you think a contract using eval is risky, you're not forced to lock money with it. The evaluation is still bounded by existing VM limits.\"},{\"q\":\"What are the locking bytecode limits in TXv5?\",\"a\":\"TXv5 (transaction version 5) increases the locking bytecode limit to 100,000 bytes, significantly up from P2SH limits. This is an important consideration because locking bytecode is stored in the UTXO set, which affects node storage requirements. Developers should be mindful of these expanded limits and their impact on UTXO set growth.\"},{\"q\":\"Why do the bytecode length limits no longer matter after the VM Limits CHIP?\",\"a\":\"Following the VM Limits CHIP, bytecode and stack item length limits are no longer relevant to worst-case transaction or block validation performance. Since standard transactions can include many inputs up to MAX_STANDARD_TX_SIZE (100,000 bytes), lower per-item or per-input length limits offer no additional safety to the network while inconveniencing applications with larger contiguous data requirements.\"},{\"q\":\"What are the different use cases for OP_EVAL in BCH?\",\"a\":\"Different developers value OP_EVAL for different reasons: 1) Stack optimization - implementing custom operations like 'unroll' to move items in the stack without dedicated opcodes; 2) CashScript compiler - provides a simple way to compile functions into executable bytecode with compiler-managed calling conventions; 3) Bytecode compression - detecting repeating patterns and using CAT/SPLIT to construct optimized code; 4) Flexibility - executing stack items from any source in the transaction (locking script, unlocking script, other inputs via introspection, or constructed dynamically).\"},{\"q\":\"What is the difference between OP_EVAL and the Subroutines CHIP?\",\"a\":\"The key difference is where code can come from. Subroutines forces code to be defined in the locking script with an index-based call system (runsub). OP_EVAL is more flexible - it executes bytecode from the stack, which can originate from anywhere: the locking script, unlocking script, other inputs/outputs via introspection, or dynamically constructed via CAT. Subroutines offers potentially better bytecode compression in some cases and a 2-byte call overhead, while OP_EVAL offers maximum flexibility for contract designers.\"},{\"q\":\"Where can I find the Subroutines CHIP proposal for BCH?\",\"a\":\"The Subroutines CHIP proposal is available at codeberg.org/bitcoincash/CHIP-subroutines. It's linked from Bitcoin Cash Research (BCHR) as well. The CHIP process involves crystallizing discussions into a formal document to avoid people having to wade through hundreds of comments.\"},{\"q\":\"Is BCH Script meant to be 'safe' or 'unsafe' like C?\",\"a\":\"Script is a low-level language and is intended to be 'unsafe' in the same way assembly or C are unsafe - it gives developers direct control without guardrails. CashScript can be 'safe' as a higher-level language that compiles to safe Script patterns. The philosophy is: provide powerful low-level primitives, and let compilers/higher-level languages provide safety abstractions for developers who want them.\"},{\"q\":\"Can OP_EVAL cause DoS attacks on BCH nodes?\",\"a\":\"No. Scripts run in a container and are bounded by the parent's VM limits. There's an 'execution budget' - once depleted, the transaction is considered invalid. The VM keeps a tally of every operation executed. A program either passes or fails; it can't break consensus or the VM itself. Code evaluated via OP_EVAL is verified and limited the same way normal scripts are.\"},{\"q\":\"How can I make OP_EVAL safe by verifying code before execution?\",\"a\":\"You can hash-verify code before executing it: <push bytecode from stack> OP_DUP OP_HASH256 <hardcoded hash> OP_EQUALVERIFY OP_EVAL. This pattern allows bytecode to be fetched from arbitrary sources (another input, NFT commitment, etc.) while ensuring only the expected code runs. The hash in your 'main' program acts as a commitment to the subroutine code.\"},{\"q\":\"Can BCH verify Zero-Knowledge Proofs (ZKPs) on-chain?\",\"a\":\"Yes, BCH can technically verify ZKPs without needing a dedicated opcode, but it's currently highly impractical - you'd need to use many different contract inputs. After the VM Limits upgrade (2025), it becomes more feasible. The real challenge is transaction size and fees: porting a zkVM's verification might cost ~10,000x typical BCH transaction fees. Future CHIPs adding loops and optimization could make ZKP verification more practical.\"},{\"q\":\"Can OP_EVAL functionality be emulated in current BCH Script?\",\"a\":\"Yes, OP_EVAL's 'unsafe' features can already be emulated using BCH's native introspection opcodes like OP_UTXOBYTECODE. A Medium article (search 'Emulating OP_EVAL using Bitcoin Cash native introspection opcodes') demonstrates this. This means the security model hasn't fundamentally changed - careful contract design has always been necessary.\"},{\"q\":\"Is BCH Script compiled or interpreted?\",\"a\":\"BCH Script is interpreted in a VM sandbox, not compiled to machine code like x86 and then executed. Unlike Forth which can be compiled to machine language, BCH Script runs directly in the node's script interpreter. This means concepts like 'splitting code and compiling segments in parallel' from programming language theory don't directly apply to runtime execution.\"},{\"q\":\"What's the history of covenants on BCH?\",\"a\":\"BCH has had covenants since 2018. In 2022, native introspection opcodes made covenants 'easy' to implement. In 2023, CashTokens brought persistent state, allowing covenants to communicate with each other and provide compact proofs. In 2025, the VM Limits/BigInts upgrade enables more advanced capabilities - things like Lamport signatures might fit in a single input. The 2026 CHIPs (Loops, OP_EVAL, P2S) would further reduce costs and complexity.\"},{\"q\":\"What CHIPs are planned for BCH in 2026?\",\"a\":\"The proposed 2026 CHIPs include Loops, OP_EVAL, and P2S (Pay-to-Script). These are still in 'debate' stage as of early 2025. These upgrades would make certain advanced covenants (like ZK verification) much smaller and cheaper. However, they need to go through the full CHIP process with community review before activation.\"},{\"q\":\"Would ZK privacy transactions replace P2PKH on BCH?\",\"a\":\"No, P2PKH won't be replaced - it's superior for UX and ease of use. ZK shielded transactions would be opt-in for privacy. Users would enter a p2sh contract system holding BCH, receiving an NFT with a random-looking 32-byte commitment. Inside the system, you split/merge/transfer by providing ZK proofs and creating outputs with updated NFT commitments. To exit back to regular P2PKH, you provide a different ZK proof to claim your portion of the pooled BCH.\"},{\"q\":\"What advantage would ZK shielded pools have over CashFusion for BCH privacy?\",\"a\":\"The main advantage is non-interactivity. With a ZK shielded pool, you pay in, transact inside the shielded covenant, and pay out whenever you like - no need to wait for others. CashFusion requires coordinating with other participants in real-time. For external observers, a ZK pool would look like one address transacting with itself, with the NFT commitment encrypting balances and ownership inside the pool.\"},{\"q\":\"What's the nullifier problem for ZK privacy on BCH?\",\"a\":\"When implementing Tornado Cash-style ZK privacy on BCH, you need to track all previously used 'nullifiers' to prevent withdrawal replay/double-spending. ETH has global state and hash tables that make this trivial, but BCH has no equivalent. All used nullifiers would need to be fed into the contract when withdrawing, becoming the limiting factor. One workaround is a challenge step with bonds - require a 'bond' when withdrawing that someone can claim if they prove the nullifier was already used - but this hurts UX compared to EVM implementations.\"},{\"q\":\"Why will ZK transactions on BCH be large even with efficient opcodes?\",\"a\":\"Even if the contract/opcode is small, the ZK proofs themselves are inherently large, so transactions will be big. Proof sizes can't get smaller unless some breakthrough cryptosystem is discovered. This is a fundamental limitation of current ZK technology, not something that can be optimized away with better contract design. The proofs themselves take up most of the space.\"},{\"q\":\"How does a ZK proof prevent miners from changing the withdrawal address?\",\"a\":\"The recipient address is used as an input into the ZK proof itself. When creating the proof, you essentially hardcode the destination address. When the contract verifies the proof using the nullifier hash, merkle root, and other inputs, changing any of these values (including the recipient address) would make the proof verification fail. The proof is mathematically bound to the specific recipient.\"},{\"q\":\"Is there any existing work on Groth16 ZK verification for CashScript?\",\"a\":\"Yes, there's an experimental repository at github.com/mr-zwets/groth16_cashscript that explores implementing Groth16 verification in CashScript. This work helps identify what's currently missing and what additional capabilities would be needed to make ZK verification practical on BCH.\"},{\"q\":\"What are the risks of porting ZK code from EVM to BCH without deep cryptographic knowledge?\",\"a\":\"Significant risks exist. When reimplementing cryptographic code without domain knowledge, you can introduce subtle vulnerabilities - like nonce reuse in ECDSA which can expose private keys. ZK implementations may have similar non-obvious pitfalls. Even if BCH Script is theoretically Turing complete and can 'express any program', the implementation details matter enormously for security. Anyone porting ZK protocols should understand not just the contract logic, but the underlying cryptographic assumptions.\"},{\"q\":\"What is a 'Turing tarpit' and how does it relate to BCH Script?\",\"a\":\"A Turing tarpit is a language that is technically Turing-complete but nearly impossible to use for practical programming. The original BCH Script VM inherited from BTC was even worse - not Turing complete at all, like a calculator without multiplication where you had to do ADD, ADD, ADD repeatedly. BCH's upgrades (native introspection, BigInts, VM Limits) have progressively made Script more practical, moving it away from tarpit territory.\"},{\"q\":\"How does OP_CHECKSEQUENCEVERIFY (CSV) work with nSequence for relative timelocks?\",\"a\":\"Consensus ALWAYS enforces whatever nSequence value is in the transaction - miners can't mine a transaction until the input ages to match. However, without CSV or introspection, whoever can spend the funds can set ANY valid nSequence value (0 up to the UTXO's current age). CSV or introspection lets the script LIMIT what values are allowed, enforcing a minimum wait time. Three scenarios: 1) Pre-signed tx: locked by signature; 2) Self-controlled funds: can pick any value; 3) Covenant: script enforces minimum.\"},{\"q\":\"Can miners bypass nSequence relative timelocks if CSV isn't used?\",\"a\":\"If the nSequence field isn't locked (by signature, CSV, or introspection), a miner could theoretically modify the transaction to change the nSequence value and mine it ahead of time. This is why you need to lock the field somehow: signatures cover nSequence, CSV validates it in script, or introspection can check tx.inputs[i].sequenceNumber. Once locked, consensus enforces it and miners CAN'T mine until the input ages.\"},{\"q\":\"What is BitCANN and how does it work?\",\"a\":\"BitCANN is an Unstoppable Domains/ENS-like domain name protocol for BCH. It's one of the most complex script systems built on BCH, using relative timelocks and multiple interacting contracts. The project is available at github.com/BitCANN/contracts and includes documentation with diagrams explaining the contract interactions.\"},{\"q\":\"What BCH project ideas are needed in the ecosystem?\",\"a\":\"Several project ideas are wanted: 1) Visualizer/simulator for different AMM DEX curves; 2) CashScript-py SDK; 3) Address analyzer (to check for privacy leaks); 4) Double spend proof (DSP) checker website; 5) BCMR indexer in TypeScript. Also WalletConnect apps: airdrop/dividends, vault, Last-Will inheritance, Mecenas recurring payments, Hodl timelock, and AnyHedge integration.\"},{\"q\":\"How do recurring payments work in BCH smart contracts?\",\"a\":\"With BCH recurring payments like Mecenas, you pre-fund an amount and no further user action is needed. The recipient (or any server/user) can 'pull' the pre-set amount at pre-set intervals - the contract enforces the timing and amounts. An alternative approach (unspent.cash) has anyone with any BCH wallet initiate payments without WalletConnect. For pull-based payments without pre-funding, authorization tokens can be issued from a pool with spending restrictions.\"},{\"q\":\"Can BCH recurring payments use fiat denominations?\",\"a\":\"Users often want fiat-denominated payments (e.g., $30/month) which requires an oracle to determine BCH amounts at payment time. This works until the oracle stops operating. Projects like unspent.cash deliberately avoid oracles to ensure longevity - the contracts are designed to work for decades without any central dependency. It's a tradeoff between convenience (fiat amounts) and resilience (no oracle dependency).\"},{\"q\":\"What is the OP_RETURN Scanner tool?\",\"a\":\"OP_RETURN Scanner is a utility to find all occurrences of a specific OP_RETURN marker on-chain. For example, searching for 'BCMR' finds all 3400+ BCMR registration transactions. Available at opreturn-scanner.netlify.app with source code at github.com/mr-zwets/opreturn-scanner. Useful for indexing protocols that use OP_RETURN markers.\"},{\"q\":\"What is ARCC for BCH?\",\"a\":\"ARCC (github.com/kiok46/arcc) is an advanced recurring payment contract structure for BCH. It provides more sophisticated recurring payment capabilities compared to simpler approaches. The Zapit team has been looking into integrating it as a service.\"},{\"q\":\"Why should protocols use OP_RETURN markers (LOKAD-id) for on-chain data?\",\"a\":\"Using a LOKAD-id prefix in OP_RETURN outputs makes your protocol discoverable and indexable on-chain. Without it, transactions are hard to find and identify. With a registered LOKAD-id (4-byte prefix), anyone can easily search for all transactions using your protocol. Register your protocol's LOKAD-id at github.com/lokad/lokad-idspace to claim a unique identifier.\"},{\"q\":\"How can BCH dApps work without application servers?\",\"a\":\"By putting all contract details on-chain, BCH dApps can operate as client-only applications with no backend server. The client reads contract state from the blockchain, constructs transactions locally, and broadcasts them. Examples like BCH Hodl Dapp (bch-hodl-dapp.netlify.app) demonstrate this pattern. This eliminates server hosting costs and single points of failure. The tradeoff is requiring on-chain storage and careful protocol design for discoverability.\"},{\"q\":\"How do I monitor an address for incoming BCH payments using Electrum protocol?\",\"a\":\"Use the Electrum Cash Protocol (electrum-cash-protocol.readthedocs.io): 1) Connect to a Fulcrum server, 2) Use blockchain.scripthash.subscribe to monitor an address - this returns current state and notifies on changes (0-conf and first confirmation), 3) When notified, call blockchain.scripthash.get_balance or blockchain.scripthash.listunspent to get details, 4) Use server.ping to keep connection alive. The subscription triggers on any state change (receives AND spends), so filter for receives on your side.\"},{\"q\":\"How can I implement Dutch Auctions with CashTokens?\",\"a\":\"Dutch Auctions (price decreases over time until someone buys) can be implemented using CashScript timelocking contracts. The contract starts at a high price and decreases based on block number. Key considerations: 1) Adding a 'cancel' function requires preventing race conditions where seller cancels right after a buyer commits, 2) You can use BIP68 512-second time units for finer granularity than block-based timing, 3) For canceling lots, consider making it trivial for consigners to 'buy back' their UTXOs through the UI. See bitcoincashresearch.org discussions on Unspent Phi for implementation details.\"},{\"q\":\"Why does my CashScript contract fail when using checkSig with the OR operator?\",\"a\":\"This is due to the NULLFAIL rule (BIP-146). When checkSig evaluates a signature against the wrong public key, it doesn't return false and continue - it errors out entirely. So `require(checkSig(sig, pubkeyA) || checkSig(sig, pubkeyB))` will always fail because whichever key doesn't match will cause an error, not return false. The fix: use two separate signature parameters and pass an empty signature (0x) for the one you're not using: `function release(sig sigA, sig sigB) { require(checkSig(sigA, pubkeyA) || checkSig(sigB, pubkeyB)); }`. Then pass (0x, realSig) or (realSig, 0x) depending on which key is signing.\"},{\"q\":\"How do I sign a transaction that spends CashTokens?\",\"a\":\"When spending a CashToken UTXO, the signature preimage must include token data in TWO places: 1) Token prefix + token data before the scriptCode/locking script for the input being spent, and 2) The 'transaction outputs hash' must include token prefixes for any outputs containing tokens. A common bug is updating only the input's token contents but forgetting to include tokens in the outputs hash. Reference documentation.cash/protocol/blockchain/transaction/transaction-signing.html and the CashTokens CHIP for the exact serialization format. SIGHASH_UTXOS is optional - you can sign token transactions without it.\"},{\"q\":\"Does checkSig return false or error when signature verification fails?\",\"a\":\"Due to the NULLFAIL rule, checkSig will ERROR (fail the script entirely) if a non-empty signature fails verification. It only returns false (allowing script to continue) when passed an empty byte (0x/null). This is why 'NULLFAIL' - null OR fail. This prevents malleability attacks where someone could flip a failing signature to something else that also fails but changes the transaction hash.\"},{\"q\":\"Why was token data placed outside the scriptCode in signature preimages?\",\"a\":\"Token data is intentionally placed outside (before) the scriptCode in the signature preimage so that old software cannot accidentally generate valid token signatures and burn tokens. The 'modified' locking script is only used to cover the input being spent's prevout. For tx encoding, tokens go inside the output; for sig preimages, they're external. This design ensures unupgraded wallet software simply cannot send tokens at all, rather than potentially destroying them.\"},{\"q\":\"What's the best approach for subscribing to millions of scripthash addresses?\",\"a\":\"Fulcrum's default max_subs limit of 10 million is a DoS prevention measure. For more than a million subscriptions (50MB+ network traffic just to subscribe), you're better off downloading full blocks and filtering them in your own software. Run behind a full node - this is safe and cheap. Just remember which blocks you've read to catch up after downtime. This approach scales much better than individual address subscriptions.\"},{\"q\":\"How does BitCANN remember which domains have been claimed?\",\"a\":\"BitCANN doesn't store domain state on-chain - the contract doesn't 'remember' anything. Instead, the real domain UTXO can terminate anyone's UTXO trying to add the same name again. State management is delegated to external agents who use the incentive system to penalize invalid/illegal auctions. The existence of an 'ExternalAuthNFT' from a Domain contract proves ownership. Each TLD (.bch, .xyz) gets its own category ID, and multiple people could launch competing instances for the same TLD - resolution happens off-chain through reputation.\"},{\"q\":\"How do I subscribe to Chaingraph using GraphQL in TypeScript?\",\"a\":\"Check out github.com/mr-zwets/chaingraph-ts for TypeScript examples of Chaingraph GraphQL subscriptions. It shows how to set up real-time subscriptions to monitor mempools, transactions, and other blockchain data using the Chaingraph API at demo.chaingraph.cash/v1/graphql.\"},{\"q\":\"How do I integrate CashScript with WalletConnect?\",\"a\":\"Use the `generateWcSourceOutputs` utility function to convert a CashScript transactionBuilder to a WalletConnect object in 4 lines: 1) Build the unsigned tx hex, 2) Decode the transaction using libauth's decodeTransaction, 3) Call generateWcSourceOutputs with the builder inputs and decoded tx. See github.com/CashScript/cashscript/issues/191 for the complete implementation and the suggested utility function.\"},{\"q\":\"How is the dust limit calculated in BCH?\",\"a\":\"The dust limit formula is: `dust_limit = 444 + output_size * 3`. The dust limit doesn't change with VM limits. However, for practical safety with CashTokens, most wallets and dApps use a fixed amount: Electron Cash uses 800 sats, many dApps use 1000 sats, and General Protocols uses 1332 sats to support old-school P2MS scripts. The 546 sat figure commonly cited is only for standard P2PKH outputs. libauth has a function for calculating the exact amount per output.\"},{\"q\":\"Can CashTokens be frozen or seized by the issuer?\",\"a\":\"By default, no - once CashTokens are sent to someone's P2PKH address, the issuer cannot seize them. To enable freeze/seize functionality, tokens would need to remain in a smart contract rather than being sent directly to wallets. In that model, users wouldn't be exclusive owners - they'd have 'privilege' to transfer their portion, privilege that could be revoked by an admin key. This is why BCH may not qualify for some regulated stablecoin frameworks that require freeze/seize capabilities.\"},{\"q\":\"How does having a P2SH ancestor affect 0-conf reliability?\",\"a\":\"A 0-conf P2SH ancestor (contract transaction) makes descendant P2PKH 0-conf less reliable. If two users race to spend the same contract UTXO (like a DEX pool), both create valid transactions but only one wins. The loser's descendant chain (their change outputs used in subsequent txs) becomes invalid when the other tx gets mined. This is a fundamental UTXO contention issue - the 0-conf of contract outputs affects all transactions built on top of them.\"},{\"q\":\"How does using DeFi affect my 0-conf payments to merchants?\",\"a\":\"If you do DeFi actions (which are P2SH/contract transactions), you end up with a chain of 0-conf P2SH transactions. When you then pay a merchant with the proceeds, your P2PKH payment has 0-conf P2SH ancestors - giving it a DSP score of 0. The merchant may demand 1 confirmation. With 10-minute blocks, there's only ~0.5% chance your DeFi chain confirms during the gap between DeFi and checkout. With faster 1-minute blocks, your DeFi would likely confirm before you finish shopping, and the merchant would see a clean P2PKH with full DSP coverage.\"},{\"q\":\"How can DEX pools avoid UTXO contention and race conditions?\",\"a\":\"Several approaches: 1) Each pool requires a co-signature from a managing node that ensures it doesn't sign the same UTXO twice - permissionless but sequenced, 2) Multiple independent 'micro LPs' managed by different entities can be aggregated by services, 3) Pools can use bid contracts where users submit bids and batchers/sequencers fill them. The tradeoff is between fully permissionless (anyone can interact, but race conditions occur) and lightly permissioned (signature needed, but no races). A good middle ground: open signing - 'give me a TX and I'll fill in the sig, ensuring I don't sign the same UTXO twice'.\"},{\"q\":\"What is Small Index and how does it help DEX pool discovery?\",\"a\":\"Small Index (bitcoincashresearch.org/t/a-small-key-value-index-contract/1471) is an on-chain key-value index that can tag multiple protocols per token category. It was designed for CatDex but could handle Cauldron, TapSwap, and Dutch auctions. It solves the problem of SPV wallets finding pools - if pools advertise using this method, wallets can discover them without relying on centralized servers. Pool operators would presumably use it since it increases their volume.\"},{\"q\":\"What improvements were made to multisig and contract signing on BCH?\",\"a\":\"Schnorr multisig uses the same OP_CHECKMULTISIG but with smaller signatures. OP_CHECKDATASIGNATURE can be used in multi-party setups for 'opening a gate' in contracts (e.g., cross-chain swaps), and before 2022 it was used to emulate transaction introspection. The 2022 upgrade introduced native tx introspection opcodes, so contracts can now directly commit to and verify future spending transaction contents.\"},{\"q\":\"How do I debug P2SH scripts that work in Bitauth IDE scenarios but fail when broadcast?\",\"a\":\"Several approaches: (1) Use CashScript's bitauthURI method on the Transaction builder to generate a URL you can inspect in the IDE. (2) Manually create a contract artifact without using the CashScript compiler, then use the TransactionBuilder and mocknet environment (example: github.com/mr-zwets/Cauldron_Swap_Test). (3) Check that your script evaluates to a non-zero value on the stack (not just empty). (4) Consider using cashlab (github.com/hosseinzoda/cashlab) which uses straight bitauth templates with tests. A common issue is scripts evaluating to empty stack instead of '1' or another truthy value.\"},{\"q\":\"Can CoinJoin be used for trading on BCH with CashTokens?\",\"a\":\"Yes! With CashTokens, CoinJoin techniques can be used for trading, not just mixing coins. Previously, CoinJoin was only used for privacy/mixing since UTXOs only held BCH. Now that UTXOs can hold BCH + tokens, you can use the CoinJoin technique (combining multiple inputs and outputs in a single transaction) to atomically trade tokens. With introspection/OP_CHECKDATASIGNATURE, contracts can enforce '<=' requirements rather than just '==' like SIGHASH_SINGLE allows.\"},{\"q\":\"How can I look up a P2S (Pay-to-Script) address on a block explorer?\",\"a\":\"Block explorers like 3xpl and Blockchair support a 'script-' address format where the address is the first 32 hex characters of the SHA256 hash of the output script. You can generate the URL using this shell script: `hex=0xAC; echo \\\"https://3xpl.com/bitcoin-cash/address/script-\\\"$(echo -n $hex | sed -s 's/^0x//' | tr 'A-F' 'a-f' | sha256sum | cut -b 1-32)`. This is similar to how Fulcrum indexes scripts by their hash.\"},{\"q\":\"Can BCH transactions have multiple OP_RETURN outputs?\",\"a\":\"Yes, BCH supports multiple OP_RETURN outputs in a single transaction (since the May 2019 upgrade). The total combined size across all OP_RETURN outputs must still be 220 bytes or less. This allows protocols to use multiple smaller OP_RETURN outputs without consolidating everything into one. See flowee.org/docs/spec/forks/multiple-op-returns-for-bitcoin-cash/ for details.\"},{\"q\":\"What is static analyzability in BCH scripts and why does it matter?\",\"a\":\"Static analyzability means being able to know what code will execute in a script before actually executing it. With proposals like OP_EVAL that can execute arbitrary stack data, static analysis becomes harder. One solution is adding an 'executable' bit to stack items - only items pushed verbatim get the bit, and operations like OP_ADD clear it, then OP_EVAL can only execute items marked executable. Trade-offs: static analyzability helps contract analysis and blockchain metrics but reduces chainanalysis resistance (which some consider a privacy benefit).\"},{\"q\":\"How can I verify code in OP_EVAL scripts comes from a trusted source?\",\"a\":\"Even with OP_EVAL as-is, you can verify code provided in unlocking data: use `OP_DUP OP_SHA256 <expected blob hash> OP_EQUALVERIFY OP_EVAL`. This hashes the provided code and verifies it matches the expected hash before executing. For code from NFT commitments, you can authenticate against the NFT's commitment value. Without verification, a locking script of just `OP_EVAL` is functionally an anyone-can-spend script since anyone can push `0x51` (OP_1) as unlocking data.\"},{\"q\":\"Where can I find the authoritative specification of BCH scripting language?\",\"a\":\"The primary reference is documentation.cash/protocol/blockchain/script.html which contains the full BCH script specification. For a higher-level approach, use CashScript (cashscript.org) which compiles a more readable syntax into the actual Script opcodes.\"},{\"q\":\"What are the current standardness rules (relay limits) that differ from consensus on BCH?\",\"a\":\"The 5 main standardness issues that differ from consensus: (1) max contract size, (2) max tx size, (3) max OP_RETURN size (220 bytes), (4) dust threshold, (5) output standardness (P2PKH/P2SH only). P2S addresses would resolve 2 of these. There's ongoing discussion about closing the gap between relay and consensus rules - either by making relay limits into consensus rules, or by relaxing them.\"},{\"q\":\"What are common security mistakes in BCH smart contracts?\",\"a\":\"A critical mistake is checking signatures against pubkeys provided in the input without authenticating them. TapSwap almost blew up because it checked sig against pubkey provided in input but without authenticating it via a committed hash - anyone could have provided their own pubkey and signature to unlock funds. Rule: any data provided in the unlocking script (input) that affects contract logic MUST be authenticated against values committed in the locking script, typically via hash comparison.\"},{\"q\":\"Can contracts allow dynamic code execution approved by an authority after the UTXO is created?\",\"a\":\"Yes! With OP_CHECKDATASIGVERIFY + OP_EVAL, you can create scripts where the bytecode to execute must be signed by a specified key. Example redeem script: `OP_TUCK <pubkey> OP_CHECKDATASIGVERIFY OP_EVAL`. This unlocks with `[...data pushes...] <sig> <bytecode> <redeem>`. This pattern allows a master key holder to approve alternative spending methods AFTER UTXOs are created, without requiring users to re-spend their UTXOs. This type of flexible multisig/oracle logic is possible today with VM limits.\"},{\"q\":\"What applications does OP_EVAL enable that wouldn't be possible otherwise?\",\"a\":\"OP_EVAL enables cryptography on the stack and Zero-Knowledge Proofs (ZKPs) in script which wouldn't be possible to express within VM limits without the 100x to 1000x bytecode compression that EVAL provides. It's not just about 'saving bytes' - contracts like Groth16 ZKP verification simply wouldn't fit within script limits without function reuse. The benefit is enabling an entirely new category of applications, not just efficiency improvements.\"},{\"q\":\"How can I debug BCH smart contract transactions?\",\"a\":\"Several debugging tools are available: (1) tx-debugger-4e98d2.gitlab.io - a general-purpose tx debugger that generates Bitauth IDE templates for any transaction, (2) meep (github.com/gcash/meep) - command-line tool to execute and debug transactions: `meep execute --tx=<txid> -i <input_index>`, (3) Bitauth IDE (ide.bitauth.com) - visual step-through debugger for script execution. CashScript also provides a bitauthURI method to generate IDE links from transaction builders.\"},{\"q\":\"Which JavaScript/TypeScript library should I use for BCH frontend development?\",\"a\":\"Several options depending on your needs: (1) Libauth - the most comprehensive BCH library for TypeScript, handles everything including CashAddr validation, (2) mainnet-js - easier to work with if Libauth seems tricky, good for rapid development, (3) minimal-slp-wallet - used by the open-source PSF wallet at wallet.psfoundation.info, built on the Cash Stack backend infrastructure. For address validation specifically, all three support CashAddr.\"},{\"q\":\"Is there a standard P2NFT script pattern for NFT-owned UTXOs?\",\"a\":\"There's no consensus 'standard' yet, but a compact pattern exists: `OP_DUP OP_UTXOTOKENCATEGORY OP_SWAP OP_UTXOTOKENCOMMITMENT OP_CAT OP_HASH160 <x> OP_EQUALVERIFY` where x is hash160(categoryId || commitment). The unlocking script pushes the input index where the NFT is placed. Wallets supporting this would scan for P2SH addresses derived from NFTs in the wallet - similar to how HD wallets scan P2PKH addresses from pubkeys. The wallet generates the expected script hash for each NFT it holds, then queries Electrum for matching UTXOs.\"},{\"q\":\"What security issues exist with NFT-owned UTXOs?\",\"a\":\"The NFT UTXO itself must verify the whole transaction. If the NFT is spent with SIGHASH_SINGLE (or similar), a third party could add more inputs owned by the NFT and redirect those funds. The NFT spending contract must commit to all inputs/outputs to prevent this attack. Always ensure your NFT contract validates the complete transaction, not just a subset.\"},{\"q\":\"Can I use half the category ID for cheaper donation addresses?\",\"a\":\"You only need 2^128 entropy (half the 256-bit category ID) if YOU generate the category/NFT yourself. But if you're given an NFT by someone else, they could have pre-computed a colliding pair, so you'd want the full 2^256 entropy. For self-generated donation addresses: `<0> OP_UTXOTOKENCATEGORY <16> OP_SPLIT OP_DROP <half_categoryID> OP_EQUAL` - this allows sweeping 1000s of UTXOs with just 1 signature.\"},{\"q\":\"Does Libauth work on backend Node.js or just frontend?\",\"a\":\"Libauth works great on backend too. Use modern Node (v22+ LTS) with standard ESM settings. If having issues, try deno or bun as alternatives. Node issues are usually tsconfig settings. The 'tsx' library (npm package) is recommended as a wrapper around Node for running TypeScript - it handles ESM much better than ts-node and 'just works' in most cases.\"},{\"q\":\"Are LLMs reliable for writing novel BCH smart contract code?\",\"a\":\"LLMs are language models that translate ideas into code, but struggle with world models and logical structure. They're bad with stuff not already done thousands of times. For novel code like ZK rollups on BCH: (1) stuff as much *relevant* context (code examples, docs) into the prompt as possible, (2) use large context windows (32K+ tokens), (3) have one AI generate code and another AI critique it. LLMs give contradictory answers depending on context, they just play along with whatever premise you give them - you decide what is true.\"},{\"q\":\"Does Blockbook have real-time subscriptions or just polling?\",\"a\":\"Blockbook has a WebSocket API with subscriptions for real-time updates. You can subscribe to new blocks, address changes, and transaction events. The REST API is for one-off queries, while the WS API handles live notifications - similar to how Electrum works with its subscription system.\"},{\"q\":\"How can hardware wallets like Trezor identify contract types in DeFi transactions?\",\"a\":\"BCHN is adding a 'patterns' RPC that exposes script template identification. This will let indexers like Blockbook detect which known contract types are involved in a transaction. When integrated, Trezor could display meaningful information like 'This is a CashTokens swap' instead of just showing raw script hashes. See the BCHN merge request for details.\"},{\"q\":\"Can BCH's big math opcodes handle elliptic curve operations?\",\"a\":\"The May 2025 big math upgrade is good for calculations like interest rates, but EC operations would be extremely costly to emulate in script. You'd need loops for field inversion and curve equation checks, plus verification that points actually lie on the secp256k1 curve (y²=x³+7 mod p). An attacker could submit invalid points otherwise. With loops and OP_EVAL, EC routines could be defined once and reused, but native EC opcodes would be far more efficient.\"},{\"q\":\"Why add native EC opcodes when CHECKDATASIG can attest to ZK proofs?\",\"a\":\"Using CHECKDATASIG for ZK proof validation requires trusting a third party to verify the proof off-chain and sign an attestation. Native elliptic curve opcodes would allow on-chain proof validation without that trust layer. The goal is trustless ZK proof verification where the BCH script itself validates the math, not relying on an external party's signature.\"},{\"q\":\"How does contract discoverability affect wallet backups?\",\"a\":\"Today's model is deterministic: derive keys from seed entropy, derive lockscripts from keys, find funds locked by those lockscripts in the UTXO set. With arbitrary contracts, this determinism breaks and single-seed backups may no longer work. On-chain discoverability proposals have privacy costs and only work for wallets that implement them. It may be time to rethink what a world without deterministic discovery looks like - banks can't do seed recovery either and they function fine.\"},{\"q\":\"Why do generic contract discovery protocols have poor UX?\",\"a\":\"Generic solutions that try to work for any contract type result in generic UX that can't be used by many wallets. Better approach: have actual products where contract devs work directly with front-end/wallet devs for specific integrations. When you have that collaboration, discovery becomes easy - just build GUI specifically for one or two contracts. The best UX comes from specific implementations, not universal protocols.\"},{\"q\":\"Can I store more than 220 bytes of data on-chain by using inputs instead of OP_RETURN?\",\"a\":\"Yes. Use OP_DROP at the start of your redeem script, then push arbitrary data before the redeemScript in your unlock: `<signature> <publicKey> <arbitrary_data> <redeemScript>`. The script drops the data and proceeds with normal validation. This bypasses the ~220 byte OP_RETURN limit and can be used for storing template parameters, audit data, etc. Downside: requires creating an initial contract UTXO first.\"},{\"q\":\"How should we approach proposing new opcodes for ZK proofs?\",\"a\":\"Don't propose opcodes as the first step - that's wishful design that often fails. Instead: (1) modify a full node privately, (2) make the actual ZK script work completely, (3) test thoroughly until it's not instantly hackable, (4) then propose what was actually needed. What if one step is too expensive? What if ZK is irrelevant for your use case? What if something fails you haven't thought of? Build first, propose second.\"},{\"q\":\"Can BCH NFTs be used for event tickets or lottery systems?\",\"a\":\"Yes. Flow: participants provide BCH address, issuer mints NFT with unique commitment (date + sequence number). To redeem, transfer NFT back to issuer (like an admission slip). NFTs can be traded on marketplaces like Cauldron, via TapSwap auctions, or even peer-to-peer in person. No smart contracts needed for trading - just transfer the asset between wallets. Similar to concert ticket use case.\"},{\"q\":\"What is the scope of DSProof protection?\",\"a\":\"DSProof is a merchant tool, not a safety system. It's opt-in and covers most real-life P2PKH transactions. Merchants can decide to only accept P2PKH for instant 0-conf, requiring confirmation for P2SH spends. Wallets can implement this default. Double-spends require special software - they don't happen accidentally. DSP detects P2PKH double-spend attempts within ~1 second, but P2SH scripts are not covered.\"},{\"q\":\"What's a good Python stack for BCH payment integration?\",\"a\":\"Use pybitcash (bitcash.dev) - it's well maintained by a reputable developer. For indexing, Fulcrum is best-in-class. Use blockchain.address.get_mempool to detect 0-conf transactions in the mempool for fast payment confirmation. Long-term, libauth (currently TypeScript) may get Rust bindings with Python wrappers. For reference, check minisatoshi.cash for alternative service options.\"},{\"q\":\"How do I fund a CashScript contract?\",\"a\":\"Use Contract.address to get the contract's P2SH address, then send funds to it from any wallet. Important: make sure you're on the correct network - chipnet and testnet4 and mainnet have different address prefixes. If getBalance() shows 0 but explorer shows funds, you're likely querying the wrong network. The contract address is derived from the redeem script hash - same script with different constructor args gives different addresses.\"},{\"q\":\"How does the UTXO model differ from EVM for smart contracts?\",\"a\":\"Think of UTXOs as individual cash bills. Each bill has a 'locking script' - a codified checklist of constraints. Key difference: EVM code encodes actions on accounts; UTXO code encodes limitations. **Anything not constrained is allowed** - this is the root of footguns. P2PKH constrains: signature required + pubkey hash must match. With introspection opcodes you can add constraints like '50% must go to address A'. But if you don't constrain the other 50%, it goes wherever the transaction creator decides.\"},{\"q\":\"What's a major security footgun with UTXO contracts?\",\"a\":\"If not constrained, all UTXOs for a contract can be spent in one transaction, and value from one UTXO can satisfy constraints for ALL inputs. Example: contract requires '1000 sats to address X as first output'. Attacker spends 10 contract UTXOs in one tx - that single 1000 sat output satisfies all 10 inputs, attacker keeps 90% of the value. Solution: constrain based on the input's own value, not fixed amounts, or use per-input verification patterns.\"},{\"q\":\"Should I use chipnet or testnet4 for BCH development?\",\"a\":\"Chipnet is recommended by default - it has better tooling, explorers, and faucets. It upgrades 6 months before mainnet to test upcoming features. Testnet4 is the conservative general-purpose testnet. For time-based contracts (timelocks, etc.), use regtest - you can mine blocks on demand to simulate time passing. Some devs test directly on mainnet with small amounts for final validation.\"},{\"q\":\"How is a CashScript contract address derived?\",\"a\":\"The contract address is the hash160 (for P2SH20) or hash256 (for P2SH32) of the redeem script, encoded with the network prefix. Same contract code with different constructor arguments produces different addresses. If your address isn't consistent between runs, check that constructor args (pubkeys, timestamps, etc.) are identical. You can verify by deriving the address manually from the compiled bytecode.\"},{\"q\":\"Why does contract.getBalance() return 0 when explorer shows balance?\",\"a\":\"Network mismatch - your app is querying a different network than you funded. Common causes: (1) chipnet vs testnet4 confusion, (2) Electrum server not synced or offline, (3) expired SSL certificate on server. Debug by verifying the address matches across your code and explorer. Use `npm install cashscript@next` for updated chipnet servers. You can specify custom servers: `new ElectrumNetworkProvider('chipnet', 'chipnet.bch.ninja:50004')`.\"},{\"q\":\"Can I use CashScript from Python without npm/TypeScript?\",\"a\":\"Yes. mainnet.cash provides a REST API with built-in escrow contracts, and you can evaluate general CashScript contracts through it. There's a maintained Python API at github.com/mainnet-cash/mainnet-python-generated. This lets you call CashScript features from Python without touching npm. You can also call the CashScript compiler separately and use the bytecode with any library.\"},{\"q\":\"Does BCH script use two's complement or sign-magnitude for numbers?\",\"a\":\"Stack items use 'Script Numbers' which is sign-magnitude encoding (sign bit in the high bit of the last byte). Other protocol parts differ: opcode parameters use unsigned int, C++ implementation uses two's complement for signed ints. The 2022 8-byte integer upgrade excluded one value (-2^63) that fits in 8-byte two's complement but needs 9 bytes in script number format. With the 2025 big integers upgrade, you can operate on values up to 10000 bytes.\"},{\"q\":\"Where can I find advanced CashScript examples beyond the docs?\",\"a\":\"Several sources: (1) Emerald DAO project at 0353f40e.gitlab.io/emerald-dao/, (2) awesomebitcoin.cash/#script for curated script resources, (3) Bitcoin Cash University YouTube channel with tutorials on contracts like Badgers and FundMe, (4) cashscript.org/docs/showcase for production projects. You can submit PRs to add your projects to these lists.\"},{\"q\":\"Should I use mainnet-js or libauth for my BCH project?\",\"a\":\"Depends on needs. mainnet-js: automatic UTXO selection, automatic change outputs, easiest for simple BCH/token sends. Bundle is now 270 kB gzipped (down from 737 kB). But has bundler/webpack compatibility issues. libauth + cashscript: lighter combo, no bundler headaches, but more manual work. If you don't need wallet functionality or ElectrumX, pure libauth is cleanest. Many devs prefer libauth + cashscript as their SDK combo.\"},{\"q\":\"How can I prove I created something at a specific date on BCH?\",\"a\":\"Put a hash in OP_RETURN - this has worked since 2009. Services like memo.cash let you easily write hashes/messages to the chain. TokenTiger.com evolved from document attestation. The main use case is defensive: create 'prior work' so nobody can later claim IP over useful stuff. Some early Bitcoiners used document hashes as public keys and sent funds there (unprunable attestation). There's little commercial market for pure attestation, but it's useful as a component in larger applications.\"},{\"q\":\"What are the trust concerns with proposed BCH ZK rollups?\",\"a\":\"Current proposals rely on validator multisig where 2-of-3 validators could collude to take all funds. Without native ZK proof verification (like BitVM provides for BTC), you need trusted parties. The 'challenge' mechanism relies on stake penalties, but if money is gone, challenges are worthless. The bigger issue is lack of native verification for commitment proofs themselves. Current staking models exist because there's no BitVM equivalent on BCH yet. Building prototype first before proposing opcodes is recommended.\"},{\"q\":\"What's new in CashScript v0.11.0?\",\"a\":\"Major release with debugging capabilities for the transaction builder - you can now use mocknet and Bitauth IDE for local testing/debugging. This greatly improves developer experience. The release was in development for over half a year with multiple pre-releases to iron out edge cases. Contains breaking changes, check the migration-notes on cashscript.org. Rosco's Bliss talk covers the new features and capabilities.\"},{\"q\":\"How do time-based locks work with MTP (Median Time Past)?\",\"a\":\"MTP lags behind real time by ~1 hour by design (median of last 11 blocks). For OP_TXLOCKTIME contracts, nLocktime is validated against MTP, not wall clock time. To calculate MTP: get last 13 block headers via Fulcrum, decode timestamps, take the median. Your contract logic will lag with MTP. There's no concept of 'now' in contracts - answering 'now' trustlessly is hard. You can account for offset in script by adding ~330 seconds to approximate.\"},{\"q\":\"Can a transaction with future lock-time enter the mempool?\",\"a\":\"No. A tx with lock-time in the future will not be accepted in the mempool. You can assume in script that the lock time is always in the past (relative to MTP). The node validates nLocktime against MTP before accepting the transaction. This means you can't pre-broadcast time-locked transactions - they must wait until MTP passes the lock-time.\"},{\"q\":\"How does tokenaut.cash track DeFi TVL and contract transactions?\",\"a\":\"It depends on the particular contract. Some contracts have OP_RETURN markers that identify their type. Some have constant addresses that can be monitored. Some can be tracked by NFTs that they emit (like Furu's wrapped tokens using minting NFTs). There's no universal method - each contract type has its own identification pattern. The BCHN 'patterns' RPC will help explorers detect known contract templates.\"},{\"q\":\"Can contracts have mutable parameters stored in NFT commitments?\",\"a\":\"Yes. A contract can store current benefactor/parameters in an NFT commitment and let authorized parties mutate state with a signature. With OP_DEFINE, you can get NFT commitment via introspection, define a program from it, and invoke it. Security caveat: invoked code has access to full stack (no stack isolation). To use safely: (1) ensure stack is empty before invoking, (2) verify expected number of return items. This enables 'upgradable' contracts where spending paths change without moving funds.\"},{\"q\":\"Why consider reducing BCH block time from 10 minutes?\",\"a\":\"Multi-coin wallets don't implement 0-conf properly for BCH - they wait for confirmation, making BCH seem slow. With 1-minute blocks, even if wallets wait for 1 confirmation, it's still fast. This prevents losing potential users to bad experience. Native BCH wallets handle 0-conf fine via DSProof, but we can't control external wallet behavior. The 10-minute time was arbitrary in the original design. Faster blocks also improve DeFi UX for contracts requiring confirmations.\"},{\"q\":\"What are MEV (Miner Extractable Value) contracts on BCH?\",\"a\":\"Contracts using anyone-can-spend transactions that pay small 'gas fees' claimable by anyone. Example: unspent.cash perpetuity payments where monthly installment transactions can be built by anyone using only introspection logic, no signatures. Dozens of such contracts exist. AMM contracts like Cauldron are incompatible with zero-conf because multiple users/bots can compete for the same UTXO. See bitcoincashresearch.org for a catalog of MEV contracts.\"},{\"q\":\"Would faster blocks break existing block height-based timelocks?\",\"a\":\"No. The approach: height locktime would continue to be based on 10-min chunks, so nothing breaks. Legacy contracts use block heights that map to 10-min equivalents post-upgrade. A new locktime field would be needed for contracts wanting increased height precision (1-min resolution). MTP-based timelocks remain unaffected. The CHIP draft documents these compatibility measures.\"},{\"q\":\"Are there libraries for BCH DeFi trading without using DEX websites?\",\"a\":\"Yes. VegaBCH (github.com/hosseinzoda/vegabch) is a library for doing DeFi that doesn't require using the primary DEX websites. Trading bots already use these libraries today. This enables programmatic trading and arbitrage without relying on any centralized frontend. The contracts themselves are on-chain and accessible by anyone.\"},{\"q\":\"Are complex MEV-resistant DEX designs better than simple anyone-can-spend AMMs?\",\"a\":\"Not necessarily. Simple anyone-can-spend AMMs work today in production - Cauldron and Moria have ~1k BCH TVL. There are 0 deployments of complex queuing systems. Complexity is the enemy of security. Ease of development and deployment is BCH's advantage. Even if you build a queuing AMM, faster blocks would still improve it. Like introspection opcodes - we had covenants with CHECKDATASIG but added introspection because it makes everything easier.\"},{\"q\":\"Is decentralization always the goal for crypto projects?\",\"a\":\"No - decentralization is a means to an end, not a goal itself. It's a gradient where the extremes are clear but everything else depends on purpose. A practical goal might be: 'avoid government or other big company being able to control my stuff.' In DeFi context, decentralization means reducing rug-pull risk by the LP. Some centralization is valuable today (like Cauldron using centralized signing for MEV protection), but BCH is one of the few chains where fully trustless, non-custodial, decentralized contracts are possible.\"},{\"q\":\"Does formal verification require immutable state?\",\"a\":\"No, formal verification has no relation to mutable vs immutable state. When people bring up 'formal verification' concerns about proposals like OP_EVAL, they rarely go into details about what specifically they're looking for. Without concrete requirements, it's hard to evaluate whether a proposal helps or hinders formal verification. The debate often becomes vague hand-waving on both sides.\"},{\"q\":\"What is the @bch-wc2 connector for CashScript projects?\",\"a\":\"The @bch-wc2 connector packages provide a unified interface for CashScript-based projects that works identically for both privkey-based apps and WalletConnect2-based keyless apps. This erases the border between local development (with private keys) and web deployment (using wallet connections). The mainnet-js and CashScript extensions work seamlessly with these connectors to share the same development flow locally and on web.\"},{\"q\":\"How can recurring/subscription payments work in BCH without a middleman?\",\"a\":\"Use xpub instead of single address. The receiver sends an xpub in the payment request. The payer's wallet stores that xpub and pays to the next derived address each month automatically. No server middleman needed - the wallet handles derivation locally. This is privacy-friendly (new address each payment) and only needs one-time setup. Flowee Pay has implemented serverless repeated payments this way.\"},{\"q\":\"What are the tradeoffs between push and pull payment schemes for subscriptions?\",\"a\":\"Push (sender initiates): Lower trust requirements, sender keeps full control, but relies on sender being present/available and provides less info to receiver about future payments. Over millions of users, there will be missed/late payments. Pull (receiver initiates): Allows receiver to take action (stronger incentive), can see insufficient funds and send reminders, but leaks more information and typically requires oracle for fiat-denominated amounts. Pull can be done trustlessly using vault + NFT authorization tokens, but private pull is harder to achieve.\"},{\"q\":\"Why are recurring payments important for BCH adoption?\",\"a\":\"Most people spend ~80% of their value in recurring payments (by volume). Having recurring payments that work 'in the wild' would be a major step up from where BCH is today. This includes rent, subscriptions, loan payments, etc. Solutions need to handle: fiat denomination (oracle needed), missed payment handling, and cancellation flows. Physical goods subscriptions add complexity with delivery skipping, discounts, and inventory management.\"},{\"q\":\"How do revocable token annuities work for subscriptions?\",\"a\":\"The subscriber locks funds in a contract that releases payments on a schedule (e.g., monthly). The payments are 'anyone-can-spend' after timelock, so the service or anyone can submit them. The subscriber holds an NFT that lets them cancel - spending the NFT drains remaining funds back to the subscriber. This allows pull-style automatic payments while giving the subscriber a clear revocation mechanism. See 'Unspent Phi v3' timelocking token-aware contracts for implementation details.\"},{\"q\":\"Can one subscription vault serve multiple services?\",\"a\":\"Yes - you could have one 'streaming account' vault where Netflix, Spotify, etc. can each pull their specific amounts at their specific intervals. This is achieved by issuing multiple NFT authorization tokens (one per service) from the same vault. Each NFT encodes the service's allowed pull amount and interval. This is more practical than maintaining separate vaults per service. The vault holder controls which services have keys.\"},{\"q\":\"Can recurring payments avoid oracles for fiat amounts?\",\"a\":\"Yes, multiple approaches: (1) Use stablecoins like MUSD/PUSD instead of BCH - contract pulls fixed stablecoin amount, (2) User sets maximum sats allowed per pull (adjustable by user over time), (3) Push model with user confirmation - wallet shows pending payments with calculated fiat values, user clicks 'Pay All' only if amounts match expectations. The push confirmation model adds one click but eliminates all oracle trust.\"},{\"q\":\"Is there market demand for BCH-denominated subscription services?\",\"a\":\"Based on 3+ years running the largest monthly recurring payment protocol on BCH, there's zero market demand for coin-denominated subscriptions. Users want fiat-denominated payments. This is why stablecoins (MUSD, PUSD) are important - the unspent annuities protocol can work with any CashToken, so anyone can create monthly annuities denominated in their preferred stablecoin with withdrawals/cancellations.\"},{\"q\":\"With BCH Functions CHIP, can I execute a script from a neighboring input as a function?\",\"a\":\"Yes, you can define a script pushed as data in a neighboring input as a function and execute it in the context of the current script. Using OP_RETURN outputs to store reusable function code would require a separate 'read-only inputs' extension - OP_RETURNs can never be inputs since they're unspendable, but the concept of referencing without spending is interesting for future proposals.\"},{\"q\":\"What are read-only UTXOs and why are they problematic?\",\"a\":\"Read-only UTXOs (from TXv5 proposal) are inputs that don't get spent when referenced in a transaction. The idea allows reading data/code from UTXOs without consuming them. Problems: (1) Breaks current assumption that NFTs spent as input without appearing in output are burnt - could break existing contracts, (2) UTXO set pollution since they never get cleaned up, (3) Introduces global state which hurts scaling. The concept is interesting but this specific design is flawed.\"},{\"q\":\"Why are anyone-can-spend subscription contracts more robust than app-based push?\",\"a\":\"If a subscription contract is public and anyone-can-spend (after timelock), then any of 5B+ phone users worldwide can earn a few thousand sats by executing the scheduled payment. This hyper-redundant approach is far more robust than relying on one phone's background sync or Push API (which browsers break in unique ways). Apple and Google actively obstruct payment mechanisms that threaten their revenue, making app-based solutions fragile. The trustless on-chain approach is envied by devs in other ecosystems.\"},{\"q\":\"Is BCH's scheduled payment capability unique compared to EVM chains?\",\"a\":\"Yes. You can't hardcode an MEV executor fee and expect it to work long-term on EVM chains due to volatile gas costs. While EVM chains have 'click button to execute scheduled transaction' patterns, those are typically for one-time MEV fees (unlock, swap, mint). BCH uniquely enables fire-and-forget recurring payments for years or decades with no set executor - the combination of script introspection + permanently low fees doesn't exist elsewhere. BU's EVM project might be the only other chain where BCH-style recurring payments could work.\"},{\"q\":\"How should I generate cryptographic random numbers in JavaScript?\",\"a\":\"Don't use Math.random() for generating keys, seeds, or R values - it's predictable and could lead to people guessing your seed. Use the Web Crypto API's crypto.getRandomValues() instead. Note: this requires HTTPS/secure context (SSL connections). For Node.js, use the crypto module's randomBytes(). The key requirement is that the random source be cryptographically secure (CSPRNG), not just statistically random.\"},{\"q\":\"Does BCH have its own WalletConnect standard?\",\"a\":\"Yes, BCH has its own wallet connection standards independent of the Reown/WalletConnect network. The WalletConnect network is permissioned and has its own token, which doesn't align with BCH's permissionless philosophy. BCH wallets use different connection protocols, and there are WC2-compatible packages (@bch-wc2) that provide unified interfaces for CashScript-based projects, allowing the same code to work with both local development (private keys) and web deployment (wallet connections).\"},{\"q\":\"What are the benefits of using libauth templates for DeFi modules?\",\"a\":\"The vox/unspent library architecture uses libauth templates with helper functions to build transactions, with libauth doing all the heavy lifting (no CashScript SDK). This makes modules portable - each is just a template and about a page of helper code. The templates could potentially be integrated into other wallets like Flowee Pay or Electron Cash once libauth-style libraries are available in those ecosystems. This enables cross-DEX functionality like getting real-time quotes across multiple protocols in a single transaction.\"},{\"q\":\"How do NPM supply chain attacks affect crypto wallets?\",\"a\":\"NPM package compromises are becoming a serious problem - phishing emails have compromised many projects recently. For crypto wallets, attackers can inject code to steal private keys or drain funds. Mitigations include: (1) Pin exact package versions (not just major.minor), (2) Run dev environments in Docker containers, (3) Use scripts to check lockfiles for known compromised package+version combinations, (4) AI-based package scanners are emerging. NPM can remove affected versions once reported.\"},{\"q\":\"Is UTXO model more secure than EVM account model?\",\"a\":\"From a practical attack surface perspective, yes. In EVM/Web3, blind signing is routine - unless you constantly check approvals, wallets can be emptied through previously-approved malicious contracts. There are 'infinite attack vectors.' In UTXO model, each transaction explicitly lists inputs and outputs - you can't approve unlimited future spending. The UTXO model has fewer ways for attackers to exploit previously-granted permissions.\"},{\"q\":\"Who should verify contract templates for safety?\",\"a\":\"Normal users can't tell if a template will rug them - they're still 'blindly trusting things.' The practical solution is trusted verification by wallet makers. Your wallet trusts templates approved and verified by its development company and refuses to use unapproved templates. This moves trust to wallet makers, which works because reputation is a well-understood concept. Users naturally trust their wallet already.\"},{\"q\":\"Why is Solidity compared to JavaScript for security concerns?\",\"a\":\"Solidity is 'the JavaScript of the blockchain world' - low barrier to entry means super high adoption, but it's hard to cover everything that can go wrong. The drive to ship quickly means security corners get cut. In EVM, even with hardware wallets like Ledger, blind signing is routine. Cold storage coins mixed with blind signing creates dangerous combinations. Unlike BCH/BTC where users don't sign smart contracts constantly, EVM culture requires continuous interaction (staking, yield farming, trading), multiplying risk exposure.\"},{\"q\":\"What changed between transaction version 1 and version 2?\",\"a\":\"Transaction version 2 only changed the interpretation of the nSequence field, not the transaction format itself. It was introduced via a soft fork (BIP68). To use the relative timelock opcodes that interpret sequence data, you must set the transaction version to 2. The format is identical otherwise - 'it's all a bit fucked up now' because they didn't change the actual structure, just the meaning of one field. See reference.cash/protocol/forks/bip-0068 for details.\"},{\"q\":\"How do BCH covenants solve multisig malleability for atomic swaps?\",\"a\":\"In multisig, either party can re-roll their signature to change the txid, breaking any descendant transaction that depends on the exact parent txid. BCH covenants solve this the SIGHASH_NOINPUT/SIGHASH_ANYPREVOUT way: descendant transactions commit to the *contents* of parent TXs without committing to specific prevout txids. If an ancestor's txid changes, you simply update the descendant's prevout reference and it remains valid. This enables BCH-XMR atomic swaps using covenants instead of multisig.\"},{\"q\":\"How can I check the OP_RETURN field of a transaction?\",\"a\":\"For a single transaction with known txid: (1) Use sickpig's explorer (explorer.bch.ninja) - the JSON tab shows full parsed transaction data, (2) Blockchair also reports OP_RETURN details. Programmatically: an OP_RETURN is an output beginning with 0x6a. Parse the raw transaction with libauth and filter the outputs list. If you have a full node, you can get the raw transaction data directly via RPC.\"},{\"q\":\"Should I store addresses as strings or hashes in an exchange database?\",\"a\":\"Store hashes and generate address strings for user UX on-the-fly. This is especially useful since you may want to support multiple address types (BTC legacy, BCH CashAddress, BCH token CashAddress). If you already store address strings, that works too - it just moves the encoding/decoding elsewhere. For confirmed blocks, use verbosity 2 RPC and read addresses from vout. Note: BTC parsers will misinterpret CashToken data as part of the output script.\"},{\"q\":\"How do I calculate 10^x in BCH Script?\",\"a\":\"Two main approaches: (1) Lookup table - push all possible values to stack and use OP_PICK to select. Works well for known bounds (e.g., x <= 18 for token decimals). (2) Binary decomposition - use CAT for cheap 8^x, or conditionally multiply by 10^16, 10^8, 10^4, 10^2, 10 based on binary decomposition of x. The binary approach saves ~30 bytes but is more complex. With the 2026 upgrade adding loops, exponentiation becomes trivial: just <10> OP_MUL in a loop with counter.\"},{\"q\":\"What new features are in CashScript v0.12.0?\",\"a\":\"CashScript v0.12.0 includes: (1) Removal of the deprecated Transaction Builder, (2) Several small breaking changes for cleaner API, (3) getVmResourceUsage() function to measure VM resource usage (opcost, stack depth, etc.), (4) New TransactionBuilder safety options for better error handling. The version consolidates the API and provides better tooling for contract developers.\"},{\"q\":\"Can I create mocknet wallets with the CashScript SDK like in the playground?\",\"a\":\"Yes - the playground is open source. Look at github.com/CashScript/cashscript-playground for the wallet-related code. TLDR: Either CashScript SDK supports it directly, or you can do it with libauth and/or mainnet-js. For testing contracts that need both contract UTXOs and user UTXOs, reference unspent.app and fbch which are open source and use a mix of mocknet and regtest with mainnet-js.\"},{\"q\":\"Are mainnet-js and CashScript SDK compatible?\",\"a\":\"Yes, but you'll need glue code to make them talk to each other. There are three UTXO type formats: CashScript's format, mainnet-js format, and the common electrum-cash format underneath. You can create a wallet with mainnet-js and use its UTXOs with CashScript SDK to interact with contracts - just need to convert between the formats.\"},{\"q\":\"How does the public chipnet faucet work?\",\"a\":\"Coinbase outputs are sent to an anyone-can-spend contract: `<42> OP_NUMEQUAL`. The p2sh20 base58 address is 2N28ZR5MgBoKq6sBceEoGvTuGs1wfZeXvFF. After the 100-block coinbase maturity timelock, anyone can claim them using a CashScript contract like `require(answer==42)`. This creates a public faucet where chipnet miners donate coins that developers can freely claim for testing.\"},{\"q\":\"How does Nostr achieve censorship resistance?\",\"a\":\"The censorship-resistant property comes from the simplicity of the protocol. Spinning up a relay is super simple. Even if you got banned from all popular relays, you can run your own relay and your friends/followers can connect to it. Notes are transport-agnostic - you could even have a local 'Nostr mesh' where each client is both client and relay. If fully banned, you could broadcast your new relay URL via blockchain OP_RETURN using your Nostr identity key.\"},{\"q\":\"Where can I find BCH opcode documentation?\",\"a\":\"Several resources: (1) vm.cash - interactive opcode reference with debugging tools, (2) documentation.cash - lists operation codes, (3) flowee.org/docs/spec/blockchain/script/ - comprehensive opcode descriptions. All these sites render the same core documentation slightly differently. vm.cash is particularly useful for interactive testing.\"},{\"q\":\"Is there a JavaScript library to connect directly to BCH P2P network?\",\"a\":\"Yes - p2p-cash (github.com/mainnet-pat/p2p-cash) allows JS apps to connect directly to the BCH P2P network. However, working with Fulcrum is much more convenient for both developers and users without sacrificing decentralization too badly. If push came to shove, we'd see more Fulcrum servers spin up or true SPV wallets like Flowee Pay get more popular.\"},{\"q\":\"Why is wallet sync an underappreciated problem?\",\"a\":\"Wallet sync is harder than it appears. Options include: (1) Indexer servers like Fulcrum - convenient but requires server infrastructure, (2) SPV with Merkle blocks (Flowee Pay approach) - works regardless of wallet size, no need to subscribe to addresses. Merkle approach has network activity stable even for a million addresses, but historically had slow startup (now solved in Flowee Pay). Satoshi wrote about wallets connecting to servers 'like connecting to a mail server.' The gap problem exists when optimizing address subscriptions.\"},{\"q\":\"How can SPV wallet initial sync be optimized?\",\"a\":\"During initial sync, get the header merkle root from elsewhere so the user can start using the wallet right away. In the background, download the headers to compute and verify the root yourself. Fulcrum has blockchain.block.headers method returning all headers between start_height and count. When specifying cp_height, you get a merkle proof against a root at the specified height. This allows gradual verification without blocking user experience.\"},{\"q\":\"Does subscription.v3.cash support cancellation?\",\"a\":\"Yes - the vox.cash subscription.v3.cash contract has withdrawal capability, unlike the basic annuity contracts that just drip funds on intervals without cancellation. The improved design uses NFTs - the service holds an NFT that authorizes pulling funds, and when you want to cancel you burn their NFT. This enables multi-service subscription pools where multiple services pull from the same fund pool with individual authorization tokens.\"},{\"q\":\"Why is Flipstarter called 'not actually a contract'?\",\"a\":\"While Flipstarter is advertised as an 'assurance contract,' once the money is sent, the obligation on the receiver drops to zero. The only enforcement mechanism is social pressure - the opposite of a contract. A recipient could theoretically borrow BCH to self-fund their campaign, pocket real donations, and do minimal work. A solution is paying a fee to an overseeing party for better proposals, follow-up, progress checking, and weekly payouts instead of lump-sum.\"},{\"q\":\"Why use Noble curves instead of libauth for browser extensions?\",\"a\":\"Libauth has top-level await statements that break Chrome extension MV3 (Manifest V3) style design. Noble curves (paulmillr.com/noble/) provides an alternative for building BCH transactions in JavaScript without these compatibility issues. BCH's Schnorr implementation is somewhat unique, so if you need a Schnorr example, seek help from BCH developers who've worked through the challenges.\"},{\"q\":\"How are Vox DeFi apps structured?\",\"a\":\"Every Vox app consists of three parts: (1) A libauth template defining the contract logic, (2) A builder function for transaction construction, (3) A UI page for user interaction. This modular architecture makes the contracts portable - each is just a template and about a page of helper code. Technical breakdowns are in the libauth templates, with general audience READMEs in each app directory.\"},{\"q\":\"What are contract pattern fingerprints in BCHN?\",\"a\":\"BCHN merged support for P2S contract tracking via pattern fingerprints. A contract 'pattern' is obtained by stripping data pushes (replacing them with push counts), and the 'fingerprint' is the hash of that pattern. This means contracts with the same executable bytecode but different parameters (like different AnyHedge contracts with different keys) will have the same fingerprint. Useful for finding all instances of a contract type. Use getrawtransaction with verbosity 2 and the 'true' flag for patterns.\"},{\"q\":\"How can I find P2S contracts with the same pattern but different parameters?\",\"a\":\"Two approaches: (1) If you know the exact contract, use Electrum script hash subscription - look it up via electrum-cash-protocol.readthedocs.io script-hashes. (2) For finding all contracts of a type regardless of parameters, use BCHN's new fingerprint feature which strips data pushes. For example, each AnyHedge contract has a different address due to specific parameters, but they all share the same fingerprint because the executable bytecode is identical.\"},{\"q\":\"How does BCH prevent infinite loops from locking up nodes after enabling loops in Script?\",\"a\":\"The May 2025 VM limits upgrade changed script limits from naive 'opcode count' and 'bytesize' to a compute budget system. Each byte in a script gets 800 compute budget, and different opcodes have unique costs depending on their arguments/inputs. A loop (or any script) will terminate with failure and be invalid if it exceeds the compute budget. This means loops can pack logic more densely, but developers must ensure their logic isn't too dense per byte. Additionally, BCH loops are bounded (not GOTO-style) - they don't need explicit exit conditions because they're inherently finite.\"},{\"q\":\"Does BCH Script use two's complement for signed integers?\",\"a\":\"No - BCH VM uses signed magnitude representation, not two's complement. In signed magnitude, the highest bit indicates sign (0=positive, 1=negative), while the remaining bits represent the absolute value. For example, 0x8d (binary 10001101) in signed magnitude is -13 (not -115 as in two's complement). This is why converting bytes to integers may give unexpected results if you're checking against standard hex-to-decimal converters. Use BitAuth IDE (ide.bitauth.com) to sanity check these conversions.\"},{\"q\":\"How does BCH's state model differ from Ethereum's global state?\",\"a\":\"On Ethereum, global state is a huge RocksDB-based key-value database - storage reads and writes cost extra gas, but you only pay for the state slots you access. On BCH, state is local and transferrable via token commitments - when you need state, you include the tokens carrying that state and pay for their presence. In both cases, you don't pay for state you don't care about. The key difference: BCH state is explicitly carried in UTXOs, while Ethereum state lives in a global database that contracts read/write to.\"},{\"q\":\"Are BCH transactions getting larger over time?\",\"a\":\"Yes, metrics show BCH transactions are becoming 'fatter' - primarily on the input side (more inputs per transaction). This isn't necessarily bad - it likely indicates more DeFi usage and feature-rich transactions. After P2S (Pay to Script) adoption, transaction weight might shift more toward the output side. With future improvements like cross-input signature aggregation and wallets supporting alternatives to P2PKH, the 'fat' could be trimmed significantly.\"},{\"q\":\"How can blockchain explorers detect and track specific contract types on BCH?\",\"a\":\"BCHN 28.0.2 added contract fingerprint support to its RPC/REST APIs. Add a 'true' parameter after verbosity in getrawtransaction or getblock calls to enable patterns/fingerprints. This allows indexers like Chaingraph and visualizers like TxStreet to detect contract types. A repository of known fingerprints is maintained at gitlab.com/0353F40E/script-bytecode-fingerprints - useful for identifying specific contracts like AnyHedge, Cauldron, etc.\"},{\"q\":\"Can you hash introspection values in BCH covenants instead of checking individual values?\",\"a\":\"Yes - this is basically emulating CheckTemplateVerify (CTV). You can hash multiple introspection values together and match against the hash instead of specifying and checking individual introspection values. This makes the contract bytecode smaller when you need to verify many transaction properties. See the BitAuth IDE example at ide.bitauth.com/import-gist/17f490fc177bec0f5631009f3cfbe91f for implementation.\"},{\"q\":\"Can smart contracts send to RPA (Reusable Payment Addresses)?\",\"a\":\"RPA lets senders derive receiver addresses that look like typical P2PKH. A contract could lock UTXOs to an RPA-derived address where the private key holder can spend. However, if a contract implements RPA verification for payouts (checking that outputs go to valid RPA destinations), it would destroy most privacy features - the contract reveals the linkage between the RPA and the output address. Using a fresh standard HD address is simpler and more private for escrow/swap situations.\"},{\"q\":\"What is the relationship between CashScript and the BCH VM?\",\"a\":\"CashScript is a compiler - a high-level language that compiles to bytecode for the BCH VM to execute. The VM operates like assembly code with push/pop stack operations. The script hash gets embedded in transactions. CashScript makes it easier to write contracts without dealing with low-level opcodes. Think of it like how Solidity compiles to EVM bytecode, except BCH's VM is stack-based rather than account-based.\"},{\"q\":\"What's the key concept to understand BCH smart contracts?\",\"a\":\"Understand lockscripts well, and you'll have 90% of the correct picture. The critical insight: smart contracts don't *make* actions - they only verify that actions in a transaction conform to the contract specification. Someone has to build the transaction and broadcast it; the contract just validates that the transaction is valid according to its rules. It's essentially a giant checklist that must pass for the transaction to be valid.\"},{\"q\":\"Why might Electrum/Fulcrum connections fail intermittently from the same IP?\",\"a\":\"You might be hitting the `max_clients_per_ip` limit on the Fulcrum server. This commonly happens when running multiple applications simultaneously - Electron Cash, Cashonize wallet, CashScript playground, and other web apps all connecting to the same Electrum server. Switching IPs helps temporarily, but once all clients reconnect from the new IP, it fails again. Restart applications to close stale connections.\"},{\"q\":\"How do I fund a contract in the CashScript Playground?\",\"a\":\"The CashScript Playground defaults to 'mocknet' - a fake, local mock network environment. On mocknet, use 'add random utxo' to simulate funding - this creates fake UTXOs for testing. To test with real BCH, change the network to 'chipnet' or 'testnet4' in the 'new contracts' tab, then send real BCH to the contract address. The 'add random utxo' button only works on mocknet.\"},{\"q\":\"Are there existing contracts for recurring payments on BCH?\",\"a\":\"Yes, several implementations exist: (1) Mecenas - a perpetual payment contract where anyone can trigger periodic payments to a recipient, (2) CashChannels - a payment channel system, and (3) Unspent.app's annuity contracts for scheduled payments. Search for 'Mecenas BCH' for the covenant-based approach, or check Unspent.app for their annuity/recurring payment tools. These use timelocks and covenants to enforce payment schedules.\"},{\"q\":\"What are the transaction size limits on BCH?\",\"a\":\"BCH has a 100KB standardness limit for relay (transactions larger won't propagate through the mempool by default) and a 1MB consensus limit (maximum possible in a block). For most applications, stay well under 100KB. If you need larger transactions, you'd need to work directly with miners. The 100KB limit exists to prevent mempool DoS attacks while still allowing substantial smart contract complexity.\"},{\"q\":\"How does BCH prevent DoS attacks from expensive opcodes in contracts?\",\"a\":\"BCH uses a 'compute budget' system introduced with the VM limits upgrade. Each transaction gets a budget of 800 operation cost units per byte of transaction size. Different opcodes have different costs - simple operations cost 1, while expensive operations like signature checks cost more (26000 for CHECKSIG). If a transaction exceeds its budget, it's invalid. This allows complex contracts while preventing abuse, as attackers must pay proportionally more fees for compute-heavy transactions.\"},{\"q\":\"How do I convert CashAssembly (ASM) to bytecode using libauth?\",\"a\":\"Use libauth's encoding functions to convert ASM tokens to bytecode. Parse the ASM string, map OP_* tokens to opcodes using OpcodesBch, and use encodeDataPush for data. Example: `const instructions = asm.split(' ').map(token => token.startsWith('OP_') ? { opcode: Op[token] } : decodeAuthenticationInstructions(encodeDataPush(hexToBin(token.replace(/[<>]/g, '').replace(/^0x/, ''))))[0]); return encodeAuthenticationInstructions(instructions);` The key functions are encodeDataPush, encodeAuthenticationInstructions, and OpcodesBch from @bitauth/libauth.\"},{\"q\":\"How is zero represented in BCH script arithmetic?\",\"a\":\"In BCH script, zero is represented as an empty stack item, not 0x00. OP_0 pushes an empty stack item which equals arithmetic zero. The byte 0x00 is NOT a valid number for arithmetic operations - they will fail if you try to use it. When arithmetic operations (like OP_SUB) result in zero, they produce an empty stack item. The VM treats empty items as numeric zero for chaining operations. Script counts: 0x82 (-2), 0x81 (-1), \\\"\\\" (0), 0x01 (1), 0x02 (2). Use OP_NUM2BIN to convert an empty stack (zero) to 0x00 bytes if needed.\"},{\"q\":\"How do I create a Bitauth IDE scenario with an NFT token input?\",\"a\":\"Define the token in the sourceOutputs section of your scenario. The sourceOutputs represent the UTXOs being spent (inputs). Example: `\\\"scenarios\\\": { \\\"my_scenario\\\": { \\\"transaction\\\": { \\\"inputs\\\": [{ \\\"unlockingBytecode\\\": [\\\"slot\\\"] }], \\\"outputs\\\": [] }, \\\"sourceOutputs\\\": [{ \\\"lockingBytecode\\\": [\\\"slot\\\"], \\\"token\\\": { \\\"nft\\\": { } } }] } }`. The sourceOutputs section 'passes in' the token, while outputs defines what tokens are sent out. The schema is auto-generated from TypeScript definitions in libauth - tracing back to those definitions makes it easier to work with.\"},{\"q\":\"How can scripts with variable compute needs share the same hash while minimizing fees?\",\"a\":\"Use OP_DROP at the start of your locking script to accept a padding blob of variable size from the unlocking script. The spender provides just enough padding to fund the compute budget needed for their specific execution path. For security, enforce the padding is all zeros with `OP_BIN2NUM OP_NOT OP_VERIFY` at the start. This prevents third-party modification while letting different callers pay only for the compute they actually need, rather than worst-case fees for all possible execution paths.\"},{\"q\":\"Could BCH add an OP_SIGHASH opcode?\",\"a\":\"An OP_SIGHASH opcode that takes a sighash flag and returns the transaction hash (like CHECKSIG computes internally but without verifying a signature) would be useful. This is similar to BTC's OP_CTV but more flexible since it works with all sighash types. CTV can already be emulated in BCH script using introspection opcodes and loops (about 153 bytes), but a native opcode would be more efficient. Combined with OP_CHECKDATASIG, this enables covenant patterns, CTV-style vaults, and other advanced constructions.\"},{\"q\":\"How can I implement append-only data storage on BCH?\",\"a\":\"Create a UTXO that outputs back to itself, forming a chain you can follow to append entries. Each spend stores data in the unlocking bytecode while sending the UTXO back to the same address. This creates an append-only log tied to one address (easy lookup vs HD addresses). To protect against malleability attacks on the unsigned data portion, either: (1) use two signatures (SIGHASH_ALL + CHECKDATASIG), (2) store a hash of the data in an output (NFT commitment or OP_RETURN), or (3) use a proposed OP_SIGHASH to commit to custom data.\"}]},{\"name\":\"CashTokens & NFTs\",\"count\":30,\"faqs\":[{\"q\":\"Why does my mainnet-js TokenSendRequest show tokenData as undefined?\",\"a\":\"This is likely a display issue, not a bug in your code. The transaction may have succeeded even if tokenData shows undefined in the decoded transaction object. Verify by checking a block explorer that supports CashTokens like explorer.electroncash.de. If you're sending tokens to the same wallet address, wallet history may show '0 tokens' because technically no balance change occurred - the tokens just moved between UTXOs in the same wallet.\"},{\"q\":\"What is the timeline for TXv5 (transaction version 5) on BCH?\",\"a\":\"As of early 2025, there's no immediate push for TXv5. Jason Dreyzehner stated he won't push for it unless BCH becomes a Top 10 coin, as the integration effort for all ecosystem participants would need to be justified by sufficient adoption. Read-only inputs could alternatively be implemented without a new TX format by adding just 1 optional byte to input encoding, similar to how CashTokens was added to output encoding.\"},{\"q\":\"Can NFT commitments be used for social media or messaging on BCH?\",\"a\":\"Yes. A user 'profile' could be a minting NFT, with messages issued as NFT outputs stored in the commitment field. The commitment can contain the message directly (up to 40 bytes) or an IPFS hash pointing to larger off-chain data. Messages can 'stay up' as long as a small per-block fee is paid. For dropping/deleting content, you simply spend and don't recreate the UTXO. This enables memo-style or chan-style dapps with blockchain-backed identity.\"},{\"q\":\"What is the current status of SLP (Simple Ledger Protocol) on BCH?\",\"a\":\"SLP still receives occasional transactions but most of the ecosystem has moved on to CashTokens. The SLP Foundation still has funds and continues to fund infrastructure that depends on SLP. SLP was an important stepping stone for tokens on BCH, but CashTokens provides native, miner-validated token functionality that SLP couldn't achieve.\"},{\"q\":\"How does Paytaca's StableHedge stablecoin solution work?\",\"a\":\"StableHedge (bitcoincashresearch.org/t/stablehedge/1504) has these properties: the peg mechanism is centralized (Paytaca maintains it), treasury/backing is fully transparent on-chain, and minting/redemption is permissionless. The treasury holds 50% in BCH (which anyone can 'pull' via redeem function) and 50% in 2x AnyHedge shorts. Users trust Paytaca to maintain correct backing, but all state is publicly verifiable - if they rug or lose backing, everyone sees it immediately.\"},{\"q\":\"What is the intended verification model for BCMR metadata?\",\"a\":\"BCMR was designed for the receiver to provide metadata that the verifier validates - not for wallets to fetch from indexers. Example: scanning a merchant's payment terminal, they provide their BCMR JSON including auth-head and merkle proof. You verify the auth-chain back to auth-base (usually under 10KB total). DNS-based verification is also standard - the token issuer hosts BCMR JSON on their webserver. Trusted indexers that fetch metadata for you inverted this model, trading trustlessness for convenience. For NFT collections with thousands of images, the intended model breaks down (megabytes of BCMR data) so indexers became necessary.\"},{\"q\":\"What's the best design pattern for BCH paper wallets or cash stamps?\",\"a\":\"For onboarding new users with physical paper wallets, the recommended flow requires 2 QR codes: 1) A URL QR that links to the CashStamps site and redirects to app store/play store for wallet download, 2) A BCH-WIF (Wallet Import Format) QR that any compatible wallet can sweep/claim. This makes the paper wallet interoperable - not locked to one specific wallet. For generating paper wallets, opensourcemetalwallet.com provides tools and wallet.fullstack.cash can sweep BCH and SLP tokens.\"},{\"q\":\"What is Bitcart and how does it compare to BTCPayServer for BCH?\",\"a\":\"Bitcart (bitcart.ai) is an open-source, self-hostable crypto payment processor supporting BCH, BTC, LTC, XMR and more. It's Python-based with 6+ years of development and 4+ years of BCH support. Features include testnet4 support. The team is considering adding CashTokens support pending Electron Cash API availability. For merchants wanting to accept BCH without third parties, Bitcart is a viable alternative to BTCPayServer.\"},{\"q\":\"What dust amount should I use for CashToken UTXOs?\",\"a\":\"Use 1000 sats as a safe default for CashToken UTXOs. This covers the worst-case dust calculation for token outputs which can have larger serialized sizes than regular P2PKH. While you could calculate the exact minimum using the formula (444 + output_size * 3), most developers find it simpler to use a fixed safe value. libauth provides functions for exact calculation if needed.\"},{\"q\":\"How can I measure BCH ecosystem growth beyond transaction count?\",\"a\":\"Transaction counts on low-fee chains like BCH are susceptible to inflation (people wanting metrics to 'look better'). TVL (Total Value Locked) in DeFi protocols is a better metric since it's harder to artificially inflate. Track BCH TVL at tokenaut.cash/defi or defillama.com/chain/Bitcoincash - protocols like Cauldron, BCHBull/AnyHedge, Moria, and FutureBitcoin.cash (FBCH) show clear growth patterns. FBCH is currently the largest TVL CashToken project.\"},{\"q\":\"Where can I find BCMR (Bitcoin Cash Metadata Registry) implementations?\",\"a\":\"Several BCMR implementations exist: (1) otr.cash - On-chain Token Registry, (2) github.com/zapit-io/ptr - Zapit's registry, (3) bcmr.flowee.cash - Flowee's BCMR server with HTML views for tokens and auth-chains, (4) bcmr.paytaca.com - Paytaca's metadata indexer (note: not technically a token registry per BCMR spec, more of a metadata aggregator). A comprehensive list of BCH ecosystem resources including BCMR registries is at minisatoshi.cash/ecosystem.\"},{\"q\":\"Does Blockbook support UTXO chain token balances like CashTokens?\",\"a\":\"No, Blockbook only supports EVM token balances currently. Adding UTXO chain token support (like CashTokens) would essentially be a new project - there's no existing framework for it in Blockbook. The architecture assumes account-based token tracking, so supporting CashTokens would require significant changes to the database schema and API.\"},{\"q\":\"Can Tornado Cash be recreated on BCH?\",\"a\":\"With loops, yes. Requirements: (1) ZKP verification to prove you own a deposit without revealing which one, (2) merkle trees to track deposits. When depositing, you get a receipt commitment. When withdrawing, you submit a ZK proof proving you know a secret corresponding to some commitment in the deposit tree - without revealing which commitment. This breaks the link between deposit and withdrawal.\"},{\"q\":\"How do ZK mixers like Tornado Cash provide privacy?\",\"a\":\"You don't reveal which deposit you're withdrawing. Instead of submitting the specific commitment you're redeeming, you prove a secret with data + keys. The ZK proof shows: 'I know a secret that corresponds to one of the commitments in the deposit merkle tree' without revealing which one. This is fundamentally different from CashFusion which just mixes UTXOs - ZK mixers cryptographically break the deposit-withdrawal link.\"},{\"q\":\"What Rust library should I use for BCH development?\",\"a\":\"rust-bitcoincash on GitLab (gitlab.com/rust-bitcoincash/rust-bitcoincash) supports CashTokens. For Electrum API access, use the electrum-client-netagnostic crate. Note: Rust libraries without recent commits aren't necessarily unmaintained - Rust forces explicit typing so libraries are often 'done' rather than abandoned. If you want to build a libauth-rs equivalent, that would be valuable for the ecosystem.\"},{\"q\":\"Where can I find BCHN's JSON-RPC API reference?\",\"a\":\"docs.bitcoincashnode.org/doc/json-rpc/ has the full RPC reference for BCHN. This is equivalent to Bitcoin Core's RPC docs but includes BCH-specific additions like CashTokens support, patterns detection, and Double Spend Proof methods.\"},{\"q\":\"Do BCH wallets support WebP images for NFT art?\",\"a\":\"Browser-based wallets are fine - WebP has been supported in browsers forever. Qt5-based wallets (like Electron Cash) may have issues - WebP requires a different image plugin. The plugin can significantly increase APK size for mobile apps. WebP offers ~96% size reduction over PNG (e.g., 934 MB → 37 MB). If using WebP, test in Electron Cash and other Qt-based wallets before deploying.\"},{\"q\":\"How do AMM DEXs on BCH determine token price?\",\"a\":\"Two ways: (1) Price oracle - an external service provides price, adds some trust. (2) On-chain math - calculate price from BCH and token supplies in the AMM itself (constant product formula). The second method means each AMM pool has its own price based on its reserves. If two pools have the same tokens at different prices, arbitrage bots will trade to equalize them.\"},{\"q\":\"How can I derive a BCH address directly from a Nostr npub?\",\"a\":\"Since BCH and Nostr both use the secp256k1 curve, you can derive a BCH address from a Nostr npub. The PSF Foundation wallet auto-generates a 12-word mnemonic, creates a private key at index 0 on the m/44'/245'/0'/0 derivation path (standard for SLP-token aware wallets), and from that private key generates both the BCH address and the nsec/npub for a Nostr account. You can also import an existing nsec and derive the corresponding BCH address. This enables trustless Nostr-BCH tipping.\"},{\"q\":\"What are the approaches for integrating Nostr and BCH wallets?\",\"a\":\"Two approaches: (1) Build Nostr into BCH wallet - the PSF SLP DEX does this, with basic social media functions and Likes. You can 'Like' SLP tokens and post directly on tokens. (2) Build BCH wallet into Nostr client - would require Nostr client developers to integrate BCH libraries. Both approaches work because nsec keys are secp256k1 compatible. You can derive any secp256k1 pubkey from an nsec, making Nostr well-positioned to be a multi-coin wallet + decentralized social media platform.\"},{\"q\":\"Is there a C# .NET library for BCH development?\",\"a\":\"Yes - BitcoinCashClient (github.com/david-shattuck/BitcoinCashClient) is a NuGet package that abstracts BCH complexity for C# .NET applications. It uses NBitcoin as the base layer for transaction construction. Used in production by AFoG (A Fistful of Gwei). The author is working on removing the NBitcoin dependency to enable full control over transaction construction for CashToken support. A getting-started video tutorial is available.\"},{\"q\":\"How can a BCH private key serve as identity across multiple dApps?\",\"a\":\"Since BCH uses secp256k1, the same private key can be used for: (1) BCH transactions and CashTokens, (2) Nostr posting and messaging (npub/nsec), (3) DeFi like AnyHedge hedging, (4) DEX swaps on Cauldron/TapSwap, (5) Wallet connection to dApps. The key is having standard protocols that each dApp uses - the blockchain and Electrum provide the common connection layer. This enables a unified identity across the entire BCH dApp ecosystem.\"},{\"q\":\"How do time-locked vaults protect users from their own mistakes?\",\"a\":\"Smart well-educated users sometimes make mistakes - when drunk, high, stressed, or FOMO-driven during NFT mints. A time-locked vault set up during a good state of mind protects you in future impaired states. If it's impossible to sign anything other than the previously verified intended use, users don't need to understand the signing process at all. The vault with timelock gives a cooling-off period, and multisig adds additional verification layers.\"},{\"q\":\"How should exchanges handle CashToken UTXOs sent to deposit addresses?\",\"a\":\"Quarantine (ignore) CashToken UTXOs to retain an option to recover them manually if the user covers recovery fees. Implementation: override the block parser to construct a pruned block containing only BCH transactions, process those normally with parent class logic, then create token vouts in DB with FAILED status. FAILED status incomings are excluded from UTXO selection queries, effectively quarantining them while preserving the data for potential recovery.\"},{\"q\":\"Can Nostr be used as a coordination layer for BCH wallets?\",\"a\":\"Yes, and several developers are interested in exploring this. Nostr could enable decentralized communication between wallets without centralized services. For example, Alice could tell Bob how many tokens to transfer without using email or Telegram. The protocol uses the same secp256k1 curve as BCH, so the same private key can be used for both Nostr identity and BCH transactions.\"},{\"q\":\"How could x402 protocol be adapted to BCH efficiently?\",\"a\":\"The challenge is that x402 settles every API call on-chain, which isn't cost-effective even with BCH's low fees. Adaptation ideas: (1) The 'Facilitator' middleware has an HD wallet, assigns addresses to users, accepts batch payments and debits against them, (2) JWT tokens that are self-verifying (no Facilitator needed), (3) Payment channels for 1:1 service provider relationships. The whitepaper mentions 'batched settlements' but it's not specified yet. A semi-centralized first iteration is acceptable - don't let perfect be the enemy of good enough.\"},{\"q\":\"What tools can decode a raw hex BCH transaction?\",\"a\":\"Several options: (1) explorer.bch.ninja/decoder - online decoder by sickpig, (2) tx-debugger-4e98d2.gitlab.io - transaction debugger, (3) Electron Cash GUI - Ctrl+T to load and view transactions, (4) Electron Cash CLI: `electron-cash deserialize <txhex>` for JSON output (note: CashTokens support is incomplete pending PR review). For offline use, Tom's flowee transaction parser is also available.\"},{\"q\":\"Does BCH have a PSBT (Partially Signed Bitcoin Transactions) standard like BIP-174?\",\"a\":\"Currently there's no standardized PSBT for BCH. Electron Cash can export .txn files with raw tx + metadata for offline signing, but it's wallet-specific and CashTokens support is incomplete. A CHIP wouldn't be appropriate since PSBT isn't consensus-related. The XO project (stack.xo.cash) is developing a more robust alternative that aims to be better than traditional PSBT for BCH, including proper offline signing support. Check stack.xo.cash/blog for updates.\"},{\"q\":\"How do I derive a token-aware address from a public key hash in libauth?\",\"a\":\"Use `addressContentsToLockingBytecode` with the type set to 'p2pkhWithTokens' (note the plural 'tokens'). This is the token-aware variant of p2pkh that allows the address to receive CashTokens. The common mistake is using 'p2pkhWithToken' (singular) which doesn't exist. For example: `addressContentsToLockingBytecode({ payload: pkh, type: 'p2pkhWithTokens' })`.\"},{\"q\":\"What is the byte size of a token category in CashTokens?\",\"a\":\"A token category ID is always 32 bytes (the transaction hash of the genesis transaction). However, in transaction serialization, the commitment field size depends on capability: 'none' capability tokens use 32 bytes for the category, while 'mutable' or 'minting' capability tokens need 33 bytes (32 for category + 1 for capability byte). When calculating transaction sizes for fee estimation, account for this difference.\"}]},{\"name\":\"Libraries & SDKs\",\"count\":14,\"faqs\":[{\"q\":\"How can BCH be integrated with Nostr for tipping?\",\"a\":\"There are two main approaches: 1) Non-custodial: Integrate BCH library features directly into Nostr clients - not a full wallet, just basic send/receive functionality. This is technically simpler but requires client developers to do the work. 2) Custodial: Use a third-party service that generates BCH addresses server-side by combining Nostr pubkeys with a secret. This works immediately with all Nostr clients via a simple URL scheme. The custodial approach mimics how Lightning zaps work in Nostr today and requires minimal integration effort from client developers.\"},{\"q\":\"Should I use mainnet-js or libauth for building a BCH dApp with React/Next.js?\",\"a\":\"Libauth is a low-level library while mainnet-js is high-level (and internally powered by libauth). If mainnet-js has the functionality you need, it's the easiest starting point. For advanced control, use libauth directly. You can also extend the base wallet class in mainnet-js with custom functionality for your application. For React/Next.js specifically, there's an official demo at github.com/mainnet-cash/mainnet-js/demo/react-next that shows proper configuration.\"},{\"q\":\"Why do I get 'topLevelAwait' warnings when using mainnet-js with Next.js?\",\"a\":\"The warning 'The generated code contains async/await because this module is using topLevelAwait' can often be safely ignored if your Next.js configuration is correct. This is webpack being overly cautious about the next.config.mjs settings. Check if there are actual runtime errors in the browser console - if the wallet generates a BCH address successfully, mainnet-js is working correctly. Use yarn as the package manager (there's a yarn.lock file in the repo) and ensure you're following the demo example configuration.\"},{\"q\":\"What options exist for building BCH applications in Go?\",\"a\":\"For Go developers, BCHD is the easiest option since it's written in Go and provides GRPC for easy integration. The Neutrino wallet project has working Go code for wallet functionality you could reuse. Other backend options include ChainGraph and the BCHC indexer. For Electrum/Fulcrum communication, you'd need to create a Go library since none currently exists - or use BCHD's GRPC interface instead.\"},{\"q\":\"What's the recommended way to implement BCMR on-chain authchain resolution?\",\"a\":\"Using Fulcrum directly for BCMR authchain lookups is slow and creates excessive server load. Better options: 1) Paytaca's BCMR indexer (github.com/paytaca/bcmr-indexer) - dedicated Python indexer with REST API, 2) Cauldron's Rust indexer (indexer.cauldron.quest), 3) Rostrum's blockchain.utxo.get if using Rostrum servers (nexa.gitlab.io/rostrum/), 4) mainnet-js has built-in BCMR support. For light verification, DNS-based BCMR resolution works too (explorer.salemkode.com/registers shows examples).\"},{\"q\":\"What Rust libraries exist for BCH development?\",\"a\":\"Several Rust options for BCH: 1) rust-bitcoincash (gitlab.com/rust-bitcoincash/rust-bitcoincash/) - main Rust library, 2) Riften Labs tooling (gitlab.com/riftenlabs) including a Rust indexer, 3) Cauldron's Rust-based BCMR indexer. libauth also uses Rust for WebAssembly hash functions (github.com/bitauth/libauth/tree/master/wasm/hashes). Note that Java and C++ have more mature compiled-language BCH tooling overall.\"},{\"q\":\"What is a Rust light P2P client for BCH?\",\"a\":\"There's a light P2P client example at github.com/samrock5000/p2p-client using the Rust nakamoto package. It lets you update a bloom filter from an input form and send 'loadfilter' messages to peers. It detects BCH addresses and hex-encoded data, and is intended for demonstration/learning. Future plans include merkleblock fetching and inclusion proof validation. It builds on Linux and macOS.\"},{\"q\":\"How do I fix ESM errors when using Libauth with ts-node?\",\"a\":\"Use `tsx` instead of `ts-node` - it handles ESM modules much better and 'just works' in most cases. Libauth v3 requires Node v22+ LTS. Common issues: (1) Check your tsconfig.json module settings, (2) Libauth uses top-level await for WASM initialization which can cause issues with some setups, (3) If mixing ESM with CommonJS, Node v23 has experimental support but may conflict with top-level await. The tsx package (npm install tsx) is the recommended solution.\"},{\"q\":\"How do I get UTXO breakdown for fee calculation in mainnet-js?\",\"a\":\"Use `await wallet.getAddressUtxos()` to get individual UTXOs with their values. This tells you if your balance is '5 $100 bills' or '100 $5 bills' - which affects transaction fees. Fee handling is abstracted by default in mainnet-js (a feature), but you can access raw UTXO data when needed. The JS library and REST API have identical APIs.\"},{\"q\":\"Does BTCPayServer have BCH support?\",\"a\":\"The underlying NBitcoin/.NET library has BCH support (albeit with unflattering class names like 'BTrashPubKeyAddress'), added by Nicolas Dorier himself back in April 2018. NBXplorer (BTCPayServer's indexer) also lists BCash support. However, actually getting BCH into BTCPayServer proper would require someone to build a BCH plugin and likely face social/political resistance. BTCPayServer recently showed openness by merging Nano support, so if someone wanted to make a project of it, worst case is forking to 'BCHPay'.\"},{\"q\":\"Is there a Swift/iOS library for BCH development?\",\"a\":\"Yes - SwiftFulcrum lets you connect to the BCH network via Fulcrum from iOS/iPad. You can get connected to the BCH network in under 5 minutes. The library is designed for native iOS development and provides access to BCH blockchain data through Fulcrum's Electrum-compatible protocol.\"},{\"q\":\"Does libauth support partially signed transactions?\",\"a\":\"Yes. While not interfacing directly with libauth for this, bitauth IDE (ide.bitauth.com) uses libauth under the hood and there you can define any signing scenario you want. Libauth's templating system supports complex multi-party signing scenarios.\"},{\"q\":\"How do you create a chipnet wallet using mainnet-js?\",\"a\":\"Use the TestnetWallet class - mainnet-js uses chipnet as its testnet by default. When you instantiate a TestnetWallet, it automatically connects to chipnet infrastructure. No additional configuration is needed for chipnet development.\"},{\"q\":\"What port should I use for chipnet WebSocket Electrum connections?\",\"a\":\"For WebSocket connections to chipnet, use port 50004 with wss:// protocol. Example: `wss://chipnet.imaginary.cash:50004`. The standard non-WebSocket Electrum port is 50002. When using mainnet-js with testnet, you can just specify 'testnet' and the library will find the best node automatically using its built-in server list.\"}]},{\"name\":\"Protocol & CHIPs\",\"count\":13,\"faqs\":[{\"q\":\"What is RPA (Reusable Payment Addresses) in BCH?\",\"a\":\"RPA is a privacy feature similar to stealth addresses that allows users to share a single reusable address that generates unique receive addresses for each payment. It's currently supported in Electron Cash wallet and is still in alpha stage. With wallet native support, RPA can provide convenient privacy. The specification can be found at github.com/imaginaryusername/Reusable_specs/blob/master/reusable_addresses.md\"},{\"q\":\"Can I use the same keypair for both a BCH wallet and a Nostr account?\",\"a\":\"While BCH and Nostr both use the secp256k1 curve, the keypair schemes are different. The same private key will give you different public keys because Nostr uses BIP340 (BTC-style Schnorr). So if you send BCH to an address derived from someone's Nostr pubkey (npub), they can't spend it using their Nostr private key directly. The signing algorithms are compatible (you can use npriv for signing a BCH transaction), but the public key derivation differs.\"},{\"q\":\"What is the millisatoshi (mSAT) CHIP proposal for BCH?\",\"a\":\"The mSAT CHIP proposes increasing BCH transaction precision by allowing sub-satoshi amounts. The main motivation is fee sustainability: if BCH reaches $100M/coin, the current 1 sat/byte minimum would make the smallest transaction cost ~$219. With millisats (1 mSAT/byte = 1 sat/kB), minimum fees drop to $0.22. Note that the minrelayfee exists for network health (preventing UTXO bloat), not to ensure miner income - miners can already choose what fees to accept via direct transaction submission or by mining empty blocks.\"},{\"q\":\"What are read-only inputs in TXv5 and why are they useful?\",\"a\":\"Read-only inputs allow a transaction to reference a UTXO without spending it. This is valuable for oracle protocols like d3lphi where users can read oracle data without 'fighting' over the UTXO. Without read-only inputs, high-volume oracle usage would cause transaction chain conflicts. The trade-off is more complex mempool management: nodes must track transactions that reference the same UTXO read-only until they're mined.\"},{\"q\":\"Why does BCH prefer hard forks over soft forks for upgrades?\",\"a\":\"BCH developers have found that in many situations, hard forks are better: less headache, cleaner code, and less complicated than soft forks. The key is having everyone aboard through a reasonable process like the CHIP (Cash Improvement Proposal) system. With clear coordination and community agreement, hard forks enable cleaner protocol improvements without the technical debt that soft forks can accumulate.\"},{\"q\":\"Can BCHN be configured for fees lower than 1 sat/byte?\",\"a\":\"Yes, the mintxfee setting allows configuring fees in BCH/kB. The default is 0.00001 BCH/kB (1 sat/byte), but it can be set lower. However, mintxfee controls transaction creation while minrelayfee controls propagation - both need to match network-wide for consistent behavior. Lower fees require network-wide agreement since inconsistent settings break 0-conf reliability. Currently, going below 1 sat/byte would need ecosystem coordination, similar to how consensus changes work.\"},{\"q\":\"What's the relationship between relay rules and consensus on BCH?\",\"a\":\"Relay rules and standardness rules are not technically consensus, but they're 'pseudo-consensus' - consequential changes that deserve as much thought and consideration as a consensus CHIP. Nobody can just assert what the network will do since changes to relay rules have real network-wide impact. For example, changing the minimum relay fee affects transaction propagation behavior across the network, even though it's not enforced by consensus.\"},{\"q\":\"Are DeFi price oracles inherently centralized?\",\"a\":\"Most are, yes. Getting USD/EUR prices requires a centralized source since those currencies are controlled by governments. Even for on-chain assets, someone typically signs the price data and extracts trade fees, introducing centralization. A hashrate-based oracle (GigaHashCoin concept) could be truly decentralized since mining difficulty is consensus-determined. For asset prices, having multiple independent sources helps but doesn't eliminate trust - you still need conversion between currencies which requires trusted rate providers.\"},{\"q\":\"What are the actively maintained BCH specification documentation sources?\",\"a\":\"Several forks exist with varying maintenance levels: (1) reference.cash - Bitcoin Unlimited's copy, accepts PRs, (2) flowee.org/docs/spec - Flowee's copy, pulls updates from other forks, (3) codeberg.org/bitcoincash/specification - Tom/Flowee's copy, considered most consistently maintained. documentation.cash (Verde) has stale issues and slower PR acceptance. The challenge with community-owned docs is no personal benefit for maintainers. For recent upgrade info, consider pasting CHIP specs directly when working with LLMs.\"},{\"q\":\"What is tempnet and how does it relate to chipnet?\",\"a\":\"Tempnet is a fork of chipnet. Since it's a fork, people who have chipnet coins can help test on tempnet as well. Chipnet is the test network with 2025 upgrade features activated, used for development testing before mainnet activation. Tempnet provides an additional testing environment for specific scenarios.\"},{\"q\":\"What is the difference between BCH reference specification and software howtos?\",\"a\":\"Reference specification tells you data formats (transactions, blocks, network messages) and consensus/network rules. It's meant to be read by implementers of software, not end users. Using or configuring specific software that satisfies the spec is not part of the spec itself. For example, header spec and stratum protocol spec belong in the specification, but guides for particular pool software do not. BCH could use more end-user howtos, but those are a different type of documentation.\"},{\"q\":\"Where can I test JSON Payment Protocol (JPP) wallet implementation?\",\"a\":\"Test with real BitPay merchants like Ampex or Namecheap. BitPay supports both JSON Payment Protocol (JPPv2) and BIP70 protocol buffers - what your wallet handles depends on what Accept header it sends. For implementation reference, see Selene wallet's payment_protocol.ts. Note: Don't implement the 'Trusted Keys' functionality - BitPay's keys are expired and it's just a secondary measure on top of HTTPS. Example JPP implementations are at stamps.cash, tags.infra.cash, and scantopay.cash.\"},{\"q\":\"When did chipnet activate the 2026 VM upgrades?\",\"a\":\"Chipnet activated the 2026 BCH network upgrades on November 15th, 2025 (the standard BCH upgrade lock-in date). Developers should switch from tempnet to chipnet for testing 2026 features like loops, bounded loops, P2S, and other new VM capabilities. Mainnet activation follows on May 15th, 2026.\"}]},{\"name\":\"Wallet Development\",\"count\":28,\"faqs\":[{\"q\":\"How do I fix WalletConnect session issues on TapSwap?\",\"a\":\"If TapSwap shows connection info instead of asking you to select a wallet, it may still be connected to a previous session. Go to Settings > End all sessions to force disconnect. If the button doesn't work, open your browser's developer tools and remove all localStorage items that mention 'wc2'. Consider using Safari or Chrome rather than Edge for better WalletConnect compatibility. Note that Brave browser also has known issues with WalletConnect.\"},{\"q\":\"Where is the Electrum Cash Protocol documentation for communicating with Fulcrum?\",\"a\":\"The raw JSON-RPC protocol documentation for communicating with Fulcrum directly is available at electrum-cash-protocol.readthedocs.io. This covers all the API methods for querying addresses, UTXOs, transaction history, and subscribing to address changes. For Go development, consider using BCHD's GRPC interface instead, or bchwallet at github.com/gcash/bchwallet.\"},{\"q\":\"Is WalletConnect decentralized, and what happens if it goes down?\",\"a\":\"WalletConnect is NOT decentralized - it's just a transport layer for the wallet API. It's widely used across cryptocurrency but represents a single point of failure. The long-term proposal is to move this transport layer to libp2p. However, using WalletConnect with a standardized API (like Pat's BCH wallet API spec) is still better than every dapp needing to create its own built-in web wallet with questionable security.\"},{\"q\":\"Do BCH wallets implement SPV as described in the Bitcoin whitepaper?\",\"a\":\"Yes, some BCH wallets implement true SPV (Simplified Payment Verification) as specified in section 8 of the Bitcoin whitepaper. Electron Cash and Flowee Pay both verify merkle proofs against block headers to confirm transactions are included in mined blocks. This is proper SPV - not just 'trust the server' but actual cryptographic verification that a transaction is buried under proof-of-work.\"},{\"q\":\"What are Double Spend Proofs (DSP) in BCH?\",\"a\":\"Double Spend Proofs (DSP) are a BCH feature that alerts the network when someone attempts to double-spend unconfirmed coins. When nodes detect conflicting transactions spending the same inputs, they generate a cryptographic proof and broadcast it. Wallets like Electron Cash can display DSP alerts to merchants. Testing on testnet is easier than mainnet due to fewer nodes. See flowee.org/posts/dsproof/ for details.\"},{\"q\":\"What are the correct WalletConnect chain IDs for BCH?\",\"a\":\"BCH uses CAIP-2 format chain IDs that differ from BTC's bip122:genesisHash format. The correct chain IDs are: 'bch:bitcoincash' for BCH mainnet, 'bch:bchtest' for BCH testnet, 'bch:bchreg' for BCH regtest. This is defined in Pat's WalletConnect spec for BCH. Note: BTC uses bip122:000000000019d6689c085ae165831e93 (genesis hash) which is a different convention.\"},{\"q\":\"What's the status of BCH integration with WalletConnect?\",\"a\":\"There's an open GitHub issue (#5672 in walletconnect-monorepo) for BCH chain registration. However, registering a chain with WalletConnect's Explorer doesn't impact or improve the ability for wallets and dApps to support your chain - it's simply a discovery mechanism. The actual integration requires individual wallets and dApps to implement BCH support independently. The chain registration just helps users discover which wallets/dApps already support BCH.\"},{\"q\":\"How can BCH work during power outages or without internet?\",\"a\":\"Several approaches exist: (1) Wallets can pass around merkle proofs to verify input validity without internet - you can't detect double spends offline, but for small payments the risk is acceptable. (2) Mesh networks (like Hong Kong protesters used) provide low-bandwidth backup connectivity - BCH transactions are tiny so even intermittent mesh access suffices. (3) RFID cards loaded with pre-confirmed UTXOs (developed by Tobias Ruck at be.cash) where the card holds $1/$5/$10 UTXOs - merchant needs internet but payer doesn't. (4) CoinText-style SMS services (now defunct) that tied wallet custody to phone numbers. With battery/solar power and a 4G hotspot, most realistic scenarios are covered - an 80W panel can run a 4G hotspot off-grid.\"},{\"q\":\"What's the best way for wallets to sync with the blockchain?\",\"a\":\"Full nodes with merkle blocks solve this in an extremely cheap, scalable, and private way - much faster and more consistent than Electrum servers. The problem is many wallets don't use merkle blocks and instead use Electrum or other indexing layers which create new problems. Merkle block sync provides the best user experience with consistently fast wallet opening.\"},{\"q\":\"Does Blockbook support merkle proofs for SPV wallets?\",\"a\":\"No, Blockbook doesn't have APIs for merkle proofs which makes it unsuitable for SPV wallets. It's a different kind of audience than Electrum - Blockbook is designed for trusted setups like hardware wallets (Trezor) where the indexer is trusted. It uses REST and WebSocket APIs primarily for address balance lookups and transaction history, not for light client verification.\"},{\"q\":\"How can mobile wallets run background tasks like auto-fusion?\",\"a\":\"Mobile platforms restrict battery usage heavily. Options: (1) Background Runner - scheduled jobs every ~15 mins, acceptable for delayed notifications, (2) Push Notifications - instant but requires backend server knowing your addresses (privacy tradeoff). Push requires Firebase (Google) or ANS (Apple). A central server for address monitoring goes against decentralization. Alternative: run background sync when phone is charging overnight.\"},{\"q\":\"How do I use Electron Cash on a testnet?\",\"a\":\"Start Electron Cash from the command line with the `--chipnet` flag. This connects to the chipnet testnet. Other flags like `--testnet4` may work depending on version. This isn't prominently documented but is the standard way to access testnets with the desktop wallet.\"},{\"q\":\"How does ElectrumX address status hash work for wallet caching?\",\"a\":\"When you call `blockchain.address.subscribe`, you get a status hash and receive new ones on each update. Cache the hash along with history + unspents - only refresh when hash changes. The hash is computed from transaction history in order: confirmed txs use CTOR, unconfirmed sorted by height then hash. Computing this client-side is expensive and the docs have grey areas about mempool ordering.\"},{\"q\":\"Can Nostr npubs be converted to BCH addresses for tipping?\",\"a\":\"Yes! Nostr nsec keys are secp256k1 compatible with BCH. A draft NIP enables converting npub to BCH address, allowing direct payments/tipping between Nostr users with BCH. The code derives the BCH address from the npub's public key. Long-term vision: wallets like Cashonize adding Nostr features to social media directly and receiving value on-chain. See github.com/bastiancarmy/nostr-multi-chain-tipping-nip for the implementation.\"},{\"q\":\"What is Nostr and how does it relate to BCH?\",\"a\":\"Nostr is like Twitter but decentralized - it uses relays (similar to Bitcoin nodes) to send signed messages rather than routing through a central server. Since Nostr nsec keys use the same secp256k1 curve as BCH/BTC/ETH, you can derive BCH addresses from Nostr keys. This means Nostr is well-positioned to be a multi-coin wallet + decentralized social media platform. BCH solves the tipping problem natively (current Nostr direction favors Lightning). E2EE messaging is also supported.\"},{\"q\":\"What free public REST APIs exist for BCH data?\",\"a\":\"Several options: (1) Fulcrum (github.com/cculianu/Fulcrum) - ElectrumX protocol server with public instances, (2) ChainGraph (github.com/bitauth/chaingraph) - GraphQL API with public instances, (3) mainnet.cash - REST API similar to old bitcoin.com API, (4) Cash Stack at free-bch.fullstack.cash - evolved from the original bitcoin.com API/BITBOX. Choose based on your data needs - Fulcrum for wallet operations, ChainGraph for complex queries, mainnet/Cash Stack for general REST access.\"},{\"q\":\"What is CashConnect and how does it differ from WalletConnect?\",\"a\":\"CashConnect (also called CashRPC) is a BCH-specific protocol for wallet-to-dApp communication, used by BCH Guru. It's designed to solve HD wallet integration challenges. While CashConnect currently uses WalletConnect as its transport layer, it's a separate protocol. WalletConnect 2.0 is complex with 5 types of servers (relay, push, history, verify, echo) - replacing it with something like libp2p is under consideration but would require significant work.\"},{\"q\":\"How complex is WalletConnect 2.0 infrastructure?\",\"a\":\"Very complex. WalletConnect 2.0 requires 5 types of servers: relay servers, push servers, history servers, verify servers, and echo servers. This makes it difficult to replicate with generic open source alternatives. The protocol is opinionated and the network is currently permissioned (controlled by Reown company). For BCH, alternatives using libp2p are being explored for running web-accessible Fulcrum, Chaingraph, and BCH-P2P infrastructure from home.\"},{\"q\":\"Would browser-native crypto payments be better than wallet connect?\",\"a\":\"Yes - for HTTP-based micropayments like x402, wallet connect is overkill. The ideal is a wallet in a browser plugin or a browser that ships with a wallet natively. Using web protocols to make a browser talk to a wallet app on the same device adds unnecessary complexity. For mobile, deep linking or app-specific protocols would be more appropriate than routing through external relay servers. Browser support for HTTP 402 status code is what's needed to make web payments mainstream.\"},{\"q\":\"Can EVM wallet designs like MetaMask/MEW be adapted for BCH?\",\"a\":\"It's challenging. Both BCH and Ethereum use secp256k1 curve, so key derivation works. However, EVM wallets are deeply steeped in the account model - adapting UX from account to UTXO model is 'completely non-trivial'. Previous attempts like Badger Wallet (badger.cash) failed to adapt well. The UI might be reusable but the UX requires rethinking from scratch. XO.cash is a native BCH approach to the 'DeFi hub wallet' concept.\"},{\"q\":\"Why do wallet developers build new wallets instead of contributing to existing ones?\",\"a\":\"Often it comes down to wanting control and sometimes inability to work together with others. Building on existing wallets would let developers instantly gain users - for example, a DeFi plugin for established wallets would give access to that user base. Existing wallets like Flowee Pay have plugin/module architectures specifically designed for this integration. The open source mantra is that adding to existing projects is more effective than starting your own, but BCH sees many parallel wallet development efforts.\"},{\"q\":\"How can a templating system improve dApp security over wallet connect?\",\"a\":\"A generalized templating system moves complexity from dApps into the wallet. Instead of apps asking for signatures (which can be exploited), apps ask users to perform specific actions. The wallet understands the template, lets users verify locally that what the app requested matches what they're about to do, then executes it. This moves trust from 'apps that can update at operator whim' to 'templates that are pre-verified and static.' Wallets can learn new features by adding template support rather than implementing each dApp.\"},{\"q\":\"Why are templates more trustworthy than dApps?\",\"a\":\"Templates push trust to template makers rather than dApp operators. A dApp can change from day to day, so you have to renew your trust every time you use it. A template should only need updating very rarely, so you don't need to renew trust frequently. High-security wallets will refuse templates they haven't audited and signed for. High-versatility wallets will let you add any template with just a warning. Most wallets will fall somewhere between these extremes.\"},{\"q\":\"What's a dangerous NPM security vulnerability related to email domains?\",\"a\":\"For many NPM packages, the domains used for maintainer email addresses have expired. An attacker can register the expired domain, launch a mail server, then use the password reset mechanism to gain control of the package. This enables publishing malicious versions. Mitigations: NPM should require 2FA for package publishing, wallets should pin exact dependency versions, and sites should monitor domain expiration for BCH-related projects. The distrust.co project was created specifically to defend against such supply chain attacks.\"},{\"q\":\"Can BCH wallets use Nostr relays for messaging without implementing all NIPs?\",\"a\":\"Yes - NIP01 (basic protocol) is enough. You don't need to implement all Nostr proposals. Since both BCH and Nostr use secp256k1, you can use the same private key for both BCH address and Nostr npub. For E2EE messaging, use the appropriate NIP. Running your own relay on Start9 tied to your Nostr key and syncing across multiple relays gives decentralization. BCH clients can implement their own tipping without needing new NIPs accepted.\"},{\"q\":\"What is Yggdrasil and could it help BCH infrastructure?\",\"a\":\"Yggdrasil is a mesh networking technology that replaces the TCP/IP layer. It's an excellent concept that addresses issues like NAT traversal and enables direct connections. An interesting idea is deriving Yggdrasil addresses from wallet keys. For now, the combination of Fulcrum + BCH node + Nostr relays for comms works well. If oppression intensifies, having wallets operate as nodes could become important.\"},{\"q\":\"What is CashFusion and how does it provide privacy?\",\"a\":\"CashFusion is an opt-in mixing protocol for Bitcoin Cash privacy. It's an automated, continuous version of CoinJoin that runs in the background of compatible wallets. Unlike older mixers that require same amounts, CashFusion uses combinatorial mathematics to create hundreds of possibilities for who paid whom. Multiple users contribute coins to a shared transaction pool, all inputs/outputs get shuffled together, and coins return as 'mixed' coins. The fees are split between all participants, so per-user cost is typically 2-4x a normal transaction (due to more inputs/outputs), not the full transaction fee shown in wallet UIs.\"},{\"q\":\"How can I visualize BCH transaction privacy and CashFusion effects?\",\"a\":\"The cashflow.dev tool can visualize transaction privacy patterns. It can show standard HD wallet privacy (address non-reuse patterns) vs CashFusion privacy by comparing fund flows with and without fusion transactions. You can run experiments like sending funds between two HD wallets with no address reuse, then compare to the same experiment interspersed with fusion transactions.\"}]},{\"name\":\"Privacy & Security\",\"count\":5,\"faqs\":[{\"q\":\"What is 'software rot' and why does it matter for BCH development?\",\"a\":\"Software rot (or bit rot) refers to the gradual degradation of software quality over time, even without code changes. External dependencies update, operating systems change, APIs deprecate, and security vulnerabilities are discovered. This means software requires ongoing maintenance just to keep running. The 80/20 rule often applies: 80% of software can be written in 20% of the time, but the remaining edge cases and bugs take much longer. Simple, focused tools with minimal dependencies tend to age better - some well-designed utilities can run unchanged for years.\"},{\"q\":\"What's the difference between ZK-SNARKs and ZK-STARKs for BCH?\",\"a\":\"ZK-SNARKs require a 'trusted setup' ceremony which is considered a potential vulnerability - if the setup is compromised, fake proofs could be created. ZK-STARKs are transparent (no trusted setup) and potentially quantum resistant, but have larger proof sizes. For BCH, implementing any ZK system would require understanding the tradeoffs and potentially developing a custom implementation that fits the UTXO model.\"},{\"q\":\"Are sidechains/drivechains possible on BCH?\",\"a\":\"Technically yes, but nobody's building them. The industry moved to ZKPs for sidechains - SPV 2-way peg proofs never took off. Perspective: sidechains on BTC were proposed to deflect on-chain innovation; ETH uses L2s because account-based architecture can't scale; BCH's UTXO architecture CAN scale on L1. The power of the base chain hasn't been fully utilized yet. Sidechains are for specialized use cases that aren't feasible on-chain.\"},{\"q\":\"How can ZKP2P hooks enable trustless fiat on-ramps to BCH?\",\"a\":\"ZKP2P hooks can act as automation robots for cross-chain settlement. The flow: (1) User buys USDC on Base via ZKP2P P2P trade wanting BCH, (2) The successful ZKP2P intent fulfillment triggers the hook, (3) The hook takes USDC from ZKP2P escrow and sends it to THORChain with a memo specifying 'swap for native BCH and send to this BCH address', (4) THORChain's decentralized nodes handle the cross-chain swap and final delivery. This enables trustless fiat-to-BCH on-ramping using existing infrastructure.\"},{\"q\":\"How does ZKP2P verify fiat payments for trustless on-ramping?\",\"a\":\"ZKP2P verifies browser TLS data and email data to confirm fiat payments have been made. An alternative approach would use a custom Firefox or Chromium build instead of browser extensions - the browser can watch for certain variables in the document (sent form fields, AJAX/JSON data) and filter that data. This approach requires no proxy and no TLS manipulation, potentially being simpler and working with any bank rather than requiring specific integrations.\"}]},{\"name\":\"Infrastructure & Nodes\",\"count\":14,\"faqs\":[{\"q\":\"How can I speed up BCH full node initial sync?\",\"a\":\"Several approaches: 1) Use Bitcoin Verde with its fast sync mode for the quickest option. 2) For BCHN, ensure you have an SSD (preferably NVMe), a moderately fast CPU, and a fiber connection. With good hardware, BCHN can sync from 0-100% in 2-4 hours. If your sync is taking 24+ hours even with decent hardware (1Gbit, Xeon, NVMe), consider switching to Verde for faster initial sync, then you can switch back to BCHN if needed.\"},{\"q\":\"What chipnet block explorers are available for BCH testing?\",\"a\":\"Several chipnet explorers exist: cbch.loping.net, chipnet.chaingraph.cash, and chipnet.bch.ninja. Note that some explorers may depend on shared Fulcrum servers - if one goes down due to bandwidth abuse, multiple explorers may be affected. Having a local node or using an explorer that runs its own server provides more reliability for development.\"},{\"q\":\"What is whitepaper pruning and do any Bitcoin nodes implement it?\",\"a\":\"Whitepaper pruning (from section 7 of the Bitcoin whitepaper) describes discarding spent transactions while keeping block headers. Importantly, NO Bitcoin node (BTC or BCH) implements this. Current 'pruned nodes' just delete old block data but still require downloading the full blockchain initially. True whitepaper pruning would allow nodes to start with only headers and UTXO set, but this isn't implemented anywhere.\"},{\"q\":\"How does SPV merkle proof verification work?\",\"a\":\"SPV clients download only block headers (80 bytes each). When they need to verify a transaction, they request a merkle proof from a full node - this is the set of hashes needed to compute from the transaction up to the merkle root in the header. The client independently computes the merkle root and checks it matches the header. Since headers are chained with proof-of-work, this proves the transaction is buried under that work without needing the full blockchain.\"},{\"q\":\"Are bloom filters in BCHN a fixed size?\",\"a\":\"Yes. At construction, a fixed-length byte array is created. Inserting items into a bloom filter only toggles individual bits but does not change the size in any way. This is a fundamental property of bloom filters - they use a fixed memory footprint regardless of how many items are inserted.\"},{\"q\":\"How do I manually connect to a BCH node using the P2P protocol?\",\"a\":\"The P2P handshake sequence is: A sends `version`, B responds with `verack` then `version`, A responds with `verack`. You can use netcat (nc) with xxd to send binary messages. Example using a version message hex: `echo 'e3e1f3e876657273696f6e...' | xxd -r -p | nc node_ip 8333`. The version message needs correct magic bytes (e3e1f3e8 for mainnet), command name, payload length, and checksum. If you get no response, your message format may be wrong - nodes silently ignore invalid messages.\"},{\"q\":\"How do nodes choose between two competing blocks at the same height?\",\"a\":\"When the network has N+A and N+B (two blocks at equal height with equal chainwork), there's no objective tie-breaker. Nodes pick subjectively using this policy: 1) Favor your own block if you mined it (you saw it first with 0 latency), 2) If neither is yours, favor the one you saw first ('first-seen' rule). This is why block races resolve - different parts of the network see different blocks first, but eventually one block gets a child mined on it and that chain becomes objectively longer.\"},{\"q\":\"How did payment processors detect double spends before Double Spend Proofs existed?\",\"a\":\"Before DSP, services like BitPay connected to many nodes across the network and tracked which nodes sent an 'inv' message for each transaction. By monitoring transaction propagation across the network topology, they could detect if conflicting transactions existed. This wasn't about predicting which transaction would be mined - it was simply about detecting whether a double spend attempt occurred at all, which was enough to indicate high risk in a payment context.\"},{\"q\":\"If I send a low-fee transaction and later a higher-fee double spend, will a dsproof still be created?\",\"a\":\"Yes! Any full node that receives a second conflicting transaction will generate a Double Spend Proof (dsproof), and it will be relayed by any node that has either transaction. So even if miners have different fee thresholds, the 0-conf scenario remains protected by DSP as long as the conflicting transactions reach any full nodes.\"},{\"q\":\"Are all BCH UTXOs stored in memory?\",\"a\":\"No, UTXOs are stored on disk. Only when spending a UTXO does it get loaded into memory. This optimization is already built into the node implementations, so having many old unused UTXOs doesn't consume RAM - they only add to disk storage requirements.\"},{\"q\":\"Why does my Schnorr signature fail with 'Non-canonical DER signature' error?\",\"a\":\"The signature is likely 64 bytes but should be 65 bytes for BCH. You need to append the hashtype byte (e.g., SIGHASH_ALL = 0x41) to the 64-byte Schnorr signature. The node interprets signatures without this byte as ECDSA (which requires DER encoding), causing the 'Non-canonical DER' error. Working with signatures is tricky - any error produces an entirely invalid result with minimal debugging information.\"},{\"q\":\"How do Nostr relays communicate with each other?\",\"a\":\"They don't. Nostr is not peer-to-peer or federated. It's client-server where the client connects to many independent servers and does what it will with whatever data those servers serve. Relays don't sync with each other. The architecture is 'smart client, dumb relay.' Everything is glued together by pubkey crypto - you know a message is from someone because their notes are signed by their pubkey, regardless of which relay the note came from.\"},{\"q\":\"Why is the indexer (Fulcrum) separate from the node?\",\"a\":\"Maintenance reasons. While it could be combined (BCHD does indexing), keeping them separate allows spreading services over multiple machines for better scaling. Some nodes do have indexing built-in, but separation is cleaner for deployment flexibility. The tradeoff is convenience vs. operational flexibility.\"},{\"q\":\"How does Chaingraph handle double spends differently than Electrum?\",\"a\":\"Chaingraph remembers and serves double spends - if you query for UTXOs, you might get outputs from two conflicting transactions. Electrum provides a consistent (but not persistent) view - it won't show conflicting UTXOs, but will 'change its mind' if the winning transaction changes. Takeaways: (1) Double spends are normal and more common than expected, (2) Electrum always shows consistent chain state, (3) Chaingraph queries need careful filtering to exclude replaced transactions.\"}]},{\"name\":\"Transaction Building\",\"count\":13,\"faqs\":[{\"q\":\"Could read-only inputs cause MEV (Miner Extractable Value) issues on BCH?\",\"a\":\"The concern is valid but not new. A miner could theoretically ignore transactions using a read-only UTXO while including a transaction that spends it fully, invalidating those transactions. However, this isn't fundamentally different from miner double-spends that are already possible. Miners throwing out read-only spends would be throwing away fees for no good reason. Read-only input implementation needs careful examination, but Cardano and Nexa have already implemented similar features.\"},{\"q\":\"What is header-first mining and why do miners use it?\",\"a\":\"Header-first mining is when miners start mining on a new block immediately after receiving just the 80-byte header, before downloading and validating the full block. They mine an EMPTY block because they don't yet know the UTXO state (which transactions might conflict with the new block's transactions). This solves a hardware problem: miners can't turn off ASICs between blocks because the power fluctuations (0 to 100 amps instantly) damage equipment. So they either: 1) keep mining the old block (risking orphan), or 2) mine empty on new tip until validated. Most choose option 2.\"},{\"q\":\"Why doesn't Foundry (the largest BTC pool) use header-first mining?\",\"a\":\"Foundry doesn't use header-first for several reasons: 1) BTC has 1MB block limit so block propagation bandwidth impact is insignificant, 2) As the majority hashrate pool, they have less to lose from the validation delay since smaller miners will still switch to Foundry's blocks first anyway, 3) With BTC's high fees, mining an empty block sacrifices significant revenue compared to BCH where fees are minimal.\"},{\"q\":\"Why doesn't DSP (Double Spend Proof) work for P2SH transactions?\",\"a\":\"DSP only covers P2PKH transactions with specific requirements from the spec: 1) The transaction must contain all P2PKH inputs, 2) Either spending from confirmed UTXOs OR all mempool ancestors must also be all-P2PKH, 3) All inputs must be signed SIGHASH_ALL without ANYONECANPAY. If you have a P2SH ancestor in your 0-conf chain, the DSP 'score' is 0 - meaning NOT COVERED by DSPs. This is why not all 0-conf is equal - P2PKH from confirmed UTXOs has full DSP protection, but P2PKH descended from 0-conf P2SH has none.\"},{\"q\":\"Could minimum relay fees be automatically adjusted based on some on-chain metric?\",\"a\":\"Research exists on using block difficulty as a price oracle for this purpose. There's correlation between PoW difficulty and USD price, which could allow fees to auto-adjust without relying on any third party - it's a pure on-chain metric. See bitcoincashresearch.org/t/research-block-difficulty-as-a-price-oracle/1426 for details on this approach.\"},{\"q\":\"Why does BCH have a dust limit and can it be removed?\",\"a\":\"Dust limits control state bloat, which is critical for scaling. Without it, attackers could cheaply create millions of UTXOs that permanently stay in the UTXO set (Kaspa was attacked this way - see github.com/kaspanet/kips/blob/master/kip-0009.md). The per-byte transaction fee alone isn't sufficient to prevent state bloat attacks. The dust limit should be enforced on UTXO creation but not on spending - we want users to easily clean up and remove dust from state. One proposal is to halve the dust limit every 4 years, conditional on difficulty at least doubling (as a proxy for coin value growth).\"},{\"q\":\"What does faster block time improve beyond 0-conf payments?\",\"a\":\"Two main things: (1) AMM DeFi - these cannot use 0-conf because multiple users can compete for the same UTXO simultaneously. Until a block is mined, nobody knows which transaction will win. With 1-min blocks, wait time drops from 10-90 min to 1-9 min. (2) PR/perception - BCH appears 'snappier' with more confirmations in shorter timeframe. For regular payments, 0-conf handles everything fine.\"},{\"q\":\"Can miners game a hashrate-based price oracle by packing fake fees?\",\"a\":\"This was debated. Including fees makes the oracle gameable - miners could pack blocks with their own transactions paying fees to themselves. However, there's a deterrent: if the block gets orphaned by chance, those packed transactions enter the mempool and other miners can claim those fees. Also, extreme fee packing (2x-3x normal) makes the block tempting for other miners to reorg and steal. Historical evidence from BTC shows miners haven't reorged to steal even massive accidental fees (hundreds of BTC) - the risk of starting a hashwar prevents it.\"},{\"q\":\"What is the x402 protocol for web micropayments?\",\"a\":\"x402 is Coinbase's HTTP-based micropayment protocol using the HTTP 402 status code (Payment Required). It enables pay-per-API-call and pay-per-content models without traditional paywalls. The protocol is chain-agnostic - different implementations can support different cryptocurrencies. BCH with its low fees would be well-suited for this use case. The scheme is simple enough that BCH could build its own compatible economy around it, using stablecoins like PUSD for stable pricing.\"},{\"q\":\"How safe are multi-generational unconfirmed transaction chains on BCH?\",\"a\":\"P2PKH transactions are not malleable (by third parties), and unconfirmed chains aren't uncommon on BCH. Risk increases if the chain includes anyone-can-spend style P2SH UTXOs. For all-P2PKH chains, you can check for DSP (Double Spend Proof) against every unconfirmed transaction. BCH fixed 3rd-party malleability but 1st/2nd-party malleability (by private key holders or multisig participants) is still possible.\"},{\"q\":\"Is BCH x402 protocol implementation being worked on?\",\"a\":\"Yes - at least one developer is investigating x402 protocol implementation on BCH. The protocol (by Coinbase) is advertised as blockchain-agnostic and enables HTTP 402 payment responses. Work has started but was paused for other projects like BCH BLAZE workshops. Given BCH's low fees, it's well-suited for x402's micropayment use cases.\"},{\"q\":\"Are payment channels used in production on BCH?\",\"a\":\"Payment channels have been possible on BCH (and Bitcoin before it) for over a decade. At least one party has been making thousands of payment channels on BCH regularly, though not using standard libraries. BCH can also implement eltoo (Decker-Russell-Osuntokun) channels. The p2s output type should help lower complexity for implementation. Payment channels are especially viable for 1:1 relationships like service providers and users.\"},{\"q\":\"Is UTXO contention a problem BCH needs to address?\",\"a\":\"Yes - UTXO contention is a real issue BCH will need to face as usage grows. Chat apps that use shared UTXOs (like skynet.ar.io) encounter contention regularly. It's also easy to accidentally create double spends in automated systems that aren't mature yet. Protocol authors should recognize this is a place they don't want users to be and avoid shared UTXO patterns where possible. Exact tradeoffs in various solutions aren't yet clear.\"}]},{\"name\":\"Testing & Development Tools\",\"count\":1,\"faqs\":[{\"q\":\"In the CashAddr spec, why do test vectors use 'prefix:' literally as the prefix?\",\"a\":\"It's just an example for implementers to test their code with any arbitrary prefix. The encoded checksum depends on the prefix used, so the spec provides test vectors with a generic 'prefix:' placeholder so developers can verify their implementation handles custom prefixes correctly. Real addresses use 'bitcoincash:' for mainnet or 'bchtest:' for testnet.\"}]},{\"name\":\"dApp Development\",\"count\":5,\"faqs\":[{\"q\":\"How can I add a BCH address to my Nostr profile for receiving tips?\",\"a\":\"You can add a BCH address to your Nostr profile metadata using a custom field like 'bchAddr'. The Nostr data types and protocols already support this - you just add it to your kind 0 (metadata) event. For example: {\\\"name\\\": \\\"yourname\\\", \\\"bchAddr\\\": \\\"bitcoincash:qp...\\\"}. However, no major Nostr clients currently display or allow editing BCH addresses by default. For broader adoption, a coin-agnostic NIP proposal for tip addresses would help, where clients can auto-detect the coin type from the address format.\"},{\"q\":\"What is JeDex and how does it solve MEV?\",\"a\":\"JeDex is a limit order exchange designed to solve MEV (Miner Extractable Value) and fairness in DEX execution. Unlike AMMs where miners can reorder transactions for profit, JeDex uses a queuing system. A limit order exchange is also more efficient use of capital than an AMM - no need for large liquidity pools. Still in proof-of-concept stage, no production deployments yet.\"},{\"q\":\"Does Nostr support group chats like Telegram?\",\"a\":\"Yes - NIP28 defines the standards for group chats on Nostr relays. nostrchat.io is an open source front end that implements it. slpdex.com also uses NIP28 for its chat feature. These can't compete with well-funded companies like Telegram in terms of features and scale, but they enable chat apps that don't rely on centralized services. Note that NIP28 gets criticism - Fiatjaf called it a failure - but it works and people build software around it.\"},{\"q\":\"What is x402 and how has it been adapted for BCH?\",\"a\":\"x402 is a protocol created by Coinbase leveraging the HTTP 402 'Payment Required' error code (created alongside 404 but never properly utilized). Coinbase's implementation focuses on USDC payments on Base L2. A BCH adaptation has been created that uses the same protocol structure but accepts Bitcoin Cash for payments. Video walkthroughs and documentation are available for developers wanting to implement x402 servers accepting BCH.\"},{\"q\":\"Can I convert a Nostr npub to a BCH address?\",\"a\":\"No, you cannot directly convert a Nostr npub to a BCH address. Nostr uses secp256k1 keys (same curve as BCH), but an npub is a bech32-encoded public key, not a hash. BCH addresses are hashes of public keys. If you have access to the Nostr private key (nsec), you could derive both a BCH address and npub from it, but going from npub to BCH address would require the full public key bytes, then hashing them.\"}]},{\"name\":\"General BCH Development\",\"count\":11,\"faqs\":[{\"q\":\"How does block size affect propagation - is latency or bandwidth more important?\",\"a\":\"It depends on block size: smaller blocks make latency more important, larger blocks make bandwidth more important. With 1MB blocks (like BTC), bandwidth impact on propagation is minimal - latency dominates. With larger blocks, bandwidth becomes the bottleneck. Header-first mining helps with bandwidth (80 bytes propagate instantly) but doesn't help with latency (still bound by physics/speed of light). BCH's actual orphan rate is very low - less than one block per week.\"},{\"q\":\"Do faster blocks hurt 0-conf (zero-confirmation) transactions?\",\"a\":\"No, faster blocks do not negate nor hurt 0-conf at all. Zero-conf will always be the way forward for BCH instant payments. Faster blocks improve UX for use cases where 0-conf doesn't work (high-value transactions, exchanges, services requiring confirmations). The two approaches are complementary - faster blocks help cases where confirmations are needed, while 0-conf handles instant retail payments.\"},{\"q\":\"When is 0-conf appropriate vs when are confirmations needed?\",\"a\":\"Zero-conf is appropriate for anonymous, cash-like transactions at lower amounts (what you'd pay with paper money). For higher-value transactions (houses, cars, >$2000), confirmations are fine because: 1) These payments aren't anonymous - you have a named invoice, 2) They're not real-time - rent payments are checked 'have you paid' after an hour/day/longer, 3) The recipient has legal recourse via identity. The key insight: as soon as a transaction is not anonymous or has a named invoice, there's literally no need for instant finality.\"},{\"q\":\"Why does waiting for 1 confirmation sometimes take 40+ minutes with 10-minute blocks?\",\"a\":\"Block finding times follow an exponential distribution where the mean equals the target (10 minutes) but the median is different. The 50th percentile (median) wait for a 10-minute target is actually about 17 minutes, not 10. This means half the time you wait longer than 17 minutes for one confirmation, and occasionally much longer (40+ minutes). With a 2-minute target, the 50% wait would be about 3.4 minutes - 5x better. The benefit of faster blocks comes from reducing these long tail wait times.\"},{\"q\":\"Why does Tornado Cash use fixed deposit amounts?\",\"a\":\"To make deposits indistinguishable. With variable amounts, you could trace a 3.2 BCH deposit to a 3.2 BCH withdrawal. By using fixed tiers (e.g., 1, 10, 100, 1000 BCH), all deposits of the same tier look identical. When you withdraw, the cryptographic proof shows 'someone who owns a deposit key is withdrawing' - but not which specific deposit from the pool.\"},{\"q\":\"Why do block timestamps sometimes look inaccurate?\",\"a\":\"Block timestamp is used as extended nonce bits for mining. ASIC chips exhaust the 4-byte nonce space quickly, so miners roll the timestamp to generate more work without needing a new merkle root (which requires re-hashing the coinbase). The 'midstate' is the hash of the header up to the merkle root - the ASIC grinds the suffix (timestamp, target, nonce). When exhausted, controller provides a new midstate. This is why tightening timestamp accuracy rules would hurt miners.\"},{\"q\":\"How would BCH's ASERT difficulty adjustment handle faster blocks?\",\"a\":\"ASERT is time-based, invariant of target block time. If it could halve/double difficulty after 2 days with 10-min blocks, that continues with 1-min blocks - the adjustment is just done in more frequent, smaller increments. Result: smoother adjustment, not faster. Shorter blocks also reduce lag during big hashrate disruptions. ASERT's elegant design adapts easily to different block times with minimal parameter changes.\"},{\"q\":\"What is the GigaHashCoin concept for a decentralized price oracle?\",\"a\":\"GigaHashCoin proposes using mining difficulty and block reward as a trustless price oracle: GH/BCH = difficulty / block reward. Since mining difficulty is determined by the decentralized mining process itself, this oracle would be as decentralized as mining. With ASICs already far on the development S-curve (efficiency gains slowing), it should be less inflationary than fiat but still slightly inflationary. The oracle requires averaging price info over multiple blocks to reduce manipulation risk.\"},{\"q\":\"What are the key principles for a community DAO on BCH?\",\"a\":\"Three fundamental principles: (1) Proportional voting rights based on contribution amount, (2) Ability to withdraw remaining funds at any time - this prevents trapping money and perverse incentives like 'we have money, let's vote on whom to gift it,' (3) When DAO pays out, it takes the same percentage from everyone's original payment. These mechanisms hold the DAO accountable and prevent the corruption seen in traditional community funds.\"},{\"q\":\"Where can I get BCH/USD price data for applications?\",\"a\":\"For real-time prices: oracles.cash provides on-chain price data, or use REST APIs from BitPay and Coinbase that return simple JSON responses. For historical data: CoinGecko offers historical prices (though TOS is lengthy and reliability varies). Both BitPay and Coinbase have straightforward endpoints that don't require complex authentication for basic price queries.\"},{\"q\":\"What does 'non-final transaction' error mean in BCH?\",\"a\":\"This error means your transaction's locktime is set to a block height or timestamp that hasn't occurred yet. The transaction will be rejected until the specified time/block is reached. To fix this, check the current blockheight and make sure your locktime doesn't use anything newer than it. If you don't need timelock functionality, set locktime to 0 or a past block height.\"}]}]",
    "source": "faq/telegram/bch_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-0",
    "content": "Topic: name\nContent: \"BCHN FAQ\"",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-2",
    "content": "Topic: source\nContent: \"Bitcoin Cash Node Telegram 2025\"",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 222",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/bchn_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"Initial Block Download & Sync\",\"count\":61,\"faqs\":[{\"q\":\"How long does Initial Block Download (IBD) take for a BCHN node?\",\"a\":\"IBD time depends primarily on disk speed: approximately 12 hours on SSD, or 3-4 days on a slow spinning disk (HDD). With a top-of-the-line NVMe SSD, sync can complete in 3-4 hours. RAM is not a significant factor - disk I/O is the main bottleneck.\"},{\"q\":\"Is it safe to download blockchain checkpoints or snapshots from third parties?\",\"a\":\"It's not recommended to download blockchain data from unknown third-party sources. This creates trust issues since you can't verify the data wasn't tampered with. IBD from genesis doesn't take that long on modern hardware, so the security trade-off isn't worth it. However, copying your own node's data folder to another machine you control is fine.\"},{\"q\":\"What hardware specs matter most for running a BCHN node?\",\"a\":\"Disk speed is the most important factor, particularly for Initial Block Download. An NVMe SSD dramatically outperforms HDDs. RAM is not a significant factor - 8GB is plenty, and 16GB is more than enough. CPU helps with validation but isn't usually the bottleneck. For example, an 8-core VM with 16GB RAM and SSD storage can sync overnight with txindex enabled.\"},{\"q\":\"How do I restart sync from a specific block height if my node is on a bad chain or stuck?\",\"a\":\"Use the invalidateblock RPC command on a block hash to remove that block and all its descendants from your chain. Then use reconsiderblock on the same hash to restart sync from that height. For example, you could invalidateblock the last halving block, then reconsiderblock it to restart sync from that point.\"},{\"q\":\"How do I update my BCHN node to a new version on Linux?\",\"a\":\"The update process is straightforward: 1) Download the new version, 2) Unpack it, 3) Replace the old binaries with the new ones, 4) Restart the node. That's it - no special migration needed between minor versions.\"},{\"q\":\"Is BCHN Initial Block Download faster than Bitcoin Core?\",\"a\":\"Yes, BCHN IBD is significantly faster than bitcoind. This is likely due to both IBD improvements made by BCHN developers and the fact that BCH blocks are much less full than BTC blocks post-fork, meaning less data to process per block.\"},{\"q\":\"What IBD time can I expect with high-end hardware?\",\"a\":\"With top-end hardware (i9-14900k, 128GB DDR5, Samsung 990 Pro NVMe SSD, 3 Gbps internet), full IBD with txindex completes in about 3 hours. The bottleneck is typically the peers providing blocks, as CPU usage stays around 15%, RAM usage about 2GB, IOPS at 25%, and bandwidth 250-500 Mbps.\"},{\"q\":\"Why does CPU usage increase during IBD at a certain block height?\",\"a\":\"There's a checkpoint in BCHN where signature verification begins. Before this checkpoint, signatures aren't fully verified to speed up IBD. After the checkpoint, full cryptographic verification occurs, increasing CPU usage significantly. You can configure the node to perform complete verification from genesis, which is slower but more thorough.\"},{\"q\":\"How can I rebuild my chainstate without re-downloading the blockchain?\",\"a\":\"Delete the chainstate directory (and optionally txindex) while keeping your blocks folder. When you restart the node, it will rebuild the chainstate and UTXO set from your local block files. This eliminates download bottlenecks and tests your local verification speed. Rebuilding takes roughly 2h45m on high-end hardware without network overhead.\"},{\"q\":\"What are the main performance bottlenecks during IBD and verification?\",\"a\":\"The limiting bottleneck is typically a single-threaded unbuffered loop handling random reads and writes to the database. SSD random I/O performance requires high queue depth with multiple parallel threads to achieve maximum throughput. There's also I/O amplification from Berkeley database indexing. Modern SSDs can achieve 10x better random I/O with parallel threads vs single-threaded access.\"},{\"q\":\"Can I run BCHN on a Raspberry Pi 5?\",\"a\":\"Yes. With an NVMe SSD, IBD completes in about 5 hours 41 minutes on a Pi5. Full verification (checking all signatures from genesis) takes about 21 hours, partly due to limited 8GB RAM preventing the UTXO database from being fully cached. A system with more RAM (64GB+) can cache the entire UTXO set.\"},{\"q\":\"What should I do after my BCHN node is fully synced?\",\"a\":\"1) Copy it to a headless (no monitor) Linux server, 2) Make sure all ports are open and the node is visible from the outside - verify by connecting from a different internet connection like mobile/LTE, 3) Run the software for years in the background, 4) Occasionally connect via SSH to download and install BCHN updates (about once a year), 5) That's it - you're helping the network by providing peer connectivity and block propagation.\"},{\"q\":\"What is UTXO commitments and why is it better than bootstrap files?\",\"a\":\"UTXO commitments is a protocol feature being developed for Bitcoin Cash that allows nodes to verify a UTXO set snapshot cryptographically without trusting the source. Unlike bootstrap/checkpoint files which require trusting whoever provides them (an attack vector), UTXO commitments enable trustless fast-sync by including a hash of the UTXO set in block headers. This provides the speed benefit of snapshots with the security of full verification.\"},{\"q\":\"How do I configure dbcache to allocate more RAM for faster sync?\",\"a\":\"Add 'dbcache=1000' to your bitcoin.conf file to allocate 1GB of RAM for the database cache. This is near the point of diminishing returns, as Linux will also cache I/O. The default is a small amount, so explicitly setting it can speed up sync significantly. You need to specifically allocate RAM in the config - it won't automatically use available system RAM.\"},{\"q\":\"Can external storage cause slow sync times?\",\"a\":\"Yes, using external storage (especially over USB) can significantly slow down IBD. USB connections add latency compared to internal SATA or NVMe connections. If your sync is unusually slow, check if you're using external storage and consider using an internal drive instead.\"},{\"q\":\"Why does sync slow down dramatically near the end?\",\"a\":\"Two main reasons: 1) Blocks get much bigger in recent years due to increased usage, and 2) newer blocks get full signature checking which is CPU-intensive. You can use the 'connect=<ip>' option to download from a trusted node on your LAN for faster, more controlled sync. This also spares other people's bandwidth.\"},{\"q\":\"Does BCHN sync reliably from block 0 without manual intervention?\",\"a\":\"Yes, BCHN syncs reliably from genesis in most cases. BCHN developers have synced many times without issues. Some users report needing to use invalidateblock if they got stuck on a forked chain, but this is rare. Problems usually stem from unreliable hardware, power issues, unstable OS, or poor network connections rather than BCHN software issues.\"},{\"q\":\"How do I configure bitcoin.conf to speed up a slow sync?\",\"a\":\"Create a bitcoin.conf file with: 'listen=0' (don't listen for incoming connections), 'connect=<ip>' (connect only to a specific trusted peer like your own fast node), and 'dbcache=1000' (allocate 1GB RAM for database cache). Save this in the BCHN data directory ($HOME/Library/Application Support/Bitcoin/ on macOS, ~/.bitcoin/ on Linux). Restart the node to apply changes.\"},{\"q\":\"Is there a bootstrap option for extremely slow hardware?\",\"a\":\"There's a BitcoinCash1/Mainnet repository on GitHub that provides blockchain data you can download. However, syncing from the network is always recommended. If your hardware is so slow that sync would take years, the node probably won't be useful to the network anyway - it may burden other nodes with latency and bandwidth costs. Consider upgrading your hardware before running a public node.\"},{\"q\":\"What causes LevelDB corruption errors during BCHN sync?\",\"a\":\"LevelDB corruption (block checksum mismatch errors) can be caused by: 1) Hardware issues that disk tests might not detect, 2) Docker/container environment issues - try the straight x64 binary instead, 3) OS compatibility problems - RHEL-based systems have more issues than Debian. If fsck and badblocks pass but corruption persists on multiple machines, try a clean Debian installation without containers.\"},{\"q\":\"What is the -debug=leveldb flag used for?\",\"a\":\"The -debug=leveldb flag enables more detailed diagnostic messages when LevelDB errors occur. If you're experiencing database corruption during sync, restart your node with this flag to get more complete information in the debug.log file about what's going wrong.\"},{\"q\":\"Can defective RAM cause LevelDB corruption during sync?\",\"a\":\"Yes, don't rule out RAM as a cause of LevelDB corruption. Defective RAM and CPUs can do unexpected things that disk tests might not detect. If you've tested the hard drive and still see corruption, consider running memory diagnostics. Also, Docker containers still run on your main OS's filesystem and kernel - recent OS upgrades can cause issues that Docker can't isolate.\"},{\"q\":\"Is 8GB of RAM enough for a BCH node on Raspberry Pi?\",\"a\":\"Yes. People have successfully run 2 BCHN instances (mainnet + chipnet) with respective Fulcrum instances on a Pi 4 with 8GB without problems. Just make sure you have some swap configured for the initial sync and be prepared for the machine to spend a couple of days of work until it's up and running.\"},{\"q\":\"Do I need to configure swap for Raspberry Pi initial sync?\",\"a\":\"Yes, make sure you have some swap configured for the initial sync on Raspberry Pi. The sync process can be memory-intensive, and having swap prevents out-of-memory issues. Be prepared for the machine to spend a couple of days working until it's up and running with 8GB RAM.\"},{\"q\":\"Can a power outage or brown-out cause sync issues?\",\"a\":\"Yes. Power issues like brown-outs can damage RAM, which then causes LevelDB corruption during sync. In one reported case, persistent LevelDB corruption during sync was traced back to RAM damaged by a power brown-out. If you're experiencing unexplained sync failures, consider running memory diagnostics and checking your power supply.\"},{\"q\":\"How do I generate a wallet address and mine after syncing my node?\",\"a\":\"Use the bitcoin-cli binary which has wallet and mining commands. Run 'bitcoin-cli help' to see available commands. However, for day-to-day wallet use, you'd probably prefer Electron Cash instead of the full node wallet. For mining, you'll need separate mining software since BCHN doesn't include built-in mining functionality - the mining software works together with BCHN.\"},{\"q\":\"Is there a GUI version of BCHN for Linux?\",\"a\":\"Yes. BCHN ships two apps in the same download: bitcoind for CLI and bitcoin-qt for GUI. The Ubuntu PPA also has both. Check if you already have bitcoin-qt in your installation - it gets shipped with bitcoind.\"},{\"q\":\"Is BCHN faster to sync than bchd or Bitcoin Verde?\",\"a\":\"Yes. BCHN is faster to sync than the alternatives (bchd and bitcoin-verde). BCHN takes well under eight hours to sync on a good machine, sometimes much faster. Claims that 'BCHN is slow' are misinformation - it's the fastest BCH full node implementation to sync.\"},{\"q\":\"How do I know if my BCHN node has finished syncing?\",\"a\":\"Check the 'initialblockdownload' field using 'bitcoin-cli getblockchaininfo'. If 'initialblockdownload' is 'false', then the sync is done. Note that 'verificationprogress' will never be exactly 1 due to the weird way it's calculated, so use 'initialblockdownload' instead.\"},{\"q\":\"What should I do if my BCHN sync gets stuck?\",\"a\":\"Stop the sync and start it again - this usually solves 99% of the issues. It's typically due to network issues. Don't download from random torrent sources; just do sync from scratch, it's fast enough.\"},{\"q\":\"How does RAM affect IBD time?\",\"a\":\"RAM has a measurable but not dominant effect on IBD. On an i5 mini PC, IBD with 64GB RAM took 2h37m, while the same system limited to 8GB took 4h00m. The benefit comes from OS caching. Putting chainstate in a RAM disk only improved time slightly (to 2h29m) because IO processing is single-threaded, limiting parallelization benefits.\"},{\"q\":\"What's the standard practice for deploying multiple nodes?\",\"a\":\"Initial sync on a high-end system, then make your own archive of the data and use it to initialize other nodes. Update your backup occasionally. This is faster than syncing each node from scratch. An 'official' snapshot creates inappropriate trust dependency - keeping your own works great.\"},{\"q\":\"Why is the node P2P network better than torrent snapshots?\",\"a\":\"The node P2P network IS essentially a torrent network specifically tailored for blockchain. Nodes connect to a P2P network and download blockchain in chunks, but unlike torrents, they also verify as they download rather than waiting for the full download to complete before starting verification. This makes P2P sync more efficient than torrent-then-verify approaches.\"},{\"q\":\"What's the best way to keep BCHN updated automatically?\",\"a\":\"Install via Linux package manager (like Ubuntu PPA), and system updates will automatically keep BCHN updated. For manual installation: download new version, check signatures and checksums, unpack archive, stop service, copy binary, restart service. Package managers may have a slight version lag but ensure dependencies are correct.\"},{\"q\":\"Are UTXO commitments urgent for BCH?\",\"a\":\"Views differ. Some say it can wait years since internet/storage speeds keep increasing and IBD is already fast on modern hardware. Others argue it's important for first sync at mass adoption levels - even with fast hardware, IBD takes hours, and hardware may not scale as fast as chain growth with 256MB+ blocks.\"},{\"q\":\"What does 'checkpoint mismatch' error mean in BCHN logs?\",\"a\":\"This is normal behavior - a peer sent block headers that don't match BCHN's embedded checkpoints. The peer is marked as 'misbehaving' and discouraged (banned temporarily). Your node continues syncing from valid peers. Not everything printed to output are actual errors - BCHN is just telling you what's happening in the network.\"},{\"q\":\"What does 'socket recv error Connection reset by peer (104)' mean in BCHN logs?\",\"a\":\"This is not an error - it simply means a peer disconnected for any reason. This happens all the time and will continue to happen. Check progress=1.00000 which indicates 100% synced. Not all 'spooky' log messages are actual errors.\"},{\"q\":\"How efficient is Compact Blocks for very large blocks?\",\"a\":\"Compact Blocks has about 3% overhead relative to blocksize. At 1GB blocks, the transaction list would be ~30MB - still manageable with modern 1-2 Gbps bandwidth. If mempools are synced between nodes, blocks propagate easily with less than 1% missing transactions needing to be requested separately.\"},{\"q\":\"How can block propagation be optimized for scaling?\",\"a\":\"Nodes should set mempool policies to accept as many transactions as possible, minimizing missing transactions when receiving blocks. Ideally, nodes would maintain two caches: one for block template transactions and one for all valid transactions ever seen. The validation bottleneck should be removed from propagation, allowing pipelining of block data as it downloads.\"},{\"q\":\"What happens when BCHN's mempool gets full?\",\"a\":\"Transactions are randomly dropped from the mempool when it's full, and this affects the minrelay fee for the node (it increases). This is Satoshi-era legacy architecture. The node may later have to re-download dropped transactions when they appear in a block. Modern hardware has plenty of RAM and NVMe cache to avoid this, but the architecture hasn't been updated.\"},{\"q\":\"What does 'error code: -10 - Bitcoin is downloading blocks' mean when mining on testnet?\",\"a\":\"This error means your node is still syncing with the network and can't provide block templates for mining yet. Wait until your node is fully synced before attempting to mine. The error resolves automatically once sync completes.\"},{\"q\":\"What is the difference between Erlay and Graphene for block propagation?\",\"a\":\"Compact Blocks have download size that scales linearly with number of transactions because you must send the list of txids. Graphene further reduces the data needed to communicate which transactions are missing. However, Compact Blocks will probably be fine forever. If faster blocks are implemented, blocks stay smaller and Graphene's value proposition diminishes. Compact Blocks should be adequate for the foreseeable future.\"},{\"q\":\"What are the concerns about 1-minute blocks for SPV wallets and nodes?\",\"a\":\"With 1-minute blocks, there would be ~1 million blocks every 2 years. This creates header download concerns for SPV wallets (~800MB for 10 million headers from 2009 to now). BCHN currently keeps block headers in memory (~400 bytes per header in CBlockIndex), which would require 4GB RAM at 10 million blocks. While blocks can be pruned, headers cannot. However, SPV wallets can use header merkle proofs (periodic checkpoints) to avoid downloading all headers, making this solvable without consensus changes.\"},{\"q\":\"What are the tradeoffs of reducing block time to 1 minute?\",\"a\":\"It's not magical pixie dust - it solves some problems (variance reduction, faster finality for DeFi, potentially more mining decentralization) but creates new ones (10x more headers to download, more memory for header index, questions about reorg protection interactions at lower difficulty). The only purely technical concern is header size increase, but memory and bandwidth have improved far more than 10x since 2010. From a purely technical view, 1-minute blocks are superior to 10-minute blocks. The real issue is ecosystem impact and risk of politically induced chain split.\"},{\"q\":\"What happens when Compact Blocks fail to reconstruct a block?\",\"a\":\"Compact Blocks fail gracefully - even a full block download is just 3% overhead compared to a simple block message. Graphene is more complex and its fallback behavior when missing transactions is less clear. Since internet speeds keep improving, Compact Blocks' simple approach with graceful degradation is likely sufficient indefinitely.\"},{\"q\":\"What are the IBD times for Raspberry Pi 5 with different storage options?\",\"a\":\"On a Pi5 (8GB RAM, Ubuntu 24.04, dbcache=1000, txindex=1, gigabit internet): NVMe SSD takes 5h41m with default verification, or ~21h with full signature validation. USB-connected SATA drive takes 12h8m. Network storage via NFS takes 23h11m (26h17m through Wireguard), and SMB connection takes a whopping 261 hours. USB-connected SSDs on Pi5 are unreliable - they cause IO errors and read-only filesystem crashes. Use NVMe connection for reliability.\"},{\"q\":\"What are the main performance bottlenecks during IBD?\",\"a\":\"For mid-range and low-end PCs, IBD is either CPU-bound during signature checking, or IO-bound when managing the UTXO set. The IO problem is complex - it involves interaction between node software, database software (LevelDB), filesystem, and OS kernel, complicated by CPU caching. To benchmark properly, you can run IBD off a single local node to eliminate network variance, or rerun IBD after removing chainstate to test pure local verification speed.\"},{\"q\":\"What stratum proxy works well with BCHN for solo mining?\",\"a\":\"asicseer-pool (github.com/cculianu/asicseer-pool) works with zero fuss for BCHN solo mining. It's written in clean C code, builds easily on ARM64 devices like Raspberry Pi, and works reliably without heavy dependencies. Simply sync your BCHN node, configure asicseer-pool, and point your ASICs (like Bitaxe) at it to start solo mining.\"},{\"q\":\"Where can I find official Docker images for BCHN?\",\"a\":\"The official BCHN download page (bitcoincashnode.org/en/download) points to hub.docker.com/r/zquestz/bitcoin-cash-node. Other well-maintained Docker images include hub.docker.com/r/uphold/bitcoin-cash-node. For Fulcrum (Electrum server), use hub.docker.com/r/cculianu/fulcrum by the same developer.\"},{\"q\":\"Does BCHN have native Apple Silicon (ARM64) support?\",\"a\":\"Currently BCHN only provides x86_64 macOS builds. Apple M-series users can run it through Rosetta 2 which works well. Native ARM64 builds are planned for the future - when released, they'll likely be a 'fat' universal binary supporting both architectures in one download.\"},{\"q\":\"How can I solve USB SSD power issues on Raspberry Pi?\",\"a\":\"Don't power SSDs from the Pi's USB ports - Pi USB power is often insufficient. Use an external 5V power supply connected directly to the SSD while keeping the USB cable for data only (cut the power wire or use a data-only cable). Use a 5V relay to synchronize SSD power on/off with the Pi. Pi5 with NVMe via PCIe is more reliable than Pi4 with USB-connected drives.\"},{\"q\":\"What OS should I use for BCHN on Raspberry Pi 5?\",\"a\":\"Raspberry Pi OS (64-bit full version) works perfectly out of the box. No need for Ubuntu or other distros. Use the Raspberry Pi Imager to install it directly to your NVMe or SD card. For BCHN, download the aarch64-linux-gnu version from the GitHub releases page.\"},{\"q\":\"Do I need to install Berkeley DB separately for BCHN?\",\"a\":\"No. BCHN binaries are pre-compiled with everything needed - just download and run. Berkeley DB 5.3 is only required if you're building from source code. For Raspberry Pi, download the aarch64-linux-gnu version and run it directly without any compilation.\"},{\"q\":\"How do I start BCHN on Raspberry Pi after downloading?\",\"a\":\"Unzip the downloaded tar.gz file, navigate to the bin folder (cd bitcoin-cash-node-28.0.1/bin), then run ./bitcoin-qt for the GUI version or ./bitcoind for the headless daemon. Initial blockchain sync takes about 13 hours on Pi5 with good internet. If you get 'node is probably already running' error, reboot the Pi and try again.\"},{\"q\":\"How much RAM does BCHN need on Raspberry Pi?\",\"a\":\"8GB is plenty. Fully synced BCHN plus asicseer-pool uses less than 2GB total. During initial sync, RAM usage stays around 2GB. The 8GB Pi5 leaves plenty of room for running other programs alongside your node.\"},{\"q\":\"What is a peer in BCHN terminology?\",\"a\":\"A peer is another node on the BCH network. There are fully synced peers with complete blockchain data, pruned peers that only keep recent blocks, and peers currently syncing. Your node connects to peers to exchange block data and transactions.\"},{\"q\":\"How can I monitor my BCHN node's resource usage?\",\"a\":\"Install btop with 'sudo apt install btop -y' then run 'btop' in terminal. It shows real-time CPU, RAM, and network usage. On Pi5 during initial sync, CPU typically stays under 20% for early blocks since they have few transactions.\"},{\"q\":\"What CPU usage should I expect during BCHN initial sync?\",\"a\":\"Early blocks have few transactions, so CPU usage is low (limited by disk/network). CPU picks up as blocks get larger. BCHN skips signature verification until the last year of blocks, then CPU can reach 400% (all 4 cores at 100%) during signature checking near the end of sync.\"},{\"q\":\"What happens if BCHN loses power during initial sync?\",\"a\":\"Restart the node and it will continue from where it left off - usually only backing up slightly. For 24/7 operation, consider using a UPS with software to trigger graceful shutdown when battery is low. Use a systemd service file to auto-start/stop BCHN with the OS.\"},{\"q\":\"Does BCHN run on Windows?\",\"a\":\"Yes, BCHN has a Windows version - continuing the tradition from the original Satoshi client which was Windows-only. Downloads are available on the BCHN GitHub releases page. However, Linux (especially Debian) is generally preferred for server reliability and 24/7 operation.\"},{\"q\":\"Can I run BCHN with an HDD instead of SSD?\",\"a\":\"Yes, even a Raspberry Pi can keep up with an HDD, but initial sync takes significantly longer. SSD (even SATA) is better for performance. For mining or high-frequency transaction queries, SSD is strongly recommended. The blockchain data writes mostly once, but UTXO lookups benefit from faster storage.\"}]},{\"name\":\"Node Configuration\",\"count\":23,\"faqs\":[{\"q\":\"Do antivirus tools flag BCHN as malware?\",\"a\":\"Some antivirus tools like Avast, AVG, and DrWeb may flag BCHN as a 'Bitcoin miner' - which is technically accurate since it contains mining code, but this is a false positive in terms of it being malware. If you don't trust the pre-built binaries, you can always build BCHN from source code. You can check VirusTotal for the official releases to verify the scan results.\"},{\"q\":\"How high will transaction fees be when all BCH is mined and the block subsidy ends?\",\"a\":\"Fees should remain similar in purchasing power to what they are today. The Bitcoin Cash strategy is mass adoption - millions of very low-fee transactions that collectively provide substantial block rewards through volume. When the block subsidy runs out, fee markets will drive the system. With the large block space available at that point, there will be a base price like today, and a fee market would only kick in during rare periods of full blocks.\"},{\"q\":\"Can I copy my BCHN data folder to set up another node?\",\"a\":\"Yes, you can copy your own node's data folder to populate another node. Turn off the source node, transfer the entire data folder to the new machine, then start both nodes. Important: both nodes must have the same configuration, especially regarding pruning settings and transaction indexes (txindex).\"},{\"q\":\"Why is my node re-indexing after I restarted it?\",\"a\":\"A node shouldn't do significant indexing when restarting - only catching up on blocks mined while offline. If you see 'txindex is catching up on block notifications', that's normal brief catch-up. However, if indexing takes days after a simple restart, something may be wrong. Check your logs and ensure your configuration hasn't changed. Adding the txindex option to an existing node without it will trigger a full re-index.\"},{\"q\":\"Can I connect Electron Cash to a pruned BCHN node?\",\"a\":\"No. Electron Cash connects to Electrum-protocol servers (like Fulcrum or electrs), which require txindex to function. txindex is incompatible with pruning. Fundamentally, EC needs transaction history to function, and pruning is the opposite of keeping history - there's no way around this limitation.\"},{\"q\":\"Can I use BTC mining setup guides for setting up BCH mining?\",\"a\":\"Yes, setup guides that work for BTC will also work for BCH with minor adjustments. The mining process is essentially identical since both use SHA-256 proof-of-work. Running a BCH pool is exactly the same as running a BTC pool.\"},{\"q\":\"Can I run Bitcoin Core (BTC) and BCHN on the same PC at the same time?\",\"a\":\"Yes, but you need to customize the configuration files. Each node needs its own data directory (use -datadir option) and unique ports (use -port and -rpcport options). Make sure there are no port conflicts. Running nodes in separate containers or virtual machines is a cleaner approach that avoids configuration conflicts.\"},{\"q\":\"What does maxconnections actually control?\",\"a\":\"The maxconnections setting controls how many nodes you allow to connect TO YOU (incoming connections), not how many nodes you connect to. Most nodes only attempt 8 outgoing connections by default. To actively connect to more peers, use the addnode RPC command or add 'addnode=<ip>' entries to your config file.\"},{\"q\":\"How do I set up Miningcore mining pool with a BCH node?\",\"a\":\"Search for 'retromike miningcore' on YouTube for detailed tutorials on setting up a mining pool with BCHN. The setup allows multiple remote miners to connect to your pool. Before using pool software, enable direct mining on your local BCH node first.\"},{\"q\":\"Why can't Fulcrum replace BCHN RPC for all public API needs?\",\"a\":\"Fulcrum is not feature-complete for all RPC functionality - it doesn't provide some methods like getblock. Its daemon passthrough feature has no whitelist configuration, so enabling it would expose all RPC methods to the public including state-modifying commands. For blockchain data access with missing Fulcrum methods, you need a filtered RPC proxy in front of BCHN.\"},{\"q\":\"Should Linux node operators configure swap?\",\"a\":\"Yes. Swap provides several benefits: 1) It saves you in rare memory exhaustion cases - without swap the kernel kills your process immediately, with swap you have time to react, 2) Unused RAM pages get moved to swap, freeing space for useful file caches. Set swapiness correctly so it doesn't slow down when you have enough RAM. Some Linux distros now default to no swap, which is considered a mistake by experienced operators.\"},{\"q\":\"What determines minimum hardware requirements for running a BCH node?\",\"a\":\"The mempool size setting effectively determines minimum hardware requirements. To guarantee basic quality of experience for users, you need basic quality hardware. If you don't have enough RAM to cache the expected mempool size (currently ~300MB default, should be ~3GB), you can override defaults but should heed warnings. Even a swap file helps on lower-spec machines.\"},{\"q\":\"Does BCHN support wallets created with older Berkeley DB versions?\",\"a\":\"BCHN uses Berkeley DB 5.3. Newer BDB can read older BDB files (like those from version 4.8) but not the other way around. There's an '-upgradewallet' flag that upgrades the wallet database to the latest format when starting BCHN.\"},{\"q\":\"Why don't exchanges support CashToken addresses for BCH withdrawals?\",\"a\":\"While BCHN validates cashtoken addresses, exchanges like Binance only support legacy cash addresses, not token addresses. Many exchanges use the node's RPC directly for consensus, transaction format, and UTXO management rather than implementing it themselves. With enough user pressure and trading volume to justify it, exchanges would likely support token addresses, especially for stablecoins. Making BCHN wallet support CashTokens would make exchange adoption much easier.\"},{\"q\":\"What ports should I open for my BCHN node?\",\"a\":\"For mainnet, open TCP port 8333 for P2P connections with other nodes. Port 8332 is for the RPC interface (local communication with your own applications). The defaults are documented in the example config file at docs.bitcoincashnode.org/share/examples/bitcoin.conf. Only port 8333 needs to be forwarded on your router for incoming peer connections.\"},{\"q\":\"Does BCHN support testnet for development?\",\"a\":\"Yes, BCHN supports multiple test networks. Documentation is available at docs.bitcoincashnode.org/doc/test-networks/. Using testnet is recommended when developing StartOS packages or testing node configurations before deploying to mainnet.\"},{\"q\":\"Is there a multi-architecture Docker image for BCHN?\",\"a\":\"Yes, mainnet/bitcoin-cash-node supports both amd64 and arm64/v8 architectures. It uses Debian trixie-slim as the base image, allowing you to run BCHN on ARM servers and devices. When using it for chipnet/upgrade testing, remember to pass the -upgrade2026activationtime flag.\"},{\"q\":\"Why is BCHN limited to 16 outgoing connections?\",\"a\":\"The outbound connection limit is inherited from Bitcoin Core defaults - nodes make approximately 8-16 outgoing connections by default. The -maxconnections parameter primarily controls inbound connections. Some users report setting very high limits (999+) and reaching hundreds of connections without issues. The conservative default prevents excessive resource usage for typical deployments.\"},{\"q\":\"Can I run BCHN on a custom P2P port?\",\"a\":\"Yes, you can change the port in the config file. The node broadcasts its listening port to peers who pass it along to others. You can run multiple nodes (BCH, BTC, etc.) on the same IP by assigning different ports to each. Ensure your firewall/router allows the custom port. Use listen=1 in config to accept inbound connections on that port.\"},{\"q\":\"How do I fix Fulcrum build errors on macOS?\",\"a\":\"If you get errors like 'unknown type name __builtin_constant_p', upgrade to the latest macOS dev tools and do a clean rebuild: rm .qmake.cache; make distclean; qmake; make -j8. The qmake cache stores old compiler settings that cause issues after dev tool updates - always clean it when upgrading your build environment.\"},{\"q\":\"How do I enable PCIe Gen3 speed on Raspberry Pi 5?\",\"a\":\"Edit /boot/firmware/config.txt and add 'dtparam=pciex1_gen=3' in the [all] section. Check speed before and after with 'sudo hdparm -t --direct /dev/nvme0n1'. This nearly doubles NVMe read performance. Most modern NVMe drives work fine at Gen3 speed.\"},{\"q\":\"Which Docker image should I use for BCHN?\",\"a\":\"mainnet/bitcoin-cash-node is recommended because it supports both ARM and x86 architectures. zquestz/bitcoin-cash-node is another community option. Chris Troutner also maintains a well-documented Docker setup at cashstack.info for running BCH nodes.\"},{\"q\":\"Is there a Start9 package for BCHN?\",\"a\":\"Yes, an alpha Start9OS 0.4.0 package was created. For Fulcrum integration, it needs txindex=1 and ZMQ configuration. The package is being submitted to the Start9 community marketplace. Fulcrum-bch as a separate package is being developed to support running BCH alongside BTC on the same Start9 server.\"}]},{\"name\":\"Mining & Consensus\",\"count\":78,\"faqs\":[{\"q\":\"Who decides the transaction fee amount in Bitcoin Cash?\",\"a\":\"Fees are decided by miners through free market dynamics, just like today. A miner could theoretically set any minimum fee threshold, but pricing too high means processing fewer transactions. The free market determines the correct price. Miners won't mine below what's profitable, but they also won't price themselves above what's economically sustainable for the ecosystem (unless block space is full).\"},{\"q\":\"Does mining BCH cost the same as mining BTC?\",\"a\":\"Hash rate is governed primarily by price. The cost/revenue ratio between BTC and BCH is always roughly the same due to difficulty adjustments. If either chain becomes more profitable to mine, hash power moves there until the cost-to-revenue ratios balance out. This is how proof-of-work mining naturally equilibrates between SHA-256 chains.\"},{\"q\":\"Why do I see eCash or BSV nodes when running my BCH node?\",\"a\":\"You may see stale peer connections from eCash, ABC, or even BSV nodes. These are legacy peer connections that haven't been cleaned up. They may even attempt to send you blocks, but that doesn't mean you're on the same chain. Your node will reject incompatible blocks. There are no 'eCash nodes on the BCH chain' - these are just stale peer entries.\"},{\"q\":\"What is Bitcoin Core's 'kernel API' refactoring?\",\"a\":\"Bitcoin Core refactored their code into two portions: the 'kernel' containing core primitives and consensus/blockchain management, and everything else. However, this kernel isn't particularly reusable outside their build system - it's mainly internal code organization to make development and maintenance more scalable for their team. It doesn't significantly impact node performance or scaling capabilities.\"},{\"q\":\"What does 'can't open the block database' error mean?\",\"a\":\"This usually means the database files are locked by another process, corrupted, or you're trying to use the same data directory for multiple node implementations. If running both BTC and BCH nodes, ensure each uses a different data directory. Stop any other node instances, check for lock files in the data directory, and ensure you have proper file permissions.\"},{\"q\":\"How many publicly accessible nodes are there on the BCH network?\",\"a\":\"Around 200-500 publicly accessible nodes. While smaller than some other networks, BCH prioritizes on-chain scaling over node count. The network benefits from more public-facing nodes with open ports that can accept incoming connections. Fewer nodes means faster block propagation due to network diameter.\"},{\"q\":\"Has BCH already fixed the issues in Bitcoin Core's Great Consensus Cleanup proposal?\",\"a\":\"Yes, BCH has already addressed all the issues that Bitcoin Core's Great Consensus Cleanup proposes to fix: 1) Timewarp attack - impossible on BCH due to the ASERT DAA which examines block times differently, 2) Worst case block validation time (quadratic hashing) - already fixed, 3) 64-byte transactions - already disallowed on BCH. These fixes were implemented years ago.\"},{\"q\":\"Is the timewarp attack possible on BCH?\",\"a\":\"No. The timewarp attack is only possible on BTC due to a quirk/bug in how Bitcoin Core's DAA examines block times only on the first and 2016th blocks. BCH uses the ASERT DAA which is more sophisticated and doesn't have this vulnerability. The timewarp attack has never been possible on BCH since the DAA upgrade.\"},{\"q\":\"How does BCH's DAA prevent the timewarp attack?\",\"a\":\"BCH's ASERT DAA adjusts difficulty every single block and uses a 3-block median timestamp. Unlike BTC's 2016-block adjustment window that only examines timestamps on boundary blocks, ASERT continuously evaluates block times. This design completely eliminates the timewarp attack vector that exists in Bitcoin Core's original difficulty adjustment algorithm.\"},{\"q\":\"When did BCH fix the quadratic sighash problem?\",\"a\":\"BCH fixed the quadratic scaling of signature hashing in 2017, and further improved block validation with VM limits. This is the 'worst case block validation time' issue that Bitcoin Core's Great Consensus Cleanup is now trying to address. BCH solved it years ago.\"},{\"q\":\"Is there a coinbase transaction collision risk in BCH's future?\",\"a\":\"There's a theoretical edge case around block height 1,983,702 (~year 2040) where a coinbase transaction could potentially match a pre-BIP34 coinbase from early blocks. Some early miners put garbage in coinbase scripts that happened to look like height numbers. The fix is either implementing BIP30 verification for coinbase transactions, or implementing UTXO commitments which fixes this as a side effect. UTXO commitments are targeted well before 2040.\"},{\"q\":\"What hashing scheme will UTXO commitments use - MuHash or ECMH?\",\"a\":\"Both MuHash and ECMH (elliptic curve multiset hash) are being evaluated. MuHash is faster but larger (~300 bytes), while ECMH is smaller (33 bytes) but slower. BCHN has already added MuHash support. Bitcoin Core's 'assumeutxo' also uses MuHash. The final choice depends on tradeoffs between data size, computational speed, and compatibility with mining pools. Committing to a hash of the set descriptor (rather than the full descriptor) allows using either scheme with minimal coinbase overhead.\"},{\"q\":\"What is the UTXO commitments implementation roadmap?\",\"a\":\"The recommended approach is phased: 1) First, opt-in sharing of UTXO data via P2P protocol extensions (doesn't break nodes not participating), 2) Add ability for nodes to accept a UTXO set and continue from there, 3) Test that EC-multisets or MuHash are optimal and that P2P protocol changes work well, 4) Once proven scalable and useful, activate the consensus rule. This way the feature is immediately useful when activated, not just a theoretical improvement.\"},{\"q\":\"Are there concerns about larger coinbase transactions with UTXO commitments?\",\"a\":\"Yes. Some ASIC miners have issues with larger coinbase transactions - one pool found that coinbases paying more than ~100 addresses (~3.4KB) could crash ASICs. Additionally, the stratum mining protocol sends the base coinbase to miners, so larger coinbases mean more network traffic. These concerns need evaluation. An alternative is adding a second required transaction at position 2 in each block for extended header data, keeping the coinbase small.\"},{\"q\":\"How far back does the UTXO commitment lag?\",\"a\":\"The design for UTXO commitments specifies lagging 100 blocks behind the current block height. This means miners commit to the UTXO set state from 100 blocks ago, which is already known and stable. This approach doesn't break header-first mining since the commitment doesn't need to be continuously updated as new transactions are added to the block template.\"},{\"q\":\"Should wallets handle duplicate transaction IDs?\",\"a\":\"No, for practical purposes you can assume txid is always unique. Even in the rare historical cases of duplicate txids (blocks 91,812 and 91,842), only the most recent transaction's outputs are spendable - the earlier one becomes permanently unspendable. Wallets can safely use txid:index format without worrying about collisions.\"},{\"q\":\"What's the difference between BIP30 and BIP34?\",\"a\":\"BIP30 is the consensus rule that forbids new UTXOs from overwriting existing UTXOs (prevents duplicate txids). BIP34 is the rule requiring block height to be encoded in the coinbase script. Currently BIP34 is enforced but BIP30 is not (for performance reasons), because BIP34 guarantees BIP30 can never be triggered until ~2040. Before then, BIP30 enforcement needs to be re-enabled or UTXO commitments implemented.\"},{\"q\":\"Does BCHN include a built-in CPU miner?\",\"a\":\"No, BCHN removed the CPU miner component. CPU mining hasn't been practical for BCH for many years due to ASIC dominance. If you want to mine BCH, you need external mining software connected to your node (like cgminer or bfgminer) and ASIC hardware, or you can connect to a mining pool.\"},{\"q\":\"Can I connect my ASICs directly to BCHN for mining?\",\"a\":\"No, BCHN doesn't have built-in mining software. You need separate mining pool software (like ckpool) that connects to BCHN via RPC to get block templates, and then your ASICs connect to that pool software. Mining software doesn't replace BCHN - it works together with BCHN. BCHN provides the mempool and block templates; mining software handles the actual hashing.\"},{\"q\":\"Why are ASICs more energy efficient for mining than CPUs?\",\"a\":\"ASICs are purpose-built chips optimized specifically for SHA-256 hashing, while CPUs are general-purpose processors. The efficiency difference is so extreme that if someone used all the world's CPUs for mining, a single modern ASIC could outcompete them. CPU mining will spend far more on electricity than it ever earns in block rewards.\"},{\"q\":\"Can I run a blockchain explorer on top of BCHN?\",\"a\":\"Yes. You can run explorers like bch-rpc-explorer (github.com/sickpig/bch-rpc-explorer/) or custom explorers on top of BCHN. These connect to your node via RPC to display blockchain data in a web interface.\"},{\"q\":\"How can I verify my node is validating correctly?\",\"a\":\"Your node validates every transaction automatically. The logs print transaction count for every block. Compare your node's latest block hash with a public explorer to verify you're on the correct chain. There's no central website listing all nodes - this is by design (decentralization).\"},{\"q\":\"What happens if I upgrade BCHN after the May 2025 activation has already occurred?\",\"a\":\"If your node was stuck on an old chain (e.g., parked or rejected blocks due to new consensus rules), you'll need to use the 'reconsiderblock' RPC command on the first block after the upgrade activation. This tells your node to re-evaluate that block with the new rules. Simply upgrading the software isn't enough if your node already rejected blocks under old rules.\"},{\"q\":\"What does 'parked' status mean for a block?\",\"a\":\"A 'parked' block is one that your node has temporarily set aside rather than following. This happens when there's a potential chain split or reorg protection kicks in. You can see parked blocks with 'getchaintips' RPC. To follow a parked chain, use 'reconsiderblock' on the parked block's hash. Parking is a safety mechanism to prevent your node from following a malicious chain during attacks.\"},{\"q\":\"Why does testnet have frequent chain splits?\",\"a\":\"Testnet has very low proof-of-work requirements, which means blocks can be mined quickly in bursts. When multiple miners produce blocks at nearly the same time, the network temporarily splits until one chain accumulates more work. This is normal testnet behavior and helps developers test reorg handling. Mainnet's much higher difficulty makes such splits extremely rare.\"},{\"q\":\"How does CTOR help with transaction lookup performance?\",\"a\":\"CTOR (Canonical Transaction Ordering Rule) requires transactions in a block to be sorted by their txid. This enables binary search for transaction lookup instead of linear search. Finding a transaction in a block goes from O(n) to O(log n) complexity. This significantly speeds up block validation and transaction verification, especially as blocks get larger.\"},{\"q\":\"Why don't cryptocurrency exchanges support CashTokens yet?\",\"a\":\"Exchanges typically use the node's built-in wallet (bitcoind) for transaction management via RPC commands. Since BCHN's wallet doesn't have full CashTokens support, exchanges can't easily implement CashTokens trading. They prefer high-level RPC 'sendmoney'-style commands rather than implementing custom transaction authoring for each blockchain. Adding wallet-level CashToken support to BCHN would help exchanges adopt tokens.\"},{\"q\":\"Do cryptocurrency exchanges use node wallets directly?\",\"a\":\"Yes, all major exchanges we know use the bitcoind-style wallet directly. They support 100+ coins and find it easier to send high-level RPC commands to the node wallet than to implement detailed transaction authoring, signing, and coin management for each blockchain they support.\"},{\"q\":\"What are the 3 parts of the P2S CHIP that affect storage?\",\"a\":\"The P2S CHIP has 3 relevant parts: 1) Increase unlocking script (scriptSig) from 1650 bytes to 10KB for standard transactions - doesn't impact UTXO set but allows larger txns/blocks, 2) Max token commitment from 40 to 128 bytes - impacts UTXO database, 3) Locking scripts (outputs) can be any script up to 201 bytes instead of just templates - also impacts UTXO database since unspent outputs stay there.\"},{\"q\":\"How could BCHN improve block storage for per-transaction pruning?\",\"a\":\"Store 1 block per file in a hierarchical directory structure based on block hash (e.g., block 0000...abcdef12 stored at <datadir>/blocks/2/1/f/e/0000...abcdef12.blk). This enables per-transaction level pruning as Satoshi described in section 8 of the whitepaper. Bitcoin Verde already uses this approach. The subdirectories are keyed off the least significant nybbles of the block hash.\"},{\"q\":\"Is the hierarchical block file approach efficient?\",\"a\":\"Yes. Using just 4 hex characters (ff/ff) divides blocks by 256*256=65536 directories. For the next 150 years at normal 10-minute blocks: ~7.9 million blocks / 65536 = only 120 blocks per directory on average. Even with theoretical 10-second Infrastructure Blocks: 7218 blocks per directory. No UNIX filesystem has problems handling less than 10,000 files per directory.\"},{\"q\":\"What's the computational cost of UTXO commitments per block?\",\"a\":\"The computational cost is minimal - just a single elliptic curve addition or subtraction per each UTXO in a block. It costs about as much as verifying that block fees add up correctly. The overhead is negligible compared to other block validation operations.\"},{\"q\":\"How do major exchanges handle unsupported token deposits?\",\"a\":\"Coinbase: Funds are stuck - if the token is added in the future, they will be credited. Kraken: Funds stuck but you can contact support and they might recover them eventually for a fee. This is consistent with how BCH should handle unsupported CashTokens - the tokens just sit there until supported or manually handled.\"},{\"q\":\"What's the difference between token dust and BCH dust?\",\"a\":\"BCH dust can be consolidated without additional complications - just combine small UTXOs into one. Token dust cannot be consolidated without destroying the token, since tokens are tied to specific UTXOs. Determining 'spendable balance above dust needed to keep tokens' adds complexity. Most implementations just show full balance and handle dust preservation automatically in transaction creation.\"},{\"q\":\"Is there a block height limit for BCH?\",\"a\":\"Block heights are stored as int32 (signed 32-bit integer). Overflow would occur at approximately 2.1 billion blocks, which is about 20,000 years away at current 10-minute block times. This will require a hard fork to fix before then - plenty of time to plan.\"},{\"q\":\"How long should I wait for safe 0-conf without Double-Spend Proofs?\",\"a\":\"Wait about 5 seconds for transaction propagation across the network - after this, the probability of a successful double spend drops to nearly zero (assuming no miner-assisted attack, which is expensive). Double-Spend Proofs (DSPs) can reduce this safe waiting time to 2 seconds or less. Fulcrum provides DSP support for Electrum-protocol clients.\"},{\"q\":\"How does BCHN generate and propagate Double Spend Proofs (DSPs)?\",\"a\":\"When any node notices both conflicting transactions, it generates the dsproof and propagates it across the network. Individual nodes need one of the two transactions to validate the proof. The node may flush the proof when a block is mined containing one of the transactions. If a block contains 'the other' transaction, the node may generate a proof if that's the first time it sees both transactions.\"},{\"q\":\"Why is first-seen rule secure for 0-conf transactions?\",\"a\":\"Non-mining nodes don't matter for transaction security - once pools have seen it, it's as good as mined (unless pools themselves are hunting for better deals). If you can identify and query just the TOP10 mining pool nodes, no double spend will make it through.\"},{\"q\":\"Can 0-conf or DSPs handle DeFi scenarios where multiple valid transactions compete?\",\"a\":\"No - this is unsolvable by 0-conf or DSP schemes because there's no 'invalid' transaction when transactions are competing (like in DeFi arbitrage scenarios). There's no 'double spend' - every transaction is valid. Shorter block times can mitigate this by reducing wait time for confirmation.\"},{\"q\":\"How can I expose limited RPC calls to the public safely?\",\"a\":\"Use a thin microservice behind NGINX to filter allowed method names, with NGINX handling rate and bandwidth limiting. Safe methods for public exposure include: getblock, getblockcount, getblockhash, getrawmempool, getrawtransaction, waitfornewblock. Never expose state-modifying commands or wallet calls like listunspent to untrusted parties.\"},{\"q\":\"Why hasn't BCHN adopted Xthinner or Graphene for block compression?\",\"a\":\"Xthinner/Graphene are complex technologies and the benefits compared to BCHN's current Compact Blocks implementation would be minimal - just reducing the existing ~3% overhead further. When Bitcoin Unlimited donated Xthinner code to Bitcoin Classic, it caused remote attacks and crashes. Someone would need to rewrite it with security in mind. The current system works well enough.\"},{\"q\":\"How does BCHN's mempool eviction actually work?\",\"a\":\"When the mempool approaches its limit (~300MB default), transactions aren't evicted randomly. The minimum fee bar rises until enough low-fee transactions are dropped. When the situation normalizes, the fee bar drops again. This fee-based eviction strategy was inherited from Bitcoin Core around 2015, when attackers discovered they could crash nodes by flooding them with transactions until OS killed the process due to memory exhaustion.\"},{\"q\":\"Why is mempool coherency important for the BCH network?\",\"a\":\"You want everybody's mempool to be as similar as possible for best Compact Block performance. If nodes have different mempool sizes and policies, they'll drop different sets of transactions when full, leading to inconsistent relay policies. This causes bad UX where users think they paid but the merchant's node never saw the transaction, and increases missing transactions during block propagation.\"},{\"q\":\"Is BCHN's default mempool size appropriate for modern hardware?\",\"a\":\"No - the ~300MB default was set when average machines had 1GB RAM. Now average PCs have 8-16GB RAM, with node operators often having 64GB+. The baseline should be raised significantly. However, simply allowing variable mempool sizes creates coherency problems - ideally it should scale with ABLA (block size limit), like 30 blocks worth of transactions.\"},{\"q\":\"How should mempool size be determined going forward?\",\"a\":\"The suggestion is to link mempool size to the ABLA (Adaptive Block Limit Algorithm) cap - for example, 100x the current block size limit. This would be a flat number that can be updated with each network upgrade. Currently ~3GB would be appropriate. Dynamic sizing based on system RAM creates mempool incoherence problems because different nodes would drop different transactions.\"},{\"q\":\"Is there a single network-wide mempool?\",\"a\":\"No - there is no 'the' mempool. Each node has its own mempool. People often think of the mempool as shared cloud storage, but it's not. Mempool 'coherence' (keeping all nodes' mempools similar) is a goal that's impossible to perfectly achieve anyway, though beneficial for Compact Block performance.\"},{\"q\":\"Which nodes' mempools matter most for transaction confirmation?\",\"a\":\"Only nodes close to miners really matter. If explorers have huge mempools but miner-connected nodes have tiny ones, you'd see your transaction on explorers but it wouldn't get mined. The opposite could also happen - transaction doesn't show on explorers but gets mined because it reached miners through a different path.\"},{\"q\":\"What mempool size formula has BCH community consensus?\",\"a\":\"Around 72-144 times the current blocksize limit: 72x gives ~2.3GB now (half a day of blocks), 144x gives ~4.6GB (full day of blocks). This scales automatically with ABLA. Combined with a startup warning if system RAM is too small, this should serve the network well without manual updates.\"},{\"q\":\"What is the advantage of memory-mapped files for blockchain data?\",\"a\":\"Memory-mapped files aren't advantageous because of their swapping property (you get file cache for free with regular files anyway). The main advantage is reducing double and triple buffer copying in your app - less overhead to access data, which may pay off for CPU-intensive loads. The kernel manages flushing unused pages automatically.\"},{\"q\":\"Should BCHN allocate dedicated RAM for the UTXO set?\",\"a\":\"Yes. RAM is cheap (<$2/GB for DDR4). For mining pools and solo miners (the only nodes that affect network capacity under load), the cost of RAM is trivial compared to electricity for hashing. Allocating dedicated memory for the entire UTXO dataset plus mempool makes sense. BCHN should assume it runs on a dedicated server.\"},{\"q\":\"Where do most BCH nodes run - home hardware or VPS?\",\"a\":\"After Tor nodes, VPS nodes dominate the network. Anyone serious about running a pool should have no problem getting a 1GB/s VPS to relay blocks. Mining nodes generally shouldn't run on Tor due to increased orphan risk from latency, though anonymous mining is possible at a premium in increased orphan rates.\"},{\"q\":\"What hardware is needed to run a local BCH mining pool?\",\"a\":\"A basic setup with 16GB RAM and 200Mbps static IP can work, but a dedicated server or VPS is recommended over consumer hardware like an Optiplex. Internet latency matters more than bandwidth for mining. Use mining calculators like coinwarz.com to estimate how long it takes to find a block with your hashrate. For serious pools, use proper datacenter hosting with backup power.\"},{\"q\":\"What is pool solo mining and what are its benefits?\",\"a\":\"Pool solo mining allows multiple hashers to share a fast computer in a data center with low-latency internet connection. You receive the full block reward for blocks you find (minus a small fee to the node operator). It avoids the overhead of financial management by pool operators, which can have both technical and legal complications. While it doesn't reduce mining variance, it may improve profitability through lower orphan rates. Additional benefits include avoiding high pool overhead fees meant to cover share withholding attacks, and potentially avoiding government regulation as a money transmitter.\"},{\"q\":\"How much does luck affect solo mining profitability?\",\"a\":\"Luck is critical in solo mining - you could find 3 blocks in the expected time for 1 if lucky, or the inverse if unlucky. Experienced miners report blocks arriving at 1.5x-2x or even 6x the expected time. Solo mining works if you have enough capital (hardware and electricity) that variance doesn't matter, or if you're lucky. The pain of unlucky streaks is very real.\"},{\"q\":\"How does block size affect Compact Blocks efficiency?\",\"a\":\"On chains with 1MB blocks (like BTC), Compact Blocks loses its benefit when about 10% of transactions aren't in the public mempool. With larger blocks (like BCH's 32MB), even if 80% of transactions are missing, Compact Blocks remains beneficial. Larger block limits make Compact Blocks more resilient to mempool mismatches.\"},{\"q\":\"Will miners reorg each other's blocks to steal fees when block subsidy goes to zero?\",\"a\":\"This disaster scenario is unlikely. Miners can't spend stolen coins immediately due to the 100-block maturity requirement for coinbase outputs, so their incentive is for the chain to grow rather than be stuck at the same height. No single pool can afford to throw money away on failed reorg attempts - it only works with >=51% hashrate. For BCH, the goal is many low-fee transactions at constant rates, making fee sniping economically pointless. It makes no economic sense to reorg in order to steal.\"},{\"q\":\"How do faster blocks affect mining decentralization?\",\"a\":\"1-minute blocks mean 10x lower difficulty per block, making it 10x cheaper to start a viable solo mining operation. Due to non-linear wealth distribution (many more people have modest resources than large ones), a 10x reduction in solo mining cost may attract far more than 10x additional solo miners. Solo miners find blocks more frequently with faster block times, reducing painful unlucky streaks. However, this effect is relative - as price rises, hashpower follows, eventually requiring similar relative investment to mine solo.\"},{\"q\":\"Do 1-minute blocks increase orphan rates?\",\"a\":\"Not significantly. Smaller blocks take proportionally less time to verify - with parallel processing it's O(log n) for the Merkle root. Transmission delay is physical latency plus data divided by rate - smaller block times mean proportionally smaller blocks, keeping the same effect on orphan rate. Speed-of-light delay is <0.1 second for terrestrial propagation, insignificant for 1-minute blocks. The only remaining concern is header sizes, but that's been addressed by hardware improvements.\"},{\"q\":\"What are the requirements for changing BCH block time while maintaining halving alignment?\",\"a\":\"The new block time must be a number made of factors of 600 (e.g., 1, 2, 3, 5, 6, 10 minutes), and the change must be done at a 'tick' that's divisible by both the old and new interval durations. This ensures all dependent functionality (like the halving schedule) aligns nicely with the original schedule.\"},{\"q\":\"What limits the maximum block size in the P2P protocol?\",\"a\":\"The P2P protocol currently limits block size to 2GB because the message size field uses a 32-bit integer. A 10x increase in block frequency (e.g., 1-minute blocks) would allow up to 20GB every 10 minutes rather than 2GB, effectively kicking the can down the road before a P2P protocol upgrade is needed. Upgrading to a 64-bit size field is relatively straightforward and can be done with long deprecation periods.\"},{\"q\":\"Does block validation block propagation?\",\"a\":\"Yes, in the current architecture inherited from Bitcoin Core, if even just 1 transaction is missing from the mempool, validation will block propagation until that transaction is fetched and verified. This doesn't have to be the case - nodes could verify header and merkle root on the hot path and do the rest in parallel with propagation, but that's not how the current implementation works.\"},{\"q\":\"Why don't cryptocurrency exchanges support CashTokens yet?\",\"a\":\"Having the BCHN wallet handle CashTokens is likely a prerequisite for centralized exchanges to implement CashToken support. However, wallet support alone won't cause exchanges to automatically list tokens. Exchanges typically charge listing fees or require sufficient volume/liquidity, and they only list tokens that pay or qualify. The RPC already provides everything needed for block explorers - that's not an obstacle. For exchange integration, the token projects themselves (like MUSD) would likely need to contribute to getting wallet support implemented.\"},{\"q\":\"How many nodes are actually close to mining hashpower?\",\"a\":\"Research shows that even with more than 10,000 BTC nodes, there's only a small set of approximately 100 nodes that are really close to hashpower. To minimize orphan risk, a new miner would want to optimize their connections to announce blocks to this cluster using the shortest path available. This finding was documented in the Coinscope paper and has been recently replicated.\"},{\"q\":\"Is propagating blocks before full validation a DoS vector?\",\"a\":\"Not really, because nodes would still verify the header chain, header PoW, and block merkle root before propagating. Producing a valid header just to spam would cost significant proof-of-work. The block creator won't send bogus data because they'd lose their PoW reward if the block doesn't mature. There's still some delay between receive and send to hash all transactions and verify the merkle root, but that's much faster than full validation.\"},{\"q\":\"How does Compact Blocks handle missing transactions during block announcement?\",\"a\":\"When a node receives a Compact Block (header + short txids) and some transactions are missing from its mempool, it cannot immediately verify the merkle root because it only has short txids. The receiver must first get at least the full txids of missing transactions, then verify header PoW and merkle root, and only then forward the block to other peers. The rest of validation can proceed in parallel with propagation. If all transactions are already in the mempool, verification is just a matter of hashing and can be very fast.\"},{\"q\":\"How do I set up solo mining with BCHN?\",\"a\":\"Solo mining BCH with BCHN is essentially the same as BTC. You need: 1) ASIC miners (like Antminer series) designed for SHA-256 algorithm - CPUs won't work, 2) Mining software like CGMiner or BFGMiner, 3) A stratum proxy to connect ASICs to BCHN since ASICs can't speak RPC directly - they need the stratum protocol. BFGMiner can act as this proxy. Note: Small-scale solo mining is rarely profitable without major investment or cheap electricity due to intense competition from large mining operations.\"},{\"q\":\"Does BCHN have built-in Stratum support for mining?\",\"a\":\"No, BCHN does not have a built-in Stratum module. You need a stratum proxy to connect mining hardware. ASICs can't handle RPC directly - they only understand the simpler Stratum protocol. Software like BFGMiner can bridge between your ASIC's Stratum connection and BCHN's RPC interface. This is similar to Bitcoin Core's setup.\"},{\"q\":\"Can I run BCHN off an SD card on Raspberry Pi?\",\"a\":\"Not recommended. SD cards are slow and unreliable for BCHN. They may not survive long under the constant read/write operations of a blockchain node. Even with Pi5's faster bus, SD cards are not suitable for running a node. Use NVMe-connected SSD on Pi5 for best performance and reliability.\"},{\"q\":\"What does 'Potential stale tip detected' mean in BCHN logs?\",\"a\":\"This message appears when no new block has been received for more than 30 minutes (~2975 seconds). It's caused by normal mining variance - sometimes blocks just take longer to find. The node responds by trying additional outbound peers. This is not a problem with your node - it's just informing you that the chain tip hasn't been updated recently, which occasionally happens naturally.\"},{\"q\":\"Why is fast block propagation important for miners?\",\"a\":\"Fast propagation is crucial in both directions. When you find a block, you want maximum propagation to other miners so they start building on your block instead of potentially replacing it. In reverse, you want to see other miners' blocks ASAP so you don't waste hashpower trying to solve a height someone already got. Knowing the block header quickly is especially important - see 'header first mining'.\"},{\"q\":\"Why can't I connect my ASIC directly to BCHN?\",\"a\":\"ASICs (like WhatsMiner or Antminer) only speak the Stratum protocol, while BCHN provides an RPC interface. You need a stratum server in between. The architecture is: ASIC <-> Stratum Server <-> BCHN Node. The stratum server and pool software can be a single program. Software like BFGMiner can bridge this gap for solo mining setups.\"},{\"q\":\"How long would it take to solo mine a BCH block with 90 TH/s?\",\"a\":\"At current difficulty (approximately 728 billion), with 90 TH/s you'd statistically need about 402 days to hit a block. However, mining is probabilistic - someone hit a block with just 4 TH/s. The math gives expected time, but actual results vary wildly due to the nature of finding valid hashes.\"},{\"q\":\"What are the alternatives to the Bitcoin Unlimited block explorer?\",\"a\":\"If explorer.bitcoinunlimited.info is down, alternatives include explorer.bch.ninja (a fork of the same codebase) and explorer.melroy.org (a BCH-adapted mempool.space fork). These provide similar block exploration features for Bitcoin Cash.\"},{\"q\":\"Why does getBlockHash return 500 errors near the tip?\",\"a\":\"If getBlockHash returns 500 errors for recent blocks but works for older blocks, you're likely requesting a block height that doesn't exist yet. There may be a race condition in your code where you're asking for the next block before it's mined. Consider using ZMQ notifications instead of polling RPC for tip updates - it's more reliable for detecting new blocks.\"},{\"q\":\"Can I run asicseer-pool on Windows?\",\"a\":\"No, asicseer-pool only runs on POSIX-compliant systems (Linux, macOS, FreeBSD, NetBSD). It cannot run natively on Windows - only through WSL (Windows Subsystem for Linux). For mining setups, especially on devices like Raspberry Pi, it's strongly recommended to use Linux rather than Windows for both performance and compatibility reasons.\"},{\"q\":\"Is Raspberry Pi 5 suitable for BCHN and solo mining?\",\"a\":\"Pi5 with 8GB RAM works well for running BCHN and mining pool software. Use NVMe via PCIe for reliable storage - Pi4 USB3 connections can be unreliable due to power draw issues. BCHN uses ~925MB RAM on Pi5, pool software adds ~1GB more. For serious mining operations, consider a mini PC for better reliability. asicseer-pool runs efficiently on ARM but needs to be compiled for the ARM architecture.\"},{\"q\":\"What storage issues should I watch for with BCHN?\",\"a\":\"The blockchain data is write-once and not problematic, but the UTXO set requires key-value lookups that cause write amplification and NAND flash wear. BCH's current traffic level means this isn't urgent, but with higher load it becomes significant. SD cards are less reliable than NVMe SSDs for long-term node operation - consider using quality storage for production nodes.\"},{\"q\":\"Where can I discuss asicseer-pool setup?\",\"a\":\"Join the dedicated Telegram channel at t.me/asicseerpool for asicseer-pool discussions, setup help, and community support for solo mining with BCHN.\"}]},{\"name\":\"Network & Peers\",\"count\":26,\"faqs\":[{\"q\":\"Should I use Raspberry Pi 4 or Pi 5 for running a BCHN node?\",\"a\":\"Raspberry Pi 5 is strongly recommended over Pi 4. The Pi 4 has reliability issues with SSDs over USB - the drives may draw more power than USB spec allows, causing crashes and 'read only filesystem' errors. Pi 5 has native NVMe support over PCIe which is much more reliable. The Argon Neo NVMe case with a WD 1TB NVMe SSD is a good combination that can reliably run both BCHN and Fulcrum.\"},{\"q\":\"What SSD should I use with Raspberry Pi for BCHN?\",\"a\":\"For Pi 4: Samsung 860 EVO or Crucial MX500 (SATA-based, good over USB 3.0). For Pi 5: Use NVMe drives over PCIe - Samsung 970 EVO Plus or WD Black SN850. Pi 5 with an NVMe Base PCIe extension board accepting M-key NVMe SSDs (2230 to 2280) is the best setup. No need for expensive high-speed NVMe drives on Pi - the single PCIe lane limits bandwidth to ~900 MB/s anyway.\"},{\"q\":\"How do I clear my node's mempool to remove stale transactions?\",\"a\":\"There's no direct RPC command to clear the entire mempool. If you have stale transactions that weren't properly broadcast due to a crash or connectivity issue, you can stop the node, delete the mempool.dat file from your data directory, and restart. This forces the node to rebuild its mempool from the network. Note that BCHN doesn't automatically rebroadcast transactions - that's the wallet's responsibility.\"},{\"q\":\"What port does BCH mainnet use?\",\"a\":\"BCH mainnet uses port 8333, the same port as BTC mainnet. This is the default port for P2P connections.\"},{\"q\":\"What is port 18333 used for?\",\"a\":\"Port 18333 is used for testnet. If you're only running a mainnet node, you only need to forward port 8333. You don't need to map port 18333 unless you're running a testnet node.\"},{\"q\":\"Is Ubuntu 18 still supported for BCHN?\",\"a\":\"Ubuntu 18 support is being dropped. It uses ancient libc and an ancient compiler at this point, which is holding back development. Ubuntu 18 is also EOL (end of life). Consider upgrading to Ubuntu 20 or newer, or use Debian 12 which builds BCHN seamlessly.\"},{\"q\":\"How does BCHN handle orphan transactions?\",\"a\":\"When BCHN receives an orphan transaction (one with missing parent inputs), it asks the peer that sent it for the missing parent, but only once. If that fails, it gives up. This works fine on BCH because mempools typically clear every ~10 minutes due to low congestion, and you usually hear about parents through normal broadcast propagation. Bitcoin Core recently implemented asking multiple peers for missing parents, which BCHN may backport.\"},{\"q\":\"Why am I not getting inbound connections even after forwarding ports?\",\"a\":\"Your ISP might be using CG-NAT (Carrier-Grade NAT) which prevents port forwarding from working. Check your public IP at whatsmyip.org and see if it's in the 100.64.0.0/10 range. If your IP is in this range, your ISP is using CG-NAT and you won't be able to receive inbound connections without contacting them for a real public IP or using a VPN/tunnel service.\"},{\"q\":\"How do I create a new wallet in BCHN if I forgot my passphrase?\",\"a\":\"Stop BCHN, move or rename the wallet.dat file from your data directory (don't delete it permanently - rename it in case you remember the passphrase later), then restart BCHN. It will create a new wallet. The wallet.dat file is located in the BCHN data directory (e.g., ~/Library/Application Support/Bitcoin/ on macOS, ~/.bitcoin/ on Linux).\"},{\"q\":\"Is the Ubuntu PPA version of BCHN up to date?\",\"a\":\"Yes, the Ubuntu PPA repository has the latest version of BCHN (28.0.1) for all LTS versions of Ubuntu (bionic, focal, jammy, noble). Make sure to upgrade your BCHN node before network upgrades to stay in consensus. Check launchpad.net/~bitcoin-cash-node/+archive/ubuntu/ppa for current versions.\"},{\"q\":\"Why does macOS say BCHN crashed when I quit it normally?\",\"a\":\"This is likely a Qt framework issue, not BCHN-specific. The same behavior is seen with Electron Cash on macOS. The node shuts down successfully, but macOS reports a crash due to how Qt handles the shutdown process. Try running from the command line to see what it says upon shutdown. It's generally a benign cosmetic issue.\"},{\"q\":\"What ports does UPnP auto-map for BCHN?\",\"a\":\"UPnP only maps the one port used for the P2P network (8333 for mainnet, 18333 for testnet). Your router would show what it actually forwarded. Since there's only one port used for the P2P network, only one is requested at any time.\"},{\"q\":\"Can I manually add inbound peers to my node?\",\"a\":\"Inbound connections are initiated by remote peers, so you'd need to contact the remote operator to have them connect to you. You can add outbound connections manually from the CLI using the addnode RPC command.\"},{\"q\":\"How should BCHN wallet handle CashTokens for backward compatibility?\",\"a\":\"Recommended approach: 1) Track ALL tokens at database level (wallet must understand the structure), 2) Hide tokens from standard RPC output by default ('don't break userspace'), 3) When spending UTXOs with unsupported tokens, automatically send tokens back to same address, 4) Create separate commands like 'command_with_tokens' for token operations. This ensures legacy exchange software continues working unchanged while enabling token support for those who want it.\"},{\"q\":\"What levels of CashToken support could BCHN wallet implement?\",\"a\":\"Four tiers discussed: 1) Status quo - pure BCH only, anything with tokens is ignored, 2) Only whitelisted token UTXOs tracked, all others entirely ignored - this is what CEXs would want, 3) Everything tracked but only whitelisted tokens shown and spendable - declutters UI while allowing BCH extraction from airdropped tokens, 4) Full token support. Start with minimum viable product and add more levels later.\"},{\"q\":\"How quickly do BCH transactions propagate across the network?\",\"a\":\"Research by Peter Rizun (Bitcoin Unlimited, 2018) showed transaction propagation follows a steep curve: 50% of nodes know practically instantly, the vast majority in 3 seconds, laggards in 5 seconds. Network connectivity has improved vastly since 2018, making times even shorter - in practice, 2 seconds or less now in some locations.\"},{\"q\":\"Why shouldn't I expose BCHN's RPC interface directly to the public internet?\",\"a\":\"The RPC interface is not designed for public exposure - it has no rate limiting or protections against abuse. Heavy calls like listunspent can cause significant CPU burden. You could face excessive bandwidth costs from abuse. Use Fulcrum instead (which provides rate limiting), or put NGINX with rate limiting in front of a filtered RPC proxy.\"},{\"q\":\"Should wallets run as part of the same program as a BCHN node?\",\"a\":\"No - it's better for security, reliability and availability to run the wallet as a separate process, ideally on a separate computer. This isn't new - it goes back to early networking days in the 1970s. Satoshi included a wallet in his proof of concept software, but for production architecture, separating wallet from node is the recommended approach for building large-scale systems.\"},{\"q\":\"Should BCHN add CashTokens support to existing RPC commands or create new ones?\",\"a\":\"The recommended approach is to mostly replicate commands (create new token-specific RPCs) rather than modifying existing commands like sendtoaddress. This preserves behavior of existing commands and prevents breaking existing setups. Keeping old RPC calls unchanged is important for exchange compatibility. See GitLab issue #534 for the detailed proposal.\"},{\"q\":\"How do I know if my node port is properly open to accept connections?\",\"a\":\"Check the getnetworkinfo RPC output or your node's connection display. If you see 'In: 2' (or any number greater than 0 for inbound connections), your port is successfully open and accepting incoming connections from other nodes.\"},{\"q\":\"Is there a CashTokens testnet faucet?\",\"a\":\"There's no dedicated CashTokens faucet, but you can get testnet BCH from tbch.googol.cash and then mint your own tokens using Electron Cash or any other wallet that supports CashTokens. Testnet4 is recommended for CashTokens development testing.\"},{\"q\":\"What DNS seeds can I use if dnsseed.electroncash.de is down?\",\"a\":\"For P2P network peers, use seed.flowee.org. For Fulcrum (Electrum) servers with valid certificates, use ec-seed.flowee.cash. The Fulcrum seed is a DNS entry for known Fulcrum servers with non-self-signed certificates, making it easier to avoid hardcoding server addresses in wallet clients.\"},{\"q\":\"What macOS version does BCHN require?\",\"a\":\"BCHN v28 supports older macOS versions, but starting with v29 (the May 2026 upgrade release), BCHN will require macOS Sequoia (macOS 15) or later. Older macOS versions will no longer be supported.\"},{\"q\":\"What is the BCHN node expiration mechanism?\",\"a\":\"BCHN nodes have a built-in expiration tied to future upgrades. For v28, the node expires at the May 2027 upgrade date - after which RPC is shut off unless you pass -expire=0. This mechanism encourages users to upgrade before major network changes. The expiration is always set relative to the next-next upgrade to give users a full year to update.\"},{\"q\":\"What's an easy way to run BCHN for non-technical users?\",\"a\":\"Start9OS provides a user-friendly way to run BCHN with a nice UI. Fulcrum 2.0 with full CashTokens support is available there, with BCHN as a dependency. Once set up, it's plug-and-play. The BCHN interface on Start9 is being actively refined for better user experience.\"},{\"q\":\"Why is Linux preferred over Windows for running BCHN?\",\"a\":\"Windows is not designed for 24/7 server operation. System updates can corrupt your node or require reboots at inconvenient times. Linux provides better uptime and reliability for node operation. Users who switch from Windows to Linux for running nodes typically report most problems disappear.\"}]},{\"name\":\"RPC & API\",\"count\":8,\"faqs\":[{\"q\":\"Does BCHN maintain backwards compatibility with RPC calls?\",\"a\":\"BCHN tries to maintain better backwards compatibility than Bitcoin Core, which is notorious for removing RPC calls and breaking older software. The philosophy is that deprecated calls can be hidden from help output but shouldn't be removed entirely, as removal breaks existing tooling that depends on those calls.\"},{\"q\":\"What is the history of the minimum transaction size rule on BCH?\",\"a\":\"ABC originally required minimum 100-byte transactions to prevent merkle tree attacks using 64-byte transactions. In 2023, BCH changed this to require minimum 65 bytes. While technically only 64 bytes needed to be disallowed, >=65 was chosen to avoid confusion. This prevents merkle tree attacks that could exploit 64-byte transaction collisions with internal merkle nodes.\"},{\"q\":\"Why does BCHN still use LevelDB despite its known issues?\",\"a\":\"LevelDB is widely known to have problems, especially with large UTXO sets, but it's 'just good enough' that replacing it is considered too risky given Bitcoin's history with database changes. Changing the database is technically challenging and could introduce consensus bugs. A database migration CHIP has been proposed for future implementation, but for now LevelDB remains the default.\"},{\"q\":\"Should I switch from bitcoind to bitcoin-qt (GUI) for running a node?\",\"a\":\"No. If you're already using command line (bitcoind), you should NOT need to switch to GUI. Keep using bitcoind. Most of the nodes used in exchanges and pools are bitcoind.\"},{\"q\":\"Should the BCHN wallet track all CashTokens or just specific ones?\",\"a\":\"The wallet should track ALL tokens at the database level. Tokens can be filtered on GUI/RPC levels, but ignoring tokens at the database level would risk burning them accidentally or ignoring valid UTXOs sent to the wallet. You would never ignore any other UTXO, so why ignore tokens?\"},{\"q\":\"Can legacy software accidentally spend CashTokens UTXOs?\",\"a\":\"No - this was a core design feature of CashTokens. Any external program not set up to spend CashToken UTXOs cannot spend them 'accidentally'. However, showing legacy software CashToken outputs it cannot spend could break the program in other ways. BCHN already has an 'includeTokens' parameter that defaults to false in commands like listunspent to prevent this.\"},{\"q\":\"Is there a 'from address' concept in Bitcoin/BCH transactions?\",\"a\":\"No, there is no such thing as a 'from' address in Bitcoin. While sending back to the 'source address' technically works, this has been considered bad practice since SatoshiDice days. For custodial wallet users, the 'source' might be an exchange hot wallet, not the user's address. Never assume you can return funds to where they came from.\"},{\"q\":\"How should BCHN handle BCH on token UTXOs with includetokens=true?\",\"a\":\"Show BCH from all UTXOs regardless of attached tokens. When any tokens are spent for any reason, automatically extract above-dust sats to a non-token change output. This is similar to how Electron Cash handles it. The includetokens=false behavior must NEVER change - this is the critical backward compatibility rule.\"}]},{\"name\":\"Performance & Hardware\",\"count\":4,\"faqs\":[{\"q\":\"Can Xthinner code quality be trusted?\",\"a\":\"The existing Xthinner code has reputation problems. When Bitcoin Unlimited donated their Xthinner code to Bitcoin Classic, it caused remote attacks and crashes. Someone would need to reimplement it from the specification with security in mind. The potential performance gains don't justify the definite costs of implementation and deployment risk at current usage levels.\"},{\"q\":\"What is the real purpose of swap on modern Linux systems?\",\"a\":\"Swap is for stuff in RAM that you're not actually using - you move it out of sight and it likely never returns to RAM. For over a decade, swap hasn't been about allowing more memory for operations (the OOM killer prevents that). Swap and swappiness is about increasing system performance by removing unused data to make room for more valuable disk caches.\"},{\"q\":\"What is BCHN's position on AI-generated code for wallet features?\",\"a\":\"BCHN maintainers are not fans of using AI for production wallet code. Wallet code is delicate - the programmer must fully understand the system. AI creates new classes of risks because it can hallucinate or lie and introduce subtle bugs. The preference is for developers who fully own and understand the subsystem including the nuances of the language.\"},{\"q\":\"Where can I discuss Fulcrum server operation and development?\",\"a\":\"For Fulcrum-specific operator and developer discussions, join the Telegram group at t.me/electroncashserver. This is the dedicated channel for Fulcrum questions, packaging help, and technical discussions.\"}]},{\"name\":\"Upgrades & Updates\",\"count\":9,\"faqs\":[{\"q\":\"What is BCHC and how does it relate to BCHN?\",\"a\":\"BCHC is essentially the same as BCHN but with the Chronik indexer integrated. It's a fork of BCHN that includes Chronik for enhanced indexing capabilities. Note that BCHC may be a bit behind the main BCHN version in terms of updates.\"},{\"q\":\"I'm getting a GMP version error when building BCHN on RHEL-based systems. How do I fix it?\",\"a\":\"This is a known issue with the cmake FindGMP module on RHEL-like systems (Alma Linux 8/9). The build system has trouble parsing GMP wrapper files in /usr/include. Workaround: delete the GMP wrapper files and rename the architecture-specific files to the wrapper filenames. The issue is logged in GitLab. Alternatively, use Debian 12 which builds seamlessly.\"},{\"q\":\"Why does BCHN-QT show a warning about 'unknown/unstable version' when I built from source?\",\"a\":\"If you build from git master branch, you get the latest development version which shows this warning. Development builds between releases are labeled with version numbers like 28.0.2 even before 28.0.2 is officially released. If you want a specific stable release (like v28.0.1), run 'git checkout v28.0.1' before building to get that exact tagged release.\"},{\"q\":\"Should I use git master or a tagged release for building BCHN?\",\"a\":\"For production use, checkout a specific release tag like 'git checkout v28.0.1' before building. Building from master gives you the latest development code which may have unreleased features or changes. The release tags correspond to tested, stable versions.\"},{\"q\":\"What features are in the May 2026 BCH upgrade?\",\"a\":\"The May 2026 upgrade (Upgrade 12) includes: Bitwise opcodes, native Functions for BCH Script, Loops for iteration in scripts, and Pay-to-Script (P2S). Preview builds are available for testing on chipnet before mainnet activation. Chipnet activates these features first, allowing developers to test before mainnet goes live.\"},{\"q\":\"How are BCH upgrades named internally in BCHN?\",\"a\":\"BCHN is transitioning from numbered upgrades (Upgrade 11, Upgrade 12) to year-based naming (upgrade2026, upgrade2027). This avoids issues with 'unlucky' numbers (13 in Western culture, 14 in Chinese culture) and makes the upgrade schedule clearer since BCH has annual consensus upgrades.\"},{\"q\":\"What Debian version is required for BCHN binaries?\",\"a\":\"BCHN binaries require Debian 12 or newer due to GLIBC 2.32/2.33/2.34 dependencies. If you get GLIBC version errors on Debian 11 (e.g., 'GLIBC_2.33 not found'), upgrade to Debian 12 to resolve them. Alternatively, you can manually build BCHN from source if you have a C++20 compiler available.\"},{\"q\":\"When did May 2026 upgrade features activate on chipnet?\",\"a\":\"The May 2026 upgrade features (Bitwise opcodes, Functions, Loops, P2S) activated on chipnet in mid-November 2025 when MTP timestamp 1763208000 was reached. Chipnet activates features months before mainnet, giving developers time to test new Script capabilities before the May 2026 mainnet activation.\"},{\"q\":\"When will BCHN v29 be released?\",\"a\":\"BCHN v29 (the May 2026 upgrade release) is targeted for release before the end of 2025, giving node operators several months to upgrade before the May 2026 mainnet activation.\"}]},{\"name\":\"Troubleshooting\",\"count\":3,\"faqs\":[{\"q\":\"What is the most commonly used operating system for running BCHN?\",\"a\":\"Probably Windows or Debian-based Linux distributions. BCHN builds most seamlessly on Debian 12. RHEL-based distributions may have build issues with certain dependencies.\"},{\"q\":\"Can changing the database cause a hard fork?\",\"a\":\"No, upgrading the database is not a hard fork. A new database can be designed and deployed permissionlessly. If the DB is bug-free, switching the DB can't result in a fork. As evidence, BCHN uses LevelDB, but Verde and Flowee use different databases - this has never caused consensus issues between implementations.\"},{\"q\":\"Does BCH need pre-consensus for simple payments?\",\"a\":\"No. For the majority of BCH transactions (simple payments by honest users), the first-seen rule coupled with Double Spend Proofs is adequate. Pre-consensus may only be needed for high-value DeFi transactions with intentional race conditions between honest players competing for the same UTXO. The 'zero reward problem' is not immediately pressing and may never materialize if transaction volume grows. Off-chain mechanisms appropriate to specific applications may serve better than a one-size-fits-all pre-consensus protocol.\"}]},{\"name\":\"General BCHN\",\"count\":10,\"faqs\":[{\"q\":\"When did BCHN switch to CMake from autotools?\",\"a\":\"BCHN switched to CMake around 2019, approximately 6 years before Bitcoin Core began their CMake transition. The autotools build system was considered difficult and cumbersome to work with compared to CMake.\"},{\"q\":\"Are there official BCHN ARM64 Docker images?\",\"a\":\"The official BCHN Docker images (zquestz/bitcoin-cash-node) are built via CI. ARM64 builds have been discussed and may be added in the future. For now, you may need to build your own ARM64 images or use the native ARM64 binaries directly.\"},{\"q\":\"Should BCHN add more built-in features?\",\"a\":\"BCHN developers prefer to remove features rather than add them. The philosophy is to keep BCHN focused on core node functionality. People can build additional features on top as separate projects. Keeping BCHN minimal makes it more maintainable and reduces attack surface.\"},{\"q\":\"What other BCH node implementations exist besides BCHN?\",\"a\":\"Other implementations include: Knuth, Bitcoin Unlimited (BU), BCHC (BCHN with Chronik), and Bitcoin Verde. These are all valid node implementations that follow the same consensus rules.\"},{\"q\":\"Why is CashTokens easier to track than SLP was?\",\"a\":\"SLP required tracking a DAG (directed acyclic graph) on top of UTXOs, plus running SLPDB as an inefficient indexing layer. CashTokens don't require any DAG tracking - the token data is directly embedded in the UTXO itself, making it much more manageable to track.\"},{\"q\":\"Do UTXO commitments need to be consensus-enforced?\",\"a\":\"There's debate on this. Some argue per-implementation commitments (like Verde's approach) are sufficient since you always have some root of trust anyway. Others argue there's no real cost to having consensus-level commitment, so why settle for trusted when trustless is achievable?\"},{\"q\":\"How does a typical cryptocurrency exchange handle deposits?\",\"a\":\"Standard exchange workflow: 1) Address generated for each user (all may be in single wallet file), 2) When coins hit an address, wallet notifies upper layer and balance is registered with exchange, 3) Coins forwarded to central management hot wallet, 4) Withdrawals handled from hot wallet in conjunction with balance database. Exchanges must manage balances internally since trades happen off-chain.\"},{\"q\":\"Is BCHN available in Umbrel?\",\"a\":\"No, BCHN is not available in the Umbrel app store. You need to install it manually from bitcoincashnode.org. If you're using Umbrel on a Linux system, ensure the binary path matches and it should work. You can also symlink to /opt or another location. Umbrel is based on Debian.\"},{\"q\":\"Is BCHN available on StartOS?\",\"a\":\"No, BCHN is not currently packaged for StartOS (a popular sovereign node operating system). However, the process to package it is straightforward - clone the Bitcoin Core package and replace the internals with BCHN. The StartOS team has indicated they're open to having Bitcoin Cash applications. Once a working .s9pk package exists, it can be submitted to the StartOS community registry.\"},{\"q\":\"How do I set up a Raspberry Pi to run BCHN remotely?\",\"a\":\"Use the Raspberry Pi Imager to load the OS image onto an SD card with SSH enabled. Then plug the SD card into the Pi - it will boot and allow remote access via SSH. You can then manage everything from your laptop/desktop without needing to plug keyboard, mouse, or screen into the Pi. This headless setup is the standard approach for running Pi-based nodes.\"}]}]",
    "source": "faq/telegram/bchn_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-0",
    "content": "Topic: name\nContent: \"CashScript FAQ\"",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-2",
    "content": "Topic: source\nContent: \"CashScript Telegram 2025\"",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 114",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashscript_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"Language & Syntax\",\"faqs\":[{\"q\":\"What language improvements are planned for CashScript?\",\"a\":\"Planned improvements include: enforcing correct bytesX for .split() assignment, disallowing bytesX types in function arguments (as these are untrusted/unenforced), renaming tx.age to something like this.activeInputAge, new syntax for activeInput (this.activeInput instead of tx.inputs[this.activeInputIndex]), syntactic sugar for slice operations, creating a source map for optimized bytecode, struct functionality to ascribe names and lengths to parts of bytestrings. Longer term: template syntax for constructor arguments so they're inserted where needed rather than always pushed at the start, and better support for hand-optimized contracts.\"},{\"q\":\"What types of structs are planned for CashScript?\",\"a\":\"Two types of struct are being considered: (1) Fixed-size 'bytestructs' that only support bytesX types, and (2) General variable-size 'structs' that support all types including bytes, int, and string. With bigint, casting to a fixed-bytesize might add large overhead, so both types will likely be needed in the long run.\"},{\"q\":\"Does CashScript support global constants?\",\"a\":\"Currently, constants can only be defined within functions (like 'int constant CONTRACT_IN = 1'), and they get put on the stack, wasting opcodes on stack manipulation when used. Global constants that inline the value at compile time are a planned feature being tracked in GitHub issue #80.\"},{\"q\":\"How can multiple variable-sized data items be stored in a single bytestring in CashScript?\",\"a\":\"Use length-prefixed encoding: each variable-length item is preceded by a byte indicating its length. For example: bytes1(completionBytecode.length()) + bytes(completionBytecode) + bytes1(feePayoutBytecode.length()) + bytes(feePayoutBytecode). This is essentially 'compiled OP_PUSH' - manually implementing what a push opcode does.\"},{\"q\":\"Has tx.age been changed in CashScript?\",\"a\":\"Yes, tx.age has been renamed to this.age to indicate that it is a UTXO-level field, not a transaction-level field. This change was included in a CashScript release.\"},{\"q\":\"What's the difference between this.activeBytecode and tx.inputs[i].unlockingBytecode in CashScript?\",\"a\":\"tx.inputs[i].unlockingBytecode represents the unlocking bytecode (scriptSig) of a specific input. this.activeBytecode represents the contract bytecode of the input currently being evaluated. The activeBytecode does NOT contain the unlocking arguments (function arguments, function selector). If you have multiple functions in a contract, there's a hidden/implicit function selector argument, but it won't be part of the activeBytecode.\"},{\"q\":\"When should I use fixed-size byte casting in CashScript?\",\"a\":\"Casting an integer to a fixed-size byte-length is very important when storing local state in an nftCommitment. If you have multiple values concatenated in one field, you need fixed length for most items to be able to split them (or use length-indicators). See next.cashscript.org/docs/language/types#int-to-byte-casting\"},{\"q\":\"What happens when casting bytes(n + 1) in CashScript? What's the length?\",\"a\":\"When you convert bytes to integer, increment, then convert back to bytes, the length depends on whether the commitment is minimally encoded as an int or not. A commitment could be bytes8 of zeroes and the end result would only have length of 1. Casting to bytes without a length argument is a noop (no OP_NUM2BIN call). Only when you pass a length argument will you have the opcode, and overflow can occur if casting to a byte size too small for the number.\"},{\"q\":\"Will NUM2BIN overflow after the BigInt upgrade?\",\"a\":\"No. NUM2BIN can't overflow the stack item but it can overflow max int. With BigInt, maxint==maxstack, so no more overflow. Any valid stack item will be convertible to a valid int through bin2num (though you may hit VM limits depending on your budget).\"},{\"q\":\"Do I need to prefix hex strings with '0x' in CashScript contract params?\",\"a\":\"No, you don't need to prefix hex strings with '0x' in the contract params. Just use the raw hex string.\"},{\"q\":\"Does CashScript support loops?\",\"a\":\"Yes, CashScript @next version has a do-while looping construct. This feature was developed before the BCH Blaze Hackathon to make it available for participants. Documentation is available at next.cashscript.org/docs/language/contracts#loops-beta. Note that while the underlying VM Limits upgrade activated in May 2025, native loop opcodes (OP_BEGIN/OP_UNTIL) are part of the May 2026 upgrade.\"},{\"q\":\"How do I compile do-while loops in CashScript?\",\"a\":\"Install `cashc@next` to compile do-while loops. You can also check the preview version of the CashScript playground which uses the @next version. The underlying opcodes are OP_BEGIN and OP_UNTIL. Note: v0.13.0-next.1 includes fixes for edge cases when using do-while loops with the SDK debug tooling.\"},{\"q\":\"Do nested loops work in CashScript?\",\"a\":\"Yes, nested loops should work straightforwardly in CashScript. The documentation at next.cashscript.org/docs/language/contracts#loops-beta shows how loops work. If you have specific ASM code that needs nested loops, it can be converted to CashScript syntax.\"},{\"q\":\"Does CashScript support reusable functions?\",\"a\":\"Not yet. CashScript currently has 'functions' that define spending/unlocking conditions on a contract, but these are not reusable code-blocks with typed inputs and outputs. They are evaluated scripts for which evaluation is valid or invalid. Reusable functions (with typed inputs/outputs usable across your code like in TypeScript) are planned but will take at least half a year of development work to integrate.\"},{\"q\":\"Will CashScript have global variables like Solidity?\",\"a\":\"Global variables are planned for CashScript. However, they are 'global' only within the CashScript evaluation context - NOT global like ETH global state. For persistent state between transactions, you still need to use token commitments and carry your state with you. Global variables don't require new opcodes; it's a CashScript language feature that will improve code organization.\"},{\"q\":\"How do I get only part of a bytes value without using split's tuple?\",\"a\":\"Use `.slice(start, end)` instead of `.split()` if you don't need the second part. For example, `commitment.slice(0, 5)` returns the first 5 bytes without creating a tuple. See cashscript.org/docs/language/types#bytes for details.\"},{\"q\":\"Why can't I assign a tuple to already declared variables?\",\"a\":\"In CashScript, tuple destructuring assignment must happen when declaring the variables. You cannot assign a tuple to already declared variables. This is a language limitation - structure your code to declare variables at the point of splitting.\"},{\"q\":\"What is the type of tx.time and how do I convert it to bytes?\",\"a\":\"tx.time is an int (bigint). To convert it to bytes for storing in an NFT commitment, use casting per cashscript.org/docs/language/types#casting-table. Note that tx.time represents the locktime value set in the transaction - you must set it via txBuilder.setLocktime() from the SDK.\"},{\"q\":\"Is there a proposal for adding loops to BCH script?\",\"a\":\"Yes, there is a CHIP (Cash Improvement Proposal) for bounded looping operations: bitcoincashresearch.org/t/chip-2021-05-bounded-looping-operations/463\"},{\"q\":\"Why propose dedicated registers for OP_EVAL code execution instead of using the stack?\",\"a\":\"The stack already serves as a register - it can hold code to be executed. Dedicated registers would require additional opcodes to put code there. With OP_EVAL, code can come from anywhere: pushed directly, from introspection of other inputs/outputs, or constructed dynamically. The stack-based approach is simpler and more flexible.\"}]},{\"name\":\"Transaction Building\",\"faqs\":[{\"q\":\"Can you introspect the transaction fee inside a CashScript contract?\",\"a\":\"No, the transaction fee is not a value you can introspect in BCH script. You would have to calculate the fee yourself inside the contract by summing all input values and subtracting all output values.\"},{\"q\":\"How should I handle transaction fees in CashScript contracts?\",\"a\":\"You can hardcode a miner fee in the contract (like minerFee = 1000), but this isn't the actual tx fee - it's just how much the contract allows to release for fee payment. To tightly set the actual tx fee requires summing all input and output values. Since BCH script doesn't have loops, this isn't feasible for variable numbers of ins/outs, so contracts typically require fixed numbers of inputs and outputs. Adding `require(tx.inputs.length == 1)` would make a hardcoded fee match the actual fee.\"},{\"q\":\"Are smart contract transactions more expensive than regular signed transactions for splitting funds?\",\"a\":\"No, a splitter contract transaction can actually be *smaller* than a custodian signing a spend that splits the coins. You can have a contract address that splits amounts 50:50 to address A and B; whenever someone sends to the contract, anyone can build a tx that executes the split. See unspent.app/documentation#divide for a dApp that sets this up.\"},{\"q\":\"How can I create a UTXO that only two specific parties can spend?\",\"a\":\"This is what a 1-of-2 multisig address does. CashScript can create a contract address where UTXOs can only be spent by two different people/keypairs using a require statement for a list of Sig/pubkey, similar to Escrow.cash with optional recipients.\"},{\"q\":\"How do I create a transaction requiring inputs from two different parties?\",\"a\":\"You need two scripts (two different P2SH addresses): Script1 says 'I can only be spent by person A and need to be next to an input with script2'. Script2 says 'I can only be spent by person B and need to be next to an input with script1'. Each UTXO can specify the full required transaction shape. If using multisig, there's only 1 script with no requirement of 2 UTXOs spent by different parties.\"},{\"q\":\"What does 'Locktime requirement not satisfied' error mean?\",\"a\":\"This error means the transaction has a locktime that hasn't been reached yet. If you're using tx.time checks in your contract, you need to set the locktime with txb.setLocktime() to match your contract's requirements. Tip: Try setLocktime(0) first to isolate the issue, then set the proper value.\"},{\"q\":\"What does 'bad-txns-nonfinal, non-final transaction' error mean?\",\"a\":\"This error means you set a blockheight as locktime which has not been reached yet by the blockchain. The transaction cannot be mined until the locktime is met. Check your setLocktime() value and ensure the blockchain has passed that time/block.\"},{\"q\":\"Why does my locktime transaction fail even though the time has passed?\",\"a\":\"The blockchain doesn't have the exact time. It uses 'median time past' - a trailing measure because it's a decentralized system without an accurate real-time concept. When using tx.time with seconds-based locktime, you may need to wait longer than expected. The blockchain time can lag behind real-world time, causing transactions to be rejected as 'non-final' until the median time past catches up.\"},{\"q\":\"How does locktime work - is it block number or timestamp?\",\"a\":\"Values less than 500,000,000 are interpreted as block numbers. Values 500,000,000 or higher are interpreted as Unix timestamps. This is set in the transaction via txBuilder.setLocktime(). From the contract, you check tx.time and compare with stored values.\"},{\"q\":\"How do I check the current block for absolute timelocks?\",\"a\":\"In JavaScript: `const nextBlock = await provider.getBlockHeight()` then `txBuilder.setLocktime(nextBlock)`. In the contract, `tx.time` will contain the current block number when the locktime is set to a block height.\"},{\"q\":\"Is txb.build() async in CashScript?\",\"a\":\"No, txb.build() is not async in CashScript. You don't need to await it.\"},{\"q\":\"How do I lock an output with P2S (Pay-to-Script) in CashScript?\",\"a\":\"P2S is not yet supported as first-class in CashScript. However, the transaction builder allows sending to arbitrary Uint8 lockingBytecode (which enables P2S outputs). You'd manually construct the locking script from contract arguments + artifact compiled output. For general BCH documentation, see documentation.cash.\"}]},{\"name\":\"SDK & API\",\"faqs\":[{\"q\":\"What makes CashScript unique?\",\"a\":\"What makes CashScript unique isn't advanced language features. It's the SDK with a great (fully overhauled) transaction builder API and integrated debugging functionality, plus the language tooling: online playground, contract testing-suite, syntax highlighting & auto-completion.\"},{\"q\":\"How can I create CashTokens using the CashScript SDK?\",\"a\":\"Creating CashTokens (both fungible and non-fungible) with the CashScript SDK is easy using the advanced transaction builder. Simply add the `token` parameter to your transaction output: { to: contract.tokenAddress, amount: sendAmount, token: { amount: 100n, category: contractUtxos[0].txid } }. The 'advanced' transaction builder is being made the default in the next release.\"},{\"q\":\"What is the correct format for TransactionBuilder.addOutput()?\",\"a\":\"The addOutput method takes an object parameter with 'to' and 'amount' properties: txb.addOutput({ to: address, amount: bigintValue }). Don't pass separate arguments. Refer to cashscript.org/docs/sdk/transaction-builder#addoutput--addoutputs for the correct signature.\"},{\"q\":\"What does 'missing inputs' error mean in CashScript?\",\"a\":\"'Missing inputs' means your transaction is missing one or more inputs. It's related to transaction building, not signing. Check that you're correctly using transactionBuilder.addInput(someUtxo, someUnlocker) and try console.log(someUtxo) before adding it as an input to verify your UTXO data is correct.\"},{\"q\":\"Should I use TypeScript when developing with CashScript?\",\"a\":\"Yes, strongly recommended. CashScript is a TypeScript library with full type checking from start to finish. Many errors that are difficult to debug in JavaScript would be caught immediately by TypeScript. For best integration, compile CashScript artifacts in .ts format using 'cashc --ts' flag.\"},{\"q\":\"Is there a Python version of the CashScript SDK?\",\"a\":\"CashScript-Py (a Python version of the CashScript SDK) is being developed. Python is one of the most popular programming languages, and this project aims to attract new developers and enable a new category of BCH applications. See fundme.cash/campaign/37 for the crowdfunding campaign.\"},{\"q\":\"Do I need to match my cashc compiler version with my CashScript SDK version?\",\"a\":\"Yes, to properly use the improved debug tooling, cashc v0.11 outputs additional data in the artifact. If you're on cashc v0.8 but cashscript v0.11, the debugging tooling is not as good. Both should be on the same major version.\"},{\"q\":\"Does CashScript produce JSON artifacts for contracts?\",\"a\":\"Yes, CashScript produces ABI artifact JSON files during compilation. This artifact contains the contract's ABI (Application Binary Interface) including function definitions, parameter types, and the compiled bytecode. The artifact is used by the SDK to instantiate and interact with contracts. For working with contracts programmatically, use the TransactionBuilder API documented at cashscript.org/docs/sdk/transaction-builder.\"},{\"q\":\"Can the CashScript SDK manage non-CashScript scripts?\",\"a\":\"Yes, the CashScript SDK can handle non-CashScript-based spend scripts. The TransactionBuilder has a generalized concept of 'unlockers' that allows this flexibility. However, it requires manual tinkering and there's no official documentation for this use case yet.\"}]},{\"name\":\"Debugging & Testing\",\"faqs\":[{\"q\":\"What debugging capabilities does the new CashScript transaction builder provide?\",\"a\":\"The latest CashScript pre-release adds debugging capabilities to the new transaction builder. This allows the transaction builder to be used with local testing/debugging using mocknet as well as inside the Bitauth IDE. The old (simple) transaction builder has been marked as deprecated. A migration guide is available at next.cashscript.org/docs/releases/migration-notes\"},{\"q\":\"Why is there a difference between CashScript's debugging bytecode and production bytecode?\",\"a\":\"The contract bytecode is optimized for production, but the debugging tooling with Bitauth IDE uses the 'unoptimized bytecode' (found in artifact under debug.bytecode). This is a known issue where dev and prod are different. Workaround: Remove the 'debug' object from the artifact to use correct bytecode without the 2-way mapping, or switch to CashScript 0.10.5 which doesn't add debugging tooling and develop on chipnet.\"},{\"q\":\"Does CashScript's .debug() use the improved VM limits from May 2025?\",\"a\":\"Only in the @next version of CashScript. The stable release includes it after the upgrade is deployed.\"},{\"q\":\"Is there a difference between CashScript's dev and prod bytecode now?\",\"a\":\"As of v0.11.0, the sourcemap and debug info have been reworked to work with the contracts' optimized bytecode. This means your contracts are exactly the same in 'dev' as in 'prod'.\"},{\"q\":\"Why do I get 'Script evaluated without error but finished with a false/empty top stack element'?\",\"a\":\"This error is most likely related to something in your contract logic, not the internal workings of the CashScript compiler. To debug, share your full contract and instructions to reproduce the error. Also ensure you're using matching versions of cashc and cashscript SDK - v0.11 of both is recommended as it significantly improves debug tooling.\"},{\"q\":\"How can I see the line-by-line mapping of CashScript to opcodes?\",\"a\":\"Use the BitauthIDE debugging integration with `const uri = await transactionBuilder.getBitauthUri();`. This opens Bitauth IDE with: CashScript source code in comments on the right panel, compiled opcodes color-highlighted in the middle panel, and opcode execution results on the far right. Documentation at cashscript.org/docs/guides/debugging#bitauth-ide. Note: This requires full transaction context, not just the compiler.\"},{\"q\":\"Does mocknet support the upcoming BCH VM upgrades?\",\"a\":\"Yes, mocknet allows you to configure which virtual machine is used for evaluation, so you can use BCH 2026. The CashScript @next branch has this set as the default mocknet configuration, allowing you to test contracts using the new opcodes before they activate on mainnet.\"},{\"q\":\"Can I use functions and loops in Bitauth IDE that aren't yet in CashScript?\",\"a\":\"Yes. CashScript @next has do-while loops available now. Functions with the new opcodes can be used in Bitauth IDE, which is a lower-level tool. If you need features not yet in CashScript, Bitauth IDE provides direct access to the new BCH opcodes.\"},{\"q\":\"How can I debug high transaction fee errors in CashScript?\",\"a\":\"Add logging before sending: `const totalInputAmount = transactionBuilder.inputs.reduce((acc, input) => acc + BigInt(input.valueSatoshis), 0n);` and `const totalOutputAmount = transactionBuilder.outputs.reduce((acc, output) => acc + BigInt(output.valueSatoshis), 0n);` Then calculate `txFeeSats = totalInputAmount - totalOutputAmount`. Also get `byteLength = transactionBuilder.build().length / 2`. High fee errors usually mean you're failing to account for some value in the inputs. The maximum fee safety options help catch these issues before accidentally burning funds.\"},{\"q\":\"Why can't I console.log tx introspection values in CashScript?\",\"a\":\"You can only log variables, not introspection statements which still need to be evaluated at runtime. Assign the introspection value to a variable first, then log the variable.\"},{\"q\":\"Can I test multiple contracts in a single transaction in CashScript?\",\"a\":\"Yes, the CashScript playground supports combining multiple different smart contracts into one transaction and provides great debugging results. A preview is available at cashscript-playground-git-multi-contract-lahana.vercel.app\"},{\"q\":\"Does the CashScript playground require transaction confirmations to see UTXOs?\",\"a\":\"No, the playground uses Electrum servers to fetch UTXOs so it doesn't require confirmations - it should show 0-conf UTXOs. If UTXOs aren't appearing immediately, the refresh button may have an issue. Note: Testing on mainnet is discouraged; mocknet is the default for a good reason.\"},{\"q\":\"What testing tools does CashScript v0.12.1 provide?\",\"a\":\"CashScript v0.12.1 introduced a test extension for the Vitest test runner, making it easier to write and run tests for CashScript contracts. This integrates CashScript contract testing directly into modern JavaScript/TypeScript testing workflows.\"}]},{\"name\":\"CashTokens\",\"faqs\":[{\"q\":\"Is there documentation for using CashTokens with CashScript?\",\"a\":\"Yes, a CashTokens guide has been created for the CashScript documentation. It covers creating, transferring, and managing CashTokens. See the CashScript documentation guides section.\"},{\"q\":\"What happens if I leave out a token from a CashScript transaction output?\",\"a\":\"Leaving out a token just burns it. This is a common gotcha that surprises developers. If you have tokens in an input and don't include them in an output, they are permanently destroyed.\"},{\"q\":\"How can I check if a token is an NFT and what its capability is?\",\"a\":\"The NFT capability is stored at the end of the tokenCategory with an extra byte. The first 32 bytes are the tokenCategory, and byte 33 indicates NFT capability if present: 0x (empty) = no NFT, 0x00 = immutable NFT, 0x01 = mutable NFT, 0x02 = minting NFT. Check `tx.inputs[i].tokenCategory.length > 32` to verify it's an NFT.\"},{\"q\":\"Why doesn't my token category match between contract and explorer?\",\"a\":\"CashScript uses little endianness for tokenCategory, which is different from how explorers display it (big endianness). You need to reverse the byte order when comparing. There's a video explaining this at youtu.be/uDfOFlfo1aA?t=868.\"},{\"q\":\"What are common mistakes when working with token categories?\",\"a\":\"Two common mistakes: 1) Script uses different endianness from explorers and transaction building - you may need to reverse byte order. 2) `.tokenCategory` appends the capability byte to the 32-byte tokenId, making it 33 bytes for NFTs. If you see '02' at the end, that's the minting capability byte. The documentation has clear warnings about these issues.\"},{\"q\":\"How can I merge NFTs in a contract?\",\"a\":\"Burn the input NFTs by not including them in outputs, then create a new one. In the contract, require specific input categories and ensure they're not used in outputs while outputting a new NFT with the merged properties. This is essentially 'burn N and create 1' pattern.\"},{\"q\":\"How do I create an NFT collection using the Cash-Ninjas minting contract?\",\"a\":\"The commands for creating NFT collections are documented in the README at github.com/cashninjas/minting-contract. The tooling has been used successfully for projects like the Pepi collection. For specific problems, ask in the CashScript Telegram group.\"},{\"q\":\"How do ERC20 tokens map to BCH's UTXO model?\",\"a\":\"For basic fungible token functionality (creating, transferring, querying balances), use CashTokens native fungible tokens directly - no smart contracts needed. BCH has first-class support for fungible tokens at the protocol level. However, if you need advanced features like custom supply management, tokenomics hooks, or transfer restrictions, you would need to create a CashScript contract wrapper around the tokens. The key insight: basic ERC20 = native CashTokens; extended ERC20 = CashScript contract + CashTokens.\"}]},{\"name\":\"State Management\",\"faqs\":[{\"q\":\"How can I make a CashScript contract copy itself with modified constructor arguments?\",\"a\":\"This is called 'simulated state'. Use this.activeBytecode to get the contract bytecode (includes constructor arguments but NOT unlocking arguments), split off the parts to replace, prepend new constructor arguments in reverse order with push byte prefixes (e.g., 0x14 for 20-byte push), hash the result and require output matches new LockingBytecodeP2SH32(newContractHash). Example at github.com/mr-zwets/RefreshContractV2. Note: The contract address changes each time. Storing state in NFT commitments (as BCH pump contract does) is now the preferred approach.\"},{\"q\":\"What is the best way to manage contract state in CashScript?\",\"a\":\"Simulated state (modifying constructor arguments) is now considered an antipattern. The BCH pump contract demonstrates the superior approach: storing contract state externally in an NFT commitment. This keeps the contract address stable while allowing state changes.\"},{\"q\":\"Can I store data in a CashScript contract like Solidity?\",\"a\":\"BCH does not have global state like Ethereum. Instead, create a CashToken NFT and store data in its commitment. This gives local transferrable state your contract can introspect to base decisions off and update if needed. The commitment size is currently max 40 bytes, increasing to 128 bytes with the May 2026 upgrade.\"},{\"q\":\"Why doesn't BCH have global state like Ethereum?\",\"a\":\"It's actually an advantage - it's what sets BCH and the CashVM apart from ETH in terms of performance. Global state is considered bad for scalability. BCH uses a UTXO model where state is carried with tokens (NFT commitments). The XO stack may make this 'carry state with you' approach easier to manage in the future. You can achieve similar functionality to ETH contracts with slightly different patterns.\"}]},{\"name\":\"Contract Design & Patterns\",\"faqs\":[{\"q\":\"Why use CashScript smart contracts instead of a JavaScript server controlling funds?\",\"a\":\"The key difference is custody and trustlessness. Smart contracts hold funds in a trustless manner where even the contract creator cannot access them. With a server, you control a pubkey and can change your code/payout anytime. Smart contracts commit to constraints that cannot be changed (e.g., 10% always goes to address A forever). CashScript is for creating on-chain enforced rules that don't require trusting an operator. The idea is 'code as law' - not needing courts, just code.\"},{\"q\":\"What is a practical example of a CashScript smart contract?\",\"a\":\"A 'Last Will' inheritance contract: instead of giving someone custody of your BCH funds to process inheritance when you die, you give control to a smart contract where you still hold custody but after some idle time your relatives can claim the funds according to the contract rules. Example code is available at cashscript.org/docs/guides/covenants#restricting-p2sh-recipients\"},{\"q\":\"What developer patterns is CashScript planning to support natively?\",\"a\":\"The CashScript team has observed three patterns users have developed: (1) Defining structs as comments to track how to 'split' bytearrays, (2) Creating macros/re-usable functions on top of CashScript (like Fex.cash did for reusable constants across contract files), (3) Defining transaction shapes inside contract logic to give better mental models for input/output meaning. The team wants to support all these natively. Patterns 1 and 2 can take inspiration from existing languages like Solidity. Pattern 3 is unique to the UTXO model with introspection - no existing programming language has support for this, requiring novel language design research.\"},{\"q\":\"Are CashScript contracts deployed like Ethereum smart contracts?\",\"a\":\"Think of BCH contracts as elaborate spending conditions rather than deployments. Some contracts have unique 'deployments' authenticated by a tokenId (like Moria, ParityUSD), while others are just spending scripts like multisig or vaults that share the same spending conditions and get a stable address. You can also put functions themselves on token commitments (if they fit in 128 bytes), giving you local transferrable functions.\"},{\"q\":\"Do CashScript contracts have an address and balance?\",\"a\":\"Yes, you have an address and a list of UTXOs on the address. Depending on the type of contract you're making, you either care about the total 'balance' or you only care about specific UTXOs. For unique deployment contracts, you typically care about specific UTXOs authenticated by tokens.\"},{\"q\":\"How can I use a constructor argument that doesn't affect contract logic but differentiates addresses?\",\"a\":\"Use a pattern like `require(index >= 0)` to use the index variable without actually changing the contract rules. This technique is used in unspent faucets to create unique addresses while keeping the same contract logic. It also avoids compiler warnings about unused variables.\"},{\"q\":\"How do I get the contract address inside a CashScript function?\",\"a\":\"`this.activeBytecode` gets the contract's bytecode (including constructor arguments but NOT unlocking arguments). For the P2SH locking bytecode (closest thing to 'address' in script), use `tx.inputs[this.activeInputIndex].lockingBytecode`.\"},{\"q\":\"What's a good mental model for multi-contract systems?\",\"a\":\"There are three main patterns: 1) Different contract identities with unique tokenIds and their own state (e.g., borrowing and pool contracts). 2) Sidecar contracts holding different fungible tokens from the main contract. 3) Breaking up complex functions into separate function contracts attached to a main verifier (e.g., add, withdraw, liquidate as separate contracts). For pattern 1, you have multiple primary contracts; for 2 and 3, you have primary and helper contracts. These patterns remain relevant even after CashScript gets functions.\"},{\"q\":\"Why does my factory contract produce different bytecode than CashScript's new Contract()?\",\"a\":\"CashScript performs bytecode optimization by default. The artifact's debug.bytecode is unoptimized (used by Bitauth IDE debugging), while the actual contract bytecode is optimized and shorter. Solution: Use the CashScript-compiled (optimized) bytecode as the factory parameter instead of raw cashc-compiled bytecode. This ensures addresses match between factory-created contracts and new Contract() instances.\"},{\"q\":\"What is the current contract size limit in CashScript?\",\"a\":\"Since the May 2025 VM Limits upgrade, the old 520-byte stack element limit has been increased to 10,000 bytes and the 201-opcode limit replaced by an operation cost system. The CashScript compiler may still warn about contract sizes for standardness reasons, but consensus limits are now much more generous. Check cashscript.org for current standardness limits.\"}]},{\"name\":\"WalletConnect\",\"faqs\":[{\"q\":\"Does CashScript have built-in WalletConnect support?\",\"a\":\"Yes, CashScript v0.11.1 adds BCH WalletConnect integration. The TransactionBuilder now has a method to generate a BCH WalletConnect transaction object, which can be sent to a WC client for signing. This further simplifies BCH dapp development.\"},{\"q\":\"How do I integrate CashScript TransactionBuilder with WalletConnect?\",\"a\":\"Use the generateWcSourceOutputs utility function to convert from CashScript transactionBuilder to WalletConnect object in 4 lines of code. Build the unsigned transaction, decode it, then call generateWcSourceOutputs(transactionBuilder.inputs, decodedTransaction). This is being considered for standardization in CashScript. See github.com/CashScript/cashscript/issues/191\"},{\"q\":\"Is there a tutorial for adding WalletConnect to a CashScript dApp?\",\"a\":\"Yes, there's a tutorial video titled 'Adding WalletConnect to your CashScript Dapp just got much easier!' at youtu.be/EPdtEyFEE8A\"},{\"q\":\"How do I debug CashScript when using WalletConnect?\",\"a\":\"When using WalletConnect, the transactionBuilder has placeholders, so transactionBuilder.debug() won't work directly. To test/debug, replace the placeholders with a test wallet using SignatureTemplate with a private key (WIF format or raw bytes). Get your WIF from your wallet and pass it to SignatureTemplate, then all debugging tooling works.\"},{\"q\":\"What are the limitations of datasigs with WalletConnect?\",\"a\":\"WalletConnect via CashScript's generateWCTransactionObject() works well for standard signatures, but has limitations with data signatures (datasigs). The current implementation uses zero-byte placeholders for signatures that wallets populate. Datasigs are problematic because: (a) using a hash placeholder means the wallet blindly signs that hash, which has security implications, and (b) without a hash, the data length isn't deterministic, making zero-byte placeholders impractical.\"}]},{\"name\":\"Security & Advanced Patterns\",\"faqs\":[{\"q\":\"How can betting sites using BCH demonstrate they are fair?\",\"a\":\"Betting sites are notorious for cheating. To win user trust, implement 'provably fair' verification where users can verify the randomness used. See satoshidice.com/fair for an example of how this works with cryptographic commitments.\"},{\"q\":\"Where can I find BCH atomic swap contracts for marketplaces?\",\"a\":\"The 2-party atomic swap contract setup that BCA pioneered is used by tapswap.cash NFT marketplace. Code is available at gitlab.com/0353F40E/simple-swap. CashToken introspection opcodes help with coordinating UTXOs in these setups.\"},{\"q\":\"Can Schnorr signatures be used to aggregate multiple keys for CashScript validation?\",\"a\":\"Yes. Schnorr signatures allow very simple multi-party aggregation schemes where multiple parties collaborate to produce one aggregated signature under one aggregated pubkey, checked with OP_CHECKSIG as in P2PKH addresses. The key trick is using interactive cryptography to cooperatively 'add together' the Schnorr keys of multiple parties and settle the transaction onchain as a P2PKH transaction. This enables smart contracts to regain privacy by hiding as regular P2PKH transactions. See gist.github.com/markblundeberg/a3aba3c9d610e59c3c49199f697bc38b for details.\"},{\"q\":\"What new documentation guides were added to CashScript?\",\"a\":\"Two new guides were added to the CashScript documentation: 'Transaction Lifecycle' (cashscript.org/docs/guides/lifecycle) covering the full lifecycle of BCH transactions, and 'Adversarial Analysis' (cashscript.org/docs/guides/adversarial) covering security considerations for smart contracts. Both guides document knowledge that's general to BCH development and assumed for developers but wasn't previously written down anywhere.\"},{\"q\":\"Can BCH be used as a proxy chain to profit on swap rates between two other cryptos?\",\"a\":\"Yes, this is conceptually how AnyHedge works (bchbull.com). You can earn or lose BCH based on the change in price against any supported asset. While specific assets like XMR aren't currently supported, they could be added. You could theoretically set up two different contracts to get near the same result for profiting on asset ratios. See bitcoincashpodcast.com/faqs/Tech/what-is-anyhedge for explanation.\"},{\"q\":\"Can CashScript be used to build prediction markets like Polymarket?\",\"a\":\"Yes, CashScript can be used to build prediction market contracts. Unlike simple head-to-head betting that requires position matching, you can implement AMM-style markets where each position affects the yes/no price and users can enter/exit positions freely. Such markets can also support liquidity providers who stake BCH without taking positions, earning fees on trades. Complex math functions like LMSR (Logarithmic Market Scoring Rule) cost functions can be implemented using fixed-point arithmetic approximations since CashScript doesn't have floating-point or functions like exp().\"}]},{\"name\":\"Developer Tools\",\"faqs\":[{\"q\":\"How do I install the CashScript syntax highlighting extension in Cursor editor?\",\"a\":\"The CashScript extension is available on both VSCode Marketplace (marketplace.visualstudio.com/items?itemName=CashScript.cashscript-vscode) and Open VSX (open-vsx.org/extension/CashScript/cashscript-vscode). If you can't find it in Cursor by searching 'cashscript', try searching just 'cash'. You can also download the VSIX file directly from Open VSX and install it manually.\"},{\"q\":\"Does the CashScript VSCode extension support the latest CashScript features?\",\"a\":\"Yes, the CashScript VSCode extension is updated with support for v0.11.0 features including: slice function, renamed tx.age to this.age, added missing completions & highlighting, and fixed hover information for contract and function signatures.\"},{\"q\":\"What other high-level languages compile to Bitcoin Script?\",\"a\":\"sCrypt is a high-level language similar to CashScript that compiles to Bitcoin Script. It was originally developed for BSV and has a similar approach to defining smart contracts. Reference implementations of contracts like fixed-point math libraries and LMSR prediction markets exist in sCrypt that can serve as inspiration for CashScript implementations.\"}]},{\"name\":\"Version Updates & Releases\",\"faqs\":[{\"q\":\"What are the breaking changes in electrum-cash v4?\",\"a\":\"The main breaking change in electrum-cash v4 was the removal of clustering. Release notes can be found at gitlab.com/electrum-cash/network/-/tags/v4.0.0\"},{\"q\":\"When will CashScript v0.11.0 be released?\",\"a\":\"CashScript v0.11.0 is planned for release with the BCH network upgrade on May 15th 2025. This release will include the update to electrum-cash v4+.\"},{\"q\":\"Will changes to constructor argument handling in CashScript be breaking?\",\"a\":\"Yes, changes to how constructor arguments are handled (like inserting them where needed instead of always pushing at the start) would be breaking changes only introduced in v1. There will be either a compiler flag or syntax to opt out of new optimizations for users who compile contracts directly with cashc without using the CashScript SDK.\"},{\"q\":\"What's new in CashScript v0.11.0?\",\"a\":\"This major release (over half a year in development) highlights debugging capabilities for the new transaction builder, enabling local testing/debugging using mocknet and inside Bitauth IDE. It contains improvements and breaking changes. Migration notes are updated at cashscript.org/docs/releases/migration-notes. The documentation received significant updates as well.\"},{\"q\":\"What's new in CashScript v0.11.3?\",\"a\":\"CashScript v0.11.3 adds a new .slice(start, end) syntax and improved type safety around .split and .slice operations.\"},{\"q\":\"What's new in CashScript v0.11.4?\",\"a\":\"CashScript v0.11.4 contains a bug fix for P2PKH-only transactions and a new feature for the MockNetworkProvider that allows you to simulate a real network more closely.\"},{\"q\":\"What's new in CashScript v0.11.5?\",\"a\":\"CashScript v0.11.5 includes: input index in console.log statements for debugging, improved type inference for function and constructor arguments in the Contract class, replaced redundant dependencies, and removed accidental dependency inclusion of @types/node. The next major release v0.12.0 focuses on maintenance, internal refactors, testing and removing deprecated functionality.\"},{\"q\":\"What's new in CashScript v0.12.0?\",\"a\":\"CashScript v0.12.0 includes: removal of the old deprecated Transaction Builder, several small breaking changes, getVmResourceUsage() to measure VM usage, new TransactionBuilder safety options, and several other small features. This release focuses on maintenance, internal refactors, testing, and removing deprecated functionality.\"},{\"q\":\"What features are expected in the May 2025 BCH upgrade for CashScript?\",\"a\":\"The May 2025 upgrade (now active) enabled VM Limits removal and BigInt support, allowing more complex contracts. The May 2026 upgrade will add native loops, 128-byte NFT commitments (up from 40 bytes), and P2S standard. These features are already being designed for in experimental contracts like prediction markets.\"}]},{\"name\":\"Learning Resources & Community\",\"faqs\":[{\"q\":\"How do I learn CashScript?\",\"a\":\"The best resource is the official website cashscript.org. Click the big 'Getting Started' button to access the documentation and tutorials.\"},{\"q\":\"Are there video tutorials for learning CashScript?\",\"a\":\"Yes, there's an 'Intro to CashScript' tutorial series on YouTube: youtube.com/watch?v=Ft2jo9spIHg\"},{\"q\":\"How can I quickly build a BCH dApp using CashScript?\",\"a\":\"There's a video tutorial showing how to use CashScript and WalletConnect to build a dApp quickly: youtu.be/JJZq3bXMNIw titled 'Want to Build a BCH DApp? Here's my Blueprint!'\"},{\"q\":\"Where can I learn CashScript through interactive challenges?\",\"a\":\"There's a CashScript Arena challenge platform at arena.layer1.cash. Also a Telegram group t.me/CashScript_Arena where developers create and solve 'broken' or exploitable smart contract challenges. Complete beginners are welcome, and experienced developers help create challenges and answer questions.\"},{\"q\":\"Is there a BCH hackathon I can participate in?\",\"a\":\"Yes, BCH Blaze 2025 is a virtual hackathon to build innovative projects on Bitcoin Cash using the latest network upgrades on Chipnet. It starts November 15th with up to 10 BCH in prizes plus tickets to BLISS 2026. Perfect for devs new to BCH or veterans. Register at dorahacks.io/hackathon/bchblaze2025/detail\"},{\"q\":\"Where can I find reference CashScript contracts for inspiration?\",\"a\":\"The CashScript website has a 'showcase' section at cashscript.org. The team isn't currently maintaining a full list of community contracts, but they'd welcome a community initiative repo where people can add PRs.\"},{\"q\":\"Where can I find a simple open source CashScript dApp example with UI?\",\"a\":\"There's a dApp starter template at github.com/mainnet-pat/dapp-starter with a demo at dapp-starter-bch.vercel.app. Cash-Ninjas is also open source. For more reference implementations, check the showcase section at cashscript.org.\"},{\"q\":\"Where can I find advanced open-source CashScript contract examples?\",\"a\":\"ParityUSD has open-sourced their smart contract source code - 26 contracts forming one of the most advanced applications built on BCH script. See parityusd.com/blog/open-source-contracts for the full code and documentation.\"},{\"q\":\"What interesting BCH project ideas would the CashScript team like to see built?\",\"a\":\"Interesting project ideas include: visualizer/simulator for different AMM DEX curves, CashScript-py SDK (Python implementation), address analyzer (to check for privacy leaks), double spend proof (DSP) checker website, BCMR indexer in TypeScript. Also various WalletConnect apps: airdrop/dividends, vault, Last-Will inheritance, Mecenas recurring payments, 'Hodl', and AnyHedge.\"},{\"q\":\"How does the CashScript Contributors Fund work?\",\"a\":\"The contributors fund compensates external contributors for contributions that would otherwise be unpaid. It's not a formal bounty system - the standard process is to consider payment after merging PRs from external contributors. The goal is to acknowledge, reward, and appreciate others who provide value to the CashScript project. Past recipients include contributors who worked on debugging capabilities for TransactionBuilder and contract argument typings integration.\"},{\"q\":\"Why am I getting API errors with code generated by AI assistants for CashScript?\",\"a\":\"AI assistants sometimes make up CashScript API methods that don't exist. For example, 'setUnlocker' is not a function - AI hallucinated it. Always refer to the official CashScript documentation at cashscript.org/docs/sdk/transaction-builder for the correct API. Don't trust AI-generated code without verifying it against docs.\"},{\"q\":\"Why does AI sometimes generate inconsistent CashScript translations from Solidity?\",\"a\":\"AI models are influenced by the massive amount of EVM examples in their training data, which pulls them toward 'centralized contract' patterns. When translating to UTXO/BCH, AI can generate inconsistent results (sometimes 0 contracts, sometimes complex multi-contract systems) because UTXO patterns are fundamentally different and less represented in training data. The community is still exploring how UTXO-based smart contract patterns will evolve.\"}]},{\"name\":\"Example Contracts & Projects\",\"faqs\":[{\"q\":\"Where can I find 'pump fun' style bonding curve contracts for BCH?\",\"a\":\"The p-bond contracts implementing pump.fun style bonding curves are available at gitlab.com/0353F40E/p-bond. These contracts allow token launches with automated market making curves.\"},{\"q\":\"Where can I find an example of a recurring payments contract?\",\"a\":\"There's a project called ARCC (Automated Recurring CashToken Contracts) that implements recurring payments. The contract code is at github.com/kiok46/arcc, with transaction building code at github.com/cashkit/arcc-poc. Note: With introspection now available, this approach can be simplified.\"},{\"q\":\"Is there a DAO template for building decentralized organizations on BCH?\",\"a\":\"Yes, OpenCashDAO is a DAO template featuring voting, proposals, and an upgradable contract system. The design pattern has potential for many applications similar to BitCANN. Resources: bitcoincashresearch.org/t/opencashdao/1521 and github.com/OpenCashDAO/contracts\"}]}]",
    "source": "faq/telegram/cashscript_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-0",
    "content": "Topic: name\nContent: \"CashToken Devs FAQ\"",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-2",
    "content": "Topic: source\nContent: \"CashToken Devs Telegram 2025\"",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 81",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/cashtoken_devs_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"Token Creation & Minting\",\"count\":26,\"faqs\":[{\"q\":\"How do atomic swaps work using partially signed transactions (PSBT) on Bitcoin Cash?\",\"a\":\"Atomic swaps can use an imbalanced transaction approach where the maker creates a partial transaction with their inputs/outputs, and the taker adds their own inputs and outputs to balance it. The maker's signature commits to specific inputs and outputs using SIGHASH_SINGLE, creating an off-chain offer that only gets on-chain if someone takes it. The resulting trade is essentially a coinjoin transaction.\"},{\"q\":\"What do I need to build a CashTokens wallet using my own full node?\",\"a\":\"A full node alone is not enough - you'll need an indexer like Fulcrum to get address balances. To create CashTokens transactions with JavaScript, you can either use libauth directly or helper libraries like mainnet-js or CashScript for transaction building.\"},{\"q\":\"What's the difference between Fulcrum and Chaingraph for CashTokens?\",\"a\":\"Fulcrum is anchored around wallets (addresses) - perfect for looking up what tokens exist on specific addresses. If you need to lookup a given category ID to find how the tokens are locked (what addresses they are on), use Chaingraph instead. Chaingraph acts as a more general-purpose token indexer.\"},{\"q\":\"How does CatDex enable decentralized exchange discoverability?\",\"a\":\"CatDex uses a key-value index contract for discoverability. To list your exchange, you pay to publish it as a value using the token's category ID as the key. The commitment contains a protocol identifier and your authCat ID. Anyone wanting to find exchanges for a token can query that token's key address, parse the NFT commitments to find authCat IDs, then look up the corresponding CatDex contract UTXOs.\"},{\"q\":\"What is the token ID for Moria USD (MUSD)?\",\"a\":\"The MUSD token ID is 4046913cba6b70b2214a048a3df92252849f481ffa1455ed7faf17243c36bf67. You can view it on tokenexplorer.cash which displays BCMR metadata including decimals and genesis supply.\"},{\"q\":\"Why do I get 'Invalid authchain transaction' error when loading BCMR metadata?\",\"a\":\"When using BCMR.addMetadataRegistryAuthChain(), you need to pass the token's category ID (tokenId), not the transaction ID of a token transfer. An authchain is a series of spends from vout 0 UTXOs - it errors when you provide a transaction that doesn't follow this pattern. The authchain starts from the genesis transaction of the token category.\"},{\"q\":\"Can I create a token index fund that diversifies across multiple CashTokens?\",\"a\":\"Yes, it's technically possible to create a token that automatically distributes purchases across multiple tokens. However, there are governance challenges: who decides which tokens are included, how the group changes over time, and how to make it non-custodial and non-ruggable. One approach could use the bonding curve from BCH Pump - whenever a new token completes its curve, the fund automatically starts allocating 1/N to each of the N completed tokens.\"},{\"q\":\"Can a CashToken genesis transaction send tokens to multiple addresses?\",\"a\":\"Yes. You can send tokens to multiple different addresses in a single CashToken genesis transaction. The genesis transaction can have multiple outputs, each receiving a portion of the initially minted tokens.\"},{\"q\":\"What's the best way for a token-only wallet to handle transaction fees safely?\",\"a\":\"Instead of swapping tokens for BCH in the same transaction (which loses DSP protection), keep a small BCH stash and auto-replenish it. The wallet should maintain around 10 UTXOs of 800 sats each. When the user sends tokens, use the existing BCH for fees, then create a separate child transaction that swaps tokens for BCH to replenish the stash. Making the DEX swap a child (not parent) of the payment preserves DSP coverage for the payment itself.\"},{\"q\":\"What is BlockBook and why would CashTokens support in it be valuable?\",\"a\":\"BlockBook is a multicoin blockchain indexer written in Go, created and maintained by Trezor. Adding CashTokens support to BlockBook would enable token integration in Edge wallet, Trust wallet (by Binance), Trezor hardware wallets, and possibly Exodus wallet - all of which use BlockBook as their indexer. This is considered high-impact public good infrastructure that could be crowdfunded.\"},{\"q\":\"Can a contract measure the coin age (coindays) of an external UTXO?\",\"a\":\"No. A contract cannot measure the coin age or coindays of a UTXO that wasn't held by the contract itself. There's no introspection opcode that reveals when a UTXO was created. This limitation means coin-age-based reward systems (like rewarding old HODLers) must use lockup contracts where the contract can verify how long the funds were locked within it.\"},{\"q\":\"Can an NFT and fungible tokens exist on the same UTXO?\",\"a\":\"Yes. You can have both an NFT and fungible tokens on the same UTXO, as long as they're from the same token category (tokenId). Each UTXO can only hold one token category, but that category can include both an NFT (with its commitment data) and a fungible token amount simultaneously.\"},{\"q\":\"Is there a way to get BTC price exposure on BCH without a centralized bridge?\",\"a\":\"BCH Bull has built a battle-tested oracle service for creating BTC-pegged financial products on BCH. These are synthetic assets that track BTC price rather than being backed 1:1 by actual BTC. They could be tokenized to create effectively the same utility as wrapped BTC, without needing a cross-chain bridge - you get price exposure through the oracle rather than asset custody.\"},{\"q\":\"How does having BCH on the same UTXO as CashTokens help prevent state bloat?\",\"a\":\"When BCH and CashTokens share a UTXO, the locked BCH value serves as an ongoing 'payment' for that UTXO's existence in the UTXO set. This creates economic pressure to clean up unused state - if you want your BCH back, you need to spend the UTXO. Without this mechanism, tokens could create unlimited free state that bloats the UTXO set forever.\"},{\"q\":\"What are the privacy implications of using separate BCH UTXOs for transaction fees?\",\"a\":\"Reusable separate BCH UTXOs for fees destroy privacy because they create linkable patterns across transactions. Better approaches are: (1) single-use fee UTXOs, (2) preloading CashToken UTXOs with extra sats for fees during the CashFusion mixing process, or (3) using just-in-time DEX swaps (though this has DSP tradeoffs). The ideal is to have tokens already carrying enough sats for their own fees.\"},{\"q\":\"Can a token category have both fungible tokens and NFTs?\",\"a\":\"Yes. A single token category (tokenId) can have both fungible tokens and NFTs. For example, Moria USD (MUSD) is a fungible stablecoin, but the same category also has NFTs that are used internally by the loan contract to keep track of state. The 'is_nft' field in indexer responses indicates whether NFTs exist for that category, not that the fungible tokens are NFTs.\"},{\"q\":\"How do I move CashTokens back to 'reserve supply'?\",\"a\":\"To move tokens back to reserve supply, you must move them back to the AuthUTXO - not just any address you control. There's no concept of 'original minter address' in the BCMR spec. Only the AuthUTXO is allowed to update metadata and hold reserved supply. Simply sending tokens to the genesis address doesn't make them 'reserved' - they need to be consolidated with the AuthUTXO in a single transaction.\"},{\"q\":\"How does token burning work on Bitcoin Cash?\",\"a\":\"Burning tokens means creating a transaction with tokens as input but none as output. The 'missing' BCH between inputs and outputs goes to miner fees, while 'missing' tokens are permanently deleted from the UTXO set. Tools like tokenburner.cash and the burn function in CashTokens Studio make this easy. Burned tokens are tracked by explorers and properly excluded from circulating supply calculations.\"},{\"q\":\"What are the requirements for a CashToken genesis transaction?\",\"a\":\"For a token genesis transaction, you need to spend a UTXO at VOUT 0 (output index 0). The new tokens will have as their tokenId (category) the TxId of that VOUT 0 UTXO. This means the genesis transaction ID becomes the permanent identifier for the entire token category. The spec at cashtokens.org/docs/spec/chip/#token-categories has graphics explaining the token creation process.\"},{\"q\":\"Can I create a contract that only the holder of a specific NFT can spend?\",\"a\":\"Yes. You can write a covenant contract that requires a specific NFT to be included in the transaction to redeem funds. This is sometimes called P2NFT (Pay-to-NFT). The contract checks that the transaction includes a UTXO with the required NFT category ID (and optionally commitment). This enables use cases like NFT-gated funds or payments that follow NFT ownership.\"},{\"q\":\"What are the main development tools for building with CashTokens?\",\"a\":\"For JavaScript developers, the main tooling is mainnet-js (for wallet operations and token transactions) and CashScript (for smart contracts), or libauth directly for lower-level control. For Python developers, bitcash provides CashTokens support. The CashTokens CHIP at cashtokens.org/docs/spec/chip has the official specification and supply definitions.\"},{\"q\":\"What public BCMR registries are available?\",\"a\":\"Several public BCMR registries exist: otr.cash, badgers.cash, futurebitcoin.cash, and Paytaca's bcmr.paytaca.com which indexes chain-resolved registries. tokenexplorer.cash can look up on-chain resolved metadata for any token. OpenTokenRegistry has plans for a better static registry partitioned per category.\"},{\"q\":\"How do category IDs relate to fungible and non-fungible tokens?\",\"a\":\"A single category ID (tokenId) is the parent for any combination of fungible tokens and NFTs. One category can have both fungible tokens and NFTs simultaneously. The category ID comes from the genesis transaction's TXID (specifically, the TXID of the UTXO at vout 0 that was spent to create the tokens).\"},{\"q\":\"How do I add a token to Cauldron DEX?\",\"a\":\"Listing is permissionless - connect a wallet and create a liquidity pool for your token directly. The token appears on the DEX once a pool exists. To get the token verified (displayed without warnings/badges), you need to speak to the Cauldron team. Documentation is at docs.riftenlabs.com/cauldron/claim/.\"},{\"q\":\"How do you format a payment URI to request a specific token amount?\",\"a\":\"Use BIP21-style query parameters: add `&c=<categoryId_hex>&ft=<raw_amount>` to the address. For example, requesting 100.00 MUSD (2 decimals): `bitcoincash:z...?c=<category_hex>&ft=10000`. Some wallets like Paytaca use `f` instead of `ft` for the fungible token amount. See bitcoincashresearch.org for the BIP21 CashTokens query parameters discussion.\"},{\"q\":\"Where is documentation for NFT minting logic?\",\"a\":\"The NFT behavior specification is at cashtokens.org/docs/spec/chip#non-fungible-token-behavior. This describes initial minting (genesis transactions), subsequent minting using minting capability NFTs, and the rules governing NFT capabilities (mutable, minting, none).\"}]},{\"name\":\"NFT Commitments\",\"count\":7,\"faqs\":[{\"q\":\"Can NFT creators receive royalties on every resale with CashTokens?\",\"a\":\"Yes. The fee receiver can be implemented as a pay-to-nft, which means the payout rights themselves become tradeable. This enables use cases like concert tickets where people can buy and resell, but resale is limited in price and the original creator gets a cut of each transaction.\"},{\"q\":\"What is the Unspent recurring payments system and how does it work?\",\"a\":\"Unspent is a PUSH system for recurring payments where users are paid without having to interact with or sign anything in a wallet. It uses perpetuity and annuity contracts - perpetuity pays forever (until balance is depleted), annuity pays over a defined period. Payments are BCH-denominated (fiat requires oracle complexity). The contracts are immutable commitments that can't be cancelled. The system uses 'anyone can spend' MEV for execution, and is ideal for supporting contractors with stable, predictable payments.\"},{\"q\":\"Why is it important that CashToken UTXOs can hold both tokens and BCH satoshis?\",\"a\":\"For contracts, it's a crucially important feature to hold state (via NFT commitment) and BCH value at the same time in a single UTXO. This enables contracts to manage funds while tracking state. If you need to treat BCH as a token (like for token-token only DEXes), you can use Wrapped BCH (WBCH) from wrapped.cash to convert BCH into a CashToken.\"},{\"q\":\"How do on-chain chat messages get 'cleared' if the blockchain is immutable?\",\"a\":\"NFT commitments storing messages can be burned (spent) which removes them from the active UTXO set. The history still exists on full archival nodes, but pruned nodes won't retain the data. This means the 'live' state that applications read is smaller and more manageable, while still allowing the blockchain to be technically immutable for those who want full history.\"},{\"q\":\"How can I clean up unwanted tokens from my wallet?\",\"a\":\"For tokens with Cauldron liquidity pools, you can sell them on the DEX. For tokens without LPs, use dropship.cash to send them to random recipients. Selene wallet has a 'shitcoin autodumper' feature planned that will let you select multiple tokens and batch-sell them. Vox will also have one-click dutch auctions for dumping both FTs and NFTs.\"},{\"q\":\"How do I send a payment to whoever currently holds a specific NFT?\",\"a\":\"You need an indexer that tracks NFTs and can query to find which UTXO currently holds a specific NFT. There's no built-in way to 'address' an NFT directly. Storing the recipient address in NFT metadata is problematic because it requires updating whenever the NFT is transferred, and the NFT holder must trust that the metadata controller won't redirect payments elsewhere. This remains an unsolved UX challenge.\"},{\"q\":\"How much data can an NFT commitment hold?\",\"a\":\"NFT commitments can hold up to 40 bytes of data. This small size is intentional - it's not meant for storing metadata directly. Instead, the commitment typically contains a reference to offchain metadata (like an IPFS CID or a sequential ID used to look up metadata in BCMR). For actual NFT metadata like images and descriptions, use BCMR (Bitcoin Cash Metadata Registries) with offchain hosting.\"}]},{\"name\":\"Token Transactions\",\"count\":26,\"faqs\":[{\"q\":\"What differentiates CashTokens from SLP tokens?\",\"a\":\"CashTokens are part of the UTXO data itself - they're validated at the consensus level. SLP tokens are an off-chain data convention layered on top of OP_RETURN outputs. The CashTokens specification defines a new transaction output data model where token data is included directly in the output.\"},{\"q\":\"What are LOKAD-IDs and how are they used with OP_RETURN?\",\"a\":\"LOKAD-IDs are 4-byte protocol identifiers placed at the start of OP_RETURN outputs to mark transactions belonging to specific protocols. For example, 'BCMR' is the LOKAD-ID for Bitcoin Cash Metadata Registries. Using markers in OP_RETURN is a good place to store contract details for on-chain protocols and smart contract apps. Tools like the OP_RETURN Scanner can find all occurrences of a specific marker on-chain.\"},{\"q\":\"What would a Double Spend Proof (DSP) checker tool show?\",\"a\":\"A DSP checker would take a transaction ID (txid) and show its status - whether a double-spend attempt was detected. It would also show a history of recent double-spend attempts and the generated DSPs. Currently, double spend proofs are 'hidden tech' at the node layer, so a checker website would make this security feature more visible and accessible.\"},{\"q\":\"How does the BitCANN domain registration system work?\",\"a\":\"BitCANN is a complete on-chain domain registration system featuring auctions, expiry, transferability, record updating, and multiple TLDs. It uses one authchain per TLD - multiple domain system instances could claim the same TLD, so it's up to users to pick which one is authoritative. The design is asynchronous because it doesn't keep all state in one UTXO merkle tree. It uses 'guard contracts' for the incentive structure and delegates conflict resolution to the crowd rather than maintaining consistent global state inside the contract.\"},{\"q\":\"How do on-chain token auctions work efficiently on Bitcoin Cash?\",\"a\":\"A clever auction mechanism makes each bid pay out the previous best bid, so the auction consists of a single UTXO until the item is sold. The bid is the payment in full and makes the under-bidder whole to bid again. To solve the 'wait until last second' problem, part of the new bid can be paid out to the previous bidder to encourage early bidding. This improves price discovery since anyone seeing an item 'obviously too cheap' is incentivized to bid to collect the next bidder's fee.\"},{\"q\":\"Can Bitcoin Cash contracts be modular like Ethereum's Diamond pattern?\",\"a\":\"Yes. Contracts can act as 'plugins' - for example, a Lease Contract can be independent but plug into a Domain contract. This resembles EIP 2535 (Diamonds, Multi-Facet Proxy) where other contracts just provide their 'code' but the real storage/UTXO is maintained on a single contract level. All other contracts are facets. This enables upgradable contract systems, multi-party ownership, and borrowing against assets like domains.\"},{\"q\":\"How do I broadcast a raw transaction on Bitcoin Cash without running my own node?\",\"a\":\"Use the Electrum protocol's blockchain.transaction.broadcast method instead of looking for public RPC nodes. For JavaScript/Node.js, use the electrum-cash NPM library which provides easy access to Electrum servers. This is the standard way to broadcast transactions without running your own full node.\"},{\"q\":\"Can a wallet hold only tokens and pay transaction fees through a DEX?\",\"a\":\"Yes. You can craft a transaction that performs a Cauldron DEX swap and a token payment in the same transaction, with no BCH input from the sending wallet. The swap provides the BCH needed for the transaction fee. This is like a decentralized 'post office' approach - the fee is paid by swapping a small amount of tokens for BCH within the same transaction. Note that this makes 0-conf payments more risky than typical P2PKH.\"},{\"q\":\"Why doesn't Double Spend Proof (DSP) protect token payments that use a DEX swap for fees?\",\"a\":\"DSP doesn't cover P2SH transactions. If your payment transaction has a P2SH ancestor in the mempool (like a DEX contract swap), the transaction gets a DSP score of 0, meaning it's NOT COVERED by Double Spend Proofs. The spec requires all ancestors in mempool to be P2PKH transactions signed with SIGHASH_ALL. This is why using a DEX swap as a fee source in the same or parent transaction makes 0-conf riskier.\"},{\"q\":\"What are the 5 areas where standardness rules differ from consensus rules on Bitcoin Cash?\",\"a\":\"The gap between relay (standardness) and consensus rules appears in 5 areas: (1) max contract size, (2) max transaction size, (3) max OP_RETURN size, (4) dust threshold, and (5) output standardness. Transactions violating standardness rules won't be relayed by nodes but would still be valid if mined. This gap causes friction for developers who need to document both limits, and there's ongoing discussion about closing the gap by either relaxing relay rules or tightening consensus.\"},{\"q\":\"Can I program CashTokens or BCH to automatically move to another address after a set time period?\",\"a\":\"Yes, using time-locked contracts like Unspent. However, it doesn't move automatically - someone has to call the contract to execute the transfer after the time lock expires. The party locking the coins/tokens publishes the job, and then anyone can call it to trigger the payout. This uses 'anyone can spend' MEV mechanics for execution.\"},{\"q\":\"How can I interact with Cauldron DEX programmatically without using the website?\",\"a\":\"There are two independent libraries for interacting with Cauldron contracts on-chain: vegabch (github.com/hosseinzoda/vegabch) and Cauldron_Swap_Test (github.com/mr-zwets/Cauldron_Swap_Test). These allow you to build swap transactions and interact with the DEX contracts directly from your code.\"},{\"q\":\"Can a BCH smart contract react to events on the Bitcoin (BTC) blockchain?\",\"a\":\"No, there's no way for the BCH blockchain to directly monitor BTC transactions or addresses. This is the trustless two-way bridge problem - one of the biggest unsolved problems in crypto. You could use an oracle service that reports BTC events to the contract, but someone needs to run that oracle, introducing a trust requirement. Wrapped BTC tokens on BCH exist, but they just move the problem - usually the backing is secured by multisig.\"},{\"q\":\"What debugging features were added in CashScript v0.11.0?\",\"a\":\"CashScript v0.11.0 added debugging capabilities for the new transaction builder. This allows testing contracts locally using mocknet (a simulated network) and debugging inside the Bitauth IDE. This significantly improves the developer experience by enabling local testing and debugging without needing to deploy to testnet or mainnet.\"},{\"q\":\"What does 'txn-mempool-conflict' error mean when executing a DEX trade?\",\"a\":\"A mempool-conflict error means someone else traded using the same liquidity pool before your transaction was broadcast. Each constructed DEX trade is only valid for building one transaction with the current pool state. If someone else trades first, the pool state changes and your transaction becomes invalid. You need to construct a new trade with the updated pool state and try again.\"},{\"q\":\"Are flash loans possible on Bitcoin Cash?\",\"a\":\"Yes. Flash loans have been implemented on BCH using CashScript. An example implementation is available at github.com/kiok46/flash-loans. Flash loans on BCH work within a single transaction - the loan must be repaid within the same transaction or the entire transaction fails.\"},{\"q\":\"What BCH WalletConnect features were added in CashScript v0.11.1?\",\"a\":\"CashScript v0.11.1 added native BCH WalletConnect integration. The TransactionBuilder now has a method to generate a BCH WalletConnect transaction object, which can be sent to a WalletConnect client for signing. This simplifies dApp development by allowing users to sign contract transactions with WalletConnect-compatible wallets.\"},{\"q\":\"Is there a CashTokens version of BIP21 payment URLs?\",\"a\":\"There's a proposal called chip-paypro (github.com/bitjson/chip-paypro) that extends payment URLs for CashTokens. It uses 's' (satoshis) instead of BIP21's 'amount' parameter to prevent old wallets from accidentally sending BCH-only transactions when tokens are requested. The proposal isn't widely implemented yet, and there are backwards compatibility concerns being discussed.\"},{\"q\":\"What's the difference between a regular BCH address and a token address?\",\"a\":\"A token address indicates that the receiving wallet supports CashTokens. Both address types lock to the same underlying script - they're just different encodings. Ideally, all addresses will eventually be token addresses. You can send plain BCH to a token address, and tokens to a regular address (though wallets may warn against the latter). The token address prefix is mainly a signal of CashTokens support.\"},{\"q\":\"Can a non-CashToken-aware exchange accidentally burn tokens deposited to their addresses?\",\"a\":\"No. Pre-CashTokens wallets cannot accidentally burn tokens because the sighash preimage construction for signing token inputs is different - it requires including the token prefix. A token-unaware system will fail to produce a valid signature for token UTXOs, so the transaction will be rejected. However, token UTXOs will 'poison' the UTXO set of non-token-aware systems since they can't be spent. Exchanges should filter out UTXOs with token info from their UTXO selection.\"},{\"q\":\"Can I use bch-js and mainnet-js with the same wallet without burning CashTokens?\",\"a\":\"bch-js cannot accidentally burn CashTokens because it doesn't know how to sign transactions for token inputs - the sighash construction is different. mainnet-js could accidentally burn SLP tokens if you use those, but not CashTokens. Both libraries can safely be used with the same wallet for CashTokens.\"},{\"q\":\"How can exchanges safely handle unexpected CashToken deposits?\",\"a\":\"Quarantine token UTXOs by marking them as FAILED status in your database - exclude them from UTXO selection but retain the option to manually recover them if the depositor covers recovery fees. Detect token outputs during block parsing and store them separately from regular BCH UTXOs. This prevents tokens from 'poisoning' your UTXO set while preserving recoverability.\"},{\"q\":\"Does CashTokens have the same indexing problem as SLP?\",\"a\":\"No. CashTokens fixes the major SLP indexing problem. SLP required tracking validity through the entire transaction history since tokens were off-chain conventions. CashTokens validity is enforced at consensus level - nodes validate tokens as part of normal transaction processing, making indexing significantly simpler and more reliable.\"},{\"q\":\"What's the difference between chipnet and testnet4 in Electron Cash?\",\"a\":\"In Electron Cash, 'testnet4' IS chipnet - use the `--testnet4` flag. Both networks use the 'bchtest:' address prefix, so addresses generated on one are valid on the other. If you accidentally send coins to the wrong network, you can recover them using the same seed phrase in wallet software connected to the correct network.\"},{\"q\":\"If a transaction spends fewer tokens than input, can miners claim the change like fees?\",\"a\":\"No. If you spend fewer tokens than input, the tokens are burned (called 'implicit burn'). Miners cannot claim these burned tokens. This differs from BCH satoshis where the difference between inputs and outputs becomes the miner fee.\"},{\"q\":\"How do I get unspent CashTokens for an address using Fulcrum?\",\"a\":\"Use `blockchain.address.listunspent(address, token_filter)` with the token_filter parameter. Options are: 'include_tokens' (returns both BCH and token UTXOs), 'exclude_tokens' (default for protocol 1.4.x), or 'tokens_only' (returns only token UTXOs). Protocol 1.5.0+ defaults to 'include_tokens'.\"}]},{\"name\":\"DEX & Trading\",\"count\":4,\"faqs\":[{\"q\":\"What is the convention for naming token atomic units on Bitcoin Cash?\",\"a\":\"A proposed convention is to use 'tau' (plural 'taus') as a generic name for token atomic units. It stands for 'token-atomic-unit' and happens to be a Greek letter. For example, '100 taus of MUSD' equals 1.00 MUSD (if MUSD has 2 decimals). This provides a consistent way to refer to the smallest indivisible unit of any CashToken.\"},{\"q\":\"Can I convert a mainnet address to testnet by just changing the prefix?\",\"a\":\"No. You cannot simply swap out the prefix (bitcoincash: to bchtest:) because the prefix is included in the address checksum calculation. A mainnet address and testnet address for the same public key will have different checksums and appear completely different. The underlying lockscript is the same, but the address encoding differs. Use tools like stack.xo.cash to translate between different networks correctly.\"},{\"q\":\"Can BCH do trustless cross-chain atomic swaps with other cryptocurrencies?\",\"a\":\"Yes. There's cross-chain-swap-ves for BTC-BCH swaps, axeswap.net implements BCH-XMR swaps, and BCH has been added to BasicSwapDEX. However, atomic swaps generally have poor UX compared to solutions like Thorchain - they're technically trustless but inconvenient, which makes it hard to get volume. Thorchain provides a better UX but requires trusting their validator set.\"},{\"q\":\"What bonding curve implementations exist on BCH?\",\"a\":\"There are only 2 bonding curves currently in use on BCH: Cauldron's and bchpump's. Both are described in the p-bond paper at gitlab.com/0353F40E/p-bond which covers the mathematical foundations and CashScript implementations.\"}]},{\"name\":\"Wallet Integration\",\"count\":11,\"faqs\":[{\"q\":\"Which wallets support CashTokens on testnet4?\",\"a\":\"Electron Cash supports testnet4 by starting it with the --testnet4 or --chipnet command line flag. Selene wallet has a hidden testnet4 mode: go to Settings, tap the green version button, then rapidly tap the Selene logo 6 times to access the debug menu where you can choose testnet4.\"},{\"q\":\"What are the security considerations for using WalletConnect with BCH dApps?\",\"a\":\"WalletConnect is primarily a transport layer for communication between dApps and wallets. The main security considerations aren't about the protocol itself but about the relay servers - they act as middlemen that could potentially censor connections or observe IP information. The actual signing happens in the wallet, so funds aren't at risk from the relay layer.\"},{\"q\":\"Do all wallets support SVG icons in BCMR metadata?\",\"a\":\"No. Support for data:image/svg+xml URIs in BCMR token icons is inconsistent across wallets and explorers. Cashonize and salemkode load SVG data URIs correctly, while Electron Cash and Selene don't. If you want maximum compatibility, consider using a PNG hosted at a regular URL instead of an inline SVG data URI.\"},{\"q\":\"Can I use IPFS URLs for BCMR metadata hosting?\",\"a\":\"The BCMR spec itself doesn't strictly require HTTPS - the HTTPS-only requirement appears to be an Electron Cash implementation detail. Other wallets may accept IPFS URLs (ipfs://) or other protocols. However, for maximum compatibility across all wallets and explorers, using HTTPS URLs is safest until IPFS support is more widely implemented.\"},{\"q\":\"Which wallet works for CashTokens on testnet?\",\"a\":\"Electron Cash (regular version, not SLP) supports testnet CashTokens - you need to enable the Tokens tab via the View menu. The SLP version is different software for a different token protocol. Other CashToken wallets may have better UX but often don't support testnets.\"},{\"q\":\"Are token decimals stored on-chain or determined by BCMR?\",\"a\":\"Token decimals are NOT stored on-chain - they're determined by BCMR (off-chain metadata registry). Without BCMR data, wallets show raw integer amounts. A token issued with 1000 display units and 2 decimals shows as 100000 raw units in wallets that don't read BCMR. This differs from ERC-20 where decimals are stored on-chain in the contract. Always verify raw amounts when BCMR data isn't available.\"},{\"q\":\"What happens if an attacker gains access to the Auth and manipulates BCMR decimals?\",\"a\":\"If someone changes BCMR decimals (e.g., removes 2 decimals), 500.00 tokens would display as 50000 to all BCMR-aware wallets - a potential scam vector. Token authors have significant control over metadata by design. Defenses include: projects maintaining verification lists that would delist scammy tokens, using DNS-resolved BCMR without an on-chain authchain, or app-embedded metadata. Always vet token issuers and their reputation.\"},{\"q\":\"Which mobile wallets support WalletConnect for BCH?\",\"a\":\"Paytaca and Cashonize support WalletConnect on mobile. Electron Cash doesn't have native WC functionality - it has a plugin that's desktop only. For same-device connection without scanning a QR code, tap the QR icon to get a copyable WalletConnect URI that you can paste into the wallet app.\"},{\"q\":\"Why does WalletConnect code only work with some BCH wallets?\",\"a\":\"WalletConnect library version 2.21.0 introduced a breaking change that deprecated `requiredNamespaces` - values are now automatically assigned to `optionalNamespaces` instead. Different wallets may be on different library versions. Try matching the exact dependency versions from working open source examples like bch-hodl-dapp. Chain identifiers may also vary between implementations (e.g., bch:bitcoincash vs bch:mainnet).\"},{\"q\":\"Can SVG icons be embedded directly in BCMR without external hosting?\",\"a\":\"Yes. SVG data can be encoded directly in the BCMR icon URI as a data URI (data:image/svg+xml). The icon doesn't need to be downloaded from IPFS or external hosting. However, not all wallets and explorers support data URI SVGs consistently - some may fail to display them.\"},{\"q\":\"Why do some token icons not render in wallets?\",\"a\":\"Some IPFS URLs aren't accessible on public gateways. Wallets typically use public gateways like dweb.link or ipfs.io. If your icon isn't pinned properly or the gateway can't find it, it won't render. Consider using SVG data URIs embedded directly in the BCMR to avoid IPFS dependency - the icon is encoded inline and never needs external fetching.\"}]},{\"name\":\"Smart Contracts\",\"count\":3,\"faqs\":[{\"q\":\"Is 'else require(false)' needed in CashScript contracts?\",\"a\":\"No, 'else require(false)' should never be needed and wastes bytes. Instead of an empty else-if followed by else require(false), just use else require(condition). This saves around 9 bytes. Additionally, deeply nested if statements are an anti-pattern in CashScript - see the optimization guide at cashscript.org.\"},{\"q\":\"Can I build a BCH dApp without a backend server?\",\"a\":\"Yes. By putting contract details on-chain, you can avoid the need for an application server altogether and build a client-only dApp. The BCH Hodl Dapp demonstrates this approach - all contract state is stored on-chain and can be read directly by the client application without any backend infrastructure.\"},{\"q\":\"What does the 'stack item exceeded 520 bytes' error mean in CashScript?\",\"a\":\"This error is about individual stack items during script execution, not your contract's total size. Since the May 2025 VM Limits upgrade, each stack item can be up to 10,000 bytes (previously 520 bytes). The old 201-opcode limit was also replaced by an operation cost system. Check if your contract is manipulating or creating any data structures larger than 10,000 bytes during execution, or if you're exceeding the operation cost budget.\"}]},{\"name\":\"BCMR Metadata\",\"count\":1,\"faqs\":[{\"q\":\"How can I prototype an app that needs BCMR without on-chain resolution?\",\"a\":\"For prototyping, make BCMR local to your app instead of resolving it on-chain. Import the BCMR JSON file directly and use `BCMR.addMetadataRegistry()` with the local file. You can also add external registries with `BCMR.addMetadataRegistryFromUri()`. This is simpler for development and avoids chain-resolution complexity on testnets.\"}]},{\"name\":\"Development Tools\",\"count\":2,\"faqs\":[{\"q\":\"How can I scale mainnet-js when using my own Fulcrum indexer?\",\"a\":\"mainnet-js connects directly via WebSockets to Fulcrum, unlike bch-js which uses a REST server that can be load-balanced. To enable HTTP-based load balancing and request queuing, use fulcrum-http (github.com/mainnet-pat/fulcrum-http) which adds HTTP support for Fulcrum.\"},{\"q\":\"What public Fulcrum servers are available for BCH?\",\"a\":\"Several public Fulcrum servers exist including electrum.imaginary.cash and bch0.kister.net. A full list of servers with their status can be found at 1209k.com/bitcoin-eye/ele.php?chain=bch.\"}]},{\"name\":\"General CashTokens\",\"count\":1,\"faqs\":[{\"q\":\"What's the difference between a cash-settled instrument and a redeemable wrapped token?\",\"a\":\"A cash-settled instrument (like BCH Bull's BTC-pegged products) tracks the price of an asset and settles in BCH - you get price exposure without ever holding the actual asset. A redeemable wrapped token (like WBTC on Ethereum) is supposed to be backed 1:1 by the actual asset and redeemable for it. Cash-settled instruments avoid the bridge problem entirely but don't give you actual custody of the underlying asset.\"}]}]",
    "source": "faq/telegram/cashtoken_devs_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-0",
    "content": "Topic: name\nContent: \"Electron Cash FAQ\"",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-1",
    "content": "Topic: type\nContent: \"telegram_extraction\"",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-2",
    "content": "Topic: source\nContent: \"Electron Cash Telegram 2025\"",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-3",
    "content": "Topic: extraction_date\nContent: \"2025-12-28\"",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-4",
    "content": "Topic: total_faqs\nContent: 327",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "faq/telegram/electron_cash_faq_2025.json-5",
    "content": "Topic: categories\nContent: [{\"name\":\"CashFusion & Privacy\",\"count\":81,\"faqs\":[{\"q\":\"Can CashFusion run in EC daemon mode without GUI?\",\"a\":\"Not out-of-the-box, but theoretically possible with configuration. Josh asks: 'can fusions happen when running EC as a daemon?' to work around Wayland crash issues. Pierre K's assessment: 'I don't think fusing can work out of the box in daemon mode, but adding a daemon command for it is not too difficult.' His 2022 research: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' JF provides workaround: 'there's a wallet level param cashfusion_autofuse' - if set to true in wallet file, might enable fusion. Dustin elaborates: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Key insight: Fusion state persists in wallet file, so enabling via GUI once, then running daemon might work. Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Community needs testing to confirm.\"},{\"q\":\"Why doesn't CashFusion work in daemon mode and what's the workaround?\",\"a\":\"Daemon mode lacks automatic fusion initialization. Josh tested: 'When running in daemon mode, I open another terminal and run AppImages/electron_cash.appimage daemon -C cashfusion_autofuse just to see if it'd do something but nope...just start, stop, status, load_wallet, and close_wallet.' Pierre K's research from 2022: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' No existing CLI command triggers fusion. Possible workaround: JF notes wallet stores 'cashfusion_autofuse' boolean - if enabled via GUI first, might persist. Dustin: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Not confirmed to work. Real fix needs daemon command addition - Jonas jokes: 'Lmk when you add it to ABC so I can steal it!' Workaround for Wayland crash: Run GUI once to enable, then use daemon.\"},{\"q\":\"Can CashFusion freeze coins causing problems with other wallet instances?\",\"a\":\"Yes on same machine/wallet file, NO across different machines. Adaptive Blocksize Limit: 'I couldn't pledge to fundme until i went home and close my EC wallet to shutdown cashfusion... i used paytaca and Selene.' JF explains: 'CF freezes coins temporarily while doing fusions, so you might not be able to use them for a pledge... If you're talking about different machines, it doesn't make sense. one machine doesn't know what the other is doing.' Key distinction: Same wallet file access = conflict. Same seed on different machines = no conflict. Adaptive: 'Same wallet different machine, one desktop ec the other is Paytaca or selene on mobile trying to pledge.' Dustin: 'Nothing on chain knows about the cashfusion round until the tx is broadcast... Stopping EC immediately allowing it to work is going to have to do with something environmental outside of EC / blockchain.' Possible explanation: Unconfirmed CashFusion transactions spending UTXOs that mobile wallet tries to use. Mobile wallet sees UTXOs as available, tries to spend, but they're already in mempool. Workaround: Wait for CF round to complete or disable CashFusion temporarily.\"},{\"q\":\"What happened to cashfusion.org's SSL certificate?\",\"a\":\"The SSL certificate for cashfusion.org expired on March 30, 2025 due to lack of automatic renewal. This is a common issue with manually managed certificates. Solution for site operators: use certbot with automatic renewal via cron job or systemd timer to run the cert tool periodically. Sites like Let's Encrypt provide free certificates but require regular renewal (every 90 days). This doesn't affect CashFusion functionality in EC itself, just the informational website.\"},{\"q\":\"How do I convert BCH from Electron Cash to my bank account?\",\"a\":\"EC is a non-custodial wallet - it doesn't handle fiat conversion. Process: 1) Create account on exchange (Coinbase, Kraken, Binance, etc.), 2) Complete KYC verification, 3) Get deposit address from exchange for BCH, 4) Send BCH from EC to that deposit address, 5) Wait for confirmations (varies by exchange), 6) Sell BCH for fiat on exchange, 7) Withdraw fiat to bank account. Important: Exchanges have withdrawal limits, fees, and processing times. Alternative: Peer-to-peer sales (LocalBitcoin.cash, etc.) for more privacy but more risk. EC just holds and sends BCH - all fiat conversion happens on external services.\"},{\"q\":\"What are OstrichGram and Pumpstr in the BCH ecosystem?\",\"a\":\"Both are Nostr clients with BCH integration: 1) OstrichGram - Cross-platform (desktop, mobile) Flutter-based Nostr client created by JF. Supports basic DM and group chat, with vision of adding Telegram bridge and wallet functionality. Open source: github.com/OstrichGram/OstrichGram. 2) Pumpstr - Web-based Nostr client for Bitcoin Cash. These represent community efforts to integrate BCH into decentralized social media infrastructure. Why this matters: Combines censorship-resistant messaging (Nostr) with censorship-resistant money (BCH). Both leverage that Nostr and BCH use same cryptographic curve, enabling payment addresses to derive directly from social identities. Competition between implementations drives innovation - different UX approaches (native app vs web), different feature priorities (privacy DMs vs public posting vs tipping). OstrichGram unique feature: Telegram bridge to allow cross-posting between platforms.\"},{\"q\":\"What is StartOS and why are there barriers to BCH integration?\",\"a\":\"StartOS (formerly Start9) is self-hosted server OS making it easy to run Bitcoin/Lightning nodes at home - plug-and-play sovereignty. Already supports BTC+Lightning, Fulcrum 2.0 now listed. Barrier to BCH (BCHN) integration: Primarily ideological, not technical. im_uname: 'historically the barrier is ideological, tho if they're somehow willing that would be fantastic.' StartOS team maintains specific perspective on Bitcoin maximalism. Technical packaging is straightforward - they provide hello-world-startos template and Matrix support channel for service packaging. Community efforts: Contact through Matrix (migrated from Telegram due to scammers), packaging BCHN+Fulcrum together, potentially including EC for CashFusion. Calin: 'Might be slight ideological reservation but that can be overcome I think.' Benefits if achieved: Home users could easily run full BCH infrastructure (BCHN node + Fulcrum + potentially EC) without Linux expertise, improving network decentralization and user privacy.\"},{\"q\":\"What PR updates are happening in EC codebase for November 2025?\",\"a\":\"Multiple infrastructure improvements pending. Notable PRs: #3155 - Kallisti updates desktop explorer list: 'Opened a PR to update the EC desktop explorer list.' Maintenance task - keeping external service links current. Earlier merged: #3144 (CashTokens payment requests), #3145 (P2SH export addresses), various reproducibility fixes. Алексей (BitCartCC) continues contributing, discovering gap limit issue next. Community activity: Doramas publishes CashFusion article at bitcoiniscash.org/bitcoin-cash-privacy/, expanding learning resources. Regular 'Fusion Friday' community events continuing (Fiendish posts weekly). GitHub notifications now forwarded to t.me/electroncashnotifications. JF notes SLIP-39 as potential contribution: 'low hanging fruit to do just do what electrum did' - showing path for community members to contribute. Healthy open source dynamics: External developers (BitCartCC), community members (Kallisti, Doramas), core maintainers all contributing. Shows project sustainability despite volunteer-only model.\"},{\"q\":\"Why does CashFusion on Android reject my correct wallet password?\",\"a\":\"This is a reported bug where CashFusion on Android EC sometimes rejects the valid wallet password with 'password is not valid' error, even though it's the same password that unlocks the wallet. It doesn't happen with all wallets, only some. Workaround: File a bug report on GitHub with device model, Android version, EC version, and if possible, steps to reproduce. Include whether the wallet was created on Android or imported. This helps developers isolate the issue.\"},{\"q\":\"Why did CashFusion break after updating EC from git master with protobuf error?\",\"a\":\"Error 'ImportError: cannot import name runtime_version from google.protobuf' occurs when your installed protobuf version (e.g., 3.20.1) is incompatible with regenerated fusion_pb2.py files that require newer protobuf features. The master branch updated the protobuf .proto files and regenerated Python stubs. Fix: Reinstall dependencies to get the new required protobuf version. Check that protobuf version in requirements.txt matches what's installed in your virtual environment. The 'runtime_version' import was added in protobuf 5.x, so you need to upgrade from protobuf 3.x. This is why using a Python virtual environment is recommended - you can easily update dependencies without affecting system packages.\"},{\"q\":\"What are Electron Cash's scalability limits for wallets with many addresses or UTXOs?\",\"a\":\"EC has practical limits: 1) After ~30,000 addresses, start a new wallet - performance degrades significantly, 2) Wallets with 60k+ UTXOs on single address cause freezing (can't access Coins tab, can't type amounts), 3) Long-running CashFusion (years of 24/7 operation) creates massive address/UTXO counts, consuming 5-8GB RAM. GUI issues are worse than backend - opening Addresses tab with huge address count crashes client. Workarounds: Use CLI instead of GUI for operations, avoid clicking Addresses/Coins tabs, migrate funds to new wallet periodically. Root cause: EC tries to load everything into GUI lists at once instead of lazy-loading only visible items. Fix would require significant GUI refactoring.\"},{\"q\":\"Why does EC AppImage crash after running for extended periods on Linux?\",\"a\":\"Some users report EC 4.4.2 AppImage crashing silently after hours of running (especially during screen lock). Debugging steps: 1) Run EC from terminal in verbose mode to capture logs when crash occurs, 2) Check system logs (journalctl) for segfaults or OOM killer, 3) Monitor memory usage - EC can grow to 5-8GB RAM with large wallets, 4) Ensure AppImage has execute permissions, 5) Try different compositors (X11 vs Wayland differences). Possible causes: Memory leak over time, Qt/GUI framework issue, CashFusion threading problems. Most users report stable operation for weeks - if yours crashes consistently, likely specific to your configuration. Report issue on GitHub with verbose logs, distro version, desktop environment. Workaround: Restart EC periodically as preventive maintenance.\"},{\"q\":\"Does Electron Cash have memory leaks and how much RAM does it use?\",\"a\":\"Yes, EC has known memory leaks. Calin confirms: 'Yeah swap won't really fix it - EC leaks memory sadly.' Memory usage varies by wallet size: Small wallets: ~500MB-1GB, Large wallets (years of CashFusion history): 5-8GB normal, up to 8GB during spikes. Shadow's experience: '5GB (usual) - 8GB (extreme spikes) of RAM at all times' with large wallet. Leak causes: Python object references not released, transaction history accumulation, CashFusion state management. Symptoms: Gradual memory growth over runtime, eventual crash or OOM kill. Mitigation: 1) Restart EC periodically (workaround, not fix), 2) Enable swap to delay kill and allow graceful degradation, 3) Monitor memory usage with htop, 4) Consider migrating to fresh wallet if using CashFusion for years. Note: Memory leak is in EC codebase, not Qt or Python runtime, requires code-level investigation to fix properly.\"},{\"q\":\"What is ZSWAP and how does it improve Linux memory management for EC?\",\"a\":\"ZSWAP is kernel feature that compresses RAM pages before writing to swap. Works as compressed cache between RAM and disk swap. Benefits: 1) Effectively increases usable RAM 20-30%, 2) Reduces disk I/O (compressed pages stay in RAM longer), 3) Faster than disk swap due to compression/decompression being faster than disk read/write, 4) Extends SSD lifespan by reducing swap writes. Jonathan: 'I haven't used a swapfile/partition in almost a decade now... that was resolved with zswap for me. I still don't have an on-disk swap.' Shadow uses: 4GB swapfile + ZSWAP enabled, only 52MB actual swap used with 80% ZSWAP utilization. Setup: Enable CONFIG_ZSWAP in kernel, set swappiness (Shadow uses 40). Compression algorithms: lz4 (fast), lz4hc (higher compression), zstd. Note: ZSWAP is different from ZRAM - ZSWAP backs to disk swap if needed, ZRAM is pure RAM compression. Both help EC users running 24/7 CashFusion with growing memory usage.\"},{\"q\":\"Why does modern software poorly utilize available hardware resources?\",\"a\":\"Calin's observation: 'imagine having 8GB RAM or 32GB RAM and programmers still finding a way to utilize those resources extremely poorly. No matter how good hardware gets, (some) programmers will figure out ways to poorly utilize those resources.' Root causes: 1) Python/JavaScript interpreted languages with garbage collection create memory overhead, 2) Library abstractions hide inefficiencies (protobuf, Qt framework), 3) Development speed prioritized over optimization, 4) Hardware becoming cheap makes optimization less valued, 5) Memory leaks from reference cycles or event handlers not cleaned up. EC specific issues: Transaction history accumulates without pruning, CashFusion state management grows, Qt widget memory not released. Shadow reports EC using 5-8GB with large wallet. Compare to Flowee Pay (C++) which Tom wrote with explicit resource management. Solutions: Periodic wallet restart, migrate to fresh wallet, developers prioritizing memory profiling. Industry trend: 'Electron' (not EC) apps bundling entire Chrome browser for simple apps exemplifies wastefulness.\"},{\"q\":\"Does Python's GIL prevent EC from using multiple CPU cores effectively?\",\"a\":\"Yes, Python's Global Interpreter Lock limits concurrency. Calin explains: 'it only uses 1 thread anyway because python' and 'Python is single-core always.. it doesn't really parallelize.' When user asks about limiting EC to single CPU core, Calin notes: 'you don't even need to do this.' Technical details: GIL ensures only one Python thread executes bytecode at a time, even on multi-core systems. This prevents true parallelism for CPU-bound tasks. However, EC uses multiple threads for I/O operations (network requests to Fulcrum servers, GUI rendering via Qt), which can release GIL during blocking operations. Why matters: Memory usage is better metric than CPU core usage for EC. Memory leaks affect performance more than core availability. Workarounds exist: multiprocessing module (not used in EC), native extensions can release GIL (libsecp256k1 does this). For CashFusion, bottleneck is network I/O and cryptographic operations (mostly in C extensions), not Python bytecode execution. GIL mostly impacts batch operations like scanning entire blockchain.\"},{\"q\":\"How divergent are Electron Cash and Electrum codebases now?\",\"a\":\"Very divergent - they split about 7 years ago (circa 2017-2018 when BCH forked from BTC). Electrum underwent massive refactoring since then, making it nearly impossible to port features or fixes between them. A developer attempted to port a performance fix and found the code so different they couldn't even determine if the fix was applicable. This means: 1) EC can't easily adopt Electrum's newer features, 2) Each codebase has evolved with different priorities (EC added CashTokens, CashFusion; Electrum added Lightning), 3) Security patches must be evaluated independently, 4) Android versions have different feature sets despite similar origins. Seven years is 'an eternity in software land'.\"},{\"q\":\"Why doesn't CashFusion work with hardware wallets?\",\"a\":\"Hardware wallets can't participate in CashFusion rounds. Technical reason: CashFusion requires signing many inputs/outputs rapidly during round coordination. Hardware wallets: 1) Require manual confirmation for each signature, 2) Have timeouts that would expire during fusion process, 3) Can't handle the complex multi-party signing protocol. Solution: Import seed phrase from hardware wallet into EC software wallet for fusion. However, this defeats hardware wallet security model (keys leave secure element). Workaround: After fusing with seed phrase in EC, move fused coins back to hardware wallet addresses. Not ideal but only current option. Better approach: Keep funds in software wallet (de-googled phone, offline laptop) and skip hardware wallet complexity entirely.\"},{\"q\":\"Why doesn't Electron Cash work on Fedora when running from source?\",\"a\":\"Fedora switched to BTC's libsecp256k1 which has incompatible Schnorr signatures (BCH uses different Schnorr). This causes conflicts when running EC from source. Solution options: 1) Use the AppImage which bundles compatible libraries, 2) Build BCH's libsecp256k1 from BCHN source and copy the .so file, 3) Wait for someone to package libsecp256k1-bch separately for Fedora repos. CashFusion specifically requires working secp256k1, so fallback to Python code isn't sufficient.\"},{\"q\":\"Why is CashFusion icon missing when I build Electron Cash from source?\",\"a\":\"If you built EC from source but CashFusion icon doesn't appear in the bottom status bar, you likely didn't install the plugin correctly or missed dependencies. The CashFusion plugin needs specific setup when running from source: 1) Ensure all dependencies in requirements.txt are installed (especially protobuf), 2) CashFusion is a plugin that must be enabled, 3) Check Tools > Plugins to see if it's available. The AppImage version includes everything pre-configured with proper plugin setup. If building from source, follow the complete build instructions including plugin dependencies. Quick workaround: Use official AppImage which bundles fusion plugin correctly.\"},{\"q\":\"Why doesn't Electron Cash provide ARM64/aarch64 AppImage builds?\",\"a\":\"Several challenges prevent official ARM64 AppImage: 1) EC uses older Python version requiring dependencies without prebuilt ARM64 binaries, 2) Reproducible build process is complex ('arcane' in maintainer's words), 3) Cross-compilation from x86-64 to aarch64 requires additional Docker setup, 4) Limited developer time for maintenance, 5) Testing infrastructure needed. Workarounds: Run from source using Python virtual environment (miniconda/conda recommended). Performance notes: Without compiling libsecp256k1, cryptographic operations are slow. With compiled libsecp256k1, casual use fine but CashFusion may still be slow on Raspberry Pi 4. Chris Troutner successfully built EC on Raspberry Pi (arm64), creating step-by-step README. Jonas: 'It should be possible to add some packages to the AppImage Dockerfile and cross compile it to aarch64 from an x86-64 host. But who has the time to do it and then maintain it.'\"},{\"q\":\"Is there an ARM64 AppImage for Raspberry Pi available?\",\"a\":\"Yes! Chris Troutner built ARM64 AppImage in October 2025. Announcement: 'It took me about a week of vibe coding and a lot of trial and error, but I finally managed to build an AppImage for arm64 support. I've tested this on Raspberry Pi 4 and 5 B.' Available at github.com/christroutner/Electron-Cash (v4.2.3). Key features: 1) CashFusion works (tested by Chris), 2) Step-by-step build instructions in README, 3) Can build on Pi 5 (Pi 4 slower, may crash during build). Important caveats: Build is NOT reproducible (Ubuntu packages not version-pinned), Chris not planning to maintain it long-term, same protobuf issues as x86_64. Community response enthusiastic - Shadow: 'people can now easily run CashFusion 24/7 on their Raspberry Pis without having their main PC run 24/7.' However, Jonas notes: 'The big problem... of adding an arm64 build on every release is: Who will maintain it? Builds break, someone needs to fix it.'\"},{\"q\":\"Is StartOS suitable for running Electron Cash and BCH infrastructure?\",\"a\":\"Good for dedicated BCH infrastructure, not as daily driver replacement. StartOS (formerly Start9) testing underway for BCH. Adaptive Blocksize Limit: 'We are currently testing start9 actually it's very smooth to run but bchn still has some issues... I think the experience of using BCH apps on start9 is better than normal Linux.' emergent_reasons clarifies use case: 'I don't think anybody who uses linux as their daily driver is going to switch to start9 just for bch stuff. But for people who use it for mining or whatever, that seems like a good addition to the package.' Target audience: 1) BCH miners wanting easy infrastructure, 2) Newcomers needing plug-and-play setup, 3) Users wanting dedicated backend services machine. Not for: Daily driver Linux users, developers needing flexibility. Current status: BCHN being packaged (Jordan fixing issues), Fulcrum 2.0 available. Potential future: EC packaging for 24/7 CashFusion. StartOS provides UX simplification but trades off customization typical Linux users expect.\"},{\"q\":\"How does Electron Cash connect to the Bitcoin Cash network?\",\"a\":\"Electron Cash is not 'pure SPV'. It uses Fulcrum as middleware - EC talks to Fulcrum servers, which in turn talk to full nodes. Pure SPV would mean querying any full node directly using bloom filters, but EC uses dedicated indexers (Fulcrum) that maintain address and transaction indexes for fast queries. This architecture provides better performance than pure SPV while maintaining lightweight client benefits. Users can run their own Fulcrum server for maximum privacy and control.\"},{\"q\":\"What is the technical definition of SPV and how does Electron Cash implement it?\",\"a\":\"SPV (Simplified Payment Verification) is defined as a wallet that validates transactions by: 1) Checking merkle proofs to verify transaction inclusion in a block, 2) Confirming the block is in the chain with most Proof-of-Work. EC does perform these SPV checks. However, EC is more accurately described as an 'RPC/SPV' wallet - it uses SPV to verify proofs but relies on Fulcrum servers (RPC) for blockchain queries. This differs from BIP-37 'pure' SPV which uses bloom filters to query any full node directly. The distinction is primarily about networking architecture and has privacy implications.\"},{\"q\":\"Is Electron Cash technically an SPV wallet?\",\"a\":\"EC is described as 'RPC/SPV' wallet. It uses SPV (Simple Payment Verification) in that it performs merkle proof verification of transactions without downloading the full blockchain. However, purists note it doesn't connect directly to Bitcoin Cash nodes - instead it connects to Fulcrum servers which then connect to nodes. This two-step separation: 1) Improves scaling and performance (Fulcrum optimized for address queries), 2) Can enhance privacy (your IP separated from nodes), 3) Enables features like address indexing that nodes don't provide natively. You can run your own Fulcrum server connected to your own node for maximum trustlessness. The architecture is inherited from Electrum (BTC) and wasn't changed when EC forked.\"},{\"q\":\"Does Electron Cash support Neutrino/BIP-157 compact block filters?\",\"a\":\"No, EC doesn't implement Neutrino (BIP-157 compact block filters) and there are no current plans to add it. Background: Neutrino is alternative to bloom filters for SPV privacy - client downloads block filter commitments, matches locally, requests only relevant blocks. Benefits: Better privacy than bloom filters, don't reveal addresses to servers. EC's situation: Uses Electrum protocol (Fulcrum servers) instead of direct node connections, which provides similar benefits differently. BCHD node software supports Neutrino, but EC can't connect to it directly. Future possibility: Could be implemented as option alongside current Fulcrum connection, but requires significant development effort. Current priority is improving existing features (RPA integration, CashTokens support) over protocol changes.\"},{\"q\":\"Is BIP-157/158 (Neutrino/compact block filters) the same as Bloom filters?\",\"a\":\"No, they're different privacy techniques: 1) Bloom filters (BIP-37): Send probabilistic filter to server/node, they return matching transactions. Privacy: false positives hide exact addresses, but still reveals info to server. 2) BIP-157/158 (Compact Block Filters): Client downloads block filter commitment, matches locally, requests only relevant blocks. Privacy: Server sees which blocks you request, not which addresses. BIP-157/158 is p2p protocol extension - requires node support (BCHD implemented it, BCHN hasn't). EC uses neither directly - it uses Electrum protocol (Fulcrum servers) which provides different privacy model. JF notes: 'completely different than how EC works - almost apples and oranges'.\"},{\"q\":\"What is Anubis and how does proof-of-work prevent bot abuse?\",\"a\":\"Anubis (github.com/TecharoHQ/anubis) is a proof-of-work challenge system for web applications. How it works: Before processing request, server requires client to solve SHA256 hash puzzle (find nonce that produces hash with certain number of leading zeros). Impact: 1) Bots running millions of instances must spend 1000x compute resources per request, 2) Normal users barely notice (browser does computation in background), 3) Makes mass-scraping/spam economically unfeasible. Use case discussed: Block explorer getting hammered by botnet with random user agents - rate limiting affects legitimate users, but PoW targets automated abuse specifically. Shadow's insight: 'Bots are usually cheap to run, are run in millions, billions instances. If they have to spend 1000x the resources on a request, they would maybe decrease the share of resources used to scan your website.' Alternative to CAPTCHAs that doesn't require third-party services and respects user privacy.\"},{\"q\":\"What is Fulcrum 2.0 and why is it significant for Electron Cash?\",\"a\":\"Fulcrum is the Electrum Protocol server (written by Calin Culianu) that EC connects to for blockchain data. Version 2.0 released September 2025 is major milestone. Fulcrum serves as bridge between full nodes (BCHN) and lightweight wallets (EC). Why significant: 1) EC depends on Fulcrum servers for address history, balance queries, transaction broadcasting, 2) Performance improvements benefit all EC users, 3) New features may enable EC functionality, 4) Critical infrastructure for BCH ecosystem. Fulcrum 2.0 adds support for newer protocols, better performance, bug fixes. Community celebrated release - shows active development of BCH infrastructure. Running your own Fulcrum server increases privacy (don't query third-party servers) and network resilience. StartOS integration discussions underway to make running BCHN+Fulcrum easier for home users.\"},{\"q\":\"What components in Electron Cash use protobuf and why is it dependency?\",\"a\":\"Protobuf (Google's Protocol Buffers) used in multiple EC components: 1) CashFusion - for communication protocol between fusion participants, 2) BIP-70 payment requests - legacy payment protocol uses protobuf for message serialization, 3) CashShuffle - privacy mixing protocol communication, 4) KeepKey hardware wallet plugin - device communication. Jonas: 'Yes, BIP-70 and the KeepKey plugin... CashShuffle also uses protobuf.' Why protobuf: Efficient binary serialization, language-neutral, schema validation, backward compatible. Problem: Google's protobuf library has been 'disaster for a decade' (Tom's words) with frequent breaking changes. Alternative: Tom wrote custom protobuf implementation for Flowee - 'Their protocol is stable, it's the software that's been a disaster.' EC approach: 'we try to build as much from source as possible in appimage' (EchterAgo) for security/reproducibility, but this causes build challenges. Could fetch prebuilt binaries instead (already done for PyQt) but loses source-verification benefit.\"},{\"q\":\"Why is RPA wallet change address handling a privacy concern?\",\"a\":\"RPA wallets lack separate change derivation, causing linkability issues. Jonas warns: 'Be careful when spending from the RPA wallet. Best thing to do is to send each and every UTXO separately to a normal wallet and fuse from there.' Dustin explains problem: 'IIUC, all change consistently goes to the same address, tying each transaction from the wallet together.' JF details implementation: 'If you're asking about sending from an RPA wallet, there's no change address, so whether you're doing a normal send or another RPA send, the change goes back to the originating UTXO.' Privacy impact: Andy: 'If you use multiple UTXOs in one transaction they're linked and chain analysis can determine who you are if you mix with exchange funds.' Recommended workflow: 1) Receive to RPA wallet (protects sender's privacy), 2) Transfer each UTXO individually to normal wallet, 3) Use CashFusion from normal wallet to break linkability. Inter-Wallet Transfer plugin automates this: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Current RPA is privacy tool for receiving, not comprehensive privacy solution for spending.\"},{\"q\":\"Is RPA (Reusable Payment Address) feature production-ready in EC?\",\"a\":\"Yes, stable and live for over a year. Glaxweb asks: 'any update with the reusable public key project?' Shadow confirms: 'Yes, it is LIVE in latest Electron Cash, has been for a year+. You need to create a new wallet and choose RPA as the wallet type.' Stability status: 'Indeed, it is a stable feature. I don't remember any serious bugs reported [lately].' Setup: File > New Wallet > RPA Wallet type. Use case: Share one address publicly, each sender's payment goes to unique derived address - protects sender privacy and prevents address reuse. Limitations to understand: 1) Change goes back to same address when spending (breaks privacy), 2) CashFusion not available in RPA wallets directly, 3) Best practice is sweep UTXOs individually to normal wallet before spending. Future: Work ongoing to integrate RPA into normal wallets with CashFusion support. Current RPA is specialized tool for receiving payments with enhanced sender privacy, not replacement for regular HD wallets.\"},{\"q\":\"What is the Inter-Wallet Transfer plugin and why is it useful for RPA?\",\"a\":\"Plugin automates moving UTXOs between wallets individually for privacy. Andy mentions: 'There's an inter-wallet transfer plugin that can automate it.' 2qx provides link: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Created by Karol Trzeszczkowski. Use case: RPA wallet receives multiple payments, each to unique derived address. To maintain privacy when spending: Transfer each UTXO separately to CashFusion-enabled wallet. Manual process is tedious with many UTXOs. Plugin automates: 1) Select source wallet (RPA), 2) Select destination wallet (normal with CashFusion), 3) Configure to transfer one UTXO per transaction, 4) Plugin executes transfers automatically. Adaptive Blocksize Limit: 'This would be very helpful for me until RPA make it to normal wallets where we can use cashfusion.' Important: Without this automation, users might combine multiple RPA UTXOs in single transaction, destroying privacy benefit. Plugin is third-party, verify code before trusting with funds. Maintainer is known EC plugin developer, same person who created scheduled payments plugin.\"},{\"q\":\"Where can I view CashFusion statistics and usage data?\",\"a\":\"CashFusion statistics are available at https://fusionstats.redteam.cash/. This site shows fusion activity, participation rates, and other metrics about CashFusion usage on the network. It's maintained by Rucknium (aka RedTeam), a privacy researcher in the BCH ecosystem.\"},{\"q\":\"Why doesn't Electron Cash have a map feature to show wallet users?\",\"a\":\"Privacy is the main reason. Users don't usually want to inform the network of their location. Additionally, there's a lack of good open and free map solutions. Most BCH vendor maps are closed/proprietary (like bitcoin.com map) which could block access, and many have outdated entries. OpenStreetMap has been suggested but adoption has been slow. EC prioritizes user privacy over network visibility features.\"},{\"q\":\"What are the privacy implications of Electron Cash's architecture compared to BIP-37 SPV?\",\"a\":\"EC/Electrum-style architecture has a significant privacy downside: the wallet directly tells the server all addresses of interest, allowing the server to build a complete profile of your wallet. BIP-37 SPV uses probabilistic bloom filters instead, which provides some plausible deniability (though not perfect). However, BIP-37 has its own issues. The trade-off is that EC's approach is more efficient and reliable. For maximum privacy in EC, run your own Fulcrum server or use Tor/VPN connections to public servers.\"},{\"q\":\"Does changing CashFusion mode reset the fusion round counter?\",\"a\":\"No, the fusion round counter is preserved when you switch modes (Normal, Consolidate, Fan-out). If your coins have been fused 2 times out of a target of 3 rounds, switching modes keeps that count at 2/3. The round tracking is per-coin, not per-mode. This allows you to change strategies mid-fusion without losing progress. The fusion plugin tracks each coin's history regardless of which mode was used for each fusion.\"},{\"q\":\"Can I set up Electron Cash to auto-start and fuse without entering a password?\",\"a\":\"Yes, but ONLY with an unencrypted wallet. The password is used to decrypt the wallet file itself, so there's no way to auto-start an encrypted wallet. For automatic fusion: 1) Create an unencrypted wallet (leave password blank during setup), 2) Configure your OS to launch EC at boot with that wallet, 3) Enable auto-fusion in CashFusion settings. WARNING: Unencrypted wallets can be stolen by anyone with device access - it's equivalent to hanging the key next to a locked door. Use this only on dedicated, secured machines.\"},{\"q\":\"Why doesn't CashFusion appear in my Electron Cash installation on Raspberry Pi?\",\"a\":\"CashFusion requires working libsecp256k1 for cryptographic operations. When running from source on ARM, libsecp256k1 may not be properly compiled/linked. Check Tools > Plugins > CashFusion to see if it's enabled. If missing: 1) Ensure libsecp256k1 is compiled for ARM (run `contrib/make_secp`), 2) Install in a proper virtual environment with all dependencies, 3) Verify Python can import the crypto library without falling back to pure Python. The pure Python fallback is too slow for fusion operations.\"},{\"q\":\"If I can browse with Tor Browser, why doesn't Electron Cash connect through Tor?\",\"a\":\"Tor Browser and EC use Tor differently. EC needs to connect to Fulcrum servers via SOCKS5 proxy. Configuration: 1) Tools > Network > Proxy tab > Select SOCKS5, 2) Set Host: 127.0.0.1, Port: 9050 (or 9150 if using Tor Browser's proxy), 3) Enable 'Use Tor proxy for all connections'. Also consider using .onion server addresses for Fulcrum. EC won't automatically use your system's Tor setup - it needs explicit proxy configuration. For CashFusion over Tor, ensure the fusion server is also reachable over Tor.\"},{\"q\":\"Is CashFusion still operational in 2025?\",\"a\":\"Yes, CashFusion is fully operational and actively used. The fusion servers are running and participants are fusing daily. Statistics available at https://fusionstats.redteam.cash/. CashFusion requires: 1) EC desktop (not available on mobile yet), 2) Plugin enabled in Tools > Plugins, 3) Minimum balance to participate in fusion rounds, 4) Patience as rounds fill up with participants. The protocol provides trustless mixing for improved privacy without custody risk.\"},{\"q\":\"Why do I get timeout errors when using CashFusion over Tor?\",\"a\":\"Tor connection timeouts are completely normal and expected behavior. Tor routes traffic through multiple relays which introduces latency and connection failures. These errors don't indicate a problem with CashFusion itself. Solution: Just ignore the timeout errors and wait for successful fusions. EC will automatically retry connections. The timeouts are common whether using Tor for web browsing or other purposes. Your coins remain safe - failed fusion attempts don't affect your funds. Eventually fusions will succeed when connections stabilize.\"},{\"q\":\"How long does it take to fuse large amounts like 100-800 BCH?\",\"a\":\"Fusing large amounts can take considerable time depending on: 1) Current number of active fusion participants (low activity = slower), 2) How your funds are structured (one big UTXO vs many smaller ones), 3) Fusion mode selected. Real-world example: ~20 BCH fused per day with moderate activity, so 100 BCH could take 5+ days, 800 BCH potentially weeks. Speed improves over time as coins get split into fusion-friendly sizes. Key insight: Use 'Fan-out' mode for large consolidated UTXOs to split them up first, which dramatically speeds subsequent fusions. Fusion speed depends on matching with other participants in similar value tiers.\"},{\"q\":\"When should I use CashFusion's 'Fan-out' mode vs 'Consolidate' mode?\",\"a\":\"Choose based on your current UTXO structure: 1) Fan-out (Spread out): Use when you have large consolidated piles (e.g., one 700 BCH UTXO). This splits big UTXOs into many smaller ones, making them match more fusion tiers and dramatically speeding up the process. 2) Consolidate: Use when you have many tiny UTXOs that need combining. 3) Normal: Balanced approach for typical usage. All modes are equally safe security-wise - they just optimize for different UTXO structures. The fusion round counter is preserved when switching modes, so you won't lose progress. Tip: Switch modes if fusions are too slow - your coin structure probably needs adjustment.\"},{\"q\":\"What is Fusion Fridays and when are fusion participants most active?\",\"a\":\"Fusion Fridays is a community initiative where BCH users focus on running CashFusion on Fridays to increase participant count and improve fusion speed. Higher participation means: more fusion rounds complete faster, better anonymity sets, shorter wait times. Activity varies with events (e.g., during conferences like BCH events in Slovenia, fewer people may be fusing). There's no guaranteed 'best time' but Fridays historically have higher activity. The community encourages running fusion clients 24/7 (similar to BitTorrent seeding) to provide consistent liquidity for everyone. Check fusionstats.redteam.cash for current activity levels.\"},{\"q\":\"Can I speed up CashFusion by acting as multiple participants?\",\"a\":\"Yes! EC has an option to 'fuse as 2 players' which contributes multiple sets of inputs/outputs to fusion rounds. Benefits: helps rounds fill up faster, increases your chance of participating in rounds, contributes to overall fusion liquidity. This is especially useful when participant count is low. The option is in CashFusion settings. Note: you need sufficient wallet balance to act as multiple players since each 'player' contributes different coin tiers. This feature is similar to contributing extra seeders in BitTorrent - helps everyone while also helping yourself get faster fusions.\"},{\"q\":\"Why do some CashFusion transactions not get labeled in my history?\",\"a\":\"This is a known long-standing bug that hasn't been thoroughly investigated yet. About 90% of fusions are labeled correctly, but occasionally some aren't. Possible causes: 1) App crash during fusion (labels added locally on restart don't reflect fusion metadata), 2) Timing issue in label assignment. The fusion info IS in the transaction data - theoretically could be regenerated on wallet load by analyzing tx structure (multiple inputs/outputs matching fusion pattern). Feature request: auto-mark fusion transactions with CF icon based on transaction analysis rather than relying on stored labels. For now, you can manually identify fusion txs by their characteristic structure (many inputs and outputs of similar values).\"},{\"q\":\"What is RPA (Reusable Payment Address) and how does it work in Electron Cash?\",\"a\":\"RPA enables receiving payments privately without revealing a static address or requiring sender interaction. How it works: 1) Recipient provides RPA (derived from wallet's public key), 2) Sender uses RPA to derive unique payment destination that only recipient can find, 3) Recipient scans blockchain for transactions to their RPA-derived addresses. Current EC implementation: Requires separate wallet type (not integrated into standard HD wallets yet), doesn't use change addresses (sends change back to same address like Cashonize), derives only a few keys from the seed. Limitations: Can't be used with hardware wallets (yet), not compatible with CashFusion (no change addresses). Future: Calin plans to integrate RPA as a feature of standard wallets rather than separate wallet type.\"},{\"q\":\"What is the bandwidth cost of using RPA (Reusable Payment Addresses)?\",\"a\":\"RPA requires constantly scanning every new block for potential payments. However, BCH's RPA implementation is optimized: instead of downloading full blocks (like BTC's stealth addresses), it only downloads transactions matching your prefix. With EC's prefix size, this is less than 1% of all transactions. Trade-off: As blockchain usage grows, download requirements grow proportionally (1% of 1GB blocks is still 10MB). Compare to traditional SPV with merkle proofs: download size stays constant regardless of block size. The scanning is a small price to pay for privacy in exchange scenarios, but it's why RPA wallets need to be running more frequently than standard wallets.\"},{\"q\":\"What's the difference between Bloom filters and RPA for privacy?\",\"a\":\"They serve different purposes: 1) Bloom filters: Privacy technique for querying blockchain without revealing exact addresses. You share hash patterns (with false positives for privacy) to nodes, which return matching transactions. Connect to thousands of nodes for privacy. 2) RPA (Stealth Addresses): Enables receiving payments without revealing a static address publicly. Sender derives unique destination that only you can find. These aren't directly comparable - bloom filters improve query privacy for standard HD wallets, while RPA provides completely different functionality (non-interactive private receiving). You don't need RPA for privacy if you use HD wallets with unique addresses per payment. RPA shines specifically when you can't interact with the sender to provide fresh addresses.\"},{\"q\":\"Does CashFusion work with wallets that contain CashTokens?\",\"a\":\"Yes, but tokens are automatically excluded from fusion. How it works: 1) CashFusion scans wallet for eligible UTXOs, 2) Any UTXO containing tokens (fungible or NFT) is automatically skipped, 3) Only BCH-only UTXOs participate in fusion rounds, 4) Token UTXOs stay frozen during fusion process, 5) The satoshis locked with tokens also don't get fused. This is by design - tokens require special transaction handling and can't be mixed in standard fusion protocols. If you need to fuse BCH locked with tokens, first move tokens to a separate output, then the freed BCH becomes fusable. Your tokens remain safe on their original addresses.\"},{\"q\":\"What corporate or business use cases benefit from stealth/RPA addresses?\",\"a\":\"Primary corporate benefit: Financial privacy from competitors and public. Use cases: 1) Paying invoices privately - competitors can't see resource allocation, 2) Receiving payments without exposing revenue in real-time, 3) Quarterly reporting vs forced transparency - choose when to disclose financials, 4) Payroll privacy - employees' salaries not publicly visible, 5) Subscription billing - one stealth address per customer prevents cross-customer data leakage. Non-public companies especially benefit - they don't want general public or competitors analyzing their blockchain activity. Stealth addresses enable corporate BCH adoption while maintaining traditional financial privacy expectations businesses are accustomed to.\"},{\"q\":\"Does CashFusion work on iOS Electron Cash?\",\"a\":\"No, iOS EC does not implement CashFusion and there are no current plans to add it. Primary reason: iOS doesn't support apps running continuously in the background, which CashFusion requires. The UX would be poor since you'd need to keep the app open constantly for fusion rounds. Alternative: Stack Wallet on iOS supports CashFusion but also requires keeping the app open. For best fusion experience, use desktop EC running 24/7 on a computer while using mobile wallet for spending. You can run the same seed on both - desktop handles fusions while mobile handles transactions.\"},{\"q\":\"Can I run CashFusion on desktop while using the same wallet on mobile?\",\"a\":\"Yes, this works well. Setup: 1) Use same seed phrase on both desktop EC and mobile EC, 2) Enable CashFusion on desktop with Tor running, 3) Keep desktop running 24/7 (many users run BCH nodes on same machine anyway), 4) Use mobile for everyday transactions. The desktop will continuously fuse coins in background while mobile wallet reflects the fused balance. Both instances sync with same Fulcrum servers so balance stays consistent. This is a popular setup for iOS users since iOS EC lacks native fusion support.\"},{\"q\":\"Why does my balance show incorrectly in some wallets after using CashFusion?\",\"a\":\"This is typically a gap limit issue. CashFusion creates many outputs across different derivation paths. When you import the same seed into other wallets (Paytaca, Stack, etc.), they may have smaller gap limits (default 20) and stop scanning before finding all your fused UTXOs. EC handles this well because: 1) It tracks addresses used during fusion, 2) Has better gap limit management, 3) Was designed with fusion in mind. Selene wallet (no fusion support) also shows correct balance because it may scan more addresses. Fix: In other wallets, increase gap limit or use 'scan more addresses' feature. Sending all UTXOs back to yourself consolidates them into addresses the wallet expects to find.\"},{\"q\":\"What is the privacy trade-off between fixed donation addresses vs RPA?\",\"a\":\"Fixed address donations: Anyone can see total donations received, timing, amounts, and potentially donor identities (unless they used CashFusion). Your donation history becomes public. RPA donations: Each payment goes to unique derived address only you can find - public sees random-looking addresses, can't connect donations to you or track totals. Only you know donor amounts. Major limitation: Only EC desktop currently supports sending TO RPA addresses. Donors need compatible wallet. For maximum reach: Use fixed address (simple, all wallets support). For privacy: Use RPA (limited support, more complex). Middle ground: Fixed address + ask donors to use CashFusion first.\"},{\"q\":\"Why does Android EC require a separate Tor app for CashFusion?\",\"a\":\"Android EC doesn't bundle Tor internally like desktop version. Technical reasons: 1) Android app sandboxing makes embedding Tor complex, 2) Code size and maintenance overhead, 3) Different platform constraints. Setup: Install Orbot (official Tor app for Android) separately, configure EC to use it as proxy. The fusion protocol itself works fine on Android once Tor connection is established through external app. Alternative for iOS: iOS EC has no fusion at all (not just Tor issue) due to background process restrictions. For best fusion experience: Use desktop EC which bundles Tor seamlessly and runs 24/7 easily.\"},{\"q\":\"How do I know when my coins have been fused in CashFusion?\",\"a\":\"Check your transaction history - fusion transactions appear with CF label/icon. The Coins tab shows which UTXOs came directly from fusion transactions. EC provides 'only spend fused coins' option in settings to prevent accidentally spending unfused coins. On desktop, right-click the CF icon to open progress dialog showing current fusion status. Each completed fusion is a separate transaction visible in history. Important: Multiple fusion rounds increase privacy - first fusion breaks direct link, subsequent rounds add more anonymity layers. The number of fusion rounds can be configured in CF settings. More rounds = better privacy but more fees consumed.\"},{\"q\":\"Which coins does CashFusion automatically exclude from fusing?\",\"a\":\"CF excludes several UTXO types: 1) Coins on addresses with more than 3 UTXOs (anti-spam measure, though debated), 2) UTXOs containing CashTokens (tokens require special handling), 3) Coins on manually frozen addresses/UTXOs (except CF's temporary freezes during rounds), 4) Very small UTXOs below minimum fusion threshold. To exclude specific coins: use Freeze feature on addresses or individual UTXOs. To include excluded coins: unfreeze them or adjust settings. Note: You can't fuse single-input coins effectively - fusion requires multiple inputs from your wallet to obscure which outputs belong to which inputs. Single input = outputs can still be correlated.\"},{\"q\":\"Why doesn't Tor Browser work for CashFusion on Android?\",\"a\":\"Tor Browser on Android only routes browser traffic through Tor network - it doesn't provide system-wide proxy that other apps can use. CashFusion needs Tor SOCKS proxy accessible to EC app, not just browser routing. Correct setup: Install Orbot (official Tor app for Android) which runs as VPN/proxy service that any app can connect through. Some users report Orbot issues while Tor Browser app works, but technically for CashFusion you need the proxy functionality. EC Android specifically looks for SOCKS proxy on localhost port 9050 (Orbot default). Without proper Tor instance running, CF icon won't enable and fusion won't start.\"},{\"q\":\"Does CashFusion actually work on Android EC?\",\"a\":\"Yes, but requires correct setup: 1) Install Orbot (NOT just Tor Browser), 2) Start Orbot and wait for connection (look for onion icon in status bar), 3) Open EC with Tor active - CF icon should enable, 4) Press play button to start fusion, 5) Keep phone awake with EC open - mobile OS may kill background processes. Success indicators: Fusion transactions appear in history, balance changes as coins get fused. Common problems: Wrong Tor app (browser vs proxy), phone sleeping/killing app, insufficient balance for fusion rounds, changing settings incorrectly. Many users confirm it works - if issues persist, try desktop EC where it's more reliable and can run 24/7 easily.\"},{\"q\":\"What is Calin's roadmap for RPA in Electron Cash?\",\"a\":\"Current RPA implementation is proof-of-concept as separate wallet type with limitations (no change addresses, no fusion support, limited key derivation). Planned improvement: Make RPA a feature of standard HD wallets rather than separate wallet type. Benefits: 1) One wallet file handles both regular and RPA payments, 2) Change addresses work normally, 3) CashFusion compatible, 4) No need to run separate wallet instances, 5) Better UX for receiving private payments. Timeline: Calin wants to work on this but needs development time. JF offered to help implement if given architectural guidance. Goal is seamless integration where users can optionally use RPA features within their normal HD wallet workflow.\"},{\"q\":\"Why doesn't EC automatically select the smallest viable UTXO for transactions?\",\"a\":\"EC's coin selection algorithm considers privacy, not just minimizing UTXO usage. Problem with 'smallest viable': If EC always picks smallest UTXO that covers payment + fees, blockchain analysis can easily identify which output is change (the smaller one). Example: Pay 0.03 BCH using 0.08 BCH UTXO - obviously 0.05 BCH output is change. Better approach: Select UTXO where payment and change are similar sizes (closer to 2x payment amount), making it harder to distinguish outputs. Trade-off: Uses more of your 'good' (fused) UTXOs faster, requiring more frequent fusion. If you prefer conserving specific UTXOs, use manual coin selection (right-click in Coins tab). BIP69 output sorting also helps obscure payment vs change.\"},{\"q\":\"What is BIP69 and how does it improve transaction privacy?\",\"a\":\"BIP69 is deterministic transaction output ordering standard. How it works: Orders outputs lexicographically (by script/amount) rather than by meaning (payment first, change second). Privacy benefit: Just looking at transaction, you can't tell which output is payment vs change based on position alone. Example: Without BIP69, first output might always be payment. With BIP69, outputs sorted algorithmically - position means nothing. Limitation: If payment is 0.01 BCH and change is 99.99 BCH, size difference still reveals which is which. Best privacy: Combine BIP69 with coin selection that makes payment and change similar sizes. EC uses BIP69 by default. Note: Even with these measures, sophisticated chain analysis can still make educated guesses based on spending patterns.\"},{\"q\":\"Why should I migrate to a new wallet after running CashFusion for extended periods?\",\"a\":\"Several reasons: 1) Performance - EC becomes sluggish with thousands of addresses/transactions, 2) RAM usage grows unbounded (5-8GB for years of fusion), 3) GUI crashes on Addresses tab, 4) Security - using same seed for years means one compromise reveals all history (like encryption key rotation), 5) Transaction history becomes unwieldy. Migration process: Create new wallet with fresh seed, use CashFusion to gradually move funds from old wallet to new (breaks linkage better than single transfer). Challenge: Must backup new seed phrase securely. Recommendation: Migrate every 1-2 years or after ~30k addresses. Don't wait until wallet becomes unusable - migrate proactively.\"},{\"q\":\"What is RPA's actual privacy benefit versus CashFusion?\",\"a\":\"RPA and CashFusion solve different privacy problems and are complementary, not alternatives. RPA's specific benefit: Allows posting public receiving address without third parties monitoring your balance. Dustin's clarification: 'RPA allows you to post a receiving address in public without third parties being able to see what is sent to you, that's it, nothing more. It doesn't magically prevent any other knowledge leakage.' On-chain reality: RPA outputs look identical to any other P2PKH transaction - completely indistinguishable. Tom's elevator pitch: 'Instead of giving a new address to each sender, you give a code that allows the sender to generate a personal address to send to.' Limitations: Sender always knows where they sent, receiver always knows their addresses, can't combine RPA outputs without revealing they belong to same person (need CashFusion for that). Andy: 'You can't combine outputs from two RPA transactions before CF.' Use together: RPA for private receiving addresses, CashFusion for breaking on-chain linkage.\"},{\"q\":\"Would an 'Electron Cash Private Edition' with enforced privacy settings be feasible?\",\"a\":\"Proposal: EC variant with hardcoded privacy settings - Tor default, CashFusion for all sends, RPA for all receives. Intent: Compete with Monero by preventing users from accidentally compromising privacy. Technical challenges: 1) RPA and CashFusion don't currently work together in EC (implementation limitation, not protocol limitation), 2) Restricting to RPA-only addresses severely limits usability (can't pay merchants without RPA support), 3) RPA outputs are normal P2PKH - no special on-chain privacy beyond address reuse prevention. Jonas: 'Work to be done in EC regarding RPA, more basic than this Private Edition, and I don't think anyone is doing that work.' JF: EC roadmap includes RPA as feature of standard wallets rather than separate wallet type - this foundational work must happen first. Community debate: Some argue RPA provides Monero-level privacy, but fundamentally different - RPA just generates fresh address client-side instead of server-side, doesn't hide amounts or provide ring signatures.\"},{\"q\":\"How are RPA addresses distinguishable from regular BCH addresses?\",\"a\":\"Two levels of distinction: 1) Address format (off-chain): RPA uses 'paycode:...' prefix, regular BCH uses 'bitcoincash:...' - completely different encoding. This allows wallets to recognize when user wants RPA functionality. 2) On-chain transactions: Completely indistinguishable. Adaptive Blocksize Limit: 'RPA are indistinguishable from any normal bitcoin cash address on chain.' Jonas confirms: 'Outsiders can't see if a transaction output is to a RPA or not.' This is key privacy feature - third parties monitoring blockchain can't identify RPA payments. The paycode format contains public key material that sender uses with ECDH to derive unique one-time address. Receiver scans all transactions using their private key to detect payments. Result: Standard P2PKH output on chain, but receiver didn't have to communicate fresh address each time. Enormous anonymity set because looks identical to all other BCH transactions.\"},{\"q\":\"Does CashFusion require HD (hierarchical deterministic) wallet structure?\",\"a\":\"No, CashFusion doesn't rely on HD wallets as part of its design. JF clarifies: 'every wallet nowadays typically uses HD, but fusion doesn't rely on HD as part of its design, it would work in theory even with a wallet that uses a bunch of unrelated addresses.' HD wallets conveniently generate new addresses from single seed, which CashFusion uses for sending outputs to fresh addresses. But fundamentally, CashFusion just needs: 1) UTXOs to mix (inputs), 2) Addresses to receive mixed outputs, 3) These addresses can be from any source - imported, HD-derived, or arbitrary. This means CashFusion could theoretically work with imported address wallets, multi-sig arrangements, or any wallet structure. In practice, EC uses HD for convenience and CashFusion outputs go to next HD-derived change address, but protocol itself is address-source agnostic.\"},{\"q\":\"What are the security implications of running an unencrypted wallet for continuous fusion?\",\"a\":\"Anyone with physical or remote access to your device can copy the wallet file and drain your funds. The security trade-off is identical to 'saving the password' - you're effectively storing the decryption key alongside the encrypted content. Mitigations: 1) Use a dedicated device (like Raspberry Pi) only for fusion, 2) Ensure strong OS-level security (disk encryption, limited user access), 3) Keep only modest amounts in the fusion wallet, 4) Place device in physically secure location. Running 24/7 is optimal for CashFusion liquidity, similar to BitTorrent seeding.\"},{\"q\":\"How do I back up an RPA wallet in Electron Cash?\",\"a\":\"RPA wallets use seed words and are backed up the same way as standard HD wallets. Despite EC's RPA wallet having some limitations (no change addresses, limited key derivation), it still uses a BIP39-style seed phrase for recovery. When creating an RPA wallet, you'll receive 12/24 word seed phrase - write it down securely. Important: Using the same seed for both a hardware wallet and RPA wallet creates privacy linkage between them (same pubkey exposed). Ideally RPA should use a separate derivation path to avoid this correlation, which may be addressed in future EC versions. For now, use dedicated seed for RPA wallet if privacy is critical.\"},{\"q\":\"Why would you want to rotate wallet seeds periodically?\",\"a\":\"Security principle borrowed from encryption key rotation: Using same secret for years means one compromise reveals entire history. If seed is ever exposed (even years later), attacker sees all past transactions. Recommendation: Every year or two, create new wallet with fresh seed, migrate funds. Benefits: 1) Limits damage from future seed exposure, 2) Fresh derivation paths, 3) Clears accumulated transaction history (performance), 4) Can abandon old addresses. Migration challenge: Moving all funds in single transaction creates obvious on-chain link. Better: Use CashFusion to gradually move funds from old wallet to new, breaking linkage. This is why sub-wallet features being discussed - merge old seed into new wallet for fusion migration.\"},{\"q\":\"Is there a CVE affecting EC's protobuf version and does it matter?\",\"a\":\"Yes, CVE exists but likely not applicable. Jonas identifies: 'There is a CVE for the version of protobuf that we are using: github.com/advisories/GHSA-8qvm-5x2c-j2w7. But it shouldn't be applicable since we are supposedly using the compiled upd backend.' Context: Protobuf 5.x has vulnerability but EC compiles with UPD (Universal Proto Deserializer) backend that mitigates the issue. Additional security: 1) EC packages are audited daily via automated GitHub Actions, 2) Developers verify GPG signatures during builds, 3) Protobuf only used for specific features (CashFusion, BIP-70, CashShuffle), 4) Not exposed to arbitrary external input in most cases. Best practice: Keep EC updated to latest version which includes security patches. Don't use ancient EC versions. If concerned, run from source where you can review all dependencies. CVE is tracked but assessed as low risk due to compilation method. Security-conscious users should verify with official EC channels for current assessment.\"},{\"q\":\"What is trustless wallet operation and why is it important?\",\"a\":\"Wallet verifies everything locally, doesn't depend on server honesty. When user asks about trustless, Andy explains: 'That means the wallet doesn't require you to trust any servers.' Context: Standard EC connects to Fulcrum servers for blockchain data (balance, history, broadcast). Trusts servers to give correct information. Trustless operation: Run your own Fulcrum server connected to BCHN full node, wallet only trusts your infrastructure. Benefits: 1) Server can't lie about your balance, 2) Can't hide transactions, 3) Can't refuse to broadcast, 4) Maximum privacy (no third-party sees your queries). Trade-off: Requires running full node (disk space, bandwidth, technical knowledge). Most users trust public Fulcrum servers - generally honest due to reputation. High-value users or privacy-focused should consider own infrastructure. StartOS making this easier with packaged BCHN+Fulcrum. Goal: Make trustless operation accessible to non-technical users. EC itself is open source (code trustable), but server infrastructure typically third-party.\"},{\"q\":\"How do I verify funds arrived at my paper wallet address?\",\"a\":\"Use any block explorer to check the address balance. Simply enter your public address (the one starting with bitcoincash:) into a block explorer website. If concerned about privacy, use a VPN or different internet connection than your normal one when checking, though for paper wallet balance checks this is usually not critical.\"},{\"q\":\"Why does an address show as 'used' in the Addresses tab when I've never sent funds to it?\",\"a\":\"When you copy an address from the Receive tab, Electron Cash assumes you requested a payment to that address. Since you shouldn't request multiple payments to the same address (for privacy), EC marks it as 'used' by that payment request. The Tx column in the Addresses tab shows actual transaction count - if it's 0, the address has no real transactions. To get addresses without marking them used, copy directly from the Addresses tab instead of the Receive tab.\"},{\"q\":\"Why do businesses need unique invoice addresses instead of RPA for most transactions?\",\"a\":\"Accounting and reporting requirements favor invoicing model: 1) 'Issue invoice, receive payment' matches standard accounting practices, 2) HD wallets with unique addresses per invoice solve 'who paid what' tracking, 3) Exchange rates require specific BCH amounts per transaction, 4) Auditing requires clear payment trails internally, 5) Monthly bills have varying amounts (usage-based, exchange rate fluctuations). RPA excels only when: no prior interaction possible (public donations), or backend simplification (no address generation system) outweighs scanning overhead. For standard B2B/B2C transactions with communication channels, unique invoice addresses provide same privacy benefits without RPA complexity. KISS principle applies: use simplest solution that meets requirements.\"},{\"q\":\"What are Cash Accounts and should I still use them?\",\"a\":\"Cash Accounts is an older BCH protocol for human-readable payment addresses (like email addresses for crypto). How it works: Register name on-chain with block height tag (e.g., 'Donations#12345') plus emoji checksum to prevent squatting. Purpose: Memorable addresses instead of long hex strings. Current status: Somewhat deprecated - requires trusted indexer servers for lookups. Better alternatives: 1) BCMR (Bitcoin Cash Metadata Registries) provides similar identity features with SPV-verifiable proofs and decentralized hosting, 2) RPA for privacy-focused donations. Community recommendation: Let Cash Accounts 'gently die' in favor of BCMR which is more trustless. For simple donation addresses, just use standard BCH address with description label.\"},{\"q\":\"What is the proposed sub-wallet or xpriv-based wallet feature?\",\"a\":\"Feature idea: Import multiple seed phrases or xprivs into single EC wallet instance. Use cases: 1) Migrate funds from old wallet to new via fusion (old seed as sub-wallet, outputs go to primary), 2) Import RPA wallet into HD wallet, 3) Spend from multiple sources in one transaction, 4) Consolidate donation addresses with main wallet. Tom's xpriv approach: Child wallets derived from parent seed can be used on mobile separately - if phone stolen, attacker can't access parent or sibling wallets. Only compromises that specific child. Jonas' approach: Import arbitrary seeds as sub-wallets with toggle to enable/disable. Both solve wallet migration and address consolidation problems while maintaining security isolation.\"},{\"q\":\"What exotic derivation paths does EC's scanner support and why?\",\"a\":\"EC includes derivation path scanner (Tools menu) that searches for funds across multiple HD wallet paths. Standard path: m/44'/145'/0' (BIP-44 for BCH). Exotic paths in scanner: m/144'/..., m/0'/..., m/0/..., and others. Origin: Different wallet software historically used non-standard paths before standards solidified. Example: Some wallets used m/144' instead of m/44'/145', causing funds to appear 'lost' when restoring in different wallet. Pierre K: 'I'm especially curious about the m/144'/... ones' - these were likely used by early BCH wallets during chainsplit confusion. Jonas: 'I remember I found a document somewhere (probably an excel sheet) of different paths that had been used by some wallet at some point.' Documentation largely lost (honest-dot-cash went offline taking comprehensive list). Scanner improvement: Pierre reports adding 'number of transactions found' after timeout to help users with large histories. This feature saves users who have funds but wrong derivation path configured.\"}]},{\"name\":\"CashTokens\",\"count\":36,\"faqs\":[{\"q\":\"Is there a CashTokens transaction history export feature in Electron Cash?\",\"a\":\"No, currently there is no dedicated CashTokens history export function in Electron Cash. Regular BCH transaction history can be exported, but token-specific transaction data export is not yet implemented as a built-in feature.\"},{\"q\":\"How do I view CashToken metadata (names, icons) in Electron Cash?\",\"a\":\"Currently, BCMR (Bitcoin Cash Metadata Registry) resolution requires explicit user action via a context menu in CashToken-related tabs. Right-click on a token and select 'Resolve Metadata'. This was intentional to prevent fraud (someone could mint fake tokens with misleading metadata). However, many users don't know about this feature and only see cryptic token IDs. The EC team is considering: 1) Auto-resolve with opt-in/opt-out toggle, 2) Show metadata but mark tokens as 'unknown' until user approves. Note: EC's BCMR resolver doesn't fully support the spec yet and doesn't follow auth-chains for updates.\"},{\"q\":\"Why don't CashToken tabs show by default in Electron Cash?\",\"a\":\"The CashToken tabs are currently hidden by default and must be enabled manually in preferences. To enable them: go to Tools > Preferences > General and check the option to show token tabs. The development team is considering enabling these tabs by default in future versions since CashTokens are now a core part of the BCH ecosystem. Until then, users need to manually enable them to see their tokens.\"},{\"q\":\"What is the Paytaca BCMR Indexer and can Electron Cash use it?\",\"a\":\"The Paytaca BCMR Indexer (https://github.com/paytaca/bcmr-indexer) is a service that indexes Bitcoin Cash Metadata Registry information for CashTokens. It provides API endpoints for resolving token metadata. While EC currently does its own BCMR resolution (with limitations), developers are considering using Paytaca's indexer as an alternative since it's more complete and follows auth-chains properly. The trade-off is that it's a centralized service, but it's easier and more reliable than EC's current implementation.\"},{\"q\":\"How do I fetch NFT-specific metadata (icons, names) in Electron Cash?\",\"a\":\"As of Feb 2025, EC supports NFT-specific BCMR metadata. Right-click on an NFT in the tokens tab and select 'Fetch NFT Metadata' to download and apply the token's icon and name. This is different from category-level metadata - NFTs can have individual images/names. EC now uses Paytaca's BCMR indexer for fast metadata downloads, with blockchain lookup as fallback. Note: Icons appear small in the current UI but the data is accurate. The 'Category Properties...' context menu is for token category metadata, not individual NFTs.\"},{\"q\":\"Does Electron Cash support BIP21 URI format for CashTokens?\",\"a\":\"As of Feb 2025, EC does not yet implement the proposed BIP21-style query parameters for CashTokens. The proposal (documented at bitcoincashresearch.org) suggests adding token information to bitcoincash: URIs, like: bitcoincash:addr?token_category=xxx&token_amount=yyy. This would enable QR codes and payment links to request specific token payments. Feature is on the radar but not implemented. For now, CashToken transfers require manual entry of token category and amount in EC's token sending interface.\"},{\"q\":\"Does Electron Cash support SLP tokens?\",\"a\":\"No, Electron Cash does not support SLP (Simple Ledger Protocol) tokens. SLP tokens were an earlier token standard on BCH that has been largely superseded by CashTokens. SLP is considered a 'failed experiment' with very limited exchange support remaining. EC focuses on CashTokens as the native token protocol. If you have SLP tokens, you'll need to use specialized SLP-compatible software (though options are limited). CashTokens provide better functionality and are built directly into the BCH protocol.\"},{\"q\":\"What is the 'Fetch Category Metadata' option in CashTokens tab?\",\"a\":\"This is a newer feature (added to master branch around March 2025) that allows you to fetch BCMR metadata for token categories directly from the Token History tab. Right-click on a token transaction or category and select 'Fetch Category Metadata' to download names, icons, and descriptions. This is more convenient than the older method of going into 'Category Properties' and clicking 'Apply'. The feature uses Paytaca's BCMR indexer to quickly resolve token information. Future versions may include 'Update All' functionality to fetch metadata for all tokens at once.\"},{\"q\":\"What are the requirements for a CashToken to show BCMR metadata in Electron Cash?\",\"a\":\"For your token's metadata to be resolvable in EC: 1) Register your token's BCMR (Bitcoin Cash Metadata Registry) JSON file according to the spec, 2) Have it indexed by Paytaca's BCMR indexer (EC's primary source), 3) For DNS-based resolution: publish BCMR at specific DNS location. The metadata JSON includes: token name, symbol, icon URLs, decimals, and other properties. EC fetches this data when user right-clicks token and selects 'Fetch Category Metadata' or 'Fetch NFT Metadata'. Not all BCMR spec features are supported yet (e.g., auth-chain following for updates).\"},{\"q\":\"Why don't all BCH wallets properly display balance when CashToken change outputs contain both tokens and satoshis?\",\"a\":\"When a transaction creates a change output containing both remaining tokens AND remaining satoshis (common with airdrop tools), some wallets fail to recognize the satoshis portion in their balance. EC was actually one of the few wallets that showed the change output, but even EC didn't list those satoshis in the normal balance or allow spending them via 'send max'. Fix: Send all tokens from that output back to yourself, which forces creation of a separate BCH-only output that wallets recognize. You may need to send yourself some satoshis first to cover the transaction fee. This is a wallet UI/accounting issue, not a protocol problem - the satoshis are safe on-chain.\"},{\"q\":\"Why does my BCMR token show 'no metadata available' in Electron Cash?\",\"a\":\"EC fetches BCMR metadata primarily from Paytaca's indexer. If your token shows 'no BCMR data available': 1) Token's BCMR JSON file may not be properly registered according to BCMR spec, 2) Paytaca's indexer hasn't indexed it yet, 3) DNS-based resolution isn't configured correctly. Verification steps: check if token metadata appears on tokenexplorer.cash (if yes, indexer problem; if no, registration problem). Solutions: ensure BCMR JSON is published at correct location per spec, contact Paytaca about indexer inclusion, verify token was minted with proper genesis metadata. Not all tokens have BCMR metadata - it must be explicitly set up by the token creator.\"},{\"q\":\"Does Electron Cash support QR codes for CashToken addresses?\",\"a\":\"Currently no - EC doesn't have built-in option to generate QR codes for token-aware address format (prefixed with 'bitcoincash:z' instead of 'bitcoincash:q'). Important clarification: Token addresses and regular addresses are the SAME underlying address, just displayed differently. The 'z' prefix indicates to wallets that this address can receive tokens. If you send tokens to regular QR code (q-prefix), they still arrive at same address and EC will see them fine. For other wallets, they should also find the tokens since it's same key derivation. Workaround: Use external QR code generator with your token address string. GitHub issue #3096 tracks this feature request. Not many users have needed it yet.\"},{\"q\":\"How do I burn unwanted tokens or dust in Electron Cash?\",\"a\":\"Token burning creates transaction where tokens are inputs but not outputs - they cease to exist. Current EC doesn't have one-click burn feature (removed sending to OP_RETURN for tokens). Methods: 1) Wait for PRs adding burn functionality to merge, 2) Use CLI with text editor to craft transaction manually, 3) Send tokens to provably unspendable address. For BCH dust (tagged addresses from dusting attacks): Can still send to OP_RETURN in EC. Note: OP_RETURN itself is unneeded for burning - any transaction that doesn't include token in outputs destroys it. The OP_RETURN aspect just documents the intent. Feature request: Simpler burn UI for tokens.\"},{\"q\":\"Why doesn't Electron Cash show the CashTokens tab by default?\",\"a\":\"In EC version 4.4.x releases, CashTokens functionality exists but requires manual enabling via View menu. This confuses new users expecting token support. Good news: The fix to show CashTokens tab by default is already in the codebase (master branch), just awaiting next official release. JF: 'its already in the codebase, we just haven't done a release in a while.' For immediate access: 1) Enable via View > Show Tokens (current releases), 2) Use EC SLP edition (different wallet, not recommended for CashTokens), 3) Build from source to get latest features, 4) Wait for upcoming release (planned for late 2025). Note: EC SLP edition is different product optimized for SLP tokens, not CashTokens. For testnet token experimentation, building from source or waiting for release is recommended over EC SLP.\"},{\"q\":\"Why doesn't Electron Cash address search find CashTokens addresses?\",\"a\":\"Known bug: Address tab Ctrl+F search only finds legacy (non-token) addresses, not token addresses. Damascene reports: 'if I go to Receive tab and copy Token address then go to Address tab and hit Ctrl+F... it doesn't show.' emergent_reasons confirms: 'right. I think it's just a miss in the tokens upgrade.' Issue opened as GitHub #2641 two years prior. Workaround: Switch to legacy address format from bottom status bar, then search works for legacy addresses. Root cause: CashTokens upgrade added token-aware addresses but search functionality wasn't updated to handle new format. Low priority bug since most users access addresses directly rather than searching. Fix would require updating address_list.py search logic to normalize addresses before comparison. emergent_reasons suggests filing on GitHub issues for tracking.\"},{\"q\":\"How do you detect CashTokens transactions programmatically in EC?\",\"a\":\"Multiple methods available. Adaptive Blocksize Limit's research: 'You can detect token transactions by checking for a tokenData field in BCHN or Fulcrum responses, or by scanning for the 0xEF prefix in raw transaction outputs.' Event handling: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.' Wallet setup: 'The standard restore_wallet_from_seed() works fine for receiving and detecting tokens, so basically you only need a build if you want to mint, send or burn CT.' BCHN RPC: 'BCHN exposes a tokenData object for every output carrying tokens' - documented at docs.bitcoincashnode.org. Key insight: CashTokens always include BCH dust (minimum sat amount), so normal UTXO detection works - you just need additional parsing for token-specific fields. This enables services like BitCartCC (payment processor) to support CashTokens.\"},{\"q\":\"What gaps exist in EC's CashTokens payment request support?\",\"a\":\"Payment request feature doesn't fully support CashTokens yet. Алексей (MrNaif_bel) discovered: 'payment requests feature doesn't support cashtokens, and that's what we use for invoices feature.' Issue details: 'what I just noticed in the output is the tokenreq property, but it's a boolean which is set only by the kotlin gui, and it doesn't do anything in code (maybe only visual filtering).' Events work: 'it indeed fires new_transaction and payment_received events' - basic detection fine. Missing functionality: 1) No way to specify required token amount in payment request, 2) No automatic verification that enough tokens were sent, 3) tokenreq boolean is unused placeholder. Impact: Payment processors like BitCartCC can't easily create invoices requiring specific CashToken amounts. Next step: 'I'll need to create a PR to add cashtokens support for payment requests.' This is infrastructure gap needing community contribution - basic plumbing exists but higher-level features need implementation.\"},{\"q\":\"How does CashTokens detection work at the protocol level?\",\"a\":\"Uses 0xEF prefix marker in transaction outputs. Adaptive Blocksize Limit explains: 'scanning for the 0xEF prefix in raw transaction outputs' identifies token transactions. Technical details: Standard BCH transaction outputs use locking script starting with standard opcodes. CashTokens prepends 0xEF byte followed by token data (category ID, fungible amount, NFT commitment). This prefix is consensus-validated - nodes recognize it as token marker. Fulcrum/BCHN parsing: 'BCHN exposes a tokenData object for every output carrying tokens' in JSON-RPC responses, containing category (token type ID, 32 bytes), amount (fungible token quantity), hasNFT (boolean), commitment (NFT data). Why BCH dust required: Every CashToken output must include at least 546 satoshis (dust limit) so it's valid UTXO. This means wallet's standard UTXO scanning finds tokens, but needs extra parsing to extract token metadata. Electron Cash 4.3+ has 'transaction parsing, and backend compatibility with Fulcrum' for full programmatic access to this data.\"},{\"q\":\"How do CashTokens differ from Ethereum ERC20 tokens architecturally?\",\"a\":\"Fundamentally different: UTXO-based vs account/contract model. Алексей (MrNaif_bel) comparing while implementing BitCartCC support: 'a cashtoken transaction is a BCH transaction... with extra token metadata embedded. there's no such thing as contract methods, right?' Key differences: 1) No approve/allowance pattern - in ERC20 you approve spending before transfer, CashTokens uses direct UTXO spending, 2) No transferFrom - you can only spend UTXOs you own, 3) No gas problems - 'in eth if you receive a token to an empty address, you need to send eth there first to get it out but here because it's utxo, you can just spend it right away', 4) Metadata via BCMR registry instead of contract calls - decimals(), name() replaced by off-chain/on-chain registry lookups. Adaptive Blocksize Limit: 'its utxo VM pure utxo logic better than eth.' Simplicity benefit: 'so there is no concept of allowance? if yes, great, less complexity :D' - cleaner token model without approval vulnerabilities common in ERC20.\"},{\"q\":\"How does EC resolve CashToken metadata (name, decimals, icon)?\",\"a\":\"Multi-level fallback system prioritizing on-chain data. Алексей discovered: 'somewhere deep in the code it uses paytaca indexer bcmr.paytaca.com and if not, it then tries to parse from token genesis tx or something.' Resolution order: 1) Try Paytaca BCMR indexer (centralized aggregator), 2) Fall back to on-chain BCMR embedded in genesis transaction, 3) Check DNS-based BCMR at /.well-known/bitcoin-cash-metadata-registry.json. Mathieu G clarifies: 'Most CashTokens use on-chain resolution, not DNS resolution.' On-chain embedding: Token creator can put BCMR JSON in OP_RETURN of genesis tx - fully decentralized, no external dependencies. Example registries: otr.cash/.well-known/bitcoin-cash-metadata-registry.json, meta.moria.money/m1.json (MUSD specific). For programmatic use: 'use the try_to_download_metadata function from token_meta, and save to cache' - EC provides this abstraction. 2qx notes: 'FBCH uses DNS' showing both approaches coexist.\"},{\"q\":\"What core functions are needed to integrate CashTokens into a payment processor?\",\"a\":\"Алексей's implementation plan for BitCartCC identifies three essentials: 'we only need 3 things: detect payments (invoicing), get balance, send.' Detailed approach: 1) DETECT PAYMENTS: new_payment event fires for token receipts, filter by enabled tokens, parse token_data for amounts, 2) GET BALANCE: wallet.get_utxos(tokens_only=True), group by category_id, use token_meta.format_amount() for decimal handling, 3) SEND TOKENS: make_token_send_spec() to create data structure, wallet.make_token_send_tx(), wallet.sign_transaction(). Metadata handling: Create BasicTokenMeta class, call try_to_download_metadata() to get name/decimals, cache results. Storage: 'store only category id, name, decimals' - minimal footprint. Payment requests gap: tokenreq boolean exists but unused in code - needs PR to fully support requesting specific token amounts. Note: 'don't support NFT tokens' - focus on fungible tokens for payment use case makes sense.\"},{\"q\":\"What is on-chain BCMR resolution vs DNS-based BCMR?\",\"a\":\"Two approaches for CashToken metadata discovery. DNS-based: Token project hosts JSON at domain/.well-known/bitcoin-cash-metadata-registry.json - relies on web infrastructure, simpler to update but introduces external dependency. On-chain: BCMR JSON embedded directly in token's genesis transaction OP_RETURN - fully decentralized, immutable, no external lookups needed. Mathieu G: 'Most CashTokens use on-chain resolution, not DNS resolution.' 2qx counters: 'FBCH uses DNS. All the series weren't issued at once, but if they had been, it would have been about half the CashTokens issued.' Trade-offs: On-chain is censorship-resistant and permanent but harder to update metadata. DNS is flexible but requires maintaining web infrastructure. Practical impact: Wallets like EC query Paytaca indexer first (aggregates both), then fall back to on-chain parsing. Token explorers like tokenexplorer.cash resolve from chain. For payment processors: Can use EC's try_to_download_metadata() which handles both resolution types automatically.\"},{\"q\":\"Why are BCMR registries decentralized rather than having single canonical source?\",\"a\":\"Intentional design choice for censorship resistance and permissionlessness. Adaptive Blocksize Limit: 'Electron Cash doesn't hardcode any BCMR registry URLs but its just by design, BCMR is fully decentralized anyone can publish one.' Алексей initially expected central registry: 'all current stablecoins and stuff, surely they are published somewhere?' Reality: Each token project publishes own BCMR, aggregators (Paytaca indexer) collect them but aren't canonical. Examples of fragmentation: otr.cash registry doesn't include MUSD, meta.moria.money/m1.json is MUSD-specific, tokenexplorer.cash aggregates from chain. For developers: Must handle multiple sources or rely on aggregator. Алексей's solution: 'use try_to_download_metadata function from electroncash' which tries Paytaca then falls back to on-chain parsing - abstraction handles complexity. Trade-off: More robust (no single point of failure) but requires discovery logic. Similar to how Bitcoin doesn't have 'official' explorers - decentralization means redundancy and independence.\"},{\"q\":\"What's the difference between CashToken category ID and token name?\",\"a\":\"Category ID is cryptographic identifier, name is human-readable metadata. Category ID: 32-byte hash (genesis transaction ID), globally unique, immutable - this is what blockchain sees. Example: b38a33f750f84c5c169a6f23cb873e6e79605021585d4f3408789689ed87f366 (MUSD). Name: Human string like 'MUSD' or 'Moria USD' - stored in BCMR metadata, can theoretically be duplicated by different tokens. Алексей's storage model: 'store only category id, name, decimals' - category_id is the key, name is display convenience. When integrating: 'wallet.get_utxos(tokens_only=True) tokens = group by category id' - always use category_id for logic, name only for UI. Decimals crucial: Different tokens have different decimal places, BCMR provides this info. Why this matters: You might have tokens with same name but different category_ids (one could be scam), always verify by category_id. Similar to how contracts on Ethereum have address as true identifier, not name.\"},{\"q\":\"How does EC's payment_received event work with CashTokens?\",\"a\":\"Standard event fires because CashToken outputs include BCH dust. Adaptive Blocksize Limit explains: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.' Алексей confirms after testing: 'it indeed fires new_transaction and payment_received events.' Why dust required: Every CashToken UTXO must include minimum 546 satoshis (BCH dust limit) - consensus rule ensures tokens are valid UTXOs. Implementation: Event handler receives standard UTXO notification, then parse token_data field to check if it's token transfer. Filtering: 'we just filter by those enabled in the daemon' - only process tokens you care about. Gap discovered: 'payment requests feature doesn't support cashtokens... but I am not sure how to make it detect if I sent just enough tokens' - verification of correct token amount needs additional logic beyond event handling. This design elegance: Reuses existing UTXO infrastructure rather than creating parallel token-specific event system.\"},{\"q\":\"Does EC cache CashToken metadata differently in GUI vs CLI mode?\",\"a\":\"Yes, significant difference discovered. Dustin explains GUI behavior: 'EC keeps the metadata, though, at least in the GUI, you only have to download it once per token... it'll show the category ID only until you right click and fetch category metadata. Close and re-open before and after doing that, it's fetched when you hit fetch.' However, Алексей found CLI limitation: 'in all usages of cli it doesn't save the cache back to disk :D' - metadata downloads but isn't persisted. Details: GUI stores in simple config after manual fetch, persists across sessions. CLI loads cache if exists but doesn't write new entries. Алексей: 'well if I checked correctly that's the point, it silently fetches it in background but still doesn't cache anywhere.' Dustin suggests: 'I wonder if the CLI uses the cache when it exists...' Алексей confirms: 'it does, but if I checked correctly, in all usages of cli it doesn't save the cache back to disk.' This inconsistency affects payment processor integrations - need to implement own caching layer or fix EC's CLI caching.\"},{\"q\":\"How should CashToken amounts be represented in payment request CLI commands?\",\"a\":\"Integer base units preferred for backend, formatted amounts for display. Алексей's analysis: 'amount is integer in whatever unit it is and it works but amount (BCH) makes no sense for cashtokens.' Problem: Payment requests show 'amount (BCH)' field with formatted decimal value - meaningless for tokens with different decimals. Options: 1) Add 'token_amount' field with raw integer (no formatting), 2) Query BCMR for decimals and format as 'amount (TOKEN_NAME)', 3) Let consumers handle formatting themselves. Алексей prefers: 'basically if I want to format the payment request I need to request it's BCMR metadata via paytaca indexer/search in blockchain, which might be an expensive operation.' His approach: Cache decimals on his side (BitCartCC), not burden EC with additional caching. Dustin suggests: 'I would leave amount (BCH) but you could add token_amount and not worry about token_amount (whatever)' - backwards compatible. Consensus: Raw amounts in smallest unit (like satoshis) internally, formatting is presentation layer concern. No standard term for CashToken's smallest unit (satoshi equivalent) yet established.\"},{\"q\":\"What PR added CashTokens support to EC payment requests?\",\"a\":\"PR #3144 by Алексей (MrNaif_bel from BitCartCC). Announcement: 'The PR for cashtokens in paymentrequests is up: github.com/Electron-Cash/Electron-Cash/pull/3144.' Implementation details: 'I didn't add amount formatting because didn't get a reply here' - uses raw integer amounts (like satoshis) rather than decimal-formatted token amounts. Decision was intentional to avoid BCMR metadata caching complexity. Additional discovery: 'Also noticed another bug I'll submit a fix for later - if to pay a payment request of let's say 1 BCH in 2 payments, first of 0.1 BCH, second of 1 BCH, initially it returns first tx hash. after paying 1 BCH it returns only the second tx hash, but not both.' Fix exists in upstream Electrum to backport. Context: BitCartCC (BCH payment processor) integrating CashTokens support, needs this EC feature for invoicing. Shows ecosystem development: Third-party services contributing back to core wallet infrastructure. Community appreciates: Shadow gives thumbs up. PR under review by maintainers.\"},{\"q\":\"What payment request testing did BitCartCC developer contribute?\",\"a\":\"Алексей (MrNaif_bel) integrated and tested CashTokens in payment requests. JF asks: 'does anyone have time to give this a quick test?' Алексей responds: 'I did test it with my integration with electroncash, but not many people use paymentrequests directly. Though I think it's used by the GUI in the receive tab indirectly.' Context: BitCartCC is payment processor service (similar to BTCPay Server for BTC). Integration testing: Covered daemon API usage (addrequest/getrequest commands), token detection in payment events, amount handling without decimal formatting. JF's response: 'cool. thanks for the contribution! Would be good to get one more person to test it out if anyone is around. happy to merge it.' Best practice demonstrated: Third-party service developers contributing back to wallet infrastructure. Their production use cases reveal gaps (like missing CashTokens support). Testing scope: Алексей noted GUI testing needed since receive tab uses payment requests internally. His use case is CLI/daemon primarily. Shows healthy ecosystem: External developers finding issues, writing fixes, testing against real-world usage patterns.\"},{\"q\":\"When is the next EC release planned and what's included?\",\"a\":\"Planned for approximately 2 weeks (mid-November 2025). Calin announces: 'Yes very soon I just need to approve some PRs and also do some tweaks for @moleccc.. probably in 2 week or so maybe.' Key feature: CashTokens tab enabled by default (was disabled in 4.4.2). Mathieu G: 'I know the CashTokens tab is disabled by default in the last release but would be enabled by default in the upcoming release.' Calin confirms: 'I agree that should be done.' Already merged: 'I think the PR was already merged some time back, just never got in a release afaik.' Other PRs pending merge: #3144 (CashTokens payment requests), #3145 (export history P2SH addresses fix), various infrastructure improvements. Calin: 'It's easy like 1 line change. It's in main_window.py.' Release will include all merged improvements since 4.4.2 (reproducibility fixes, audit tool whitelisting, ARM64 documentation). Shows steady development pace despite volunteer-only maintenance.\"},{\"q\":\"Why do I get 'IndexError: list index out of range' when signing transactions with Satochip hardware wallet?\",\"a\":\"This is a known bug in the Satochip plugin's CashToken handling code. The tx.token_datas() method returns output token data, but the code incorrectly uses it to check inputs. When there are more inputs than outputs, it causes an IndexError. Workaround: Send coins one at a time (single input per transaction) instead of combining multiple coins. This bug affects old Satochip wallets created before CashTokens.\"},{\"q\":\"Is the BCH dust limit always 546 satoshis for every output?\",\"a\":\"No! The commonly cited 546 sat limit is specifically for P2PKH outputs with 1000 sat/kb minimum relay fee. The actual dust limit varies based on: 1) Output script type - P2SH outputs have different sizes, 2) Token data - CashToken outputs include additional data making them larger, 3) Minimum relay fee rate. Dust limit is calculated as 3x the cost to spend the output (based on input size). For P2SH with tokens, the limit can be significantly higher than 546. EC had the 546 value hardcoded, but a PR was created to calculate actual dust limits dynamically. Reference: libauth.org/functions/getDustThreshold.html documents the calculation method clearly.\"},{\"q\":\"How does moderation work in Nostr-Telegram bridges, and why is centralization unavoidable?\",\"a\":\"Bridges between decentralized (Nostr) and centralized (Telegram) platforms face inherent moderation challenges. Current approaches: 1) Blacklist - Client operator maintains JSON file of banned pubkeys, frontend filters out their posts (doesn't involve relay), 2) Whitelist/NFT gating - Users purchase $1 NFT to gain posting rights, creating economic barrier to spam, 3) Channel owner bans - Nostr group owner can ban users, bridge respects this. Why centralization is unavoidable: Bridge must aggregate messages from one platform to another, so someone controls that aggregation. Unlike pure Nostr where users can ignore relays, Telegram users can't individually mute bridged messages (normal users can't mute others in group chat). Best solution: Whitelist approach (NFT = whitelist) rather than reactive blacklist, since spam takes time to notice and ban. Trade-off: Loses some of Nostr's censorship-resistance properties when bridging to centralized platforms.\"},{\"q\":\"What is the WalletConnect (WC) plugin for Electron Cash?\",\"a\":\"The WalletConnect plugin (developed by OPReturn, funded via Flipstarter) allows EC desktop to connect with web3 BCH dApps like Cauldron DEX. It's currently in alpha stage. Features: scan QR code to connect EC to websites, approve transactions from dApps directly in EC, interact with CashTokens and DeFi protocols. Known issues: some users report crashes when approving transactions (likely threading-related bugs), repeated password prompts before crash. The plugin is actively developed with new versions coming. To use: enable in Tools > Plugins, scan WalletConnect QR from dApp website. This brings MetaMask-like functionality to BCH ecosystem.\"},{\"q\":\"What does 'Freeze' mean for addresses or coins in Electron Cash?\",\"a\":\"Freezing prevents automatic selection when sending transactions. Key points: 1) Frozen addresses/coins won't be used as inputs when you send BCH, 2) It does NOT prevent others from sending TO that address - funds can still be received, 3) Only prevents the coins from being spent unintentionally, 4) Useful for coin control - separating funds for different purposes, 5) You can still manually select frozen coins if needed. Use cases: segregating business vs personal funds, keeping specific UTXOs for token operations, preventing accidental spending of labeled coins. Remember: freeze is local wallet setting, not blockchain-level lock.\"},{\"q\":\"What is BCMR and how does it compare to Cash Accounts?\",\"a\":\"BCMR (Bitcoin Cash Metadata Registries) is newer protocol for on-chain identity and metadata. Advantages over Cash Accounts: 1) SPV-verifiable proofs make it trustless, 2) Can be hosted on your own server or sent in payment requests, 3) More flexible - supports personal and corporate identities, 4) Works for tokens and other use cases beyond payment addresses. Cash Accounts limitations: Requires trusted indexer server for lookups (centralizing element), on-chain registration with block height tags, primarily proof-of-concept. Community direction: BCMR is preferred path forward though JSON spec is currently over-designed and mainly used for tokens. Both aim to solve human-readable addresses, but BCMR has better trust model and extensibility.\"}]},{\"name\":\"Wallet Setup & Configuration\",\"count\":57,\"faqs\":[{\"q\":\"Can I configure Electron Cash to use my own BCMR indexer instead of Paytaca's?\",\"a\":\"Not yet configurable via UI (as of Feb 2025). EC hardcodes Paytaca's indexer with blockchain fallback. To use custom indexer, it must follow Paytaca's API format (there's no universal standard yet). Options for custom metadata: DNS-resolved BCMR (part of spec but less supported) or matching Paytaca's API. The authority/registry providing metadata should ideally be shown in UI for transparency, but this isn't implemented yet.\"},{\"q\":\"What is the Point-of-Sale (POS) gap in the Bitcoin Cash ecosystem?\",\"a\":\"The BCH ecosystem lacks a well-developed point-of-sale system for HD wallets. Ideal POS requirements: 1) Open source for trust and customization, 2) Easy to deploy (no complex server setup), 3) Native app (not browser-based for performance), 4) Multi-platform: desktop, tablet, mobile, 5) HD wallet support (unique address per transaction), 6) Invoice generation with QR codes, 7) Payment detection and confirmation. Current solutions are fragmented - some browser-based, some closed source, some require server infrastructure. This remains a 'sore point' that RPA could partially address (static QR codes), but a proper POS solution with HD support is still needed for retail adoption.\"},{\"q\":\"How does BCH-Nostr integration work for tipping and social media payments?\",\"a\":\"BCH and Nostr share the same elliptic curve (secp256k1), enabling direct integration. Key insight: The npub (Nostr public key) is calculated from same private key that generates BCH address. Implementation: 1) User's Nostr identity directly maps to BCH address, 2) Tips can be sent without separate wallet setup, 3) No need for additional protocols (unlike Lightning Network zaps). Chris Troutner's slpdex.com demonstrates: group chat, Telegram bridge, E2EE DMs, profiles, leaderboards - all using Nostr with BCH payment capability. Benefits: Social media tipping without custodial service, accessible via VPN/Tor without captchas, decentralized identity tied to payment capability. Current implementations use web apps for accessibility, with BCH transactions happening on-chain. This contrasts with Lightning Network which Nostr currently uses - BCH offers simpler integration and aligns with creator (fiatjaf) who dislikes Lightning complexity.\"},{\"q\":\"What is fastlane and why did it raise concerns in EC repo?\",\"a\":\"Fastlane is mobile app automation tool for app store submissions. emergent_reasons: 'fastlane seems to be an automation setup for mobile apps.' Used for: Automating screenshots, uploading to app stores, managing metadata. PR #3137 added fastlane configuration for F-Droid submission. Concerns: 1) Unknown developer submitted it without prior discussion, 2) Includes GitHub Action that runs on PR events, 3) Contains app screenshots in repo (Jonas: 'I'm not sold on having screenshots of the app within the git repo'), 4) Copied from Electrum but not customized explanation. Dustin: 'looks like someone trying to include EC on F-Droid based to that.' Jonas investigates: 'It seems like the fastlane metadata can be used when updating on Google Play Store also, which I guess is useful.' Tom: 'IIRC f-droid allows you to have a second repo with the fdroid specific stuff.' Jonas' preference: 'any Android specific metadata should be in the android/ subdirectory' not repo root. Decision: Wait for known maintainers to review before merging anything from unknown contributor.\"},{\"q\":\"Why does 'No FX rate available' appear in Electron Cash?\",\"a\":\"This occurs when the configured price API provider is down or blocked. Common causes: 1) The specific API provider is having issues (CoinCap has been unstable, BitcoinAverage is dead), 2) Your firewall is blocking connections, 3) VPN is blocked by the API provider. Solution: Go to Tools > Preferences > Fiat and switch providers. Working providers (as of Jan 2025): CoinGecko, Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. CoinCap and BitcoinAverage should be avoided.\"},{\"q\":\"What does 'could not find paymentrequest_pb2.py' error mean when running EC from source?\",\"a\":\"This error occurs when the protobuf file hasn't been compiled. Run the command shown in the error message: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`. You need to install the protobuf compiler first (protoc). This is a recent requirement - the pb2.py file needs to be generated from the .proto definition. This started happening around late 2024/early 2025 and affects running from source. The AppImage doesn't have this issue since it includes pre-compiled files.\"},{\"q\":\"Why do I get protobuf version mismatch errors when running EC from source?\",\"a\":\"The protoc compiler version and Python protobuf library version must match. Common scenario: System protoc (e.g., 3.19) generates *_pb2.py files that are incompatible with your Python protobuf library version (e.g., 5.27). Solutions: 1) Update Python protobuf: `pip install -U protobuf`, 2) Regenerate the pb2 files: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`, 3) Recreate your venv. The generated files contain version info in their headers - check both match your installed Python library. AppImages avoid this by bundling matching versions.\"},{\"q\":\"How do I fix EC AppImage menus not showing on Wayland?\",\"a\":\"Run the AppImage with Wayland display disabled: `env -u WAYLAND_DISPLAY ./Electron-Cash-4.4.2-x86_64.AppImage`. This forces EC to use XWayland (X11 compatibility layer) instead of native Wayland. This fixes menu rendering issues on some Wayland compositors. The AppImage bundles Qt5 which has varying Wayland support. Not all users experience this issue - some run EC on Wayland without problems depending on compositor and configuration.\"},{\"q\":\"Can I recover a password-protected Electron Cash wallet file if I forgot the password?\",\"a\":\"Unfortunately, no easy solution exists. If you have encrypted wallet file but forgot password: 1) EC cannot help you bypass password - that would defeat security purpose, 2) Try common passwords you've used, write them down as you test, 3) Check if you wrote password down somewhere in 2018-2019, 4) The wallet file SHOULD have had a seed phrase backup at creation - search for 12/24 word phrase, 5) Seed phrase can restore wallet without password. The encrypted file contains private keys but they're AES-encrypted with your password. Password cracking is theoretically possible but extremely slow without specialized tools. Lesson: Always backup both seed phrase AND remember/secure your password.\"},{\"q\":\"What causes Electron Cash AppImage build failures and how are they investigated?\",\"a\":\"AppImage builds can fail even when nothing appears to have changed, often due to Python dependency issues. Example: cryptography package (required for TLS/encryption) pulls setuptools-rust which requires semantic_version, causing build errors. Puzzling aspects: 1) Dependencies pinned to specific versions in Docker containers should be deterministic, 2) Same version worked for releases a year ago, 3) No code changes but builds suddenly fail. Investigation steps: 1) Check GitHub Actions logs for specific error messages, 2) Identify which package is failing (often deep in dependency tree), 3) Try building locally vs CI environment to isolate issue, 4) Consider updating to newer package versions (but requires security review), 5) Verify Docker container hasn't changed base image. Solution often involves balancing: updating to latest (more secure, less audited) vs keeping old versions (tested but may not build). Package manager complexity is a can of worms requiring careful review to prevent malicious code insertion.\"},{\"q\":\"What caused EC AppImage build failures in September 2025 and how was it fixed?\",\"a\":\"Root cause: python-qrcode package version 6.1 had '[console-scripts]' group in entry_points.txt with dash in name, which setuptools doesn't allow. This caused semantic_version package installation to fail during cryptography package build. Debugging process by EchterAgo: 1) Traced error to pkg_resources AttributeError in egg_info, 2) Found qrcode-6.1.dist-info/entry_points.txt contained problematic [console-scripts], 3) Discovered upstream fix in python-qrcode PR #229. Solution: Update qrcode to version 7.4.2 (not 8.2 because srcdist builder uses Python 3.8 from Ubuntu 20.04, and qrcode v8+ dropped Python 3.8 support). Additional considerations: Must include SHA256 hashes for new package version, may need to add pypng as dependency, and typing-extensions also needed update. This exemplifies why 'messing with python packages is a can of worms' - even pinned versions in Docker containers can break due to transitive dependency issues.\"},{\"q\":\"Why is Python dependency management difficult for EC and what helps?\",\"a\":\"Python ecosystem challenges: 1) Frequent Python version deprecation (3.8 EOL, currently on 3.11), 2) Package backwards compatibility breaks (e.g., Keras API changes completely between versions), 3) System package manager (apt) conflicts with pip, 4) Transitive dependency version conflicts. Real examples from EC: qrcode v8+ dropped Python 3.8 support, protobuf 5.x broke reproducibility, cryptography package pulls setuptools-rust. Shadow: 'Python ecosystem seems like a complete mess to me.' Solutions: 1) Use conda/miniconda for isolated environments (JF and emergent_reasons both recommend), 2) Never mix system Python packages with pip packages, 3) Pin dependency versions in requirements.txt, 4) Use virtual environments religiously. Dustin: 'virtual environments can be a must on Linux due to OS dependencies.' Jonas notes EC maintains Python 3.11 in AppImage (EchterAgo does this maintenance work), avoiding EOL issues for users of official releases.\"},{\"q\":\"How was the protobuf reproducibility issue in EC AppImage builds fixed?\",\"a\":\"Jonas created PR #3120 with clever workaround for protobuf 5.x build path embedding. Problem: Google's new UPD (Universal Proto Deserializer) backend compiles C library at build time, __FILE__ macro embeds absolute paths into .rodata section. These paths are randomized (/tmp/pip-install-xxx) causing different hashes on each build. Solution: Replace build path strings with deterministic strings of exact same length. Jonas: 'ended up bluntly changing the strings in the binary... My guess is that it's used for printing. But the .rodata is very sensitive since the machine code jumps around in it and offsets needs to be exact.' Why not proper fix: -fmacro-prefix-map flag (used for cryptography package) doesn't work because pip randomly generates build path and we can't control it. EchterAgo: 'the problem is you don't know the path beforehand so you can't pass it in CFLAGS.' Python's mkdtemp doesn't support deterministic seeding. Current fix works but fragile - if protobuf changes string format, would need updating.\"},{\"q\":\"How can I help maintain Electron Cash packages for Linux distributions like Fedora?\",\"a\":\"You can become a co-maintainer for official Fedora packages. Responsibilities include: 1) Following Fedora package guidelines, 2) Bumping version numbers when maintainer is away, 3) Reviewing new BCH-related packages before submission, 4) Creating RPMs for dependencies like libsecp256k1-bitcoin-cash. Contact existing package maintainers (like Jonny in the EC Telegram) to start. Benefits: faster introduction of BCH-specific packages, easier installation via `dnf install electron-cash`, and community ownership of packaging. Fedora maintainer policy documentation: https://docs.fedoraproject.org/en-US/fesco/Packager_sponsor_policy/\"},{\"q\":\"How does BCH's libsecp256k1 differ from Bitcoin's version?\",\"a\":\"BCH uses a different Schnorr signature implementation than BTC's libsecp256k1. The BCH version (from BCHN) is effectively frozen and incompatible with newer BTC versions. This causes conflicts on distros like Fedora that package BTC's version. Solutions: 1) Package libsecp256k1-bitcoin-cash separately (like GNU Guix does), 2) Use static linking to bundle BCH version within the app, 3) Use AppImage which includes compatible libraries. The naming convention '-bitcoin-cash' is recommended to avoid conflicts while allowing both to be installed.\"},{\"q\":\"Does Qt5 support high DPI screens?\",\"a\":\"Yes, Qt5 has decent HDPI support, but it requires explicit enabling in code. It's not automatic like Qt6. For EC users: set QT_SCALE_FACTOR environment variable manually. The issue is that Qt5 doesn't automatically detect and adjust for high-DPI screens, especially when combined with Wayland. Only in the last couple of years have frameworks started automatically handling this through cooperation with the graphics stack. EC's Qt5 dependency is one reason why high-DPI support requires manual configuration.\"},{\"q\":\"Why does Electron Cash not detect my KeepKey hardware wallet on Windows 11?\",\"a\":\"This is a known issue: KeepKey works with Electrum (BTC) and the official KeepKey app on Windows 11, but EC reports 'no device detected'. It works fine on Linux with the same hardware. Troubleshooting: 1) Update firmware, 2) Verify USB drivers are installed, 3) Try different USB ports, 4) Run EC as administrator. The issue appears to be Windows-specific driver/permission handling in EC. Workaround: Use EC on Linux (even via Live USB) or report the issue on GitHub with Windows version and EC version details.\"},{\"q\":\"Can I see my hardware wallet seed phrase after initial setup?\",\"a\":\"Typically no - seed phrases are displayed only during initial device setup. Security model: Hardware wallets are designed so private keys never leave the device. If you could extract seed phrase anytime, defeats security purpose. Backup verification: Some devices (Ledger) have 'Check Recovery Phrase' feature through Ledger Live that verifies your backup matches what's on device without exposing it. Important: Ledger's controversial 'Recover' firmware update showed they technically CAN extract seeds, which undermined trust. Best practice: Write down seed phrase carefully during setup, store securely. If you forgot to backup or lost backup, move funds to new wallet with fresh backup rather than trying to extract seed.\"},{\"q\":\"Why can't I view my hardware wallet seed phrase in Electron Cash?\",\"a\":\"EC doesn't show seed phrases for hardware wallet-connected wallets because the seed never leaves the hardware device. Key security principle: Hardware wallets are designed so private keys (including seed) stay in secure element chip forever. EC only knows your xpub (public key) for watching addresses. To verify your backup: Use manufacturer's software (Ledger Live, Trezor Suite) with 'Check Recovery Phrase' feature - you enter your backup phrase and it confirms if correct without displaying the actual seed. This verification is different from viewing - device checks hash internally. If you need to see seed phrase, you should have written it down during initial device setup - that's the only time it's displayed.\"},{\"q\":\"Why does Electron Cash show 'no module found pathvalidate' error after updating on Arch Linux?\",\"a\":\"This happens after a Python version update (e.g., to Python 3.13). The python-pathvalidate package from AUR needs to be reinstalled to compile against the new Python version. Run your AUR helper to rebuild all Python packages that depend on the updated Python version. This is a common issue with Python version bumps on Arch-based systems.\"},{\"q\":\"How do I install Electron Cash on Ubuntu?\",\"a\":\"You can: 1) Download the AppImage from electroncash.org and run it directly, 2) Run from source by cloning the GitHub repository, or 3) Use a PPA if available. Most developers run it from source for testing. PPAs provide OS-integrated package management but require someone to maintain the packaging.\"},{\"q\":\"Can I run Electron Cash on Raspberry Pi or other ARM-based systems?\",\"a\":\"There is no ARM AppImage for Electron Cash. You must run it from source, ideally in a Python virtual environment (VENV). Building an AppImage for ARM is impractical because many binary dependencies required for the build are not available for ARM architecture. Each unsuccessful build attempt takes about 3 hours. The setup process depends on your specific OS version and pip/apt installations. This approach has worked on various versions of EC on Ubuntu and Pi OS on Pi4 and Pi5.\"},{\"q\":\"What are the advantages of running Electron Cash from source vs AppImage?\",\"a\":\"Running from source offers: 1) Easy testing of master branch or feature branches via git pull, 2) Ability to tweak config files directly, 3) Native Qt appearance (AppImage can look slightly different), 4) Package manager integration (dnf/apt updates). Disadvantages: Environment conflicts (libsecp256k1, protobuf versions, PyQt compatibility), SSL certificate issues with self-signed certs. AppImage benefits: Isolated environment, no dependency conflicts, works out of box. Trade-off based on your use case.\"},{\"q\":\"What is the current status of protobuf in EC's requirements.txt?\",\"a\":\"Protobuf is listed in requirements.txt (recently moved from requirements-hw.txt). To install properly: `pip install -U -r contrib/requirements/requirements.txt`. The bundled AppImage uses protobuf==5.27.3 with matching *_pb2.py files. If running from source with older Python protobuf library, you'll get import errors. Either upgrade protobuf or regenerate the pb2 files with your local protoc version. Version mismatch is the #1 cause of 'could not find paymentrequest_pb2.py' errors.\"},{\"q\":\"Why is there no ARM AppImage for Electron Cash?\",\"a\":\"Several technical challenges: 1) No prebuilt PyQt5 wheel for ARM (Qt6 has one, but EC requires Qt5), 2) Build process is extremely slow on ARM devices (~3+ hours per attempt on Pi4), 3) Many binary dependencies lack ARM versions, 4) Complex deterministic build requirements for security verification, 5) Technical debt from early Electrum development. Cross-compiling from x86 Docker container is theoretically possible but not implemented. Current solution: Run from source in Python virtual environment on ARM devices, accepting the setup complexity.\"},{\"q\":\"How do I install Electron Cash on Fedora Linux?\",\"a\":\"Simple one-line install: `sudo dnf install electron-cash`. Fedora maintains an official EC package in their repositories. This is the easiest installation method on Fedora, handling all dependencies automatically including libsecp256k1, protobuf compilation, and PyQt5. Updates come through regular Fedora updates. Alternative: Use the AppImage for any Linux distro, or run from source in a Python virtual environment for development/testing.\"},{\"q\":\"Should I use Python virtual environments for running Electron Cash from source?\",\"a\":\"Yes, using venv is strongly recommended, especially on rolling-release distributions like Arch Linux. Benefits: 1) Isolates EC dependencies from system Python packages, 2) Survives system upgrades that would break dependencies, 3) Easier to match specific library versions EC needs (protobuf, PyQt5, etc.), 4) Simple to recreate if broken. Setup: `python -m venv --system-site-packages ec_venv && source ec_venv/bin/activate && pip install -r requirements.txt`. Only minor hassle: may need to recreate venv on major Python version upgrades.\"},{\"q\":\"How do I install Electron Cash on Whonix?\",\"a\":\"Download and run the AppImage directly. Get it from https://electroncash.org/downloads/4.4.2/win-linux/Electron-Cash-4.4.2-x86_64.AppImage. Make it executable (chmod +x) and run. Since Whonix routes all traffic through Tor, EC will automatically use Tor for network connections. Whonix is Debian-based, so the Linux AppImage works perfectly. The AppImage bundles all dependencies, avoiding package compatibility issues.\"},{\"q\":\"What causes 'No module named pysatochip' error when installing EC from AUR?\",\"a\":\"The AUR package might not have pysatochip as a dependency if you're trying to use a Satochip hardware wallet. Solutions: 1) Install pysatochip separately: `pip install pysatochip` or from AUR if available, 2) Use the AppImage which bundles all dependencies, 3) If not using Satochip hardware wallet, this shouldn't prevent EC from running - check if the error is fatal or just a warning. The AppImage avoids these dependency issues by including everything internally.\"},{\"q\":\"Why is Electron Cash having libsecp256k1 issues on Fedora?\",\"a\":\"Fedora changed their libsecp256k1 package upstream to Bitcoin Core version and created separate libsecp256k1-abc for Bitcoin ABC version. Problem: Both packages use the same shared library name (.so file), making them mutually exclusive - can't install both simultaneously. EC requires the ABC version (with Schnorr signatures), but if you have Electrum (BTC) installed, it needs Core version, causing conflicts. Solutions: 1) Use EC AppImage (bundles its own libsecp256k1), 2) Set up LD_LIBRARY_PATH for private lib, 3) Contribute fix as PR if you have Linux dev skills. The AppImage bypasses system package conflicts entirely.\"},{\"q\":\"Does AppImage use more RAM than running from source?\",\"a\":\"Yes, AppImage has overhead compared to running from source. Shadow explains: 'AppImage eats lots of ram, more than running from source, because it creates and mounts a container.' AppImage bundles entire application with dependencies in single file, then mounts as FUSE filesystem at runtime. Overhead includes: 1) Filesystem mounting layer, 2) Duplicate libraries (system has them, AppImage has own copies), 3) Potential memory mapping inefficiencies. Running from source uses system Python and libraries directly - more memory efficient but harder to set up. Trade-off: AppImage provides easy installation and version isolation, source provides better performance and transparency. For users with tight memory constraints or wanting to minimize overhead: Use Python venv with system packages. Jonas reports successfully running EC from source on Raspberry Pi (ARM64) with this approach.\"},{\"q\":\"What Python virtual environment approach is best for running EC from source?\",\"a\":\"Multiple options with different trade-offs: 1) Python's built-in venv module: 2qx recommends 'The builtin venv module (-m venv) seems to give the least amount of headache over the long term, IMHO.' Lightweight, no external dependencies, straightforward. 2) Conda/Miniconda: JF and emergent_reasons prefer this - 'does a wonderful job of managing python envs.' More features, handles non-Python dependencies, but additional software to install. 3) System Python without venv: Can work (Tom uses on Arch via AUR) but risks system package conflicts. Common pitfall: Chris Troutner notes 'AI pointed out that the virtual environment was the source of some of the issue' - sometimes venvs add complexity. For EC specifically: Clone repo, create venv (python -m venv ec-env), activate it, pip install -r requirements.txt. EC GitHub README has instructions. Optionally compile libsecp256k1 for performance. Dustin: 'Once you have a venv, the EC readme on github gives you simple instructions.'\"},{\"q\":\"Where can I get help with running a Fulcrum server?\",\"a\":\"There's a dedicated Telegram group for Fulcrum server support: @electroncashserver. This is the appropriate place for questions about Fulcrum setup, configuration, maintenance, and troubleshooting. The main Electron Cash group focuses on wallet usage, while the server group handles infrastructure topics.\"},{\"q\":\"Why don't Bitcoin Cash nodes serve SPV proofs directly?\",\"a\":\"Current BCH node p2p protocol limitations: 1) No direct txid->SPV proof query - you can't ask 'give me merkle proof for txid X', 2) 'getdata' only returns mempool/unspent transactions, not arbitrary historical ones (unless txindex enabled), 3) merkleblock (BIP-37) returns filtered transactions+proofs but requires bloom filter setup first. This is why SPV wallets must use intermediary services: either Electrum protocol (via Fulcrum servers) which provides convenient merkle proof API, or implement full BIP-37 bloom filter workflow. Alternative: BIP-157 (neutrino/compact block filters) but not implemented in BCHN. Result: EC's Fulcrum dependency isn't a design choice but a practical necessity given current node capabilities.\"},{\"q\":\"What happens if BCH implements 1-minute blocks and exchanges respond?\",\"a\":\"Exchanges will likely increase confirmation requirements by 10x to maintain same security level (same cumulative proof-of-work). Current 6-conf requirement becomes 60-conf requirement. Result: No actual speed improvement for exchange deposits. Potential problems: 1) Some exchanges may forget to update settings (temporary faster deposits until they notice), 2) Block reward comparisons to BTC become confusing (0.1x per block), 3) Marketing becomes harder ('our blocks are faster but also worth less'). The 'benefit' relies on businesses not understanding the change or legacy systems with hardcoded confirmation counts. Ironic outcome: Main practical benefit is psychological (seeing confirmations tick faster) not actual faster finality for services requiring confirmations.\"},{\"q\":\"How does EC's Docker-based build process work?\",\"a\":\"EC builds happen inside Docker containers for reproducibility and isolation. Jonas explains: 'The Dockerfiles used for doing the builds is included in the EC source repo. In fact, the build scripts start off by actually building a docker image, launch a container and do the build inside that container.' Process: 1) contrib/build-linux/appimage/ contains Dockerfiles and build scripts, 2) Script builds Docker image with specific base (Ubuntu version, Python version), 3) Container launched with controlled environment, 4) Dependencies installed from pinned requirements.txt inside container, 5) EC compiled with known toolchain, 6) AppImage assembled with all dependencies bundled. Benefits: Same container on any machine produces identical output, isolates from host system variations, version-controlled entire build environment. Challenge: Maintaining Dockerfiles as upstream changes (Python EOL, package updates). EchterAgo maintains these build infrastructure components.\"},{\"q\":\"Why can't Fulcrum servers easily run on port 443 alongside web servers?\",\"a\":\"Protocol mismatch: Fulcrum uses raw TCP, not HTTP. tula s asks: 'why are all the EC servers on 50002? wouldnt it make sense to put a few on 443?' Problem: Running behind corporate firewalls requires port 443 (HTTPS), but Fulcrum uses JSON-RPC over TCP without HTTP headers. Andy explains: 'Fulcrum needs TCP reverse proxying and the website needs HTTP... There's no headers in fulcrum requests to filter on.' Nginx reverse proxy challenge: HTTP servers identified by Host header, but raw TCP connections have no such identification. Calin confirms: 'fulcrum doesn't use http (unless you are using the websockets interface...)' and 'raw bare TCP sockets which have no headers and no way to filter.' Workaround: pat shares solution: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy.' Requires different subdomain/IP for Fulcrum on 443. Fulcrum does have WebSocket endpoint (HTTP-based) which could work, but EC clients expect traditional TCP connection. Corporate firewall workaround remains challenge.\"},{\"q\":\"How do you configure Fulcrum on both standard and firewall-friendly ports simultaneously?\",\"a\":\"Use nginx reverse proxy with different subdomains. pat demonstrates: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy. so fulcrum.pat.mn:443 and fulcrum.pat.mn:50002 are available at the same time.' Setup: 1) Fulcrum binds to internal port (e.g., 50002), 2) Nginx terminates TLS on port 443 using domain certificate, 3) Nginx proxies to Fulcrum's internal port. Important: This works because Fulcrum gets its own subdomain - nginx can route based on Server Name Indication (SNI) in TLS handshake. Andy's concern: 'If you ran it on 443 you wouldn't be able to run a web server on the same IP' - true for same domain, but different subdomains work. Calin acknowledges: 'i can configure my server to offer an alternate 443 port for ssl' but federation/peering logic needs consideration. Benefit: Corporate networks that only allow 443 can now connect. WSS (WebSocket Secure) is alternative but requires client support.\"},{\"q\":\"What tools help simplify nginx reverse proxy configuration?\",\"a\":\"https-portal Docker container recommended. Damascene suggests: 'Use https-portal it made my life easier.' WT complains: 'I always crash and burn when I try to configure nginx.' https-portal provides: Automatic Let's Encrypt certificate renewal, simple configuration syntax, Docker integration, reverse proxy setup without deep nginx knowledge. Alternative approaches: Direct nginx configuration (complex but flexible), Caddy (simpler config than nginx), Traefik (container-native). For Fulcrum specifically: Tom shares example: 'I recently used the idea of wrapping a http-only in nginx to make it use the https part of the bigger website. It's awesome.' Points to Flowee wallet-backup-server readme for configuration example. Key insight: Infrastructure complexity shouldn't prevent running BCH services. Tools like https-portal lower barrier to entry. Important: Still need to understand what you're proxying - nginx is just traffic routing, doesn't modify Fulcrum's protocol requirements.\"},{\"q\":\"How do I install plugins in Electron Cash if they fail to load?\",\"a\":\"Common WalletConnect plugin installation issue: Error occurs when zip file is corrupted or wrong version. Troubleshooting: 1) Re-download plugin zip from official source (ensure latest version), 2) Verify file integrity (checksums if available), 3) Ensure zip isn't damaged during download, 4) Same version number doesn't mean identical files (updates within version possible), 5) Check GitHub releases for plugin changelog. Installation: Tools > Plugins > Install plugin from zip. If errors persist: check EC console for specific error messages, report to plugin developer with error details. Important: Only install plugins from trusted sources (official flipstarter campaigns, known developers). Plugins have full access to your wallet.\"},{\"q\":\"How do I tell if my wallet file is encrypted?\",\"a\":\"Open the wallet file in a text editor. If it shows as one very long single line (like an address), the file is encrypted with your wallet password. Unencrypted wallet files show structured JSON data with readable keys like 'addresses', 'labels', 'transactions'. Note: Encrypted wallet files can be very large and may crash regular text editors - use an editor like Notepad++ that handles large files well. You can decrypt the file by loading it in EC and removing the password temporarily to inspect the contents.\"},{\"q\":\"Why do some experts recommend de-googled phones over hardware wallets?\",\"a\":\"Several advantages: 1) Full control - you install the OS (LineageOS, GrapheneOS), apps are open source and auditable, 2) No supply chain risk - you buy generic phone from anywhere, 3) Familiar platform - standard Android apps work including EC, 4) Lower cost than dedicated hardware wallets, 5) Can run in airplane mode as airgapped device. Downsides: Larger attack surface than purpose-built device, requires technical knowledge to set up properly. Key insight: Hardware wallets have hidden complexities (firmware updates, driver requirements, manufacturer trust), while phones are well-understood attack surfaces. Best practice: Old de-googled phone running only EC, permanently offline for cold storage.\"},{\"q\":\"What are the human factors in choosing between hardware wallets and offline computers?\",\"a\":\"Security isn't purely technical - operational security matters: 1) Hardware wallets: Simpler UX but trusting manufacturer, supply chain, and firmware updates. Risk: Company betrayal, supply chain tampering, update vulnerabilities. 2) Offline computers: More control but requires technical knowledge to set up properly (OS installation, security hardening, air-gap discipline). Risk: User error breaking security. Key insight: No perfect solution exists. Hardware wallets have corporate trust issues; offline computers have human error issues. Best choice depends on your technical ability and threat model. Both can lose funds - hardware through company malfeasance, offline through user mistakes. Complexity itself is security enemy regardless of approach.\"},{\"q\":\"How should I structure cold storage vs hot wallet for everyday use?\",\"a\":\"Recommended setup: 1) Hot wallet on phone: Small amount for daily spending (week/month worth), 2) Cold storage: Bulk of funds on separate device kept physically safe at home. Important: 'Physically safe' doesn't require complex airgapped setup. Simple approach: Old phone or laptop kept at home (sock drawer, under bed) - key is it doesn't leave house where it could be stolen. Don't overthink security - avoid Windows, use strong password, keep seed phrase backed up separately. Splitting funds this way limits loss if phone is stolen or compromised. Cold device can be online occasionally for syncing - true airgap is unnecessary complexity for most users.\"},{\"q\":\"What is SLIP-39 and why would it be useful in Electron Cash?\",\"a\":\"SLIP-39 is Shamir's Secret Sharing for seed phrase backup - splits seed into multiple shares where only threshold number required for recovery. JF suggested as potential future EC feature. Benefits: 1) Distribute backup across locations (give shares to trusted family members), 2) Losing one share doesn't compromise funds (unlike single seed phrase), 3) No single point of failure, 4) Can require N-of-M for recovery (e.g., 3-of-5 shares needed). Example: Create 5 shares, give to 5 family members, need any 3 to recover. If one is lost/compromised, still secure. Current EC uses standard BIP-39 mnemonic (12/24 words) - single point of failure. SLIP-39 would provide more robust backup scheme. Already supported in Trezor hardware wallets. Implementation challenge: Additional complexity in wallet setup/recovery flow, compatibility with existing backup methods.\"},{\"q\":\"How do you keep swap encrypted on Linux for security?\",\"a\":\"Simple approach: Put swapfile on encrypted partition. Shadow: 'If you put your (not very used) swapfile on an encrypted partition, it becomes encrypted.' If using full disk encryption (FDE) with LUKS, all partitions including where swapfile resides are encrypted. Benefits: 1) Sensitive data paged to swap remains encrypted at rest, 2) No separate encryption key management, 3) Cold boot attacks less effective. Josh notes: 'better imo since I have fde and would like to keep swap encrypted as well.' Alternative: Dedicated encrypted swap partition, but more setup complexity. Shadow's setup: 'everything encrypted, RAM encrypted, Kernel structure randomized, no problems reported. Uptime in months.' For crypto wallet users: Critical because seed phrases or private keys in memory could theoretically be swapped to disk. With encrypted swap, even if attacker accesses disk, can't read swap contents. Combined with ZSWAP: Data compressed in RAM first, only overflow goes to encrypted disk swap - maximum security with performance.\"},{\"q\":\"How does F-Droid building/signing differ from Google Play Store?\",\"a\":\"Both platforms re-sign apps, but with different trust models. Tom explains: 'fdroid just uses the plain repo's and builds it 100% on their own system and signs it... Notice that Play Store releases are signed by Google, NOT Jonald. He signs just to allow uploading to Google's servers, they re-sign it to publish.' Key differences: Play Store: Developer signs to upload, Google re-signs for distribution. F-Droid: Builds directly from source on their servers, signs with F-Droid key. Jonas notes: 'The Play Store releases are at least signed by Jonald, but here it seems like it's built by a f-droid backend.' Tom's recommendation: 'it would be smart to use a different ID for both, so they can be installed at the same time as distinctly different apps' - prevents compatibility errors from different signatures. Security implication: Neither platform provides reproducible builds by default, both require trusting the distribution platform. F-Droid advantage is build from source (auditable), disadvantage is no developer signature verification.\"},{\"q\":\"Why did Google Play Store change to AAB uploads and how does it affect trust?\",\"a\":\"Google now re-signs all apps, reducing developer control. Tom explains: 'It was just a couple of years ago when they switched over from apk uploads to aab uploads, which are multi-arch capable.' Key change: Developer signs AAB to upload, Google re-signs with their key for distribution. Rationale: 1) Multi-architecture support (single upload serves different devices), 2) Smaller downloads (device gets only needed code), 3) Key management - 'owner could change signing keys in the play store webapp without hurting actual installs. For instance when a company fired members that they were afraid would have a copy of the signing keys.' Security implications: Users trust Google's signature, not developer's directly. This mirrors F-Droid model where platform controls final signing. Both approaches require trusting distribution infrastructure. For cryptocurrency wallets: Neither Play Store nor F-Droid provide end-to-end verification that binary matches source. Reproducible builds solve this - allowing users to verify any build matches auditable source code. Currently EC doesn't have reproducible Android builds, making this trust necessary.\"},{\"q\":\"How do I restore my wallet on a new device?\",\"a\":\"Wallet files don't automatically copy between devices. You have two options: 1) Restore wallet from seed phrase - create new wallet and select 'I already have a seed', enter your backup seed words, or 2) Send coins from old device to new device if you still have access. You can also manually copy wallet files from the old device's data directory (e.g., AppData/Roaming/Electroncash/wallets on Windows) to the new device.\"},{\"q\":\"Does Electron Cash work with Electrum BTC wallet files?\",\"a\":\"Electron Cash and Electrum use different wallet directories (e.g., Electroncash/wallets vs Electrum/wallets) so they won't interfere with each other's files. Wallet files aren't cross-compatible since they're for different blockchains. However, if you have a pre-fork BIP39 seed from before the BCH/BTC split, you can restore it in both wallets to access coins on both chains. Always keep backups of wallet files regardless.\"},{\"q\":\"Where are Electron Cash wallet files stored and what do they contain?\",\"a\":\"On Linux, wallet files are stored in `~/.electron-cash/wallets/`. Each wallet is a single file containing: addresses, transactions, labels/descriptions for transactions and addresses, and private keys (if not a watch-only wallet). If the wallet is password-protected, the file is encrypted and appears as a single long line when opened in a text editor. All your custom transaction descriptions ('labels') are stored in this file, so backing up the wallet file preserves everything. The file name is the wallet name you chose during creation.\"},{\"q\":\"Why did my transaction descriptions disappear after restoring my wallet on a new system?\",\"a\":\"Transaction labels (descriptions) are stored in the wallet file itself, not on any server or blockchain. If labels are missing after restore: 1) Check you're using the correct/latest wallet file backup (older backups won't have recent labels), 2) Verify the file isn't corrupted during copy, 3) Ensure the file loaded correctly in new EC. The wallet file location on Linux is `~/.electron-cash/wallets/`. Your coins are always recoverable from seed phrase, but labels are only in the wallet file, so keep multiple timestamped backups.\"},{\"q\":\"How do I find the xpub (Master Public Key) in Electron Cash mobile?\",\"a\":\"On Android: Open wallet > Three dot menu (top right) > Wallet information > Master public key. On iOS: This feature is NOT currently available. The iOS version lacks the wallet information/xpub display feature. You'll need to use the desktop version to view your xpub. This is a known gap in iOS functionality. If you need the xpub for services like Blockonomics, either install EC desktop and restore your wallet there, or submit a feature request on GitHub.\"},{\"q\":\"Why can't I mix private keys and watch-only addresses in a single EC wallet?\",\"a\":\"This is a current limitation of EC's wallet architecture. You cannot have a wallet file that contains both: 1) Addresses with private keys you control, and 2) Watch-only addresses (addresses you monitor but don't control). This 'seemingly arbitrary limit' is inherited from EC's wallet model where a wallet is either fully controlled (has all private keys) or entirely watch-only. Workaround: Create separate wallet files - one with your controlled keys, another watch-only for monitoring external addresses. This limitation affects some advanced use cases like coin control workflows where you want to track external UTXOs alongside your own. May be addressed in future wallet architecture updates.\"},{\"q\":\"Can Electron Cash open Electrum (BTC) wallet files?\",\"a\":\"Uncertain - it may or may not work due to codebase divergence. EC and Electrum split 7+ years ago and developed differently. Potential issues: 1) Different wallet file format versions, 2) Different derivation paths (BTC vs BCH), 3) Different encryption implementations possibly. If password-protected file opens in EC and prompts for password, the format might be compatible. After decryption, you could export private keys. Important: Even if file opens, addresses will show BCH amounts, not BTC. If you had BTC in 2018, you'll need to open in current Electrum for BTC, and separately in EC for BCH (if it existed on those addresses during 2017 fork).\"},{\"q\":\"What's the proper way to restore a wallet file versus a seed phrase in EC?\",\"a\":\"Two different restoration methods: 1) Wallet File: File -> Open, browse to .wallet file. If encrypted, enter password. The file contains complete wallet data including labels, addresses, transaction history. 2) Seed Phrase: File -> New/Restore, choose 'I have a seed', enter 12/24 words. Recreates wallet from scratch by deriving keys. DON'T open wallet file in text editor and paste contents - that's the encrypted JSON/binary data, not useful as text. Seed phrases are your ultimate backup - they regenerate everything. Wallet files are convenience backups that preserve metadata but require password if encrypted.\"},{\"q\":\"What's the difference between Electrum and Electron Cash wallet files?\",\"a\":\"They use similar but not identical formats since they forked 7+ years ago. Key differences: 1) Created for different blockchains (BTC vs BCH), 2) May have incompatible encryption or serialization versions, 3) Address derivation paths may differ. Cross-compatibility: Sometimes EC can open Electrum files if encryption is similar, but it's not guaranteed. If you have 2018 wallet: Open in Electrum (BTC) first, decrypt, export seed phrase or private keys, then use those to create new wallet in EC for BCH access. Remember: Post-2017-fork Electrum wallet likely has no BCH (created after split). Pre-fork keys could have both BTC and BCH from before split.\"}]},{\"name\":\"Transaction Management\",\"count\":60,\"faqs\":[{\"q\":\"Why does my Electron Cash show an incorrect BCH price (e.g., showing $13,000 instead of actual price)?\",\"a\":\"This happens when the price API source (like CoinCap) has incorrect data. Electron Cash fetches live prices from external APIs, and if that API returns wrong data, your wallet will display incorrect fiat values. This can be costly if you're making trades based on the displayed price. Solution: Go to Tools > Preferences > Fiat and switch to a different price source. Always verify the displayed price against other sources before making important transactions.\"},{\"q\":\"What does 'Spend only confirmed coins' option do in Electron Cash?\",\"a\":\"When enabled (Tools > Preferences > Transactions), EC will only spend UTXOs that have at least one confirmation. This provides slight security benefit: prevents spending unconfirmed change from previous transactions that might not confirm. It's useful when: 1) Making multiple transactions in succession, 2) During network congestion, 3) For extra assurance coins are truly spendable. Downside: you can't immediately respend coins from unconfirmed transactions, which may slow down workflows. For most users, leaving it off is fine since BCH confirms quickly.\"},{\"q\":\"Why does EC mobile show 'invalid address' when scanning BitPay QR codes?\",\"a\":\"BitPay changed their QR codes from simple address+amount format to URL-based format: `bitcoincash:?r=https://bitpay.com/i/xxxx`. Desktop EC supports these payment protocol URLs (fetches actual address from the URL), but EC mobile may not have implemented this BIP70/BIP72-style payment request feature yet. The merchant name and amount appear because they're in metadata, but the actual sending fails. Workaround: Use desktop EC to pay BitPay invoices, or wait for mobile update. Report as bug on GitHub for tracking.\"},{\"q\":\"How do I rescan transactions if my EC wallet is missing transaction history?\",\"a\":\"EC provides two options: 1) 'Wallet -> Rebuild History...' - Deletes local history and re-downloads everything from Fulcrum servers. Use this if you see addresses in your Addresses tab but transactions are missing. 2) 'Wallet -> Scan more addresses...' - Extends the gap limit to search for addresses further down the derivation path. Use this if addresses aren't showing up at all. If 'Scan more addresses' times out, retry - it switches servers on timeout. Check Addresses tab first: if receiving address shows under 'Used' or change address under 'Empty', but transaction history is missing, use Rebuild History. If addresses themselves are missing, use Scan more addresses.\"},{\"q\":\"How do I recover funds from a wallet EC can't handle due to too many UTXOs?\",\"a\":\"Multiple approaches: 1) Use EC CLI instead of GUI - may avoid GUI rendering issues, 2) Export individual private keys (WIF) from seed, import each address as separate wallet, 3) Set address gap to 0 to prevent wallet from scanning many addresses, 4) Use libauth or other library to derive private keys from seed phrase programmatically, 5) Create transactions programmatically using extracted private keys. For single address with 60k+ UTXOs: Even Fulcrum server may timeout on listunspent query - that much data challenges entire infrastructure, not just EC. Last resort: If it's testnet BCH (tBCH), consider starting fresh wallet and mining to new address instead of transferring.\"},{\"q\":\"What's the difference between GUI freezing and backend issues in EC?\",\"a\":\"Important distinction for troubleshooting: GUI issues freeze interface but wallet data may still be accessible via CLI or programmatic access. Example: Wallet with 60k UTXOs - Coins tab freezes GUI, but CLI commands or direct wallet access might work. EC's GUI renders entire lists in Qt widgets, causing hangs when data is large. CLI bypasses GUI rendering entirely. Solution path: If GUI freezes, try EC CLI commands (payto, listunspent, etc.) or export private keys and use external tools. Backend issues (Fulcrum timeout, database corruption) affect all access methods. Diagnosis: If wallet loads but specific tabs freeze = GUI issue. If wallet won't sync or balance wrong = backend/network issue.\"},{\"q\":\"What is a potential workaround for wallets with too many UTXOs that EC can't handle?\",\"a\":\"Tom's suggestion for extreme UTXO count (60k+): Import wallet from later block height to get partial view. This means: 1) When restoring from seed, specify recent block height instead of genesis, 2) Wallet only sees transactions/UTXOs from that height forward, 3) Avoids loading entire transaction history that causes GUI freeze. Limitations: Loses access to older UTXOs (need full import for those), primarily useful for chipnet/testnet scenarios where history is less critical. Other approaches: Extract individual private keys and import each address separately (spreads load), use CLI instead of GUI (bypasses rendering issues), or programmatically construct transactions using libauth. Note: 60k UTXOs also challenges Fulcrum server - 'listunspent' query may timeout regardless of EC client.\"},{\"q\":\"What is the verbose flag for debugging EC AppImage crashes?\",\"a\":\"Run AppImage with -v flag to capture detailed output. Josh: 'I feel dumb. Why didn't I think of this sooner? I'm running the AppImage with the -v (verbose) flag.' How to use: './Electron-Cash-4.4.2-x86_64.AppImage -v 2>&1 | tee ec_debug.log' captures all output. The verbose flag causes EC to print: 1) Library loading information, 2) Qt/GUI initialization details, 3) Network connection attempts, 4) Wallet loading progress, 5) Error messages with stack traces. When Josh ran with -v, crash output showed Wayland-specific function calls (wl_ prefixes), directly identifying display compositor as crash location. Alternative debugging: 1) Run EC from terminal (not desktop launcher) to see stdout/stderr, 2) Check ~/.local/share/Electron Cash/... for EC's own logs, 3) journalctl for systemd logs (if using systemd), 4) dmesg for kernel-level issues (OOM, segfaults). Always capture verbose output when reporting bugs to GitHub - essential for developers to diagnose issues.\"},{\"q\":\"Why does EC fail to export P2SH input addresses in transaction data?\",\"a\":\"Parsing limitation: EC's scriptSig parser doesn't handle general P2SH contracts. emergent_reasons discovers: 'if I add some debug to the export code, it sees this for p2sh inputs... address: None.' Investigation reveals: 'It even looks like the scriptsig parser just doesn't even try to parse p2sh20 or p2sh32... cannot find address in input script.' Root cause: EC's parse_scriptSig() designed for specific input types (P2PKH, multisig P2SH) but not arbitrary P2SH contracts. Bitcoin/BCH inputs contain scriptSig (unlocking script) that doesn't explicitly include address - address must be derived from script hash. For multisig: EC recognizes pattern and computes P2SH address. For general P2SH: Parser gives up, returns type='unknown', address=None. Impact: Transaction export (JSON format) missing input addresses for smart contracts like CashScript covenant transactions. Dustin: 'I noticed that a long time ago, but it isn't an issue for my use case' (uses multisig P2SH which works). emergent_reasons offers bounty for fix: 'willing to pay for a local fix.' This is technical debt from EC's P2PKH-centric design.\"},{\"q\":\"Why does EC's scriptSig parser fail for non-multisig P2SH inputs?\",\"a\":\"Uses heuristic pattern matching that doesn't cover general P2SH. Calin explains: 'it's a heuristic matcher.. and there is no general solution.' The algorithm: 1) Do I see 1 push? → p2pk, 2) Do I see 2 pushes? → p2pkh, 3) Do I see OP_0 then more pushes? → p2sh multisig, 4) Otherwise → unknown. Problem: Non-multisig P2SH contracts (like CashScript covenants) often have different push patterns. Calin: 'As an increasing number of p2sh are NON multisig... the heuristic scanner is now being exposed for the fraud that it is!' Why unsolvable locally: 'there is no way to improve it... because the problem is unsolvable with scriptSig alone as the only thing one has to examine.' Bitcoin transactions only include unlocking script (scriptSig), not locking script (previous output). Without knowing original locking script, can't definitively determine input type. Tom reinforces: 'The issue is that if you're looking at one transaction, you have the redeem. But you would need to fetch the old transactions to get the rest of the script.' Solution: Fetch previous transaction outputs from network.\"},{\"q\":\"How did Calin's PR #3145 fix the P2SH export address issue?\",\"a\":\"By fetching previous transaction outputs instead of relying on heuristics. Calin explains: 'yes it fixes the problem by getting the actual spent coins because there is no way to solve this problem from the scriptSig alone.. you ultimately need the previous output (spent coin) for the txn.' Implementation: 'this PR just does that -- leverages the fetch inputs subsystem from transaction.py to go out to the network and determine spent coins for a txn.' PR link: github.com/Electron-Cash/Electron-Cash/pull/3145. Testing: emergent_reasons confirms: 'Tried it and it worked!' Benefit: Export history now includes correct input_addresses for all transaction types, not just P2PKH and multisig. Trade-off: Requires network access during export (fetches previous txs), may be slower for large histories, adds external dependency. Context: This fixes export functionality specifically, not the general-purpose transaction parser. Calin: 'there is no solution, sadly, if the only information one has to fix it is the scriptSig.. you need to go back to the previous output scriptPubKey to know for sure.' Export can use network since it's not a real-time operation.\"},{\"q\":\"Why can't EC CLI deserialize require network access to fix P2SH parsing?\",\"a\":\"Offline operation is core design requirement. Dustin: 'we don't want cli deserialize to require network, but might be able to add an option to use/require network when we know it's P2SH and want to try to fetch.' Use cases for offline deserialize: Air-gapped transaction building, offline signing workflows, security-sensitive environments, debugging without connectivity. Dustin's workflow: 'literally going into EC GUI, hitting send, pasting a P2PKH address, hitting max, hitting preview, hitting copy, going to CLI and running electron-cash deserialize' - for automated transaction processing. CLI output format: 'return self._EnsureDictNamedTuplesAreJSONSafe(tx.deserialize().copy())' - returns transaction dictionary. Trade-off: Offline operation means limited information. emergent_reasons: 'I need the export to just work' - his use case (tax reporting) can tolerate network access. Dustin suggests: 'might be able to add an option' - optional network flag would preserve backwards compatibility. Current state: Export (GUI feature) can use network (Calin's PR #3145), CLI deserialize stays offline. Different tools for different trust models.\"},{\"q\":\"Should CLI deserialize command fetch network data to resolve addresses?\",\"a\":\"Philosophical debate on function purity vs utility. Dustin proposes: 'Still wonder why it couldn't be modified to retrieve whenever it fails if network is available, maybe even without an option.' Calin supports but clarifies: 'i am in favor of retrieving... it may slow down the RPC call a bit in some cases but I think is worth it.' However, questions scope: 'that seems like a low-level facility just to actually DESERIALIZE a transaction.' Pure deserialize: Transform bytes to data structure. Extended deserialize: Transform bytes + resolve all external references. Calin's naming concern: 'what you are alluding to is some higher level thing like DeserializePlusResolveAllExternalInfoForTxnPlsINeedKThxBye.' Potential solutions: Add optional flag (fullyResolveEverything=True), create separate command, silently fetch when network available. Dustin's use case: 'I do [use offline deserialize], that's why I assumed it's what emergent was doing.' Calin: 'do people use it in offline mode as a quick way to get fun stuff out of EC like free txn deserilization?' Question remains open for community input on best approach.\"},{\"q\":\"What's the best practice for contributing icons or UI changes to Electron Cash?\",\"a\":\"Always consult maintainers BEFORE investing significant time. Key points: 1) EC maintainers (especially Calin) prefer detailed, non-flat icon styles over modern minimalist designs, 2) EC intentionally maintains a 'retro' aesthetic, 3) Bug fixes and consistency improvements are welcome, 4) Reductionist/flat modern icons are likely to be rejected. When submitting PRs: include screenshots, expect feedback, and be prepared to modify or revert specific changes. The maintainers appreciate contributions but have strong aesthetic preferences that differ from modern design trends.\"},{\"q\":\"What is SeedCash and how does it support BCH hardware wallet functionality?\",\"a\":\"BCH-focused hardware wallet with SLIP-39 support. Martí introduces: 'Its architecture is used for HW control but in terms of the application, it is practically all new.' Fork of SeedSigner project, customized for BCH. Features: BIP-39 seeds (12-24 words), SLIP-39 shares (20 or 33 words), xpub/xpriv export, BCH address generation (CashAddr and Legacy formats), transaction signing (in development). Integration with EC: Generate SLIP-39 seed on device, export xpub via QR code, create watch-only wallet in EC. Private keys never leave device. Air-gapped: No network connectivity, communication via QR codes only. Use case: Cold storage with social recovery. Split seed into shares, distribute to trusted parties, any M-of-N can recover. Website: seedcash.cash with educational resources. Open source (based on SeedSigner). Fills gap that EC lacks native SLIP-39 support - external device handles seed management while EC provides wallet interface.\"},{\"q\":\"How can I learn about SPV and thin client technology in Bitcoin Cash?\",\"a\":\"Good resources include: 1) The original Bitcoin whitepaper section on SPV, 2) https://flowee.org/news/2023-08-thin-clients/ which explains thin client concepts for BCH, 3) Understanding that EC uses indexed servers (Fulcrum) rather than pure bloom filter SPV. Key concept: EC queries Fulcrum which maintains address/transaction indexes, rather than querying full nodes directly with bloom filters like original SPV design.\"},{\"q\":\"How does HD wallet address generation work with the gap limit?\",\"a\":\"HD (Hierarchical Deterministic) wallets generate addresses sequentially from a master seed using BIP32 derivation. The 'gap limit' (default 20 in EC) determines when to stop generating new addresses: the wallet generates addresses until it finds 20 consecutive UNUSED addresses, then stops. Online: wallet queries blockchain to check which addresses have transaction history. Offline: without blockchain access, wallet cannot determine usage, so it just generates the initial 20 addresses and stops there. This is why offline wallets work fine - they don't need to search for used addresses, they just generate the base set. The gap limit prevents infinite address generation while ensuring you don't miss funds sent to addresses further down the derivation path.\"},{\"q\":\"What advantages does Electrum protocol provide over direct node connections?\",\"a\":\"Electrum protocol (what Fulcrum implements) offers features nodes don't: 1) Merkle roots/proofs over headers - clients can store just root + minimal tip instead of entire header chain, 2) Address-based transaction queries - nodes can't query 'all transactions for address X', 3) Convenient SPV proof API - single call to get merkle proof for txid, 4) Header chain pruning support - verify once, store root, discard headers. For light clients wanting minimal trust: download header chain, verify it, compute trusted root, then discard headers. Future ideas: add header root/proof messages to node p2p protocol, service discovery so nodes can advertise if they run Fulcrum alongside. Currently, any SPV verification requires Electrum protocol.\"},{\"q\":\"Why does Electron Cash sync so much faster than other BCH wallets?\",\"a\":\"EC's architecture uses Fulcrum servers (Electrum protocol servers) that maintain pre-indexed databases of all BCH transactions. When wallet comes online: 1) Downloads new block headers (small, fast), 2) Queries server with address list, 3) Server uses its index to return only relevant transactions for that wallet. Other wallets (Stack, Cake) may use different sync methods requiring more blockchain scanning. Key optimization: BCH ecosystem (EC, Fulcrum, BCHN) has been continuously developed for fast, efficient, scalable performance. Fulcrum's address-based indexing is the main speed advantage - you only download data relevant to your specific wallet.\"},{\"q\":\"How does coinbase maturity affect spending newly mined coins?\",\"a\":\"Coinbase outputs (block rewards including both subsidy and transaction fees) have a mandatory maturity period before they can be spent. This was coded by Satoshi: blockchain enforces 100 confirmations minimum, while original client required 120 confirmations for extra safety margin. Transaction shows 'mined in block X' but remains unspendable until maturity reached (~100-120 blocks = 16-20 hours on BCH). This prevents issues if the block gets orphaned in a reorg - premature spending of coins that might disappear causes bigger problems. Applies to entire coinbase output, not just subsidy. Mining pools wait for this reason before paying out.\"},{\"q\":\"What are the trade-offs of reducing BCH block time from 10 minutes to 1 minute?\",\"a\":\"Benefits: Faster first confirmation (~1 min vs 10 min), better UX for transactions ineligible for DSP (DeFi contracts, anyone-can-spend scripts), more responsive network. Costs: 1) 10x more block headers to validate and store (more overhead for SPV clients), 2) Higher orphan rates due to propagation delays, 3) Significant retooling required across ecosystem (wallets, nodes, services), 4) More frequent difficulty adjustments needed, 5) Coinbase maturity period (100 blocks) becomes 100 minutes vs 1000 minutes. Key debate: DSPs + first-seen rule already secure most 0-conf transactions, so faster blocks mainly help edge cases. KISS principle: Some argue improving DSP coverage is simpler than changing fundamental block timing.\"},{\"q\":\"What is Fulcrum and why is it important for BCH ecosystem?\",\"a\":\"Fulcrum is high-performance Electrum protocol server developed by Calin Culianu. Role: Maintains indexed database of all BCH transactions, provides fast address-based queries to SPV clients. Why important: 1) Powers Electron Cash's fast sync and balance queries, 2) Enables SPV proof verification, 3) Provides DSProof data to wallets, 4) Serves as infrastructure for many BCH services beyond EC, 5) Optimized for scalability (handles large blocks efficiently). You can run your own Fulcrum connected to your node for maximum trustlessness. Public Fulcrum servers handle most user connections. It's the 'engine behind the scenes' that makes light wallet experience smooth compared to direct node connections.\"},{\"q\":\"How do 1-minute blocks affect SPV wallets like Electron Cash?\",\"a\":\"SPV clients download block headers to verify proof-of-work chain. With 1-minute blocks: Headers grow 10x faster - instead of ~4MB/year, now ~40MB/year. Impact: 1) Initial sync takes longer (download all historical headers), 2) Storage requirements increase for light wallets, 3) More bandwidth used for ongoing sync. For full nodes: Minimal impact since transaction data dominates storage. Headers are small (80 bytes each), but 10x more adds up over years. EC already handles header pruning (store only recent 1000 + verified merkle root), but this becomes more important with faster blocks. Trade-off is real but not catastrophic - modern phones handle it fine.\"},{\"q\":\"What are the arguments against changing BCH block time to 1 minute?\",\"a\":\"Multiple downsides identified by community: 1) SPV clients need 10x more header storage, 2) Higher orphan rates from network propagation delays, 3) Exchanges just increase confirmation requirements (no real speed gain), 4) Erodes Bitcoin heritage - block rewards no longer comparable to BTC, 5) Makes BCH harder to explain/market, 6) Massive ecosystem retooling required, 7) Doesn't actually solve DeFi MEV problems (bots adapt to faster blocks), 8) Psychological comfort only - first confirmation feels faster but same PoW security. Counter-argument: DeFi benefits from lower variance and faster state updates. Community consensus: Need extensive benchmarking (orphan rates with 32MB blocks at 1-min intervals) before any decision. KISS principle applies - don't change fundamentals without clear overwhelming benefit.\"},{\"q\":\"Why do smart contracts need block confirmations when payments work with zero-conf?\",\"a\":\"Smart contracts can have competing unconfirmed transaction chains in the mempool. Example: AMM DeFi where multiple users interact with same contract UTXO simultaneously. Problem: Until next block, it's uncertain which transaction chain becomes valid. If user builds transaction on 'wrong' unconfirmed chain, their transaction gets cancelled when block confirms different chain. This requires waiting for state reconciliation - average 10 minutes with current block time, outlier cases up to 1.5 hours. Regular payments don't have this issue because they spend from user's own UTXOs with no competition. This is key argument for faster blocks (1-minute) - reduces wait time for DeFi state updates.\"},{\"q\":\"What is BIP-21 vs JPP in payment requests?\",\"a\":\"BIP-21 is URI scheme specification: 'bitcoincash:address?amount=X&label=Y' - simple standardized way to encode payment info in QR codes. JPP (JSON Payment Protocol) is full payment protocol: Interactive exchange between wallet and merchant server returning JSON with payment details, multiple outputs, expiry time, memo, etc. Relationship: BIP-21 URI can include 'r=' parameter pointing to JPP server URL (bitcoincash:?r=https://server/invoice/123). When EC scans such QR: 1) Parses BIP-21 URI, 2) Sees 'r=' parameter, 3) Fetches JSON from that URL using Accept: application/payment-request header, 4) Parses response for outputs array. JPP advantages: Multiple outputs in single payment, merchant can set exact fee rate, expiry times, invoice memos. JPP vs BIP-70: JPP uses JSON instead of protobuf, simpler implementation. Currently EC only accepts JPP from BitPay domain, limiting broader ecosystem adoption of this payment standard.\"},{\"q\":\"What is the difference between BIP-70 and JSON Payment Protocol (JPP)?\",\"a\":\"Both are payment request protocols but use different serialization: BIP-70 uses binary protobuf format, JPP uses JSON. BitPay invented JPP as alternative to BIP-70. Key insight from Tom: 'The wallet decides if they fetch from the server the binary or the json. The server has to do both' (if they want broad compatibility). Same URL can serve different formats based on Accept header in HTTP request. EC sends 'Accept: application/payment-request' to fetch JSON. Advantages of JPP: Easier to debug (human-readable), simpler implementation (no protobuf dependency), modern web-friendly. Advantages of BIP-70: More established, smaller payload size, certificate validation. In practice: BitPay supports both, Paytaca supports JPP only, Flowee Pay supports BIP-70 only. For maximum compatibility, servers should implement both protocols.\"},{\"q\":\"What is the technical reason there's 'no such thing as a from address' in Bitcoin?\",\"a\":\"Inputs reference UTXOs, not addresses - address derivation requires assumptions. Tom warns: 'just want to jump in and remind people that there is no such thing as a from address. It just happens to work in a lot of cases, but if you build software to depend on it, you will feel pain at some point.' Technical reality: Transaction inputs contain: prevout_hash (previous tx ID), prevout_n (output index), scriptSig (unlocking data). No explicit address field. To get 'from address': Must examine previous transaction's output script, parse that script to determine type (P2PKH, P2SH, etc.), hash appropriately to create address. This fails for: Complex contracts with multiple spending paths, P2S scripts (coming next year), coinbase transactions, non-standard scripts. Tom's advice: 'Adding a refund address should be part of a good payment protocol.' For accounting/UX: Address derivation is convenience feature, not protocol requirement. emergent_reasons confirms: 'I think tom is talking about refund addresses, but that's not what I need anyway' - his use case is transaction export for accounting, where addresses are needed for reporting despite protocol limitations.\"},{\"q\":\"What is P2S and why will it change transaction parsing next year?\",\"a\":\"P2S (Pay-to-Script, native script addresses) is upcoming BCH upgrade. Tom: 'Anything that isn't p2pkh or p2sh. Now, granted, today that means those transactions are not standard. But next year you'll see a lot of p2s ones.' emergent_reasons: 'ah. yeah p2s soon. fun times :D' P2S characteristics: Native script outputs (not wrapped in hash), introspection capabilities, VM limits improvements. How it differs: Current P2SH: Output contains hash of script, script revealed at spending time. P2S: Output contains actual script directly. Parsing impact: Even more complex input patterns, different scriptSig structures, new address types. Current heuristics: Won't work at all for P2S inputs. Tom earlier: 'just want to jump in and remind people that there is no such thing as a from address' - becomes more relevant as script diversity increases. Implication: EC's transaction parsing needs modernization. Current approach (heuristic matching) increasingly inadequate. emergent_reasons' export issue is preview of challenges ahead. Solution space: Full input fetching (like PR #3145), better type detection, support for explicit type hints in transaction metadata.\"},{\"q\":\"What makes a P2SH address and how does it map to on-chain data?\",\"a\":\"Calin teaches via Socratic method: 'what does this address instruct software to do when composing a txn paying out to that address? what happens on the lower level like on the txn output level?' Answer: P2SH address = hash of redeem script, encoded with specific prefix. Dustin correctly states: 'A P2SH or P2SH32 address is the hash of the redeem script.' Creating payment: Address decoded → hash extracted → locking script constructed (OP_HASH160 <hash> OP_EQUAL). Spending that payment: Must provide: data satisfying redeem script + redeem script itself. Verification: Node hashes provided redeem script, compares to stored hash, then executes script. Calin: 'how does an address map to... the locking script in an output (scriptPubKey as the Satoshi-derived nodes call it).' Key insight: Address is just encoding of output type + hash. When examining input (spending), you see unlocking data, not locking type. This architectural decision (minimal transaction size) means parsers can't definitively identify input types without external data.\"},{\"q\":\"Why do Bitcoin transactions contain minimal information by design?\",\"a\":\"Space efficiency and trust model. Calin explains architectural decision: 'the reason it's this way -- it's just because txns contain minimal information and require external information to be fully evaluated (such as coins being spent).. so it is what it is.' Alternative considered: 'an alternative design that wasted space would have been to include all the extraneous information in the txn itself but that would be a waste of space since the node needs to have original forms of that information ANYWAY that it trusts.' Trust model: Node must verify against its own chain state, can't trust transaction's self-reported metadata. Example: Transaction says 'I'm spending UTXO X', node must look up UTXO X to verify: Does it exist? What's its locking script? What's its value? Including that info in transaction is redundant - node validates against source-of-truth anyway. Implication for wallets: 'so we are stuck in a reality where all we see is scriptSig and we have to guess what the hell it was originally as an output that is being spent.' This is fundamental blockchain design trade-off: Compact transactions vs self-contained transactions.\"},{\"q\":\"What is Electron Cash Wallet Connect?\",\"a\":\"Electron Cash Wallet Connect is a plugin that allows Electron Cash to connect to decentralized applications (dApps) on Bitcoin Cash. Version 0.02-alpha added support for complex contracts requiring user's public key and signature. It enables signing transactions and messages from web-based dApps directly in your Electron Cash wallet. Future versions will support multi-connection (connecting to multiple dApps simultaneously). The plugin is being actively developed with plans for eventual integration into mainline EC.\"},{\"q\":\"Where is the Cosigner Pool plugin in Electron Cash?\",\"a\":\"The Cosigner Pool is a built-in optional feature, not an external plugin. Find it under Tools > Preferences > Optional Features, not under Plugins. It allows multisig wallet participants to share partially signed transactions through a server. The server is still running (as of Feb 2025) and works for software wallets, but NOT for hardware wallets. Alternative methods for sharing PSBTs: QR codes (Tools > Show QR), raw hex (Ctrl-T to load), or through secure messaging apps.\"},{\"q\":\"What are the best use cases for RPA/stealth addresses?\",\"a\":\"RPA excels in non-interactive payment scenarios: 1) Donations: Public QR code where anyone can send privately, 2) Subscription services: Customer saves one address, tops up anytime without requesting new addresses, 3) Software sales: Single paycode for all buyers - they paste txid to verify payment, 4) Recurring payments: No 'this address expires in 2 hours' warnings, 5) Account top-ups: Services assign one RPA per customer. NOT ideal for: Regular business transactions where buyer/seller interact (just use unique invoice addresses), exchanges (need to track deposits precisely), any scenario requiring sender identification. RPA simplifies backend (no address generation system needed) but adds blockchain scanning overhead.\"},{\"q\":\"How do I create a secure paper wallet with Electron Cash?\",\"a\":\"EC can export individual private keys and QR codes from addresses (right-click address > Get private key). For maximum security: 1) Remove hard drive from laptop, 2) Boot from Linux LiveUSB (use UNetbootin to create it), 3) Download paper wallet generator from trusted source, 4) Generate and print wallet while offline, 5) Turn off computer - all traces vanish since nothing writes to disk. If you must use your normal system, disconnect internet before generating, then completely wipe ALL browser data (cache, history, local storage) afterward. Never generate wallets on smartphones. For the easiest approach, use EC directly: create new wallet from LiveUSB, print seed phrase and receive address QR code, test with small amount before committing larger funds.\"},{\"q\":\"How long is a Double Spend Proof (DSP) relevant for detecting fraud?\",\"a\":\"A DSP is only relevant in the first 3-5 seconds after a transaction is broadcast. After that time window, the transaction has propagated across the network and miners have it in their mempools, making double-spend attempts extremely difficult. This is why BCH's 0-conf is considered safe for retail point-of-sale transactions. EC's DSP plugin (PR #2331) monitors for these proofs in real-time, but for historical transaction views, DSP information isn't particularly meaningful since the attack window has long passed.\"},{\"q\":\"Does Electron Cash desktop already support offline transaction signing like Electrum?\",\"a\":\"Yes, EC desktop fully supports offline transaction signing identical to Electrum. The workflow: 1) Create watch-only wallet on online computer using xpub, 2) Build unsigned transaction, 3) Save transaction (QR code or file), 4) Transfer to offline computer with full wallet (contains private keys), 5) Sign transaction offline, 6) Transfer signed transaction back to online computer, 7) Broadcast. You can manually select specific inputs by right-clicking coins in the Coins tab. This feature has existed in EC desktop 'forever'. The main gap is Android EC cannot save unsigned transactions to files (though it can sign transactions received as QR codes or raw text).\"},{\"q\":\"What are Double Spend Proofs (DSP) and how does EC use them?\",\"a\":\"DSProofs are cryptographic evidence that someone attempted to double-spend a transaction. How they work: When conflicting transactions (spending same UTXO) appear on network, nodes can construct proof using signatures from both. Fulcrum queries nodes for DSPs and provides them to wallets on request. EC can display DSP alerts for incoming transactions. Current status: Implementation exists but adoption is limited - most merchants don't see fraud because it's rare with first-seen rule. Practical value: Improves 0-conf reliability by detecting attacks in near real-time. Services like SideShift use DSPs. Not perfect security (probabilistic system), but adds valuable safety layer for unconfirmed transactions.\"},{\"q\":\"Why might hardware wallets be riskier than software wallets?\",\"a\":\"Supply chain attack risks: 1) Wallets intercepted and modified during shipping, 2) Retail distribution tampering (resealed devices with compromised firmware), 3) Trust in manufacturer's security practices, 4) Physical device can be counterfeited. Real cases: $6.9M stolen from pre-compromised hardware wallets sold on TikTok - seeds were known to attackers before buyers received devices. Additional concerns: Proprietary closed-source firmware in many devices, limited ability to verify hardware hasn't been modified. Alternative: Software wallets on airgapped devices you control (old laptop running Linux offline), or EC's offline signing workflow with your own hardware. Key principle: You're trusting multiple parties in hardware wallet supply chain vs. verifiable open-source software.\"},{\"q\":\"How does zero-conf security work with first-seen rule?\",\"a\":\"First-seen rule: Full nodes accept first valid transaction spending a UTXO and reject subsequent attempts. Network propagation ensures most nodes have same 'first' transaction. Why it's secure: 1) Miners generally follow first-seen (they receive transactions from honest nodes), 2) DSProofs alert recipients if double-spend attempted, 3) Merchants running nodes can verify their transaction propagated widely. Important insight: Security improves with adoption - more merchants running nodes means more enforcement of first-seen rule. Volunteers and merchants have strong incentive to maintain rule. Not perfect (probabilistic system), but practical security is high for typical retail transactions. Critical: Works only for standard transactions - anyone-can-spend scripts or complex DeFi operations may not be eligible.\"},{\"q\":\"What's the difference between dumb NFC cards and smart cards for crypto storage?\",\"a\":\"Two very different security models: 1) Dumb NFC cards: Just hold data (your seed phrase). No code, can't sign transactions, simply store information. The wallet software reads the seed phrase to derive keys. 2) Smart cards (Tangem, etc.): Have embedded firmware that signs transactions. Keys never leave the card - you tap the card to authorize each transaction. Important distinction: Dumb cards require wallet software to handle signing (keys in memory briefly), while smart cards do signing on-device but require trusting embedded firmware. Neither eliminates need for trusted software somewhere - it just moves the trust boundary. Some prefer dumb cards because less attack surface (no executable code on card).\"},{\"q\":\"Why is Windows particularly dangerous for cryptocurrency wallets?\",\"a\":\"Multiple serious concerns: 1) Windows 11 Recall feature takes periodic screenshots of everything on screen - could capture seed phrases when wallet displays them, 2) Even if disabled, feature can be re-enabled via updates without user consent, 3) Telemetry sends data to Microsoft servers, 4) Closed-source OS means you can't verify what's running, 5) Historically most-targeted OS for malware. EC has no special protection against screenshot capture. Alternative: Use Linux (open source, verifiable) or at minimum macOS. For crypto security: Keep bulk of funds on dedicated device (old phone, offline laptop) not your daily Windows machine. Community consensus: 'Don't use Windows' is foundational crypto security advice.\"},{\"q\":\"How do GitHub phishing attacks target cryptocurrency developers?\",\"a\":\"Sophisticated phishing campaign observed in September 2025: Emails appear to come from legitimate github.com mail servers (pass SPF/DKIM) but contain links to phishing domains. Attack vector: Attacker creates GitHub issue mentioning @username, GitHub sends notification email, link in email points to malicious site. Targets: Specifically cryptocurrency developers who maintain wallet/blockchain repositories. Protection: 1) U2F/FIDO2 security keys - won't authenticate to wrong domain, 2) Password manager autofill - only fills credentials for correct domain, 3) Never click links in emails - navigate directly to github.com, 4) Check domain carefully before entering credentials. GitHub removes malicious repos quickly but notification emails persist. EchterAgo: 'good reason to have a U2F key registered and only use your password managers autofill, both will prevent phishing domains.' This is targeted attack on crypto ecosystem's most valuable assets - developer credentials.\"},{\"q\":\"What GitHub Actions security risks should open source projects watch for?\",\"a\":\"PRs adding GitHub Actions can introduce supply chain vulnerabilities. Алексей warns: 'there are some github actions vulnerabilities where they get ability to publish if you don't restrict access to publishing scope only to some workflows.' Specific concerns with suspicious PR: Added new workflow files, uses external actions from unknown sources, could potentially gain write access to repo. Jonas explains: 'If you open a pull request it is executed on the source repo' - PR code runs with elevated privileges. Best practices: 1) Be vigilant on GHA especially 'pull_request_target' trigger (has write access), 2) Review all workflow additions carefully, 3) Restrict publishing scope to specific workflows, 4) Don't blindly trust 'copied from Electrum' claims. Calin's response: 'Idk I feel like closing this esp since it has unneeded GitHub actions.' Jonas: 'I don't see the issue with this GHA' but acknowledges: 'it's good to vigilante on GHA.' Even legitimate automation tools (fastlane) need scrutiny when added by unknown contributors.\"},{\"q\":\"Why would hashing arbitrary scriptSig pushes as P2SH addresses be dangerous?\",\"a\":\"Could generate nonsense addresses that appear valid. Dustin's draft PR #3148 attempts: Hash last push as P2SH20 address. Calin identifies flaw: 'your current hack has the following properties: if the thing is actually a p2sh20, it will match p2sh20 perfectly... if the thing is anything but a p2sh20 (such as p2sh32, p2pk, p2pkh), it will incorrectly think it's p2sh20 and return a nonsense address.' Dustin's concern: 'My fear is if it's an unbroadcast transaction that is re-serialized and pays to somewhere else because the wrong address was returned during deserialization.' Calin confirms: 'yes. and you will thus get a nonsense p2sh address that doesn't correspond to what is useful to anybody.' Real danger: Software might use incorrect address for accounting, refunds, or transaction construction. Dustin accepts: 'Ok, good, my gut was right, it would be a terrible idea. Thank you for confirming.' Lesson: Better to return 'unknown' than wrong answer. Incorrect data worse than missing data for security-critical applications.\"},{\"q\":\"What does trustless mean in cryptocurrency wallet context?\",\"a\":\"Verifying information yourself rather than trusting third parties. Andy's explanation when asked: 'That means the wallet doesn't require you to trust any servers.' Levels of trust in EC: 1) SOFTWARE TRUST: EC open source, code auditable, reproducible builds - you can verify binary matches source. 2) SERVER TRUST: Most users connect to public Fulcrum servers - trust servers report correct blockchain data. 3) NETWORK TRUST: SPV (Simplified Payment Verification) trusts that longest chain is valid. Full trustless: Run BCHN full node (validates all rules), connect EC to your Fulcrum server (controls your data), verify transaction history yourself. Why matters: Servers could theoretically hide deposits, misreport balances, refuse broadcasts. Your own infrastructure can't lie to you. Most users accept server trust as reasonable (servers are public, reputational risk to lie), but high-value storage warrants own infrastructure. Progressive trust model: Start with public servers, graduate to own infrastructure as needs grow. This is core Bitcoin principle: Don't trust, verify.\"},{\"q\":\"Can you reverse or cancel an unconfirmed BCH transaction?\",\"a\":\"No, once broadcast transactions cannot be reversed by anyone. User asks: 'Can someone reverse or stop a transaction?? It hasn't confirmed yet.' Blockchain fundamentals: 1) Once transaction is broadcast to network, it propagates to all nodes, 2) No central authority can cancel it, 3) Recipient controls funds once transaction is valid, 4) Even unconfirmed transactions are typically irreversible. Exception: Double-spend attempt possible but unreliable (need to broadcast conflicting transaction quickly with higher fee, most merchants wait for confirmation). BCH specific: 10-minute block times mean short wait for confirmation, 0-conf transactions considered reliable for small amounts due to first-seen-safe miner policies. Prevention better than cure: Always triple-check recipient address before sending. User resolved issue: 'Never mind all sorted out' - likely realized address was correct. This is feature not bug: Censorship resistance means no reversals, but also means no one can stop legitimate transactions.\"},{\"q\":\"How can you derive P2SH address from redeem script if you have it?\",\"a\":\"Hash the redeem script and encode appropriately. Dustin: 'I can plug both redeem scripts into my little address generation script and get the right address for both of them, but at that point, I'm not using heuristics.' Calin confirms: 'yeah if you know for SURE it's a redeemScript as your last push.. then yeah hash it and voila! correct address.' Process: 1) Extract last push from scriptSig (this is redeem script in P2SH), 2) For P2SH20: HASH160(redeemScript) → 20 bytes, 3) For P2SH32: SHA256(redeemScript) → 32 bytes, 4) Encode with Cash Address format. Challenge: 'but the general purpose transaction parser has no way of knowing that for sure... unless... it can examine the locking script of previous txn.' Can't assume last push is always redeem script - could be P2PKH signature followed by pubkey, or other patterns. Dustin: 'I can derive the address from that script (though I was wrong about using bitcash, I used cryptos).' Python libraries like cryptos or EC's own Address class can handle encoding. Key insight: If you control the script and know it's P2SH, address derivation is trivial. General-purpose parsers can't make that assumption.\"},{\"q\":\"How do I send the maximum amount from a specific coin in Electron Cash?\",\"a\":\"After right-clicking a coin and selecting 'Send', click the 'Max' button on the Send tab. The amount field is intentionally left blank because you can multi-select coins and don't have to send the full amount. The Max button calculates the coin value minus fees automatically. Note: The Max button may be greyed out until you enter a destination address first.\"},{\"q\":\"Does the inter-wallet-transfer plugin respect frozen/locked addresses?\",\"a\":\"Yes, the inter-wallet-transfer plugin respects frozen addresses. When you freeze an address or coin in Electron Cash, the plugin will not include those in the transfer operation. This is useful when you want to migrate most of a wallet but keep certain UTXOs or addresses in place (e.g., unfused coins you don't want to move). Always test on a small wallet first to verify this behavior.\"},{\"q\":\"How do I sweep/import a paper wallet back into Electron Cash?\",\"a\":\"Electron Cash can import individual private keys from paper wallets. Go to Wallet menu > Private Keys > Sweep or Import. Enter the private key from your paper wallet. Note: Once you enter the private key on your computer, that secret is exposed to your possibly-infected system. For practice, always test with small amounts first: create paper wallet, send test amount, verify arrival, import/sweep it back to ensure the full cycle works before storing significant funds.\"},{\"q\":\"How do I transfer partially signed transactions between multisig cosigners?\",\"a\":\"Several methods: 1) Cosigner Pool - built-in feature that passes transactions through server (enable in Optional Features), 2) QR codes - display QR of partial transaction for other party to scan (may be too large for complex transactions), 3) Raw hex - use Ctrl-T to load transaction from hex string, paste in messenger (easier for remote parties), 4) File export - save transaction to file and send to cosigner. For remote users, raw hex through secure messenger is often easiest. Note: Cosigner Pool doesn't work with hardware wallets.\"},{\"q\":\"What is the difference between Bits and Sats in Electron Cash?\",\"a\":\"1 Bit = 100 Satoshis. Bits are a larger denomination than sats. In EC preferences (Tools > Preferences > General), you can choose your preferred unit: BCH (1.0), mBCH (0.001), bits (0.000001), or sats (0.00000001). Bits are sometimes called 'microbitcoin' or μBCH. The conversion: 1 BCH = 1,000,000 bits = 100,000,000 sats. Many users prefer bits for everyday transactions as the numbers are more manageable than sats.\"},{\"q\":\"Can I connect my Electron Cash wallet to my bank account?\",\"a\":\"No, EC cannot connect directly to bank accounts. It's a Bitcoin Cash wallet, not a banking application. To convert BCH to fiat currency: 1) Send BCH to a cryptocurrency exchange that supports BCH and fiat withdrawals (like Kraken, Coinbase, etc.), 2) Sell BCH for fiat on the exchange, 3) Withdraw fiat to your bank account. To find exchanges: visit https://minisatoshi.cash/ecosystem and search for exchanges. There's no 'wallet connection' - you simply send BCH to the exchange's deposit address.\"},{\"q\":\"Why does Electron Cash show clock icons up to 6 confirmations instead of just 1?\",\"a\":\"This is inherited tradition from Bitcoin Core/Electrum. In early Bitcoin, exchanges required 6 confirmations for deposits (roughly 1 hour at 10 min/block). The convention became deeply ingrained - 6 confs provided sufficient security against double-spends and reorgs. While BCH has instant/0-conf for point-of-sale transactions thanks to DSP, the 6-conf display remains as legacy indicator. The clock faces filling up gives visual feedback of increasing security. EC is intentionally 'retro' in some UI aspects.\"},{\"q\":\"Why doesn't Electron Cash Android support creating raw transactions for cold storage workflows?\",\"a\":\"EC Android has limited cold wallet functionality compared to desktop: 1) It CAN sign transactions received via QR code or raw text on offline device, 2) It CANNOT save unsigned transactions to files like Electrum Android can, 3) Screen size constraints make full feature parity with desktop infeasible. Workaround: Use EC desktop (watch-only wallet) to create and save unsigned transactions, then sign them on Android offline device. The feature gap exists because: mobile development resources are limited, and the codebase diverged from Electrum about 7 years ago (an eternity in software development), making porting features non-trivial.\"},{\"q\":\"Why doesn't EC show 'first seen' time for transactions instead of mined time?\",\"a\":\"EC currently shows mined timestamp (block time) for confirmed transactions. Request: Show when your wallet first saw the transaction instead, emphasizing zero-conf capability. Challenges: 1) 'First seen by who?' - your wallet's timestamp vs Fulcrum server's timestamp, 2) If wallet offline when tx arrives, first-seen would be when wallet syncs (misleading), 3) Multiple transactions mined in same block get identical timestamps, making ordering unclear (CTOR makes it worse). Proposed solution: Use local wallet timestamp for transactions seen while wallet running, fall back to block time for transactions discovered after confirmation. This emphasizes BCH's instant transaction capability while remaining accurate. Not currently implemented in EC but suggested as UX improvement.\"},{\"q\":\"How do I sweep or import private keys (WIF) in Electron Cash?\",\"a\":\"Two methods depending on your goal: 1) Sweep (move funds to current wallet): Wallet menu -> Private Keys -> Sweep. Enter WIF, EC creates transaction moving all funds from that address to your wallet. You can scan WIF from QR code. After sweep, original address is empty. 2) Import (add address to wallet): File -> New/Restore -> 'Import Private Keys' option. Creates wallet containing that specific private key. Address becomes part of your wallet. Use sweep when: you want funds consolidated into existing HD wallet. Use import when: you need to control specific address directly. QR scanning works for both - EC has QR button in relevant dialogs. Proposed enhancement: Support for 'bch-wif:' protocol handler for easier integration with services like stamps.cash.\"},{\"q\":\"What is the cosigner pool feature in Electron Cash?\",\"a\":\"Cosigner pool is EC's multi-signature coordination feature for 2-of-2 or m-of-n wallets. Use case: User wants OTP (one-time password) as second factor for transactions. Flow: 1) User creates partially signed transaction in EC, 2) Exports to JSON file, 3) Uploads to server/cosigner service, 4) After OTP verification, service adds its signature, 5) Broadcasts fully signed transaction. Security benefit: Even if main computer is compromised, attacker needs OTP device too. JF notes feature exists but 'not widely used or maintained.' Alternatives discussed: User's smartphone could cosign directly (becomes 2-of-2 multisig with phone), or use sign/verify message feature for authentication. Challenge: Requires external infrastructure (server running cosigning service) and workflow is manual (export/upload/verify). True 2FA for crypto is 'something you have' twice (wallet + OTP device) but adds useful separation of compromise surfaces.\"},{\"q\":\"Can you receive BCH with a watch-only wallet on Android EC app?\",\"a\":\"Yes, but with workaround needed due to UX limitation. User Henrique: 'when I click the receive button it appears This is a watch-only wallet message.' Jonas confirms bug/limitation: 'I can confirm that it does not work to just hit the request button and the wallet will complain that it's watch only.' Workaround: 'You can however go to the Assets tab and choose Addresses with Type: Receiving and Status: Unused to get a QR code to an address.' Background: pat explains watch-only purpose: 'many automated services use this to monitor the payment addresses (associated with cold wallets for example) to credit funds or release goods to buyer.' JF warns about scam vector: 'its a likely scam, people give people a wallet' - receiving to someone else's wallet is losing funds. Key distinction: Watch-only wallets CAN receive funds (blockchain doesn't care), but you CANNOT spend without private key. Android app's Request button just has unnecessarily restrictive UX that blocks QR generation.\"}]},{\"name\":\"Hardware Wallets\",\"count\":15,\"faqs\":[{\"q\":\"My KeepKey hardware wallet is not detected by Electron Cash - is there a fix?\",\"a\":\"Yes, KeepKey detection has been fixed in EC's git master branch (as of April 2025) but isn't yet in an official release. Workarounds: 1) Use a pre-release build from https://ec.loping.net/ signed by ichundes (EC developer), 2) Wait for EC 4.4.3 or later official release, 3) Run EC from source using master branch. The issue affected Windows 11 particularly. Check GitHub issue #2995 for details. Always verify GPG signatures of any pre-release builds before using.\"},{\"q\":\"Does Electron Cash mobile support hardware wallet connections?\",\"a\":\"Currently, no. Hardware wallet support exists only in EC desktop (KeepKey, Trezor, Ledger, Satochip). Mobile hardware wallet integration faces challenges: 1) iOS restricts USB connections and would require air-gap or Bluetooth, 2) Android could potentially use USB OTG but implementation is complex, 3) Development resources are limited, 4) Each hardware wallet has different connection protocols. Users requesting this feature should: submit feature request on GitHub, understand it's a significant development effort, and for now use EC desktop for hardware wallet management. Some users manage hardware wallets on desktop and use mobile only for spending from hot wallets.\"},{\"q\":\"Does Ledger work with Electron Cash after firmware updates?\",\"a\":\"Frequently breaks. Ledger updates firmware regularly and often breaks compatibility with third-party wallet software like EC. Recent reports: Latest Ledger Nano X firmware incompatible with EC. Root cause: Ledger changes APIs/protocols without coordinating with external wallet developers. Community response: Stop using Ledger. EC developers don't own Ledgers and don't test compatibility - they support what's reported working. Alternatives: Trezor (more open source), OneKey, or abandon hardware wallets entirely for GrapheneOS phone or offline laptop. Ledger's closed-source firmware and frequent breaking changes make it unreliable for non-Ledger-Live software.\"},{\"q\":\"Should Ledger work with EC on macOS and what causes detection failures?\",\"a\":\"Should work but has known issues. User T reports: 'my ledger is never detected while ledger live works well... I tried with nano s and nano x.' Common causes: 1) Ledger Live app holding exclusive device access - close it completely before using EC, 2) macOS USB permissions - EC may not have device access, 3) Browser extension conflicts, 4) Outdated EC version incompatible with newer Ledger firmware. Troubleshooting steps: Close Ledger Live completely (check Activity Monitor), try different USB port, ensure EC has USB access in macOS System Preferences, update EC to latest version. Note: Ledger Live uses WebUSB which can conflict with EC's direct USB library (hidapi). On macOS specifically, USB device access permissions more restrictive than Linux. If still failing: Check EC verbose output for USB enumeration errors, try running EC from terminal to see connection attempts. Hardware wallet support is plugin-based in EC, ensure plugin is enabled in Tools > Plugins menu.\"},{\"q\":\"Why is the Electron Cash iOS app experiencing bugs on newer iPhones?\",\"a\":\"The iOS app hasn't been updated in approximately 3 years. Issues reported: FaceID setting doesn't persist (resets on app restart) on iPhone 15 Pro with iOS 17.7.2. Root causes: 1) iOS API changes over three years not reflected in app, 2) Apple's walled garden makes updates difficult (requires Mac hardware, paid developer account), 3) Limited iOS development resources in EC community. Workarounds: try PIN-only authentication, update to latest iOS version (may fix compatibility), or use alternative wallets. One developer attempted to build from Hackintosh VM but Apple's server detected non-authentic hardware. The iOS ecosystem's closed nature is a significant barrier to open source wallet development.\"},{\"q\":\"What are the security risks with offline wallet generation that most people don't consider?\",\"a\":\"Beyond hard drive isolation, consider: 1) BIOS/firmware malware can persist even without hard drive and steal keystrokes, 2) LiveCD images can auto-connect to unsecured WiFi, 3) Malicious USB sticks may contain firmware exploits that survive reformatting (processor managing NAND chip can be hacked), 4) Hardware keyloggers on keyboard ports. These are called 'Evil Maid Attacks'. Best practice: dedicate a machine to permanent offline duty, only use new USB sticks from trusted sources, and ideally disable/remove WiFi hardware physically.\"},{\"q\":\"Should I use Windows for storing cryptocurrency?\",\"a\":\"Security experts in the BCH community strongly recommend against using Windows for significant crypto holdings. Windows has more attack surface, telemetry, update issues, and security vulnerabilities. Linux provides better security through: open source verification, minimal bloat, better update model, stronger permission system. If you must use Windows: keep minimal funds in hot wallet, use hardware wallet, keep system fully updated, use dedicated machine. Consider Linux via dual-boot or Live USB for crypto operations. As community member says: 'don't expect your money to stay safe on Windows for long'.\"},{\"q\":\"Why are hardware wallet firmware updates a security concern?\",\"a\":\"Several issues: 1) Continuous updates required - defeats purpose of 'cold' storage (must go online to update), 2) Each update is potential attack vector - one malicious update could steal funds, 3) Closed-source firmware common - you can't verify what code is running, 4) Driver updates also needed - more moving parts with trust requirements. Community perspective: 'If I have to continuously update firmware, it's not really cold storage anymore.' Alternative approach: Software wallet on device you control, with verifiable open-source code. Paper or steel backups are truly cold (no code to update). BTC-only firmware helps but still requires updates. Complex multi-coin firmware is highest risk due to large attack surface.\"},{\"q\":\"Why is open source vs closed source more important than hardware vs software for security?\",\"a\":\"Expert perspective from long-time engineers: Open source allows verification - you can read code, audit for backdoors, understand exactly what happens. Closed source requires trust in unknown parties. Hardware wallet problem: Even if open source, hardware is hard to verify (is this the actual firmware? was it modified in shipping?). Software on general-purpose hardware: Easier to verify - you can hash binaries, compile from source, audit changes. Trezor issues: Not hardware itself, but software complexity from supporting many altcoins. Large codebase = more bugs, harder to audit, more attack surface. Recommendation: Simple open-source software (EC) on hardware you control (de-googled phone, airgapped laptop) often provides better security model than complex proprietary hardware wallet.\"},{\"q\":\"What specific incident caused people to lose trust in Ledger hardware wallets?\",\"a\":\"Ledger released firmware update that added 'Recover' feature - ability to backup private keys to cloud. This fundamentally violated core hardware wallet promise: 'keys never leave device.' Community outrage: 1) Feature contradicts entire security model users bought into, 2) If firmware CAN export keys, malicious update could steal them, 3) Closed-source firmware means users can't verify code, 4) Trust in 'cold storage' destroyed when device can go online. Lesson: Hardware wallet security depends on trusting company not to break promises via firmware updates. This is why many BCH developers now recommend: open-source software wallets on offline devices you control (GrapheneOS phone, de-googled Android, airgapped laptop).\"},{\"q\":\"Why do some community members prefer seed phrase backups over hardware wallets?\",\"a\":\"Plausible deniability argument: Hardware wallets are physical objects that reveal you own cryptocurrency. If police/authorities/thieves find your Ledger/Trezor, they know you have crypto - even if they can't access it, they can seize it or use '$5 wrench attack' (physical coercion). Alternative: Seed phrase carved/written in hidden location (under floorboard, in wall, encrypted on USB). Benefits: 1) Nobody knows you own crypto unless they find the hidden backup, 2) Recovery requires only Linux LiveCD + EC, 3) No firmware updates to trust, 4) No supply chain attack risk. Encoding options: Convert 12 words to hex/binary before writing, encrypt with additional password. Trade-off: Requires more technical knowledge and secure storage location.\"},{\"q\":\"What are secure ways to backup seed phrases without hardware wallets?\",\"a\":\"Multiple approaches discussed by community: 1) Titanium/steel plate engraved with words (fire/water resistant), cement in wall, 2) KeePass encrypted database with strong password, distribute file copies to multiple locations (USB drives, trusted cloud storage in password-protected zip), 3) Paper/DVD with words encrypted using additional passphrase, 4) Convert words to binary/hex/decimal before physical storage for extra obfuscation, 5) Multiple geographic locations for redundancy (if house burns, have backup elsewhere). Key insight: Threat model matters - protect against fire/flood (multiple copies), theft (encryption/hiding), government seizure (plausible deniability). No single solution fits all - evaluate your specific risks.\"},{\"q\":\"Can open source hardware wallet chips still have backdoors?\",\"a\":\"Yes, significant concern even with 'open source' hardware: 1) You can't manufacture chips yourself - must buy from supplier, 2) Even if design is open source, how do you verify YOUR specific chip follows that design?, 3) Government can order manufacturer to add backdoors under NDA (you'll never know), 4) Secure element chips with tamper-resistance are black boxes by design. JF's insight: 'if you're relying on hardware, for all intents and purposes you are trusting the device.' Mitigation: Use generic hardware (old phone, laptop) running verified open source software - easier to audit software than hardware. Trust moves from chip manufacturer to software developers whose code you can inspect.\"},{\"q\":\"Why is code complexity the enemy of security in cryptocurrency wallets?\",\"a\":\"Expert insight from community: Every line of code is potential attack surface. Problems compound with: 1) GitHub repositories grow massive - who reviews all code plus dependencies?, 2) Compilers and build tools themselves could be compromised (compilation trust chain), 3) Multi-coin support in hardware wallets exploded firmware complexity, 4) More features = more bugs, harder audits, larger attack surface. Recommendation: Prefer simpler wallets focused on fewer chains (BCH-only firmware on Trezor safer than multi-coin). EC benefits from being specialized for BCH rather than supporting every cryptocurrency. Complexity enables monetization (supporting shitcoins makes money) but undermines security. Simple tools with focused functionality are easier to verify and trust.\"},{\"q\":\"Why does SLIP-39 lack full wallet support and what limitations exist?\",\"a\":\"Specification incomplete and implementation partial. eloyesp asks: 'is there a reason it had not been added?' JF answers: 'The only real problem here is that Electrum only does partial implementation. You can restore a SLIP39 seed but you can't actually create a new wallet with one, if im remembering right.' Tom identifies deeper issues: 'But I think the slip itself is a nice but unfinished design. It lacking a derivation path, for example is interesting.' SLIP-39 defines seed splitting (Shamir's Secret Sharing), not wallet structure. Usage concern: eloyesp: 'My main doubt, is if it would make sense to use it, given the lack of support.' JF: 'its advanced and niche... so it would be low hanging fruit to do just do what electrum did.' Workaround: SeedCash hardware wallet supports SLIP-39 natively. Martí: 'You can create a SLIP-39 BCH wallet using SeedCash and then export the xpub to electron cash.' Hardware generates seed, EC uses watch-only wallet from xpub. Tom's vision: NFC tags storing shares for physical seed recovery.\"}]},{\"name\":\"Plugins & Extensions\",\"count\":2,\"faqs\":[{\"q\":\"Why does Electron Cash reject JPP (JSON Payment Protocol) invoices from Paytaca?\",\"a\":\"EC's JPP support is hardcoded to only accept payment requests from bitpay.com domain. When scanning QR code with bitcoincash:?r= payment URL pointing to watchtower.cash (Paytaca's payment processor), EC returns error: 'payment URL not pointing to a bitcoincash payment request handling server'. Technical details: EC successfully fetches the JSON payment request (returns valid response with payment_id, outputs, amounts, addresses, expiry time), but domain whitelist check fails. Jonas confirms: 'Only for paymentrequests from bitpay.com'. Impact: Merchants using Paytaca's WooCommerce plugin can't accept payments from EC users. Workaround: Use Paytaca wallet instead, or merchant provides plain address QR code. Fix needed: Expand EC's JPP domain whitelist to include other payment processors, or remove domain restriction entirely (security trade-off). This exemplifies tension between security (restricting to known providers) and ecosystem openness (supporting all JPP servers).\"},{\"q\":\"Where can I find the Double Spend Proof (DSP) plugin for Electron Cash?\",\"a\":\"The DSP plugin is available as a GitHub pull request (PR #2331: https://github.com/Electron-Cash/Electron-Cash/pull/2331). It's not yet merged into the main release. To use it, you need to either: 1) Run from the specific PR branch, or 2) Wait for it to be merged and released officially. The plugin enables double-spend proof detection in EC. Status as of Feb 2025: waiting for code review from maintainers. Report any issues in the PR comments or the EC Telegram group.\"}]},{\"name\":\"Security & Recovery\",\"count\":16,\"faqs\":[{\"q\":\"What happened to the official Electron Cash Twitter/X account?\",\"a\":\"The @electroncash X/Twitter account was lost due to dormancy lockout - X/Twitter wouldn't allow login after a period of inactivity. The account has ~2k followers but no one can access it. Recovery attempts are being made with X support, but success is uncertain. In the meantime, the EC community needs volunteers to manage social media if the account is recovered or if a new one is created. The handle and existing followers make recovery valuable, but X support is difficult to reach.\"},{\"q\":\"Who are the current Electron Cash maintainers with GitHub merge privileges?\",\"a\":\"As of February 2025, only two people have GitHub merge privileges: Calin Culianu (cculianu) and JF (Jf010). The project is open to more contributors joining with merge access. For social media accounts, Twitter/X accounts can be delegated without sharing passwords. The team follows a trust-based model where social media managers should be accountable and transparent about their identity. Anyone wanting to contribute code should submit pull requests which will be reviewed by these maintainers.\"},{\"q\":\"Why doesn't Google banning custodial wallets affect Electron Cash?\",\"a\":\"Google's crypto wallet licensing requirements target custodial services (exchanges, services holding user funds) not non-custodial wallets (user controls keys). Key distinction: EC is non-custodial - your keys stay on device, EC never controls your funds. Custodial services need licensing because they operate as financial institutions. This is actually positive: 1) Forces users/regulators to understand custodial vs non-custodial difference, 2) May cause exchanges to be labeled differently than wallets, 3) Highlights that EC is true self-custody. However, community remains vigilant - Google could still change policies. Alternative distribution (F-Droid, direct APK) remains important backup.\"},{\"q\":\"Why do JPP (JSON Payment Protocol) invoices from Paytaca fail in wallets?\",\"a\":\"URL encoding issue: QR code contains URL-encoded characters (%3A instead of :) that some servers don't properly decode. Kallisti (Paytaca dev): 'The %3A instead of : is throwing it off. We need to properly decode URLs in that format. Bug is on our end.' Additionally, EC's JPP implementation only accepts payment requests from bitpay.com domain (hardcoded security check). Jonas points to paymentrequest.py line 95 - when JPP was implemented, only BitPay used it. Even valid JPP responses fail EC's domain whitelist. Flowee Pay uses BIP-70 binary protocol, not JSON, and also has issues. Solution requires: 1) Server properly handling URL encoding, 2) EC expanding domain whitelist or removing restriction. BIP-70 (protobuf binary) vs JPP (JSON) both serve same purpose but different formats - BitPay invented JPP but servers should support both for broad wallet compatibility.\"},{\"q\":\"What is the difference between tmpfs and ramfs for Linux filesystem use?\",\"a\":\"Critical difference for performance-sensitive applications: tmpfs can swap to disk, ramfs cannot. Shadow clarifies: 'Yes, you should not use tmpfs as ramdisks, it swaps to swap.' Usage: tmpfs is mounted to /tmp by default on many distros - files there may end up on disk swap under memory pressure. ramfs ('mount -t ramfs') stays strictly in RAM but has no size limit (can OOM). Josh uses tmpfs for Portage compilation: 'I use a tmpfs for my portage compilation to keep that in Ram. I think I'd need to convert it to A RAM disk to avoid it being swapped out.' For crypto operations where you want guaranteed RAM (like during signing), ramfs ensures data never touches disk. For general use where overflow is acceptable, tmpfs is safer (size-limited). Swap encryption helps either way - if swapfile on encrypted partition, swapped data remains encrypted. Best practice for EC: Run on system with adequate RAM, use ZSWAP to optimize, don't worry about filesystem type unless extreme security requirements.\"},{\"q\":\"What is BCH's rolling checkpoint and how does it work?\",\"a\":\"BCH's rolling checkpoint prevents deep reorganizations. The rule: 10 confirmations OR 2 hours, whichever is LONGER. This means: 1) If blocks are mined quickly (high hashrate), must still wait 2 hours for finality, 2) If blocks are slow, need minimum 10 confirmations. This prevents scenarios where hashrate spikes cause rapid block production followed by reorgs. You could theoretically reorg 100 blocks if they were all mined in under 120 minutes (unlikely but mathematically possible). The 2-hour minimum provides temporal security independent of confirmation count.\"},{\"q\":\"What seed phrase lengths are supported in Electron Cash?\",\"a\":\"EC supports BIP39 seed phrases of 12, 15, 18, or 24 words on desktop. Mobile version only supports 12 words currently. BIP39 doesn't define anything longer than 24 words, and longer would be pointless since 24 words already provide 256 bits of entropy (more than sufficient security). You can also add an optional passphrase to any BIP39 seed, though this is not recommended because there's no checksum - if you mistype it or forget it, recovery becomes extremely difficult.\"},{\"q\":\"How do I verify my Electron Cash download is authentic?\",\"a\":\"Always verify downloads using GPG signatures or at minimum, checksums. Download GPG public keys for developers (jonald2 and Calin) from https://github.com/Electron-Cash/keys-n-hashes/tree/master/pubkeys. Import these keys into your GPG keychain, then verify the signature file against your download. This confirms the binary wasn't tampered with. Even if downloading from electroncash.org directly, verification is recommended security practice.\"},{\"q\":\"Does Electron Cash support BIP38 encrypted paper wallets?\",\"a\":\"Yes, EC supports BIP38 encrypted private keys. To sweep: 1) Go to Wallet > Private keys > Sweep, 2) Enter the BIP38 encrypted private key (starts with '6P'), 3) EC will prompt for the password to decrypt it. BIP38 adds a password layer to private keys for secure paper wallet storage. If you created a BIP38 paper wallet, you'll need both the encrypted private key and the password you set during creation. Desktop EC fully supports this feature.\"},{\"q\":\"What is the difference between BIP38 and CashStamps for paper wallets?\",\"a\":\"BIP38 encrypts the private key (WIF) with a password - you need both the encrypted key and password to sweep. EC supports BIP38 sweep (it prompts for password). CashStamps uses a simpler approach: it just presents the plain WIF for sweeping without encryption. This 'dumb' approach was deliberately chosen to make it easier for wallets to support. Few wallets besides EC support BIP38 encrypted keys. Both methods work for paper wallets, but BIP38 provides an extra security layer if the paper is physically compromised.\"},{\"q\":\"How do I verify I downloaded legitimate Electron Cash and not malware?\",\"a\":\"Critical security step: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values on website, 3) Don't trust unofficial sources, app stores, or DMs sharing download links. Red flags that indicate malware: suspicious binary strings in GUI, app requesting unusual permissions, unexpected network connections, different file hash than official. Real example from chat: User showed EC with suspicious binary appearing in interface - community immediately identified as malware, advised to delete immediately and redownload from official source. Never type seed phrase into compromised software - malware steals seeds instantly. When in doubt, verify signatures or ask in official channels before using.\"},{\"q\":\"Is Electron Cash affected by npm supply chain attacks or infected JavaScript dependencies?\",\"a\":\"No, EC is completely unaffected by npm/JavaScript vulnerabilities because it's written in Python, not JavaScript. Recent attacks targeting crypto wallets through infected npm packages (which replace deposit addresses with attacker addresses) only affect web apps and JavaScript-based wallets. EC's security measures: 1) External Python packages are audited daily via automated GitHub Actions, 2) During builds, developers check GPG signatures of dependencies, 3) No JS code means no npm dependency chain. Jonas: 'No js code in EC. External packages used are audited daily.' Additionally, Python ecosystem typically has fewer external dependencies than JavaScript projects, reducing supply chain attack surface. This is one advantage of EC using native Python over Electron/JavaScript frameworks (despite the confusing name, Electron Cash is not built with Electron.js).\"},{\"q\":\"Why is the number of dependencies more important than programming language for wallet security?\",\"a\":\"Programming language alone doesn't determine security - the cumulative number of external dependencies is more indicative of supply chain risk. Example: Flowee Pay uses Java (Android integration), JavaScript (UI), and C++ (core logic) - multiple languages but controlled dependencies. Contrast with typical JavaScript apps that pull hundreds of npm packages. Python (EC's language) has same 'fetch dependencies before build' model as JavaScript, but Python projects typically have substantially fewer dependencies. More dependencies = more attack surface, more code to audit, more potential for malicious insertions. EC benefits from: focused functionality (BCH-only), mature Python ecosystem with better package vetting, and manual signature verification during builds. The recent npm supply chain attack affected wallets not because of JavaScript per se, but because those wallets pulled in compromised packages deep in their dependency tree.\"},{\"q\":\"What are the security concerns with unknown developers submitting EC to F-Droid?\",\"a\":\"Major supply chain risk. Unknown developer submitted fastlane PR (#3137) and F-Droid build without prior engagement with EC team. Calin: 'So weird.. out of nowhere some dude using Arabic script for a name does some stuff.' Mathieu G warns: 'i think there's a pretty large chance the person will try to scam people and steal their funds if they are not known.' Concerns: 1) Developer could modify source before F-Droid build, 2) GitHub Actions vulnerabilities could enable unauthorized publishing, 3) F-Droid builds aren't reproducible so can't verify binary matches source, 4) Unknown developer controls namespace. emergent_reasons strongly advises: 'If something gets posted with electron cash name by someone other than electron team, it must be called out loudly and everywhere as a likely scam.' JF acknowledges: 'its kind of weird that out of the blue someone no one knows just decided to make a build for f-droid.' Even well-intentioned contributors need vetting when handling wallet software accessing user funds.\"},{\"q\":\"Why is NFC storage of SLIP-39 shares an interesting application?\",\"a\":\"Physical seed recovery without typing 20+ words. Tom's vision: 'Would like to add it to our NFC writer so you can have various NFC tags to restore a seed.' Use case: M-of-N threshold scheme where each share stored on NFC tag. Distribute tags to different locations/people. Recovery: Collect enough tags, tap each to reader, device reconstructs seed. Benefits: 1) No typing long word sequences (error-prone), 2) Physical security (tags can be hidden/secured), 3) Social recovery (give shares to family/friends), 4) Disaster recovery (geographically distributed). Challenges: NFC tag security (can be cloned if accessed), need secure reader (SeedCash device), lose M tags = lose funds. Tom's concern: 'I would love to see someone work out a user experience of storing and restoring the shards to an actual wallet. And improve the interoperable design from that.' SLIP-39 spec defines share encoding but not storage medium or recovery UX. This is frontier of BCH seed security - combining physical and cryptographic protection.\"},{\"q\":\"Can I create paper wallets with Electron Cash?\",\"a\":\"Not easily with Electron Cash directly. For paper wallet generation, use dedicated tools: 1) Go to minisatoshi.cash/ecosystem and search for 'Paper Wallet', 2) Use paperwallet.fullstack.cash, or 3) For metal backup, check opensourcemetalwallet.com. These tools are specifically designed for secure paper wallet creation.\"}]},{\"name\":\"Network & Servers\",\"count\":10,\"faqs\":[{\"q\":\"Why does EC Android get stuck on 'generating your addresses' when offline?\",\"a\":\"This issue can occur on older Android devices (Android 7 from 2018 reported). The address generation process itself doesn't require network connectivity - EC should generate initial 20 addresses and stop if it can't verify usage on blockchain. Possible causes: 1) Very slow processor on old device (though stuck for days is excessive), 2) Potential bug specific to older Android versions, 3) Device resource limitations. Testing confirms EC Android works offline in airplane mode on modern devices. If experiencing this: try latest EC version, test same device online first to isolate the issue, and report bug on GitHub with device model and Android version.\"},{\"q\":\"Why does Electron Cash crash when my Linux computer is locked but works fine during active use?\",\"a\":\"Likely Qt framework bug rather than memory issue. User reports: EC crashes after screen lock despite 32GB RAM, works fine for hours during active computer use (browsing, gaming). Calin's diagnosis: 'This leads me to think it's somehow related to bugs in qt hmm... Might not even be memory related might be some qt bugs in the EC version of qt.' Qt handles GUI rendering - when screen locks, compositor/display server behavior changes, potentially triggering Qt bugs. KDE Plasma updates may affect this. Additional factors: 1) EC does leak memory over time (confirmed by Calin), 2) Without swap, OOM killer may terminate EC abruptly, 3) Qt version bundled with EC AppImage may have incompatibilities. Troubleshooting: Enable swap (even 1GB), run from source with system Qt instead of AppImage, check dmesg/journalctl for OOM killer messages. Josh's specific case likely Qt-related since memory usage unchanged during issue.\"},{\"q\":\"How did Electrum handle the scriptSig parsing problem?\",\"a\":\"Electrum gave up and removed heuristic parser entirely. Calin notes: 'Interestingly, Electrum gave up, removed the heuristic parse_scriptSig function.. and just shows you some garbage there for inputs.' Their alternative: 'and i think they have some mechanism for remembering and/or retrieving previous outputs somehow to fully resolve txns but i forget how they did it i remember thinking it was not as nice UI-wise as what we do.' EC's approach: Kept heuristic matching despite limitations, added fetch_inputs capability for when accuracy matters. Trade-off: EC shows 'best guess' addresses (sometimes wrong), Electrum shows raw data (always honest but unhelpful). Calin acknowledges EC's parser inadequacy: 'so we are left with parse_scriptSig() which works 95% of the time and fails spectacularly when it doesn't.' Important context: As P2S activates in May 2026 and more custom contracts emerge, heuristic accuracy will decline further. Eventually EC may need to follow Electrum's approach or implement mandatory input fetching.\"},{\"q\":\"What is the philosophy of good heuristic matching in parsers?\",\"a\":\"Minimize false positives while maximizing coverage. Calin explains: 'the idea is to pick a set of heuristics that end up being lies like as infrequently as possible.' Current EC heuristics: Work ~95% of time (P2PKH dominant, multisig P2SH common). As usage patterns change (more CashScript contracts, more complex P2SH), accuracy decreases. Dustin's proposed change evaluation: 'i think your changes increase the lie percentage, rather than reduce it.' Why worse: Hashing arbitrary push as P2SH20 would misidentify P2PKH (signature becomes 'address'), P2SH32 (wrong hash), any non-P2SH. Calin's principle: 'probably deserialize may need to be fixed tho to not at least lie to you about p2sh... like right now deserialize may lie to you... may match p2sh when it's really not.' Honesty options: Return 'unknown' (honest uncertainty), fetch previous output (accurate), or heuristic guess (risk). Current EC approach: Guess but acknowledge in code comments it's fragile. Future direction: May need to follow Electrum and abandon heuristics entirely.\"},{\"q\":\"Is Electron Cash a fork of another wallet?\",\"a\":\"Yes, Electron Cash is a fork of Electrum (the Bitcoin wallet). It was created for Bitcoin Cash. EC is one of many Electrum forks - others exist for Litecoin, Dogecoin, Dash, Zcash, BSV, eCash, Ergon, and more. Because EC inherits Electrum's codebase, it uses the same general architecture including PyQt for the GUI and the client-server model with dedicated indexers. The first EC release occurred just one day before the BCH fork in August 2017.\"},{\"q\":\"Where can I find documentation about SPV protocol for Bitcoin Cash?\",\"a\":\"Key resources: 1) Original Bitcoin whitepaper section on SPV, 2) https://documentation.cash/protocol/spv.html - BCH-specific SPV documentation, 3) BIP-37 specification for bloom filter SPV. The documentation.cash site covers the merkle proof verification concept and its implementation in BCH. Remember that 'SPV' as defined in the whitepaper is the verification concept, while BIP-37 was the first network-level implementation using bloom filters.\"},{\"q\":\"Why is there a python-dateutil version requirement (<2.9) in EC and how does it cause packaging issues?\",\"a\":\"EC's requirements.txt specifies python-dateutil less than 2.9, causing conflicts with newer Linux distributions (like Fedora rawhide shipping 2.9.0). The library is only used in electroncash/paymentrequest.py for date parsing. History: A higher version likely broke something in the past, prompting the version cap. Issue: Distribution packagers can't include EC when system dateutil exceeds 2.9. Solutions being explored: 1) Test with newer dateutil to see if original issue is resolved, 2) Remove dateutil dependency entirely (Electrum BTC doesn't use it), 3) Update code to work with newer versions. This exemplifies challenges of maintaining cross-distribution compatibility with pinned dependencies.\"},{\"q\":\"Why would 1-minute blocks help with large block scalability?\",\"a\":\"Counter-intuitive benefit: Smaller, more frequent blocks are easier to process than infrequent large blocks. With current 10-minute target, scaling to 1GB blocks means processing 1GB every 10 minutes in one burst. With 1-minute blocks, same throughput splits into 100MB blocks every minute - steadier processing load, better for network propagation, smoother resource utilization. Mining nodes handle continuous smaller workloads better than periodic massive ones. This spreads CPU/bandwidth usage more evenly. However, trade-off: 10x more block headers to validate/store, more frequent difficulty adjustments needed, coinbase maturity becomes 100 minutes instead of ~1000 minutes for same block count.\"},{\"q\":\"Why are self-signed SSL certificates risky for public Fulcrum servers?\",\"a\":\"Self-signed certs enable Man-in-the-Middle (MITM) attacks on public WiFi or unsecured networks. Users cannot easily verify if a certificate is legitimate (just a long number), making forgery trivial. While self-signed certs can be secure if you pin the specific certificate, typical users don't verify this. Web browsers treat them as untrusted for this reason. For public Fulcrum servers, use Let's Encrypt or other CA-signed certificates. Self-signed is only appropriate for private servers where you control both ends and can verify the certificate fingerprint.\"},{\"q\":\"What is the gap limit issue with EC payment requests and how does Electrum solve it?\",\"a\":\"Addresses from expired invoices not reused, causing address exhaustion. Алексей explains: 'Basically get_unused_address doesn't reuse addresses from expired invoices.' Problem: HD wallets generate sequential addresses. When payment request expires without payment, address marked 'used' even though never funded. Eventually hits gap limit (default 20) and no more addresses available. Concern: 'I wonder if it's bad that getrequest requestaddress will start returning the new request, and old request information is basically overwritten forever.' Electrum's solution: 'introduce request ids for payment requests, and they are used to query for them, not request address.' Request ID approach: UUID identifies payment request, address is implementation detail. Can reuse address if request expired without payment. Allows querying old request info even after address reused. EC currently uses address as primary key - changing to request IDs is breaking change. Алексей: 'Not sure how to proceed here.' Needs careful consideration of backwards compatibility and data migration.\"}]},{\"name\":\"User Interface\",\"count\":22,\"faqs\":[{\"q\":\"What is the GitHub workflow policy for EC maintainers with merge privileges?\",\"a\":\"Flexible trust-based system. Jonas (newly granted merge privileges) asks: 'Are you OK with me just pushing changes to master if they don't touch the actual EC code? So changes like GitHub Actions, packaging and test cases going straight to master without any review?' JF approves: 'i think that should be fine. Calin usually makes it a point to look at all commits between releases, at least to describe what's in the release.. so the danger of something bad getting in should be minimal.' Calin's perspective: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging... you are a very experienced software professional, Jonas, so I personally trust your judgement here.' Best practices: 1) Small infrastructure changes (CI, tests, packaging) can go directly to master, 2) PRs provide visibility even without formal review - Calin: 'i like the fact that it was a PR because I saw what is going on', 3) Core EC code changes need more scrutiny, 4) Tag maintainers in Telegram for urgent reviews. emergent_reasons: 'it's always safer to just go ahead and make a PR to look at yourself and give someone at least a small window to check it out.'\"},{\"q\":\"What is best practice for merging your own PRs as a maintainer?\",\"a\":\"Balance between review and velocity. Calin advises Jonas: 'You can always PR, let it sit for a few minutes then merge or skip that altogether.' For infrastructure changes: Self-merge acceptable. JF: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging to master - sort of see them up on screen in the browser as a diff.' Benefits of PR even for self-merge: 1) CI runs before hitting production (emergent_reasons: 'It should also give the CI an opportunity to hit any CI snags before hitting production'), 2) Provides audit trail, 3) Other maintainers see activity via notifications, 4) Forces self-review in different context. Jonas' approach: Created PR #3128, waited one day, merged himself. Calin: 'you could have even pushed directly for that too tbh.. it's tests so' but 'i like the fact that it was a PR because I saw what is going on.' Trust matters: Jonas given autonomy because experienced professional, but transparency valued even when formal review not required.\"},{\"q\":\"Which fiat price providers work best in Electron Cash?\",\"a\":\"Recommended working providers: CoinGecko (most commonly used), Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. Avoid: CoinCap (unstable, sometimes shows wrong prices like $13k), BitcoinAverage (dead service, should be removed). Access via Tools > Preferences > Fiat. Note: VPNs may cause issues as many sites blanket-block known VPN providers.\"},{\"q\":\"How do I get detailed error logs from Electron Cash?\",\"a\":\"Run the Electron Cash AppImage from terminal with the -v (verbose) flag. This will show the full Python traceback including source code line numbers. The error dialog in the GUI often only shows the final error message without the stack trace. Example: ./ElectronCash.AppImage -v\"},{\"q\":\"How does virtual vs reserved memory differ and why does it matter for EC?\",\"a\":\"Critical distinction for monitoring memory usage: Virtual memory is address space mapped (can be huge - Shadow saw 500GB virtual for single process), reserved/resident memory is actual physical RAM consumed. Calin: 'Virtual is just the address space it's almost meaningless number.' When monitoring EC: Look at RSS (Resident Set Size) or RES in htop, ignore VIRT column. EC with large wallet uses 5-8GB RSS (actual RAM). Tools: htop shows both columns - focus on RES. Why this matters: Process may have 100GB virtual (pre-allocated address space for potential future use) but only 1GB resident (actually using physical RAM). OOM killer cares about resident memory, not virtual. When tracking EC memory leak: Monitor RES growing over time, that indicates leak. If only VIRT grows but RES stable, that's normal memory mapping behavior, not leak.\"},{\"q\":\"What are common Linux desktop environment issues affecting EC?\",\"a\":\"KDE Plasma (Qt-based like EC) interactions discussed: 1) Memory usage - KDE uses ~750MB-1GB baseline (Jonathan reports 750MB), more than XFCE (minimal DE), but acceptable with modern RAM. 2) Qt version conflicts - EC bundles its Qt version in AppImage, system Qt (from KDE) may differ causing bugs. 3) Screen lock events - Josh's EC crashes only after screen lock, possibly compositor/session management triggering Qt bugs. 4) GPU/compositor interactions - Wayland vs X11 can affect Qt applications differently. Shadow notes: 'KDE was a RAM-eating monster last time I used it' but Josh counters: 'KDE 6 has been rock solid since I've started using it 2 years ago.' Jonathan: 'KDE is great... If you're on a memory starved machine, say 2gb or less, you might want consider other options.' Solution: If EC crashes only with certain DE behaviors (lock, suspend), try running from source with system Qt instead of AppImage's bundled Qt.\"},{\"q\":\"Does adding swap space fix EC crashes during screen lock?\",\"a\":\"No - Josh's experiment proves RAM/swap isn't the issue. After extensive community discussion about swap benefits, Josh added swap file: 'Fine! I make a dammed swap file on a no-COW btrfs subvolume.' Result: 'Just checked, EC still crashed.' Calin confirms diagnosis: 'i really think it has nothing to do with RAM and more to do with some Qt shenanigans.' Josh realizes: 'I did notice I started having issues after a qt update from a while ago.' Root cause: Qt framework bug, likely related to screen lock events on KDE Plasma. EC bundles its own Qt version in AppImage which may have incompatibilities with system compositor. Possible solutions: 1) Run EC from source using system Qt, 2) Report specific Qt version and KDE version to help diagnose, 3) Wait for EC release with updated Qt, 4) Use different desktop environment as test. Swap is still recommended for general system stability, just doesn't fix this specific Qt-related crash.\"},{\"q\":\"What causes EC AppImage crashes when screen locks and monitor turns off?\",\"a\":\"Josh identified exact trigger: 'When my monitor goes blank after locking the screen. The locking itself doesn't crash, it's when the monitor shuts off.' Error log shows Wayland-related issues (wl_ prefixes in stack trace). Key findings: 1) Not RAM/swap issue (32GB RAM, tested with swap), 2) Not memory leak (works fine during active use), 3) Specific to monitor power-off event, not screen lock itself, 4) Wayland compositor behavior when display turns off triggers crash. Shadow: 'I see wl_ in there. Sooo..... Wayland?' Andy counters: 'I run electron cash on Wayland and have had zero problems' (using AUR package, not AppImage). Possible causes: AppImage's bundled Qt version incompatible with specific Wayland compositor version, Clang/LLVM profile on Gentoo introduces incompatibility, monitor DPMS events not handled correctly by bundled Qt. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?'\"},{\"q\":\"Does AppImage bundle its own libc or use system libc?\",\"a\":\"AppImages use SYSTEM libc, not bundled version. Jonas confirms after Shadow states: 'It is basically like a docker container. Contains all necessary libraries inside it, except some most basic ones like libc.' Reason: libc is fundamental system interface to Linux kernel - bundling would break binary compatibility. AppImage bundles: Qt, Python, application-specific libraries. AppImage uses: System libc (glibc), kernel interfaces. Josh's investigation: 'So after ldding a few executables, it looks like most things are loading libc.so.6.' His Gentoo system uses Clang profile with libc++ (LLVM's C++ stdlib) instead of GNU libstdc++, but still uses system glibc for C standard library. Tom's debugging tip: 'In the proc filesystem, the pid of EC you can double check which path to the Qt lib it actually uses. For instance /proc/100/maps' - shows all loaded libraries for running process. This helps verify AppImage isn't picking up system Qt by mistake.\"},{\"q\":\"Does EC work better on Xorg or Wayland?\",\"a\":\"Mixed results - some users report no issues on either, one specific case shows Wayland-related crash. Evidence: Josh's AppImage crashes when monitor blanks (Wayland stack trace in error). Andy: 'I run electron cash on Wayland and have had zero problems' (AUR package). Jonas: 'I'm using the AppImage on Wayland (or whatever is the default on Ubuntu 24.04) and haven't had this issue.' Shadow strongly prefers Xorg: 'Wayland is totally experimental and unstable, despite any claims otherwise.' Tom defends: 'one person hates wayland and is very quick to blame it.' Reality: Wayland isn't universally broken, but specific combinations (AppImage + Gentoo + Clang + KDE Plasma) may trigger issues. WT notes: 'Wayland supposedly is a guarded, walled environment for processes, so we also have to ask if Electron Cash is doing something uncanny.' Workaround if having issues: Use AUR package (Arch) which uses system Qt, or try running EC with --xorg flag if compositor supports, or use XWayland compatibility layer.\"},{\"q\":\"Why is Electron Cash still using Qt5 instead of Qt6?\",\"a\":\"Migrating to Qt6 requires switching from PyQt to PySide2, which is not a huge code change but requires extensive testing of every GUI component. Python's dynamic typing means there's no compile-time safety check, so all UI elements need manual testing. Ubuntu is planning to eventually stop packaging Qt5, so this migration is on the roadmap but not yet prioritized due to the testing overhead.\"},{\"q\":\"What is Qt and why does it matter for Electron Cash?\",\"a\":\"Qt is the GUI framework EC uses (via PyQt5). Qt determines: how windows render, menu appearance, font scaling, and platform compatibility. EC uses Qt5 (not Qt6 yet) which affects: 1) High-DPI support (needs manual QT_SCALE_FACTOR), 2) Wayland compatibility (varying success), 3) Native appearance on different OSes, 4) Available build options. Migration to Qt6 would require switching to PySide2 and extensive testing. The AppImage bundles specific Qt version, while running from source uses system Qt. Qt version mismatches cause many UI-related issues.\"},{\"q\":\"What advantages would moving to Qt6 bring for Electron Cash?\",\"a\":\"Key advantages: 1) Qt6 has prebuilt ARM wheels (Qt5 doesn't) making ARM AppImages feasible, 2) Better native high-DPI support without QT_SCALE_FACTOR hacks, 3) Improved Wayland compatibility, 4) Modern features and better performance, 5) Ubuntu planning to stop packaging Qt5 eventually. Challenges: Requires switching from PyQt5 to PySide2, extensive testing of all GUI components due to Python's dynamic typing, and maintainer time. GitHub issue #3053 tracks this migration discussion.\"},{\"q\":\"How would a change to BCH block time target affect Electron Cash?\",\"a\":\"EC would need code modifications to SPV proof checking, but it wouldn't be a huge project. Key impacts: 1) Header verification timing assumptions would need updating, 2) Difficulty adjustment algorithm references need modification, 3) With faster blocks, can still prune headers - store only 1k recent headers plus verified merkle root. Good news: EC already uses header merkle roots/proofs, so even with 1-minute blocks (vs current 10-minute), storage remains minimal. The full node software changes are more involved than wallet changes. EC has proven adaptable - it survived the BCH fork from BTC and subsequent consensus changes.\"},{\"q\":\"Can EC be cross-compiled from x86_64 to ARM64?\",\"a\":\"Theoretically yes, practically challenging. Shadow: 'you can cross compile to Pi, zero problem... A ready VM (or a docker container) can be easily crafted, built specifically with all the tools to cross-compile it.' However, Chris Troutner built on native ARM64 machine because: 1) PyQt5 binaries not available via pip for arm64 - had to copy from Ubuntu packages, 2) Many assumptions in build scripts about native architecture, 3) Unknown if all dependencies cross-compile correctly. Jonas notes Chris' solution: 'Download the ubuntu packages and copy them' (github link to _build_arm64.sh). Cross-compilation challenges: Different library ABIs, native build tools expect host architecture, Python wheels may not have arm64 versions. JF: 'normally we build windows releases on linux, but no idea about arm64.' Current path: Build on native arm64 (Pi 5 recommended), use Chris's modified build scripts, accept non-reproducible builds. Cross-compilation would require significant build system modifications.\"},{\"q\":\"Are there legal risks for Electron Cash developers regarding bugs like incorrect price display?\",\"a\":\"Under the MIT license, the software comes with no warranty. However, legal risks depend on jurisdiction and political visibility. While the MIT license provides disclaimer protection, it's not absolute. Users have responsibility (caveat emptor/vendor) to verify critical information. Developers should focus on moral/personal responsibility to provide quality software. The fact that EC is FOSS (Free and Open Source Software) and WYSIWYG (What You See Is What You Get) provides some protection, but edge cases with determined litigants could be complex.\"},{\"q\":\"How do I create a bootable Linux USB for secure wallet generation?\",\"a\":\"Use UNetbootin (https://unetbootin.github.io/), a legendary open-source tool that creates bootable USB drives automatically. It can download Linux ISOs for you or use ones you've downloaded. Best practice: download ISO directly from the official Linux distribution website (e.g., Ubuntu, Linux Mint) rather than third-party sources. Once created, you can boot from this USB to generate paper wallets in a secure, isolated environment where nothing is written to your hard drive.\"},{\"q\":\"What permissions does EC request on macOS and are they suspicious?\",\"a\":\"EC may request several permissions: 1) Screen Recording/Accessibility - for scanning QR codes on desktop screen, 2) Camera access - for scanning QR codes via webcam, 3) Audio (sometimes bundled with camera) - likely inherited from Qt framework's multimedia module. These are legitimate features, not malware indicators. However, be cautious: If EC shows strange binary strings in GUI, unusual behavior, or requests unexpected permissions, it may indicate compromised binary. Safety steps: 1) Download only from electroncash.org, 2) Verify GPG signatures, 3) Grant minimum permissions needed, 4) Deny permissions you don't need (can always grant later), 5) If suspicious, delete and redownload verified version. macOS Gatekeeper warnings are normal for non-App Store apps.\"},{\"q\":\"Why are EC AppImage builds not reproducible and what causes this?\",\"a\":\"Reproducible builds mean building same source code produces bit-for-bit identical binary, allowing verification. Current issue: protobuf package breaks reproducibility. When protobuf was bumped from 3.x to 5.x, new UPD (Universal Proto Deserializer) backend compiles at build time, embedding build paths into .so files. Different build directories = different hashes. Jonas: 'The package that causes a diff... *drumroll*... protobuf! When bumping from 3.x to 5.x there is a new backend (UPD) that is compiled at build time. It seems like some build paths ends up in the compiled .so file.' Concerning because: Users can't independently verify released binaries match source code - must trust developers. Solutions: Pin protobuf to older version (loses features), fix build paths in protobuf compilation, or accept non-reproducibility (undesirable). Tom notes: 'The main way to avoid issues with it is to stop using their generated code and their library... Their protocol is stable, it's the software that's been a disaster for a decade.'\"},{\"q\":\"Why are reproducible builds important and what makes EC's builds reproducible?\",\"a\":\"Reproducible builds allow anyone to verify that distributed binary matches source code - minimizes trust in maintainers. JF: 'i really appreciate this aspect of our build process and minimizing the trust placed on the maintainers.' How EC achieves this: 1) Exact dependency versions pinned in contrib/deterministic-build/requirements.txt, 2) Build happens in Docker container with controlled environment, 3) Build paths normalized to deterministic strings, 4) All source code auditable. Recent challenge: protobuf 5.x embeds random build paths requiring special handling. Jonas' fix (PR #3120) replaces randomized paths with deterministic strings. Process: Multiple developers build same release, compare SHA256 hashes - if identical, proves no tampering. Chris Troutner's ARM64 build NOT reproducible: Ubuntu packages not version-pinned, would produce different hashes. This is why official releases require maintainer commitment to reproducibility standards.\"},{\"q\":\"How does F-Droid's trust model actually work for app distribution?\",\"a\":\"F-Droid only trusts git repositories, not individual submitters. Tom clarifies widespread misconception: 'the f-droid project specifically does not trust any person, it only trusts a git url. It never gets the data from a person, it gets the data from one or more git repositories you publish.' Key implications: 1) Unknown person submitting PR is irrelevant - F-Droid builds from EC's official GitHub, 2) All metadata (screenshots, descriptions) must live in EC's repo under their control, 3) EC maintainers approve all changes through normal merge requests. Tom: 'the ONLY thing you need to check is if the fdroid stuff links to the trusted git repos... No trust is needed because fdroid is designed to only pull from your git repos.' Damascene confirms: 'The person who submit has no power over it. F-droid will verify and handle it so it auto build from your git.' This design provides transparency - code is auditable, build process is known. Remaining trust required: F-Droid's build infrastructure itself, hence importance of reproducible Android builds to verify their output matches source.\"},{\"q\":\"Can Electron Cash scan QR codes directly from my desktop screen without a webcam?\",\"a\":\"Yes! EC has screen scanning feature that captures your entire desktop and searches for QR codes. Super useful if: 1) Your computer doesn't have webcam, 2) QR code is displayed on website/PDF on your screen, 3) You want to avoid camera permissions. How to use: Click QR scan button, EC requests screen recording permission (macOS may show this as 'Accessibility' access), scans screen for QR codes. Calin's advice: Only grant this permission if you actually need the feature - decline if you don't plan to use it. Alternative: Use external QR scanner app that reads screen (KDE has this built into screenshot tool), then paste text into EC. Feature works for addresses, payment URIs, and potentially WIF private keys for sweeping.\"}]},{\"name\":\"Development & Technical\",\"count\":22,\"faqs\":[{\"q\":\"Why haven't exchanges adopted CashAddr format yet?\",\"a\":\"Despite CashAddr being standard since 2018, many exchanges still only support legacy (Base58/BTC-compatible) addresses. Reasons: 1) Low priority - BCH is small market cap coin for them, 2) Development resources allocated elsewhere, 3) Legacy addresses still work (wallets auto-convert), 4) No strong business incentive to update. This affects RPA/stealth address adoption prospects - if exchanges won't even support basic CashAddr, expecting them to implement complex stealth address infrastructure is unrealistic. Community expectation: adoption will follow market cap growth. When BCH reaches top 5-10, exchanges will prioritize BCH features. Until then, advanced features like RPA will remain wallet-to-wallet primarily.\"},{\"q\":\"What is the EC maintainer situation and why is it challenging?\",\"a\":\"EC has limited maintainers despite being critical BCH infrastructure. Jonas: 'It's not like this project is packed by maintainers.' Challenges: 1) Adding new platform support (ARM64) requires ongoing maintenance - builds break, dependencies change, 2) Volunteer developers have limited time, 3) Complex build system requires deep knowledge (Docker, Python packaging, reproducibility), 4) Security implications mean careful review of all changes, 5) No full-time paid developers. Example: Chris Troutner built ARM64 AppImage but explicitly states 'I'm not planning to maintain this code base.' JF appreciates work done but recognizes burden. EchterAgo maintains build infrastructure, Jonas works on reproducibility fixes, JF and Calin on core features. Community can contribute: Report bugs on GitHub, test releases, donate to flipstarter campaigns for specific features. Specialized tasks need experts - not something anyone can pick up casually.\"},{\"q\":\"What GitHub PRs were merged for EC in October 2025?\",\"a\":\"Several PRs merged during active development period: 1) PR #3120 - Jonas' protobuf reproducibility fix (build paths deterministic), 2) PR #3126 - Small nuisance fix (details not specified in chat), 3) PR #3127 - Jonas whitelisted issues in audit tool: 'Looked thru the list of issues by the audit tool and whitelisted them all.' His summary: 'It makes a red thing turn green, and since I'm the only one on earth that looks at that thing it brings peace to my mind.' Also mentioned: GitHub issue #3121 related to some endorsement matter. JF merged PRs, noting active code review happening. Dustin has pending PRs that need conflict resolution (PR #3086). Community actively maintaining codebase despite limited maintainers. Important: These fixes primarily affect build infrastructure and developer experience, not end-user features. Shows healthy maintenance culture - even 'just makes green light' PRs valued for maintaining code quality standards.\"},{\"q\":\"How do you set up GitHub-to-Telegram notifications for EC repository activity?\",\"a\":\"Jonas created dedicated notification channel. Announcement: 'I have fixed the GitHub notifications. To not create noise in this channel I've created a new one where interested parties can see when Issues and PRs are opened and closed: https://t.me/electroncashnotifications' Background: JF noted: 'honestly i dont always check the notifications, but if you tag me here i'll def see it.' Problem: GitHub email notifications often ignored, Telegram more immediate. Implementation: Bot forwards GitHub webhook events to dedicated channel. Benefits: 1) Main EC channel stays focused on discussion, not automated noise, 2) Interested parties opt-in to notifications, 3) PRs get visibility faster, 4) Issue tracking more transparent. Jonas' first task after getting merge privileges: 'I have, as a first order of business, closed ~100 issues (all android) as duplicates' - shows active maintenance happening. This infrastructure improvement helps maintain open source project with distributed volunteer team across timezones.\"},{\"q\":\"Is Electron Cash developed by a company with paid support staff?\",\"a\":\"No, EC is volunteer-driven open source project. emergent_reasons clarifies when user asks for help: 'It's not a company - just volunteers who use and support Electron Cash. If you have a question, please post here.' Important implications: 1) No paid support staff, 2) No guaranteed response times, 3) Development depends on volunteer availability and interest, 4) Funding comes from flipstarter campaigns for specific features. Community structure: Core maintainers (Calin, JF, Jonas, EchterAgo) donate time, regular contributors (Dustin, emergent_reasons, Shadow) help with support and testing. Best practices for getting help: Post questions in public Telegram channel (not DM to avoid scams), provide technical details (version, OS, wallet type), check GitHub issues first, be patient. Contribution welcome: Anyone can submit PRs, report bugs, test releases, write documentation. JF notes: 'its an open source project. in theory anyone should be able to contribute.' Warning: emergent_reasons reminds: 'Please don't post payment links' - scam vectors exist, official channel is volunteer-run community, not commercial service.\"},{\"q\":\"What is happening with the CoinCap price API in Electron Cash?\",\"a\":\"CoinCap deprecated their v2 API on March 31, 2025. The v3 API requires an API key and charges for requests. EC users should switch to alternative price providers: CoinGecko, Kraken, Coinbase, BitPay, or Bitstamp (Tools > Preferences > Fiat). CoinGecko is recommended as a free alternative. This is a reminder that free API services often get discontinued, so relying on multiple sources is wise. EC developers may need to remove CoinCap from options or implement the new paid API.\"},{\"q\":\"What does 'RuntimeError: dictionary changed size during iteration' mean and can it corrupt my wallet?\",\"a\":\"This Python error occurs when EC's internal data structures are modified during iteration (threading issue). Yes, this can potentially corrupt your coins list, requiring a wallet rebuild. If you see this error, run EC with the -v flag for more detailed information. Consider rebuilding your wallet (Wallet menu > Information > Rebuild) to ensure coin data integrity. This is a known threading bug that occasionally occurs.\"},{\"q\":\"What common Python environment issues prevent EC from running from source?\",\"a\":\"Common issues include: 1) libsecp256k1 version conflicts (BTC vs BCH Schnorr signatures), 2) protobuf version mismatches ('cannot import runtime_version'), 3) PyQt5 vs PyQt6 conflicts, 4) SSL certificate verification failures with self-signed certs (switch to Let's Encrypt), 5) Python version incompatibilities after system updates. Solutions: Use virtual environment (venv) with site-packages, try Anaconda for clean environment, or fall back to AppImage. Running from source on ARM additionally requires manually compiling secp256k1.\"},{\"q\":\"Why is Python 3.8 usage in EC build system problematic?\",\"a\":\"EC's source distribution (srcdist) builder uses Ubuntu 20.04 which includes Python 3.8, but Python 3.8 reached End of Life (EOL) in 2024. Problems: 1) Newer packages drop 3.8 support (qrcode v8+ requires Python 3.9+), 2) Security vulnerabilities in EOL Python won't be patched, 3) Limits which dependency versions can be used. Example: Wanted to use qrcode 8.2 but had to fall back to 7.4.2 to maintain 3.8 compatibility. EchterAgo: 'ideally we'd also update srcdist to use a newer python, 3.8 is EOL.' Solution path: Update srcdist Docker container to use Ubuntu 22.04 (Python 3.10) or 24.04 (Python 3.12), but this is breaking change requiring extensive testing. Package version selection becomes constrained by oldest supported Python version in build matrix. This is why maintaining build reproducibility across years is challenging - upstream ecosystem moves forward while pinned versions create growing technical debt.\"},{\"q\":\"What logging does systemd provide for application crashes?\",\"a\":\"Tom: 'systemd will log all application crashes. It will indeed mention that it was due to the out of memory killer if applicable.' Where to check: journalctl for systemd logs, dmesg for kernel messages (OOM killer). OOM killer logs include which process was terminated and why. Important: OOM killer only logs when it actually kills process - if application crashes for other reasons (segfault, Qt bug), different log entry. Josh notes: 'I'm staunchly anti systemd haha. I use OpenRC with sysklogd' - alternative init systems have different logging. For debugging EC crashes: 1) Check journalctl/syslog for crash messages, 2) Look for OOM killer messages in dmesg, 3) Monitor memory usage over time with htop, 4) Run EC with verbose mode from terminal to capture Python tracebacks. If crash has no OOM indication, likely Qt framework bug (common with screen lock on KDE) or Python exception not caught. Shadow's tip: Even without OOM kill, having no swap can cause crashes due to failed memory allocations.\"},{\"q\":\"How do I check which libraries a running EC process is using on Linux?\",\"a\":\"Tom's debugging technique: 'you can open the text file /proc/PID/maps to get your full list of libraries for any running process.' Steps: 1) Find EC process ID: use 'ps aux | grep electron' or htop/top, 2) Read /proc/PID/maps: 'cat /proc/12345/maps' (replace 12345 with actual PID), 3) Look for library paths - shows Qt location, Python libraries, system vs bundled. For AppImage: Should show libraries from /tmp/appimage-extracted-xxx/ paths, not system paths. If you see /usr/lib/qt5 instead, AppImage is incorrectly using system Qt. Josh's investigation: 'I can't ldd the AppImage though since it's, well, an AppImage' - but /proc/PID/maps works on running process. Additional tool: ldd shows library dependencies at load time, but /proc/PID/maps shows what's actually loaded at runtime (can differ). Look for: libQt5*.so paths (should be AppImage directory), libc.so.6 (should be system), libpython*.so.\"},{\"q\":\"Could using Clang/LLVM instead of GCC cause EC compatibility issues?\",\"a\":\"Possibly, though unlikely root cause. Josh uses Gentoo with Clang profile: 'I use a Gentoo system with the Clang profile... uses the libcxx library rather than the GNU libc.' Shadow theorizes: 'Because perhaps CLANG/LLVM is not as well battle-tested as GCC, which is the mainstream compiler used absolutely everywhere.' Investigation results: Josh's system uses standard glibc for C library, libc++ only for C++ standard library. Both coexist on his system. Most applications including Steam work fine. Problem is more likely: 1) AppImage's bundled Qt (compiled with GCC) interacting oddly with system compiled with Clang, 2) Wayland compositor behavior (not compiler), 3) Specific KDE Plasma version + Qt5 version combination. Tom notes: Valve (Steam) uses Arch Linux (GCC-based) as foundation for SteamOS. EC AppImage built on Ubuntu 20.04 with GCC - should be compatible with any glibc-based system regardless of host compiler.\"},{\"q\":\"How do you limit EC to single CPU core on Linux for performance testing?\",\"a\":\"Use taskset command to set CPU affinity. ErdoganTalk asks: 'is it possible to limit ElectronCash to 1 processor/thread only?' Jonny's solution: 'You can spawn the program via the taskset command that limits the process to the cpu/thread you want.' Two approaches: 1) Launch with restriction: 'taskset -c 0 electron-cash' binds to CPU 0, 2) Modify running process: 'taskset -p -c 2 PID' where PID is python3.11 process. ErdoganTalk's experience: 'I had to start ElectronCash, then change processor affinity to 2 (or any number 0-7) on the process number for python3.11.' Use cases: 1) Testing single-threaded performance, 2) Preventing EC from monopolizing resources, 3) Debugging concurrency issues, 4) Energy efficiency on laptops. Note: EC is Python application, already limited by GIL (Global Interpreter Lock), but still uses multiple threads for I/O operations. Setting affinity primarily useful for controlling resource usage rather than improving performance.\"},{\"q\":\"Why do some P2SH inputs get incorrectly identified as P2PKH?\",\"a\":\"Heuristic parser looks for 2 pushes pattern. Calin details: 'the heuristic scanner will falsely think p2pkh if it sees 2 pushes and the first push is not 0. A legit p2sh (non-multisig) can match that pattern then the heuristic scanner just thinks p2pkh (wrongly).' P2PKH pattern: <signature> <pubkey> - exactly 2 pushes. P2SH with 2 pushes: <data> <redeemScript> - also 2 pushes! If P2SH contract's redeem script only needs one piece of data, scriptSig has 2 pushes total and gets misidentified. Conversely, correct P2SH detection: 'if it sees OP_0 as the first push, it thinks p2sh and then correctly matches.' OP_0 is required for standard multisig (BIP 11) due to OP_CHECKMULTISIG bug. emergent_reasons explains: 'The decoder is using a heuristic to identify each input as a p2pk, p2pkh, multisig-p2sh, or give up. The heuristic for p2pkh can catch p2sh in at least one specific case (2 pushes).' Dustin confirms: 'looking at the JSON where the addresses show up, it indicates the type is p2pkh (it's not, it's P2SH)' - false positive working by accident.\"},{\"q\":\"How do I build an Electron Cash AppImage from source?\",\"a\":\"Run the build script: `contrib/build-linux/appimage/build.sh 4.4.2` (replace version number as needed). This creates an AppImage with all bundled dependencies. AppImages are useful when running from source has environment issues (libsecp256k1 conflicts, Qt/PyQt version mismatches, protobuf conflicts). The AppImage bundles its own Python environment, Qt libraries, and cryptographic libraries to avoid host system conflicts.\"},{\"q\":\"Where can I find Electron Cash's Fedora RPM packaging specification?\",\"a\":\"The Fedora RPM spec file is at: https://src.fedoraproject.org/rpms/electron-cash/blob/rawhide/f/electron-cash.spec. This defines how EC is packaged for Fedora Linux, including dependencies, build steps, and protobuf file compilation. The spec downloads .proto files separately since they're not in the sdist tarball. Useful for understanding how official Linux packages handle EC dependencies like libsecp256k1, protobuf, and PyQt.\"},{\"q\":\"Is Electron Cash Android available on Google Play Store?\",\"a\":\"Yes, EC Android is still available on Google Play Store at: play.google.com/store/apps/details?id=org.electroncash.wallet. In August 2025, Google announced licensing requirements for crypto wallet apps that initially seemed to threaten all wallets, but they backtracked and clarified that non-custodial wallets (like EC) are exempt - only custodial services need special licensing. Community concern: Google controls major app distribution channel and has financial incentive (Google Pay) to restrict crypto wallets. Lesson: Don't rely solely on centralized app stores. EC is also available via: F-Droid (open source app store), direct APK download from electroncash.org, GitHub releases. Learn to sideload APKs - it's only a few clicks on Android.\"},{\"q\":\"How do you run Electron Cash from source instead of AppImage?\",\"a\":\"Running from source offers latest features and avoids binary trust issues. Steps: 1) Clone EC repository from GitHub, 2) Use virtual environment (conda/miniconda recommended by devs - JF: 'it does a wonderful job of managing python envs'), 3) Install Python dependencies from requirements.txt, 4) Optionally compile libsecp256k1 for performance (instructions in repo). Common issues: System packages (apt) conflicting with pip packages. Jonas: 'A problem is when system wide packages interfere with user local packages.' Solution: Use isolated virtual environment. For ARM64: More complex due to missing prebuilt wheels - may need to compile dependencies. emergent_reasons: 'except for libsec, not necessary to build to run from source. You can just literally run from source.' EC currently uses Python 3.11 in official builds (maintained by EchterAgo), but source can run on newer versions. Arch Linux users report success with latest Python versions via AUR package.\"},{\"q\":\"Would upgrading EC from Qt5 to Qt6 fix Wayland-related issues?\",\"a\":\"Possibly yes - Qt6 has better Wayland support. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?' Background: Qt5 was designed primarily for X11 with Wayland support added later. Qt6 designed with Wayland as first-class citizen. Specific benefits: 1) Better DPMS (monitor power management) handling, 2) Improved compositor integration, 3) Modern Wayland protocol support, 4) Bug fixes accumulated over years. Challenge: Qt5 to Qt6 migration is significant effort - API changes, deprecated features, PyQt5 to PyQt6 migration. Current EC uses PyQt5 extensively. Multiple users run EC on Wayland without issues (Jonas on Ubuntu 24.04, Andy on Arch), so Qt6 may not be strictly necessary. More immediate fix: Update Qt5 version in AppImage, or use system Qt (AUR package approach). Qt6 migration is on roadmap but not imminent due to complexity and limited maintainer resources.\"},{\"q\":\"Why can't you distinguish P2SH20 from P2SH32 addresses without previous output?\",\"a\":\"Same redeem script creates different addresses based on hash algorithm chosen. Calin explains: 'there is no way to differentiate p2sh20 from p2sh32 if the only thing you are allowed to examine about the chain is the scriptSig of the input and nothing else.' Technical details: P2SH20 uses HASH160(redeemScript) → 20 bytes, P2SH32 uses SHA256(redeemScript) → 32 bytes. Same redeem script, different output types. Dustin confirms: 'I wrote a script to generate both from the same redeem script.' scriptSig contains: Unlocking data plus redeem script (for P2SH). No indication of which hash algorithm was used for the original lock. Calin's colorful explanation: 'so even IF you perfectly solved the problem of heuristic matching for p2sh due to your being a supernatural being and bending the fabric of reality... you would still be faced with the impossible problem of deciding if this thing is p2sh32 vs p2sh20.' Dustin realizes: 'My redeem script that works will always be returned as P2SH20 even if I iterate a new one with the intention of using P2SH32.' This is fundamental Bitcoin design, not EC bug.\"},{\"q\":\"Why does my antivirus block Electron Cash as malware?\",\"a\":\"This is a common false positive with crypto wallet software. Antivirus programs (Avast, Norton, etc.) flag legitimate crypto apps because: 1) Stealth mining trojans use similar open source code, 2) Wallet-stealing malware triggers pattern matches, 3) Crypto operations look suspicious to heuristic scanners. EC is safe if downloaded from official source (electroncash.org). Verification steps: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values, 3) Add exception in antivirus for the program, 4) Consider using Linux to avoid such issues entirely. Never download EC from random links in DMs or unofficial sources.\"},{\"q\":\"Does F-Droid require reproducible builds for app inclusion?\",\"a\":\"Unclear but highly encouraged. Kallisti states: 'Fdroid requires reproducible builds afaik.' Jonas seeks clarification: 'Do you know if there is any verification of it done by f-droid before it's published?' Kallisti: 'They have some kind of review process I think.' Reality: F-Droid encourages reproducible builds but doesn't strictly require them. They do mandate building from source on their infrastructure. Verification approach: Shadow mentions: 'I read somewhere that F-Droid has some automation tools that verify the binary was indeed built from the provided source.' Jonas suggests workaround: 'The apk wont be reproducible, but there are scripts that will strip signatures and compare the files.' Trust implications: Without reproducibility, users trust F-Droid build infrastructure. With reproducibility, users can independently verify. Signal messenger has done significant work on reproducible Android builds. Challenge for EC: Chaquopy (Python-on-Android framework) may introduce non-deterministic elements. Needs investigation. Best practice: Aim for reproducible builds even if not strictly required.\"}]},{\"name\":\"General Usage\",\"count\":6,\"faqs\":[{\"q\":\"How do I report a bug in Electron Cash?\",\"a\":\"Submit bug tickets to GitHub: https://github.com/Electron-Cash/Electron-Cash/issues. Include: 1) Steps to reproduce the bug, 2) Operating system and version (iOS, Android, Windows, Linux distro), 3) EC version number, 4) Screenshots if applicable, 5) Any error messages. For mobile-specific bugs (iOS/Android), mention device model and OS version. Test on different platforms if possible to narrow down the issue. The community appreciates detailed bug reports as they help developers fix issues faster.\"},{\"q\":\"Can BCH integrate with Nostr protocol for tipping and payments?\",\"a\":\"Yes, and easier than previously thought! Initial concern: BCH uses secp256k1 ECDSA while Nostr uses Schnorr signatures - different signature algorithms would produce incompatible keypairs. Reality: Bastian Carmichael's proof-of-concept showed you CAN derive BCH address from Nostr npub (public key) directly. Same elliptic curve (secp256k1) underlies both, just different signature schemes. Implication: No NIP (Nostr Improvement Proposal) needed - can pay directly to BCH address derived from someone's Nostr identity. Use cases: Tip content creators, zap-style payments, social media micropayments. Current status: Proof-of-concept exists, needs wallet integration. Nostr currently uses Lightning Network but creator (fiatjaf) dislikes it - BCH could be better fit for instant payments.\"},{\"q\":\"How do I fix tiny fonts in EC AppImage on 4K monitors?\",\"a\":\"Set the Qt scale factor environment variable: `env QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2-x86_64.AppImage`. Adjust the number (1.5, 2, 2.5) based on your monitor's DPI and preference. For Wayland issues combined with scaling: `env -u WAYLAND_DISPLAY QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2.AppImage`. This is a Qt5 limitation - it doesn't have native high-DPI support like newer Qt6. Consider creating a desktop shortcut with these environment variables for convenience.\"},{\"q\":\"Why should Linux users enable swap even with plenty of RAM?\",\"a\":\"Swap provides benefits beyond preventing out-of-memory situations. Calin explains: 'Because you give the kernel the opportunity to evict pages from ram that are dead memory that haven't been accessed in days - in favor of disk buffers.' Benefits: 1) Kernel can swap out inactive pages (processes allocated but not using memory), 2) More disk cache available for I/O operations, 3) Better overall system responsiveness, 4) Programs expecting swap may behave unexpectedly without it. Shadow reports: 'I had problems with random processes getting killed when I ran swapless. I still had 20GB of free RAM.' Some programs assume swap exists and crash otherwise. Calin: 'swap is beneficial even in non memory starved scenarios.' Recommended: At minimum 1GB swap on NVMe/SSD. ZSWAP compresses RAM before swapping, effectively increasing available memory 20-30%. Modern swapless trend problematic - convenience (faster system) but causes edge-case failures.\"},{\"q\":\"How much storage does downloading all blockchain headers require for SPV wallets?\",\"a\":\"Approximately 4MB per year of blockchain history. For context: BCH has been running since 2009, so total header storage is ~64MB (16 years x 4MB). This is trivial on modern devices - most smartphone cameras take single photos larger than 4MB. Even downloading, parsing, and storing all headers from genesis to tip is orders of magnitude cheaper than watching one minute of YouTube. Mobile phones with 64GB+ storage don't notice this. SPV clients can also prune older headers once verified, keeping only recent 1000 headers plus a verified merkle root. This makes light wallet operation extremely efficient compared to full node requirements.\"},{\"q\":\"What DDoS protection works for BCH block explorers?\",\"a\":\"Anubis proof-of-work challenge effective and easy to deploy. ichundes reports: 'i had to put ddos protection in front of my explorer because some botnet was hitting it to the point of memory exhaustion.' Solution: 'it was quite easy to set up the protection using anubis.techaro.lol.' How it works: First-time visitors solve brief proof-of-work challenge (like mini-mining), bots struggle with computational cost while humans barely notice. Attack context: 'this is likely part of some botnet c&c, but why scrape the explorer instead of just directly querying fulcrum?' ichundes theorizes: 'traffic on port 443 looks more normal and is allowed by more firewalls.' Tom notes broader pattern: 'I've noticed a lot of scraping of stupid content... I think this is all just AI training data that is being resold.' Traditional IP blocking ineffective: 'I started with an IP blockage solution, but after blocking thousands (and some subnets) they just kept coming from new ones.' Proof-of-work protection superior: Shifts cost to attacker proportionally to their scale, legitimate users unaffected. Infrastructure operators should implement before attacks, not after.\"}]}]",
    "source": "faq/telegram/electron_cash_faq_2025.json",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-0",
    "content": "# CashScript FAQ: Essential Developer Knowledge\n\n**Curated community wisdom from BCH developer channels. ~160 essential Q&As.**\n\n---\n\n## Troubleshooting: Common Errors\n\n### \"Locktime requirement not satisfied\"\n**Q**: What does this error mean?\n\n**A**: The transaction has a locktime that hasn't been reached yet. If using `tx.time` checks in your contract, you need to set the locktime with `txb.setLocktime()` to match your contract's requirements. Tip: Try `setLocktime(0)` first to isolate the issue.\n\n---\n\n### \"bad-txns-nonfinal, non-final transaction\"\n**Q**: Why do I get this error?\n\n**A**: You set a blockheight as locktime which has not been reached yet. The transaction cannot be mined until the locktime is met. Check your `setLocktime()` value and ensure the blockchain has passed that time/block.\n\n---\n\n### Locktime fails even though time has passed\n**Q**: Why does my locktime transaction fail even though the time has passed?\n\n**A**: The blockchain uses \"median time past\" - a trailing measure because it's decentralized. When using `tx.time` with seconds-based locktime, you may need to wait longer than expected. The blockchain time can lag behind real-world time.\n\n---\n\n### \"missing inputs\"\n**Q**: What does \"missing inputs\" error mean?\n\n**A**: Your transaction is missing one or more inputs. Check that you're correctly using `transactionBuilder.addInput(someUtxo, someUnlocker)`. Try `console.log(someUtxo)` before adding it to verify your UTXO data is correct.\n\n---\n\n### \"Script evaluated without error but finished with false/empty top stack element\"",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "CashScript FAQ: Essential Developer Knowledge",
      "Troubleshooting: Common Errors",
      "\"Locktime requirement not satisfied\"",
      "\"bad-txns-nonfinal, non-final transaction\"",
      "Locktime fails even though time has passed",
      "\"missing inputs\"",
      "\"Script evaluated without error but finished with false/empty top stack element\""
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-1",
    "content": "**Q**: Why do I get this error?\n\n**A**: This is related to your contract logic, not the compiler. Ensure you're using matching versions of cashc and cashscript SDK (v0.11+ recommended). Use `.debug()` to step through your contract logic in Bitauth IDE.\n\n---\n\n### High transaction fee errors\n**Q**: How do I debug high fee errors?\n\n**A**: Add logging before sending:\n```javascript\nconst totalInputAmount = transactionBuilder.inputs.reduce(\n    (acc, input) => acc + BigInt(input.valueSatoshis), 0n\n);\nconst totalOutputAmount = transactionBuilder.outputs.reduce(\n    (acc, output) => acc + BigInt(output.valueSatoshis), 0n\n);\nconst txFeeSats = totalInputAmount - totalOutputAmount;\n```\nHigh fee errors usually mean you're failing to account for some value in the inputs.\n\n---\n\n## SDK Gotchas",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "High transaction fee errors",
      "SDK Gotchas"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-2",
    "content": "## SDK Gotchas\n\n### TransactionBuilder.addOutput() format\n**Q**: What is the correct format for `addOutput()`?\n\n**A**: Use an object parameter:\n```javascript\ntxb.addOutput({ to: address, amount: bigintValue });\n```\nDon't pass separate arguments. See cashscript.org/docs/sdk/transaction-builder#addoutput\n\n---\n\n### Compiler/SDK version matching\n**Q**: Do I need to match cashc version with SDK version?\n\n**A**: Yes. To properly use debug tooling, cashc v0.11 outputs additional data in the artifact. If you're on cashc v0.8 but cashscript v0.11, debugging tooling won't work as well. Both should be on the same major version.\n\n---\n\n### TypeScript recommended\n**Q**: Should I use TypeScript with CashScript?\n\n**A**: Yes, strongly recommended. CashScript is a TypeScript library with full type checking. Many errors difficult to debug in JavaScript are caught immediately by TypeScript. Compile artifacts in .ts format using `cashc --ts`.\n\n---\n\n### txb.build() is not async\n**Q**: Is `txb.build()` async?\n\n**A**: No, `txb.build()` is not async. You don't need to await it.\n\n---\n\n### Creating CashTokens with SDK\n**Q**: How do I create CashTokens using the SDK?\n\n**A**: Use the advanced transaction builder with the `token` parameter:\n```javascript\nconst txDetails = await contract.functions\n    .transfer(sigTemplate)\n    .to({\n        to: contract.tokenAddress,\n        amount: 1000n,\n        token: {\n            amount: 100n,\n            category: contractUtxos[0].txid\n        }\n    })\n    .send();\n```",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "mixed",
    "topics": [
      "contract",
      "transaction",
      "SDK Gotchas",
      "TransactionBuilder.addOutput() format",
      "Compiler/SDK version matching",
      "TypeScript recommended",
      "txb.build() is not async",
      "Creating CashTokens with SDK"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-3",
    "content": "---\n\n### Console.log introspection values\n**Q**: Why can't I console.log tx introspection values?\n\n**A**: You can only log variables, not introspection statements. Assign the introspection value to a variable first, then log the variable.\n\n---\n\n## Language Clarifications",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "introspection",
      "Console.log introspection values",
      "Language Clarifications"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-4",
    "content": "## Language Clarifications\n\n### Locktime: block number vs timestamp\n**Q**: How does locktime work?\n\n**A**: Values less than 500,000,000 are interpreted as block numbers. Values 500,000,000 or higher are interpreted as Unix timestamps. Set via `txBuilder.setLocktime()`, check in contract via `tx.time`.\n\n---\n\n### split() vs slice()\n**Q**: How do I get only part of a bytes value without using split's tuple?\n\n**A**: Use `.slice(start, end)` instead of `.split()` if you don't need the second part:\n```cashscript\ncommitment.slice(0, 5)  // First 5 bytes, no tuple\n```\n\n---\n\n### Tuple destructuring\n**Q**: Why can't I assign a tuple to already declared variables?\n\n**A**: Tuple destructuring must happen when declaring variables. You cannot assign a tuple to already declared variables. Structure your code to declare variables at the point of splitting.\n\n---\n\n### No global constants (yet)\n**Q**: Does CashScript support global constants?\n\n**A**: Currently, constants can only be defined within functions and get put on the stack. Global constants that inline at compile time are planned (GitHub issue #80).\n\n---\n\n### Variable-length data in bytestring\n**Q**: How can multiple variable-sized items be stored in a single bytestring?\n\n**A**: Use length-prefixed encoding:\n```cashscript\nbytes1(data.length) + bytes(data) + bytes1(data2.length) + bytes(data2)\n```\nThis is essentially \"compiled OP_PUSH\" - manually implementing what a push opcode does.\n\n---\n\n### this.activeBytecode vs unlockingBytecode\n**Q**: What's the difference between `this.activeBytecode` and `tx.inputs[i].unlockingBytecode`?",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "mixed",
    "topics": [
      "contract",
      "bytes",
      "Language Clarifications",
      "Locktime: block number vs timestamp",
      "split() vs slice()",
      "Tuple destructuring",
      "No global constants (yet)",
      "Variable-length data in bytestring",
      "this.activeBytecode vs unlockingBytecode"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-5",
    "content": "**A**:\n- `tx.inputs[i].unlockingBytecode` = scriptSig of a specific input\n- `this.activeBytecode` = contract bytecode of the input being evaluated (does NOT contain unlocking arguments)\n\n---\n\n### tx.time type\n**Q**: What is the type of `tx.time`?\n\n**A**: `tx.time` is an int (bigint). To convert to bytes for NFT commitment, use casting. Note: `tx.time` represents the locktime value set in the transaction via `txBuilder.setLocktime()`.\n\n---\n\n### Loops\n**Q**: Does CashScript support loops?\n\n**A**: Yes, CashScript @next version has `do-while` loops. Install `cashc@next` to use them. The syntax is documented at next.cashscript.org/docs/language/contracts#loops-beta. Native loop opcodes (OP_BEGIN/OP_UNTIL) are part of May 2026 upgrade.\n\n---\n\n### Reusable functions\n**Q**: Does CashScript support reusable functions?\n\n**A**: Not yet. CashScript \"functions\" are spending conditions, not reusable code blocks. Reusable functions with typed inputs/outputs are planned but require significant development work.\n\n---\n\n## CashTokens Specifics",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "int",
      "tx.time type",
      "Loops",
      "Reusable functions",
      "CashTokens Specifics"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-6",
    "content": "## CashTokens Specifics\n\n### Leaving out token = burning\n**Q**: What happens if I leave out a token from a transaction output?\n\n**A**: Leaving out a token burns it. If you have tokens in an input and don't include them in an output, they are permanently destroyed.\n\n---\n\n### Checking NFT capability\n**Q**: How can I check if a token is an NFT and what its capability is?\n\n**A**: The capability is the 33rd byte of tokenCategory:\n- `0x` (empty) = no NFT\n- `0x00` = immutable NFT\n- `0x01` = mutable NFT\n- `0x02` = minting NFT\n\nCheck `tx.inputs[i].tokenCategory.length > 32` to verify it's an NFT.\n\n---\n\n### Token category endianness\n**Q**: Why doesn't my token category match between contract and explorer?\n\n**A**: CashScript uses little endianness, explorers display big endianness. You need to reverse the byte order when comparing.\n\n---\n\n### Common token category mistakes\n**Q**: What are common mistakes with token categories?\n\n**A**: Two issues:\n1. Script uses different endianness from explorers - may need to reverse bytes\n2. `.tokenCategory` appends capability byte to the 32-byte tokenId, making it 33 bytes for NFTs\n\n---\n\n### Merging NFTs\n**Q**: How can I merge NFTs in a contract?\n\n**A**: Burn input NFTs by not including them in outputs, then create a new one. Pattern: \"burn N and create 1\" - require specific input categories and ensure they're not in outputs while outputting a new NFT with merged properties.\n\n---\n\n### ERC20 to CashTokens mapping\n**Q**: How do ERC20 tokens map to BCH?\n\n**A**: Basic fungible functionality (create, transfer, query) uses native CashTokens - no contracts needed. For advanced features (custom supply, hooks, restrictions), create a CashScript wrapper. Key insight: basic ERC20 = native CashTokens; extended ERC20 = CashScript + CashTokens.",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "bytes",
      "CashTokens Specifics",
      "Leaving out token = burning",
      "Checking NFT capability",
      "Token category endianness",
      "Common token category mistakes",
      "Merging NFTs",
      "ERC20 to CashTokens mapping"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-7",
    "content": "---\n\n## State Management\n\n### Simulated state is antipattern\n**Q**: What is the best way to manage contract state?\n\n**A**: Simulated state (modifying constructor arguments) is now considered an antipattern. Store contract state externally in an NFT commitment. This keeps the contract address stable while allowing state changes.\n\n---\n\n### No global state\n**Q**: Can I store data in a CashScript contract like Solidity?\n\n**A**: BCH does not have global state. Create a CashToken NFT and store data in its commitment (40 bytes now, 128 bytes May 2026). Your contract introspects this local transferrable state.\n\n---\n\n### Why no global state?\n**Q**: Why doesn't BCH have global state like Ethereum?\n\n**A**: It's an advantage - global state is bad for scalability. BCH uses UTXO model where state is carried with tokens. You can achieve similar functionality with slightly different patterns.\n\n---\n\n## Architecture Decisions",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "bytes",
      "State Management",
      "Simulated state is antipattern",
      "No global state",
      "Why no global state?",
      "Architecture Decisions"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-8",
    "content": "## Architecture Decisions\n\n### Why use contracts vs server?\n**Q**: Why use CashScript smart contracts instead of a JavaScript server?\n\n**A**: Smart contracts hold funds trustlessly - even the creator cannot access them. With a server, you control a key and can change code anytime. Contracts commit to constraints that cannot be changed. \"Code as law.\"\n\n---\n\n### Multi-contract mental model\n**Q**: What's a good mental model for multi-contract systems?\n\n**A**: Three patterns:\n1. Different contracts with unique tokenIds and own state (e.g., borrowing + pool)\n2. Sidecar contracts holding different tokens from main contract\n3. Function contracts attached to main verifier (separate add/withdraw/liquidate)\n\n---\n\n### Contract size limits\n**Q**: What is the current contract size limit?\n\n**A**: Since May 2025, the 520-byte stack element limit increased to 10,000 bytes. The 201-opcode limit was replaced by an operation cost system. Consensus limits are much more generous now.\n\n---\n\n### Factory bytecode mismatch\n**Q**: Why does my factory contract produce different bytecode than `new Contract()`?\n\n**A**: CashScript performs bytecode optimization. The artifact's `debug.bytecode` is unoptimized (for Bitauth IDE), while actual bytecode is optimized. Use the CashScript-compiled (optimized) bytecode as factory parameter.\n\n---\n\n### Getting contract address inside contract\n**Q**: How do I get the contract address inside a CashScript function?\n\n**A**: Use `tx.inputs[this.activeInputIndex].lockingBytecode` for the P2SH locking bytecode (closest to \"address\"). `this.activeBytecode` gets the contract's bytecode including constructor args.",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "bytes",
      "Architecture Decisions",
      "Why use contracts vs server?",
      "Multi-contract mental model",
      "Contract size limits",
      "Factory bytecode mismatch",
      "Getting contract address inside contract"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-9",
    "content": "---\n\n## Debugging\n\n### Bitauth IDE integration\n**Q**: How can I see line-by-line mapping of CashScript to opcodes?\n\n**A**: Use `const uri = await transactionBuilder.getBitauthUri();`. This opens Bitauth IDE with CashScript source, compiled opcodes, and execution results.\n\n---\n\n### Mocknet and upgrades\n**Q**: Does mocknet support upcoming BCH VM upgrades?\n\n**A**: Yes, mocknet allows configuring which VM is used. CashScript @next has BCH 2026 as default mocknet, allowing testing new opcodes before mainnet activation.\n\n---\n\n### Dev vs prod bytecode\n**Q**: Is there a difference between dev and prod bytecode?\n\n**A**: As of v0.11.0, the sourcemap and debug info work with optimized bytecode. Your contracts are exactly the same in dev as in prod.\n\n---\n\n### Testing multiple contracts\n**Q**: Can I test multiple contracts in a single transaction?\n\n**A**: Yes, the CashScript playground supports combining multiple contracts in one transaction with debugging. Preview at cashscript-playground-git-multi-contract-lahana.vercel.app\n\n---\n\n## WalletConnect",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "Debugging",
      "Bitauth IDE integration",
      "Mocknet and upgrades",
      "Dev vs prod bytecode",
      "Testing multiple contracts",
      "WalletConnect"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-10",
    "content": "## WalletConnect\n\n### Built-in support\n**Q**: Does CashScript have WalletConnect support?\n\n**A**: Yes, CashScript v0.11.1 adds BCH WalletConnect integration. TransactionBuilder has a method to generate a WalletConnect transaction object for signing.\n\n---\n\n### Debugging with WalletConnect\n**Q**: How do I debug when using WalletConnect?\n\n**A**: The transactionBuilder has placeholders, so `.debug()` won't work directly. Replace placeholders with a test wallet using SignatureTemplate with a private key (WIF format), then all debugging works.\n\n---\n\n### Datasig limitations\n**Q**: What are the limitations of datasigs with WalletConnect?\n\n**A**: Works well for standard signatures, but datasigs are problematic: using a hash placeholder means wallets blindly sign that hash (security issue), and without a hash, data length isn't deterministic.\n\n---\n\n## Ecosystem & Versions",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "transaction",
      "WalletConnect",
      "Built-in support",
      "Debugging with WalletConnect",
      "Datasig limitations",
      "Ecosystem & Versions"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-11",
    "content": "## Ecosystem & Versions\n\n### May 2025 upgrade (ACTIVE)\n**Q**: What features came with the May 2025 BCH upgrade?\n\n**A**: VM Limits removal and BigInt support, allowing more complex contracts. Stack element limit increased to 10,000 bytes.\n\n---\n\n### May 2026 upgrade (UPCOMING)\n**Q**: What's coming in May 2026?\n\n**A**: Native loops (OP_BEGIN/OP_UNTIL), 128-byte NFT commitments (up from 40 bytes), and P2S standard.\n\n---\n\n### Learning resources\n**Q**: How do I learn CashScript?\n\n**A**:\n- Official docs: cashscript.org\n- Video tutorials: youtube.com/watch?v=Ft2jo9spIHg\n- Interactive challenges: arena.layer1.cash\n- Telegram: t.me/CashScript\n\n---\n\n### Reference implementations\n**Q**: Where can I find advanced open-source contracts?\n\n**A**: ParityUSD open-sourced 26 contracts forming one of the most advanced BCH applications. See parityusd.com/blog/open-source-contracts\n\n---\n\n## Quick Reference Links",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "bytes",
      "Ecosystem & Versions",
      "May 2025 upgrade (ACTIVE)",
      "May 2026 upgrade (UPCOMING)",
      "Learning resources",
      "Reference implementations",
      "Quick Reference Links"
    ]
  },
  {
    "id": "Knowledge-Base-V2/FAQ_DISTILLED.md-12",
    "content": "## Quick Reference Links\n\n- **Core Language Reference**: See `CORE_REFERENCE.md`\n- **Security & Architecture**: See `SECURITY_ARCHITECTURE.md`\n- **CashScript Docs**: cashscript.org/docs/\n- **Playground**: playground.cashscript.org\n- **Telegram**: t.me/CashScript",
    "source": "Knowledge-Base-V2/FAQ_DISTILLED.md",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "Quick Reference Links"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// COMMON MISTAKE: Array Bounds Violation\r\n// SEVERITY: Critical (consensus failure, transaction rejection)\r\n// CATEGORY: Memory Safety\r\n\r\n// MISTAKE DESCRIPTION:\r\n// Accessing array elements (tx.inputs, tx.outputs) without validating that the index\r\n// is within bounds. In CashScript (and Bitcoin Script), out-of-bounds array access\r\n// causes script evaluation to fail, resulting in consensus rejection of the transaction.\r\n// This can brick contracts or create denial-of-service conditions.\r\n\r\n// WHY THIS IS CRITICAL:\r\n// - Out-of-bounds access causes immediate script failure (consensus-level rejection)\r\n// - Transaction is invalid and will never be accepted by the network\r\n// - Can brick contracts if bounds depend on deployment parameters\r\n// - Can create DoS if attacker controls array length (e.g., tx.inputs.length)\r\n// - No recovery mechanism for bricked contracts (immutable)\r\n// - Different from traditional languages: no runtime exception, just consensus failure\r\n\r\n// COMMON SCENARIOS:\r\n// 1. Accessing tx.inputs[N] without checking tx.inputs.length > N\r\n// 2. Accessing tx.outputs[N] without checking tx.outputs.length > N\r\n// 3. Using hardcoded indices with dynamic array lengths\r\n// 4. Iterating over arrays without bounds validation\r\n// 5. Using user-provided indices without validation\r\n// 6. Assuming minimum array lengths without enforcement\r\n\r\n// BCH COVENANT SPECIFIC RISKS:\r\n// - tx.inputs and tx.outputs are runtime-determined arrays\r\n// - Attacker can control array lengths by constructing transactions",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "transaction",
      "covenant"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-1",
    "content": "// - Contract assumes specific input/output counts without validation\r\n// - this.activeInputIndex may be out of bounds if not validated\r\n// - Multi-input contracts are especially vulnerable\r\n\r\n// ❌ VULNERABLE EXAMPLE: NFT refund without bounds checking\r\ncontract CrowdfundingVulnerable(\r\n    pubkey campaign,\r\n    int fundingGoal,\r\n    int deadline,\r\n    bytes32 nftCategory\r\n) {\r\n    function refund(\r\n        sig pledgerSig,\r\n        pubkey pledger,\r\n        bytes pledgerRefundOutput,\r\n        int refundAmount,\r\n        int nftInputIndex  // User-provided index - UNCHECKED\r\n    ) {\r\n        require(checkSig(pledgerSig, pledger));\r\n        require(tx.time >= deadline);\r\n        \r\n        int campaignValue = tx.inputs[this.activeInputIndex].value;\r\n        require(campaignValue < fundingGoal);\r\n        \r\n        // VULNERABLE: No check that nftInputIndex is within bounds\r\n        // If nftInputIndex >= tx.inputs.length, script fails\r\n        // 💥 OUT-OF-BOUNDS ACCESS: Script fails if index is invalid\r\n        // Transaction rejected by consensus\r\n        require(tx.inputs[nftInputIndex].tokenCategory == nftCategory);\r\n        \r\n        // VULNERABLE: No check that nftInputIndex is within bounds\r\n        // 💥 OUT-OF-BOUNDS ACCESS: Script fails if index is invalid\r\n        require(tx.inputs[nftInputIndex].tokenAmount == 0);\r\n        \r\n        require(tx.outputs.length >= 1);\r\n        require(tx.outputs[0].value == refundAmount);\r\n    }\r\n}\r\n\r\n// CONSEQUENCES OF THE VULNERABLE EXAMPLE:",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-2",
    "content": "// Attack Scenario 1: Index too large\r\n// - Attacker provides nftInputIndex = 999\r\n// - tx.inputs.length = 2 (only 2 inputs)\r\n// - tx.inputs[999] is out of bounds\r\n// - Script fails, transaction rejected\r\n// - Legitimate refund is DoS'd\r\n//\r\n// Attack Scenario 2: Negative index (if allowed by type system)\r\n// - Attacker provides nftInputIndex = -1\r\n// - Negative indices cause out-of-bounds access\r\n// - Script fails, transaction rejected\r\n//\r\n// Attack Scenario 3: Index equals activeInputIndex\r\n// - Contract checks nftInputIndex != this.activeInputIndex\r\n// - But doesn't check bounds first\r\n// - If attacker uses nftInputIndex >= length, bounds check happens first\r\n// - Script fails before inequality check\r\n\r\n// ✅ SECURE EXAMPLE: Refund with explicit bounds validation\r\ncontract CrowdfundingSecure(\r\n    pubkey campaign,\r\n    int fundingGoal,\r\n    int deadline,\r\n    bytes32 nftCategory\r\n) {\r\n    function refund(\r\n        sig pledgerSig,\r\n        pubkey pledger,\r\n        bytes pledgerRefundOutput,\r\n        int refundAmount,\r\n        int nftInputIndex  // User-provided index - VALIDATED\r\n    ) {\r\n        require(checkSig(pledgerSig, pledger));\r\n        require(tx.time >= deadline);\r\n        \r\n        int campaignValue = tx.inputs[this.activeInputIndex].value;\r\n        require(campaignValue < fundingGoal);\r\n        \r\n        // ✅ CRITICAL VALIDATION: Input count check\r\n        // Ensures we have at least 2 inputs (campaign + NFT)\r\n        require(tx.inputs.length >= 2);\r\n        \r\n        // ✅ CRITICAL VALIDATION: Bounds check for user-provided index",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-3",
    "content": "// This ensures nftInputIndex is within valid range\r\n        // Must be checked BEFORE accessing array element\r\n        require(nftInputIndex >= 0);\r\n        require(nftInputIndex < tx.inputs.length);\r\n        \r\n        // ✅ CORRECTNESS VALIDATION: NFT input is not the campaign input\r\n        // Prevents using the same input for both purposes\r\n        require(nftInputIndex != this.activeInputIndex);\r\n        \r\n        // Now safe: nftInputIndex is guaranteed to be valid\r\n        // ✅ SAFE ACCESS: Bounds validated before access\r\n        require(tx.inputs[nftInputIndex].tokenCategory == nftCategory);\r\n        require(tx.inputs[nftInputIndex].tokenAmount == 0);\r\n        \r\n        require(tx.outputs.length >= 1);\r\n        require(tx.outputs[0].value == refundAmount);\r\n    }\r\n}\r\n\r\n// WHY THE SECURE EXAMPLE WORKS:\r\n// - require(tx.inputs.length >= 2) ensures minimum array size (CRITICAL)\r\n// - require(nftInputIndex >= 0) prevents negative indices (CRITICAL)\r\n// - require(nftInputIndex < tx.inputs.length) prevents out-of-bounds (CRITICAL)\r\n// - require(nftInputIndex != this.activeInputIndex) prevents logic errors (CORRECTNESS)\r\n// - All checks happen BEFORE array access\r\n// - If any check fails, transaction rejected with clear error (not bricked)\r\n// - Attacker cannot cause out-of-bounds access (DoS prevented)\r\n\r\n// SEVERITY CLASSIFICATION:\r\n// NexOps classifies array bounds issues by severity:\r\n//\r\n// SEVERITY: Critical (Consensus Failure)\r\n// - Out-of-bounds array access without bounds validation",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-4",
    "content": "// - Consequence: Transaction rejection, potential contract bricking, DoS\r\n// - Detection: AST-level - array access nodes without dominating bounds check\r\n// - Prevention: Mandatory bounds validation before array access\r\n//\r\n// SEVERITY: High (Logic Correctness)\r\n// - Using hardcoded indices with dynamic arrays\r\n// - Consequence: Unexpected behavior when array length varies\r\n// - Detection: AST-level - literal indices with runtime arrays\r\n// - Prevention: Explicit length validation or dynamic index calculation\r\n//\r\n// SEVERITY: Medium (Defensive Programming)\r\n// - Accessing this.activeInputIndex without validation\r\n// - Consequence: Potential issues if contract used in unexpected ways\r\n// - Detection: AST-level - activeInputIndex usage patterns\r\n// - Prevention: Validate activeInputIndex < tx.inputs.length\r\n\r\n// STRUCTURAL INVARIANT FOR NEXOPS:\r\n// AST-Level Rule: Array Bounds Safety Invariant\r\n// For every AST node of type:\r\n// - MemberExpression accessing tx.inputs[index]\r\n// - MemberExpression accessing tx.outputs[index]\r\n// Where index is:\r\n// - A variable (not a literal constant)\r\n// - A user-provided parameter\r\n// - A calculated expression\r\n// There must exist DOMINATING require() statements that ensure:\r\n// - index >= 0 (if index could be negative)\r\n// - index < array.length (prevents out-of-bounds)\r\n// Where \"dominating\" means:\r\n// - The require() executes in ALL code paths leading to the access\r\n// - The require() executes BEFORE the access in control flow\r\n// - No intermediate code can modify the index between check and use",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-5",
    "content": "//\r\n// For literal indices (e.g., tx.inputs[0], tx.outputs[1]):\r\n// - There must exist a require() ensuring array.length > literalIndex\r\n\r\n// DETECTION RULES (AST-BASED):\r\n// 1. Parse contract into Abstract Syntax Tree (AST)\r\n// 2. Identify all MemberExpression nodes accessing:\r\n//    - tx.inputs[...]\r\n//    - tx.outputs[...]\r\n// 3. Extract the index expression for each access\r\n// 4. Classify index type:\r\n//    a. Literal constant (e.g., 0, 1, 2)\r\n//    b. Variable/parameter (e.g., nftInputIndex, outputIndex)\r\n//    c. Expression (e.g., this.activeInputIndex + 1)\r\n// 5. For each access, perform control flow analysis:\r\n//    a. Find all paths to this array access\r\n//    b. Verify dominating require() for array.length\r\n//    c. If index is variable/expression, verify bounds check\r\n// 6. Flag violations based on severity:\r\n//    - No length check: CRITICAL\r\n//    - No bounds check on variable index: CRITICAL\r\n//    - Literal index without length validation: HIGH\r\n\r\n// COMMON ARRAY ACCESS PATTERNS:\r\n\r\n// Pattern 1: Hardcoded index (literal)\r\n// ❌ VULNERABLE:\r\n// tx.outputs[0].value  // No length check\r\n//\r\n// ✅ SECURE:\r\n// require(tx.outputs.length >= 1);\r\n// tx.outputs[0].value\r\n\r\n// Pattern 2: User-provided index\r\n// ❌ VULNERABLE:\r\n// tx.inputs[userIndex].value  // No bounds check\r\n//\r\n// ✅ SECURE:\r\n// require(userIndex >= 0);\r\n// require(userIndex < tx.inputs.length);\r\n// tx.inputs[userIndex].value\r\n\r\n// Pattern 3: this.activeInputIndex\r\n// ⚠️ USUALLY SAFE (consensus enforces validity)",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-6",
    "content": "// tx.inputs[this.activeInputIndex].value\r\n//\r\n// ✅ DEFENSIVE:\r\n// require(this.activeInputIndex < tx.inputs.length);\r\n// tx.inputs[this.activeInputIndex].value\r\n\r\n// Pattern 4: Calculated index\r\n// ❌ VULNERABLE:\r\n// tx.outputs[outputCount - 1].value  // No validation\r\n//\r\n// ✅ SECURE:\r\n// require(outputCount > 0);\r\n// require(outputCount <= tx.outputs.length);\r\n// tx.outputs[outputCount - 1].value\r\n\r\n// SPECIAL CASE: this.activeInputIndex\r\n// The this.activeInputIndex is guaranteed by consensus to be valid\r\n// HOWEVER, defensive programming still recommends validation:\r\n// require(this.activeInputIndex < tx.inputs.length);\r\n// This protects against:\r\n// - Future CashScript implementation changes\r\n// - Unexpected edge cases\r\n// - Makes code intent explicit for auditors\r\n\r\n// BCH COVENANT SPECIFIC CONSIDERATIONS:\r\n// 1. tx.inputs.length is runtime-determined\r\n//    - Attacker can control by adding/removing inputs\r\n//    - Always validate before using as bounds\r\n//\r\n// 2. tx.outputs.length is runtime-determined\r\n//    - Attacker can control by adding/removing outputs\r\n//    - Many contracts explicitly require exact output count\r\n//\r\n// 3. Multi-input contracts are high-risk\r\n//    - Must validate all input indices\r\n//    - Must validate input count matches expectations\r\n//\r\n// 4. Output validation patterns:\r\n//    - Option A: Exact count (require tx.outputs.length == N)\r\n//    - Option B: Minimum count (require tx.outputs.length >= N)\r\n//    - Both prevent out-of-bounds on subsequent accesses",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-7",
    "content": "// CORRECT PROTECTION PATTERNS:\r\n// ✅ For literal index N:\r\n//    require(array.length > N);\r\n//    array[N]\r\n//\r\n// ✅ For variable index:\r\n//    require(index >= 0);\r\n//    require(index < array.length);\r\n//    array[index]\r\n//\r\n// ✅ For calculated index:\r\n//    require(expression >= 0);\r\n//    require(expression < array.length);\r\n//    array[expression]\r\n//\r\n// ✅ For this.activeInputIndex (defensive):\r\n//    require(this.activeInputIndex < tx.inputs.length);\r\n//    tx.inputs[this.activeInputIndex]\r\n\r\n// BEST PRACTICES:\r\n// 1. Always validate array lengths before accessing elements\r\n// 2. Validate user-provided indices with both lower and upper bounds\r\n// 3. Use exact length requirements when possible (tx.outputs.length == N)\r\n// 4. Place validation checks as early as possible in the function\r\n// 5. Document WHY each array access is safe in comments\r\n// 6. Test with edge cases (empty arrays, maximum indices, off-by-one)\r\n// 7. Use NexOps static analysis to detect missing bounds checks\r\n// 8. Prefer exact output counts over minimum counts (reduces attack surface)\r\n\r\n// DEPLOYMENT VALIDATION:\r\n// Before deploying contracts with array access:\r\n// - Verify all literal indices have corresponding length checks\r\n// - Verify all variable indices have bounds validation\r\n// - Test with minimum and maximum valid array lengths\r\n// - Test with off-by-one indices (length-1, length, length+1)\r\n// - Ensure error messages clearly indicate bounds violations\r\n\r\n// RELATIONSHIP TO OTHER ANTI-PATTERNS:",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "function"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-8",
    "content": "// - Related to implicit_output_ordering (both need explicit validation)\r\n// - Connected to unvalidated_position (similar validation patterns)\r\n// - Often combined with fee_assumption_violation\r\n// - Part of general input validation discipline\r\n\r\n// NEXOPS ENFORCEMENT:\r\n// NexOps MUST:\r\n// 1. Parse contracts into AST representation\r\n// 2. Identify all tx.inputs[...] and tx.outputs[...] access nodes\r\n// 3. Extract index expressions (literal, variable, calculated)\r\n// 4. Perform control flow analysis to find dominating bounds checks\r\n// 5. Verify bounds validation exists in ALL code paths\r\n// 6. Flag violations by severity:\r\n//    - CRITICAL: Variable index without bounds check\r\n//    - HIGH: Literal index without length check\r\n//    - MEDIUM: Missing defensive activeInputIndex validation\r\n// 7. Provide actionable error messages with suggested fixes\r\n// 8. Reject contracts with CRITICAL violations\r\n\r\n// AUDIT CHECKLIST FOR ARRAY ACCESS:\r\n// [ ] Identify all tx.inputs[...] accesses (AST scan)\r\n// [ ] Identify all tx.outputs[...] accesses (AST scan)\r\n// [ ] For each access, extract index expression\r\n// [ ] Classify index: literal, variable, or calculated\r\n// [ ] Verify array.length validation exists before access\r\n// [ ] For variable indices, verify bounds check (>= 0 and < length)\r\n// [ ] For literal indices, verify length check (length > literal)\r\n// [ ] Check that validation happens BEFORE access in all paths\r\n// [ ] Verify no code between validation and access modifies index\r\n// [ ] Test with edge cases (empty arrays, max indices, off-by-one)",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-9",
    "content": "// [ ] Document why each access is safe in code comments\r\n// [ ] Run NexOps static analyzer to verify all accesses are protected\r\n\r\n// TESTING RECOMMENDATIONS:\r\n// - Test with tx.inputs.length = 0 (empty inputs - should fail gracefully)\r\n// - Test with tx.inputs.length = 1 (minimum inputs)\r\n// - Test with userIndex = -1 (negative index - should fail)\r\n// - Test with userIndex = tx.inputs.length (equal to length - should fail)\r\n// - Test with userIndex = tx.inputs.length + 1 (beyond length - should fail)\r\n// - Test with userIndex = 999 (far beyond length - should fail)\r\n// - Test with valid indices (0 to length-1 - should succeed)\r\n// - Use fuzzing to test random array lengths and indices\r\n\r\n// REAL-WORLD IMPACT:\r\n// - DoS risk: Attacker can prevent legitimate transactions\r\n// - Bricking risk: Contract becomes unusable if bounds depend on parameters\r\n// - User impact: Cannot execute valid operations\r\n// - Reputation damage: Protocol appears broken or poorly designed\r\n// - Prevention cost: Minimal (a few require statements)\r\n// - Fix cost: Impossible if contract is bricked (immutable)\r\n\r\n// EXAMPLE NEXOPS ERROR MESSAGE:\r\n// ❌ CRITICAL: Out-of-bounds array access risk detected\r\n// File: crowdfunding_refundable.cash\r\n// Line: 58\r\n// Expression: tx.inputs[nftInputIndex].tokenCategory\r\n// Issue: Index 'nftInputIndex' is user-provided and not bounds-checked\r\n// Fix: Add bounds validation before access:\r\n//       require(nftInputIndex >= 0);\r\n//       require(nftInputIndex < tx.inputs.length);",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/array_bounds.cash-10",
    "content": "// Severity: Critical (consensus failure, DoS risk)",
    "source": "NexKB/common_mistakes/array_bounds.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// COMMON MISTAKE: Division by Zero\r\n// SEVERITY: Critical (consensus failure, contract bricking)\r\n// CATEGORY: Arithmetic Safety\r\n\r\n// MISTAKE DESCRIPTION:\r\n// Performing division or modulo operations without validating that the divisor is non-zero.\r\n// In CashScript (and Bitcoin Script), division by zero causes script evaluation to fail,\r\n// resulting in consensus rejection of the transaction. This bricks the contract permanently\r\n// if the zero divisor is derived from contract parameters or input data.\r\n\r\n// WHY THIS IS CRITICAL:\r\n// - Division by zero causes immediate script failure (consensus-level rejection)\r\n// - Transaction is invalid and will never be accepted by the network\r\n// - Funds locked in the contract become permanently unspendable\r\n// - No recovery mechanism exists once deployed with vulnerable parameters\r\n// - Even a single division by zero path bricks the entire contract\r\n// - This is NOT a vulnerability that can be exploited - it's a denial of service to everyone\r\n\r\n// COMMON SCENARIOS:\r\n// 1. Vesting schedules with identical start and end times\r\n// 2. Price calculations with zero duration periods\r\n// 3. Proportional splits with zero total supply\r\n// 4. Reward calculations with zero staking period\r\n// 5. Linear interpolation with zero range\r\n// 6. Any formula using (endTime - startTime) where times could be equal\r\n\r\n// ❌ VULNERABLE EXAMPLE: Vesting without duration validation\r\ncontract VestingVulnerable(\r\n    pubkey beneficiary,",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-1",
    "content": "int vestingStart,\r\n    int vestingEnd,\r\n    int totalAmount\r\n) {\r\n    function claim(sig beneficiarySig, int claimAmount) {\r\n        require(checkSig(beneficiarySig, beneficiary));\r\n        \r\n        // VULNERABLE: No check that vestingEnd > vestingStart\r\n        // If vestingEnd == vestingStart, this divides by zero\r\n        int duration = vestingEnd - vestingStart;\r\n        \r\n        // 💥 DIVISION BY ZERO: Script fails if duration == 0\r\n        // Contract is permanently bricked - funds are lost\r\n        int vestedAmount = (totalAmount * (tx.time - vestingStart)) / duration;\r\n        \r\n        require(claimAmount <= vestedAmount);\r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].value == claimAmount);\r\n    }\r\n}\r\n\r\n// CONSEQUENCES OF THE VULNERABLE EXAMPLE:\r\n// - If deployed with vestingStart == vestingEnd (even by accident):\r\n//   - First claim attempt will divide by zero\r\n//   - Transaction will fail at consensus level\r\n//   - No transaction can ever spend this UTXO\r\n//   - Funds are permanently locked (bricked)\r\n//   - No recovery possible (contract is immutable)\r\n// - This is a DEPLOYMENT ERROR, not an attack vector\r\n// - Prevention MUST happen before deployment\r\n\r\n// ✅ SECURE EXAMPLE: Vesting with explicit duration validation\r\ncontract VestingSecure(\r\n    pubkey beneficiary,\r\n    int vestingStart,\r\n    int vestingEnd,\r\n    int totalAmount\r\n) {\r\n    function claim(sig beneficiarySig, int claimAmount) {\r\n        require(checkSig(beneficiarySig, beneficiary));",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-2",
    "content": "// ✅ CRITICAL VALIDATION: Prevent division by zero\r\n        // This ensures duration is always positive and non-zero\r\n        // Must be checked BEFORE any division operation\r\n        require(vestingEnd > vestingStart);\r\n        \r\n        // ✅ CORRECTNESS VALIDATION: Prevent negative vesting math\r\n        // This ensures we're not claiming before vesting starts\r\n        // Improves audit logic clarity and prevents ambiguous behavior\r\n        require(tx.time >= vestingStart);\r\n        \r\n        // Now safe: duration is guaranteed to be > 0\r\n        int duration = vestingEnd - vestingStart;\r\n        \r\n        // ✅ SAFE DIVISION: Cannot divide by zero\r\n        // elapsed = tx.time - vestingStart is guaranteed >= 0\r\n        int elapsed = tx.time - vestingStart;\r\n        int vestedAmount = (totalAmount * elapsed) / duration;\r\n        \r\n        require(claimAmount <= vestedAmount);\r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].value == claimAmount);\r\n    }\r\n}\r\n\r\n// WHY THE SECURE EXAMPLE WORKS:\r\n// - require(vestingEnd > vestingStart) guarantees duration > 0 (CRITICAL)\r\n// - require(tx.time >= vestingStart) guarantees elapsed >= 0 (CORRECTNESS)\r\n// - Both checks happen BEFORE the division operation\r\n// - If either check fails, transaction is rejected with clear error\r\n// - Funds remain spendable (contract not bricked)\r\n// - Deployment errors are caught before funds are locked\r\n// - Simple, explicit, and foolproof protection\r\n\r\n// SEVERITY CLASSIFICATION:",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "transaction",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-3",
    "content": "// NexOps classifies arithmetic safety issues by severity:\r\n//\r\n// SEVERITY: Critical (Consensus Bricking)\r\n// - Division by zero: / or % with unchecked divisor\r\n// - Consequence: Permanent fund loss, contract unusable\r\n// - Detection: AST-level - division/modulo nodes without dominating require\r\n// - Prevention: Mandatory divisor > 0 validation\r\n//\r\n// SEVERITY: High (Silent Miscalculation)\r\n// - Integer overflow in multiplication or addition\r\n// - Consequence: Incorrect amounts, potential fund loss\r\n// - Detection: AST-level - arithmetic operations on unbounded inputs\r\n// - Prevention: Bounded input validation, explicit overflow checks\r\n//\r\n// SEVERITY: Medium (Logic Correctness)\r\n// - Negative time calculations: (tx.time - start) without start <= tx.time check\r\n// - Consequence: Unexpected behavior, potential logic errors\r\n// - Detection: AST-level - subtraction used in critical calculations\r\n// - Prevention: Explicit ordering validation (tx.time >= start)\r\n//\r\n// This classification helps NexOps audit agents prioritize issues deterministically.\r\n\r\n// STRUCTURAL INVARIANT FOR NEXOPS:\r\n// AST-Level Rule: Division Safety Invariant\r\n// For every AST node of type:\r\n// - BinaryExpression with operator '/' (division)\r\n// - BinaryExpression with operator '%' (modulo)\r\n// There must exist a DOMINATING require() statement that ensures:\r\n// - divisor > 0 (for positive-only divisors)\r\n// - OR divisor != 0 (for divisors that can be negative but not zero)\r\n// Where \"dominating\" means:\r\n// - The require() executes in ALL code paths leading to the division",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-4",
    "content": "// - The require() executes BEFORE the division in control flow\r\n// - No intermediate code can modify the divisor between check and use\r\n\r\n// DETECTION RULES (AST-BASED):\r\n// 1. Parse contract into Abstract Syntax Tree (AST)\r\n// 2. Identify all BinaryExpression nodes with operator '/' or '%'\r\n// 3. Extract the right operand (divisor) of each division/modulo\r\n// 4. Perform control flow analysis to find all paths to this node\r\n// 5. For each path, verify a require() statement exists that:\r\n//    a. References the same divisor variable or expression\r\n//    b. Enforces divisor > 0 or divisor != 0\r\n//    c. Dominates the division node (executes before in all paths)\r\n// 6. If any path lacks this dominating require(), flag as CRITICAL\r\n\r\n// TEXTUAL PATTERNS (SUPPLEMENTARY):\r\n// While AST analysis is primary, these textual patterns help identify candidates:\r\n// ❌ (endTime - startTime) without require(endTime > startTime)\r\n// ❌ (total - used) without require(total > used)\r\n// ❌ userInput without require(userInput != 0)\r\n// ❌ (price * quantity) / total without require(total > 0)\r\n// ❌ balance / count without require(count > 0)\r\n\r\n// CORRECT PROTECTION PATTERNS:\r\n// ✅ require(divisor > 0) before division (for positive-only divisors)\r\n// ✅ require(divisor != 0) before division (for divisors that can be negative)\r\n// ✅ require(endTime > startTime) before using (endTime - startTime)\r\n// ✅ require(total >= used) before using (total - used) as divisor\r\n// ✅ Early validation at the start of the function (minimizes code paths)",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-5",
    "content": "// MODULO OPERATIONS:\r\n// The modulo operator (%) has the same division-by-zero risk\r\n// ❌ value % divisor  // Fails if divisor == 0\r\n// ✅ require(divisor > 0); value % divisor\r\n\r\n// BEST PRACTICES:\r\n// 1. Always validate divisors before division/modulo operations\r\n// 2. Use require(divisor > 0) not require(divisor != 0) when dealing with durations/counts\r\n// 3. Place validation checks as early as possible in the function\r\n// 4. Document WHY each division is safe in comments\r\n// 5. In deployment scripts, validate parameters before contract creation\r\n// 6. Use NexOps static analysis to detect potential division by zero\r\n// 7. Test with edge case parameters (equal times, zero values, etc.)\r\n// 8. Add correctness checks (like tx.time >= vestingStart) to prevent negative math\r\n\r\n// DEPLOYMENT VALIDATION:\r\n// Before deploying contracts with division operations, validate:\r\n// - vestingEnd > vestingStart (for vesting contracts)\r\n// - auctionEnd > auctionStart (for auction contracts)\r\n// - priceDecayEnd > priceDecayStart (for Dutch auctions)\r\n// - totalSupply > 0 (for proportional distributions)\r\n// - Any subtraction used as a divisor results in positive value\r\n\r\n// RELATIONSHIP TO OTHER ANTI-PATTERNS:\r\n// - Often combined with unenforced parameter constraints\r\n// - Can occur in price calculation formulas\r\n// - Common in time-based linear interpolation\r\n// - Related to general arithmetic overflow/underflow concerns\r\n// - Connected to implicit_output_ordering (both require explicit validation)",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-6",
    "content": "// NEXOPS ENFORCEMENT:\r\n// NexOps MUST:\r\n// 1. Parse contracts into AST representation\r\n// 2. Identify all division (/) and modulo (%) nodes\r\n// 3. Perform control flow analysis to find dominating require() statements\r\n// 4. Verify divisor validation exists in ALL code paths\r\n// 5. Flag any division without dominating bounds checking as CRITICAL\r\n// 6. Validate deployment parameters before contract creation\r\n// 7. Reject contracts with potential division by zero\r\n// 8. Provide clear error messages with:\r\n//    - Line number of vulnerable division\r\n//    - Divisor expression that needs validation\r\n//    - Suggested fix (require statement to add)\r\n\r\n// AUDIT CHECKLIST FOR DIVISION OPERATIONS:\r\n// [ ] Identify all division (/) and modulo (%) operations (AST scan)\r\n// [ ] For each operation, extract divisor expression\r\n// [ ] Trace divisor to its source (parameter, calculation, or input)\r\n// [ ] Verify require(divisor > 0) or require(divisor != 0) exists\r\n// [ ] Verify require executes in ALL code paths leading to division (dominance)\r\n// [ ] Check that validation happens BEFORE division, not after\r\n// [ ] Verify no code between validation and division modifies divisor\r\n// [ ] Test with edge case parameters that could cause zero divisor\r\n// [ ] Validate deployment parameters prevent zero divisor scenarios\r\n// [ ] Check for negative math issues (add tx.time >= start checks)\r\n// [ ] Document why each division is safe in code comments\r\n// [ ] Run NexOps static analyzer to verify all divisions are protected",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/division_by_zero.cash-7",
    "content": "// TESTING RECOMMENDATIONS:\r\n// - Test with vestingStart == vestingEnd (should fail deployment validation)\r\n// - Test with tx.time < vestingStart (should fail with correctness check)\r\n// - Test with zero duration periods\r\n// - Test with minimal valid duration (e.g., 1 second)\r\n// - Test all edge cases where parameters could be equal\r\n// - Use fuzzing to test with random parameter combinations\r\n// - Verify error messages are clear and actionable\r\n\r\n// REAL-WORLD IMPACT:\r\n// - Funds lost: Potentially millions if large contract is deployed incorrectly\r\n// - User impact: Permanent loss, no recovery mechanism\r\n// - Reputation damage: Severe for protocol deploying bricked contracts\r\n// - Legal liability: Possible if negligence can be proven\r\n// - Prevention cost: Nearly zero (one or two require statements)\r\n// - Fix cost: Impossible (contract is immutable)\r\n\r\n// EXAMPLE NEXOPS ERROR MESSAGE:\r\n// ❌ CRITICAL: Division by zero risk detected\r\n// File: vesting_contract.cash\r\n// Line: 42\r\n// Expression: (totalAmount * elapsed) / duration\r\n// Issue: Divisor 'duration' may be zero\r\n// Fix: Add 'require(vestingEnd > vestingStart);' before division\r\n// Severity: Critical (consensus bricking)",
    "source": "NexKB/common_mistakes/division_by_zero.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// COMMON MISTAKE: Integer Overflow\r\n// SEVERITY: High (silent miscalculation, potential fund loss)\r\n// CATEGORY: Arithmetic Safety\r\n\r\n// MISTAKE DESCRIPTION:\r\n// Performing arithmetic operations (addition, multiplication, subtraction) without validating\r\n// that the result stays within safe bounds. In CashScript, integers are 64-bit signed values\r\n// with range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. Overflow causes\r\n// wraparound behavior (silent failure) rather than consensus failure, leading to incorrect\r\n// calculations and potential fund loss.\r\n\r\n// WHY THIS IS CRITICAL:\r\n// - Integer overflow wraps around silently (no error, no transaction failure)\r\n// - Can cause balances to become negative or unexpectedly small\r\n// - Can bypass validation checks (e.g., require(amount <= balance) with overflowed balance)\r\n// - Can result in incorrect payment amounts (underpayment or overpayment)\r\n// - Can break invariants that contracts rely on for safety\r\n// - Difficult to detect without careful analysis (no consensus rejection)\r\n// - Can be exploited maliciously or occur accidentally\r\n\r\n// COMMON SCENARIOS:\r\n// 1. Incrementing counters without upper bound checks\r\n// 2. Accumulating totals (sum of deposits, stakes, votes)\r\n// 3. Multiplying large values (price * quantity, amount * rate)\r\n// 4. Exponential growth calculations (compound interest, rewards)\r\n// 5. Time-based accumulations (rewards per second * elapsed time)\r\n// 6. Subtraction resulting in unexpectedly negative values",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "transaction"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-1",
    "content": "// BITCOIN SCRIPT INTEGER LIMITS:\r\n// - Minimum: -9223372036854775808 (-2^63)\r\n// - Maximum:  9223372036854775807 (2^63 - 1)\r\n// - Common satoshi amounts can overflow when multiplied by rates or time\r\n// - Example: 100,000,000 sats * 100,000,000 rate = overflow\r\n\r\n// ❌ VULNERABLE EXAMPLE: Counter without overflow protection\r\ncontract CounterVulnerable(\r\n    pubkey owner,\r\n    int currentCount  // Current counter value\r\n) {\r\n    function increment(\r\n        sig ownerSig,\r\n        int incrementAmount\r\n    ) {\r\n        require(checkSig(ownerSig, owner));\r\n        \r\n        // VULNERABLE: No check that currentCount + incrementAmount stays in bounds\r\n        // If currentCount = 9223372036854775807 (max int64)\r\n        // And incrementAmount = 1\r\n        // Then newCount wraps to -9223372036854775808 (min int64)\r\n        int newCount = currentCount + incrementAmount;\r\n        \r\n        // 💥 SILENT OVERFLOW: newCount may have wrapped around\r\n        // Contract continues executing with incorrect value\r\n        // No consensus failure, no error - just wrong math\r\n        \r\n        // This validation is USELESS after overflow\r\n        require(newCount > currentCount);  // Will fail after wraparound, but too late\r\n        \r\n        require(tx.outputs.length == 1);\r\n        // Output would encode the overflowed value, corrupting contract state\r\n    }\r\n}\r\n\r\n// CONSEQUENCES OF THE VULNERABLE EXAMPLE:\r\n// - If currentCount approaches max int64:\r\n//   - Increment causes wraparound to large negative number",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-2",
    "content": "//   - Contract state becomes corrupted\r\n//   - Future operations may fail or produce wrong results\r\n//   - Funds may be distributed incorrectly\r\n// - If used for access control (e.g., require(count < maxAllowed)):\r\n//   - Overflow could bypass the limit\r\n//   - Unauthorized access or withdrawals\r\n// - If used for calculations (e.g., rewards = count * rate):\r\n//   - Incorrect reward amounts\r\n//   - Potential fund drainage or shortfall\r\n\r\n// ❌ VULNERABLE EXAMPLE: Multiplication without bounds checking\r\ncontract RewardVulnerable(\r\n    pubkey staker,\r\n    int stakedAmount,\r\n    int rewardRate  // Reward per staked token per block\r\n) {\r\n    function claim(\r\n        sig stakerSig,\r\n        int blockElapsed\r\n    ) {\r\n        require(checkSig(stakerSig, staker));\r\n        \r\n        // VULNERABLE: No check that stakedAmount * rewardRate * blockElapsed stays in bounds\r\n        // Example: stakedAmount = 1,000,000,000 (10 BCH in sats)\r\n        //          rewardRate = 1,000,000 (1% per block in basis points)\r\n        //          blockElapsed = 10,000 blocks\r\n        // Result: 1,000,000,000 * 1,000,000 * 10,000 = overflow\r\n        int totalReward = stakedAmount * rewardRate * blockElapsed;\r\n        \r\n        // 💥 SILENT OVERFLOW: totalReward wraps around to negative or small value\r\n        // User receives incorrect reward (possibly negative, possibly tiny)\r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].value == totalReward);  // Wrong amount!\r\n    }\r\n}\r\n\r\n// ✅ SECURE EXAMPLE: Counter with explicit overflow protection",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-3",
    "content": "contract CounterSecure(\r\n    pubkey owner,\r\n    int currentCount,  // Current counter value\r\n    int maxCount       // Maximum allowed counter value\r\n) {\r\n    function increment(\r\n        sig ownerSig,\r\n        int incrementAmount\r\n    ) {\r\n        require(checkSig(ownerSig, owner));\r\n        \r\n        // ✅ INPUT VALIDATION: Ensure increment is positive and reasonable\r\n        require(incrementAmount > 0);\r\n        require(incrementAmount <= 1000000);  // Reasonable upper bound for single increment\r\n        \r\n        // ✅ OVERFLOW PREVENTION: Check that addition stays within bounds\r\n        // Method 1: Check against maximum allowed value BEFORE addition\r\n        require(currentCount <= maxCount - incrementAmount);\r\n        \r\n        // Alternative Method 2: Check against int64 max BEFORE addition\r\n        // require(currentCount <= 9223372036854775807 - incrementAmount);\r\n        \r\n        // Now safe: guaranteed not to overflow\r\n        int newCount = currentCount + incrementAmount;\r\n        \r\n        // ✅ POST-CONDITION VALIDATION: Verify result makes sense\r\n        require(newCount > currentCount);  // Should always be true if no overflow\r\n        require(newCount <= maxCount);     // Enforce maximum bound\r\n        \r\n        require(tx.outputs.length == 1);\r\n        // Output encodes safe, validated value\r\n    }\r\n}\r\n\r\n// WHY THE SECURE EXAMPLE WORKS:\r\n// - Pre-validates that currentCount + incrementAmount won't exceed maxCount\r\n// - Uses algebraic rearrangement: (a + b <= max) → (a <= max - b)",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-4",
    "content": "// - This avoids computing the potentially-overflowing sum\r\n// - Checks happen BEFORE the arithmetic operation\r\n// - Post-condition validation catches any logic errors\r\n// - Multiple layers of defense (input bounds, pre-check, post-check)\r\n\r\n// ✅ SECURE EXAMPLE: Safe multiplication with bounds checking\r\ncontract RewardSecure(\r\n    pubkey staker,\r\n    int stakedAmount,\r\n    int rewardRate,     // Reward per staked token per block (in basis points)\r\n    int maxBlockElapsed // Maximum claimable blocks (prevents overflow)\r\n) {\r\n    function claim(\r\n        sig stakerSig,\r\n        int blockElapsed\r\n    ) {\r\n        require(checkSig(stakerSig, staker));\r\n        \r\n        // ✅ INPUT VALIDATION: Ensure inputs are within safe ranges\r\n        require(blockElapsed > 0);\r\n        require(blockElapsed <= maxBlockElapsed);\r\n        \r\n        // ✅ OVERFLOW PREVENTION: Bound intermediate calculations\r\n        // Instead of: totalReward = stakedAmount * rewardRate * blockElapsed\r\n        // We compute in stages with bounds checking\r\n        \r\n        // First, check that stakedAmount * rewardRate won't overflow\r\n        // Safe threshold: if both < sqrt(max_int64) ≈ 3,037,000,499\r\n        require(stakedAmount <= 100000000000);  // 1000 BCH in sats (reasonable max stake)\r\n        require(rewardRate <= 10000);            // 100% reward rate in basis points\r\n        \r\n        int intermediateReward = stakedAmount * rewardRate;\r\n        \r\n        // Then check that intermediateReward * blockElapsed won't overflow",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-5",
    "content": "// Given our bounds above, intermediateReward <= 1,000,000,000,000\r\n        require(blockElapsed <= 9223372);  // maxBlockElapsed prevents overflow\r\n        \r\n        int totalReward = intermediateReward * blockElapsed;\r\n        \r\n        // ✅ SANITY CHECK: Ensure result is positive (catches negative wraparound)\r\n        require(totalReward > 0);\r\n        \r\n        // Typically, divide by basis points to get actual reward\r\n        int actualReward = totalReward / 10000;\r\n        \r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].value == actualReward);\r\n    }\r\n}\r\n\r\n// ALTERNATIVE SAFE PATTERN: Division before multiplication\r\n// For calculations like (amount * rate * time), consider:\r\n// - Rearrange to (amount * time) * rate if time is bounded\r\n// - Or compute amount * (rate / divisor) * time if rate can be reduced first\r\n// - Use smaller units (e.g., whole BCH instead of satoshis where possible)\r\n// - Cap individual factors to safe ranges\r\n\r\n// SEVERITY CLASSIFICATION:\r\n// NexOps classifies overflow issues by severity:\r\n//\r\n// SEVERITY: High (Silent Miscalculation)\r\n// - Integer overflow in multiplication or addition\r\n// - Consequence: Incorrect amounts, potential fund loss, bypassed checks\r\n// - Detection: AST-level - arithmetic operations on unbounded inputs\r\n// - Prevention: Bounded input validation, explicit overflow checks\r\n//\r\n// SEVERITY: Medium (Logic Correctness)\r\n// - Subtraction overflow (underflow to large positive)\r\n// - Consequence: Unexpected behavior, potential logic errors",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-6",
    "content": "// - Detection: AST-level - subtraction on user inputs\r\n// - Prevention: Explicit ordering validation (a >= b before a - b)\r\n//\r\n// SEVERITY: Critical (Consensus Bricking) - different anti-pattern\r\n// - Division by zero (not overflow, but related arithmetic issue)\r\n// - See: division_by_zero.cash\r\n\r\n// STRUCTURAL INVARIANT FOR NEXOPS:\r\n// AST-Level Rule: Overflow Safety Invariant\r\n// For every AST node of type:\r\n// - BinaryExpression with operator '+' (addition)\r\n// - BinaryExpression with operator '*' (multiplication)\r\n// - BinaryExpression with operator '-' (subtraction, for underflow)\r\n// Where operands are NOT compile-time constants:\r\n// There must exist DOMINATING require() statements that ensure:\r\n// - For addition (a + b): require(a <= MAX_SAFE - b) OR require(a + b <= MAX_SAFE)\r\n// - For multiplication (a * b): require(a <= MAX_SAFE / b) OR both bounded\r\n// - For subtraction (a - b): require(a >= b) OR require(a - b >= MIN_SAFE)\r\n// Where \"dominating\" means:\r\n// - The require() executes in ALL code paths leading to the operation\r\n// - The require() executes BEFORE the operation in control flow\r\n// - Operands are not modified between check and use\r\n\r\n// DETECTION RULES (AST-BASED):\r\n// 1. Parse contract into Abstract Syntax Tree (AST)\r\n// 2. Identify all arithmetic BinaryExpression nodes (+, *, -)\r\n// 3. Filter out operations where both operands are compile-time constants\r\n// 4. Extract operands of each arithmetic operation\r\n// 5. Perform control flow analysis to find all paths to this node",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-7",
    "content": "// 6. For each path, verify require() statements exist that:\r\n//    a. Bound the operands to safe ranges\r\n//    b. OR validate the result won't overflow\r\n//    c. Dominate the arithmetic node (execute before in all paths)\r\n// 7. If any path lacks dominating bounds, flag as HIGH severity\r\n\r\n// SAFE BOUNDS EXAMPLES:\r\n// ✅ require(a <= 1000000000) before a * b (if b is also bounded)\r\n// ✅ require(a <= MAX - b) before a + b\r\n// ✅ require(a >= b) before a - b (prevents underflow to large positive)\r\n// ✅ require(result > operand1) after addition (post-condition check)\r\n// ✅ require(result >= 0) after any operation (catches negative wraparound)\r\n\r\n// COMMON OVERFLOW PATTERNS TO AVOID:\r\n// ❌ counter++ without upper bound\r\n// ❌ total += amount without total <= MAX - amount check\r\n// ❌ price * quantity without bounding both factors\r\n// ❌ amount * rate * time without staged calculation and bounds\r\n// ❌ balance - withdrawal without balance >= withdrawal check\r\n\r\n// CORRECT PROTECTION PATTERNS:\r\n// ✅ require(counter < MAX_COUNTER) before counter + 1\r\n// ✅ require(total <= MAX_TOTAL - amount) before total + amount\r\n// ✅ require(price <= MAX / quantity) before price * quantity\r\n// ✅ require(a >= b) before a - b (for subtraction)\r\n// ✅ Bound all inputs to safe ranges at function entry\r\n// ✅ Use post-condition checks (require(result > operand))\r\n\r\n// BEST PRACTICES:\r\n// 1. Bound all external inputs at function entry (amounts, rates, times)\r\n// 2. Use pre-condition checks BEFORE arithmetic operations",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "function"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-8",
    "content": "// 3. Use post-condition checks AFTER arithmetic to verify sanity\r\n// 4. For multiplication, bound both factors to safe ranges\r\n// 5. For addition, check: a <= MAX - b before computing a + b\r\n// 6. For subtraction, check: a >= b before computing a - b\r\n// 7. Use smaller units when possible (whole BCH vs satoshis)\r\n// 8. Stage complex calculations with intermediate bounds checks\r\n// 9. Document maximum safe values for each parameter\r\n// 10. Test with boundary values (near max int64, near min int64)\r\n\r\n// DEPLOYMENT VALIDATION:\r\n// Before deploying contracts with arithmetic operations, validate:\r\n// - All input parameters have documented maximum safe values\r\n// - Multiplication factors are bounded appropriately\r\n// - Accumulator variables have maximum caps\r\n// - Time periods are bounded to prevent time * rate overflows\r\n// - Rate values are in safe ranges for multiplication\r\n\r\n// RELATIONSHIP TO OTHER ANTI-PATTERNS:\r\n// - Related to division_by_zero (both arithmetic safety)\r\n// - Connected to fee_assumption_violation (incorrect amount calculations)\r\n// - Can combine with unvalidated_position (overflow in array indexing)\r\n// - May interact with implicit_output_ordering (wrong amounts in outputs)\r\n\r\n// TESTING RECOMMENDATIONS:\r\n// - Test with values near max int64: 9223372036854775807\r\n// - Test with values near min int64: -9223372036854775808\r\n// - Test multiplication of large values (e.g., 1000000000 * 1000000000)\r\n// - Test accumulation over many iterations (counter increments)",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-9",
    "content": "// - Test time-based calculations with large elapsed times\r\n// - Use fuzzing with random large values\r\n// - Test boundary conditions (max allowed value, max + 1)\r\n// - Verify post-condition checks catch overflow attempts\r\n\r\n// REAL-WORLD IMPACT:\r\n// - Funds lost: Can range from minor to catastrophic depending on context\r\n// - User impact: Incorrect balances, unauthorized access, fund drainage\r\n// - Exploit potential: Attackers can trigger overflow to bypass limits\r\n// - Reputation damage: Severe if overflow leads to fund loss\r\n// - Detection difficulty: High (silent failure, no consensus error)\r\n// - Prevention cost: Low (bounds checking requires minimal code)\r\n// - Fix cost: High if contract is already deployed (requires migration)\r\n\r\n// NEXOPS ENFORCEMENT:\r\n// NexOps MUST:\r\n// 1. Parse contracts into AST representation\r\n// 2. Identify all arithmetic operations on non-constant values\r\n// 3. Perform control flow analysis to find dominating require() statements\r\n// 4. Verify bounds checking exists in ALL code paths\r\n// 5. Flag any unbounded arithmetic as HIGH severity\r\n// 6. Validate that bounds are appropriate for the use case\r\n// 7. Check for post-condition validation after arithmetic\r\n// 8. Provide clear error messages with:\r\n//    - Line number of vulnerable operation\r\n//    - Operands that need bounding\r\n//    - Suggested fix (require statements to add)\r\n//    - Maximum safe values for the context\r\n\r\n// AUDIT CHECKLIST FOR ARITHMETIC OPERATIONS:\r\n// [ ] Identify all addition, multiplication, subtraction operations (AST scan)",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract"
    ]
  },
  {
    "id": "NexKB/common_mistakes/integer_overflow.cash-10",
    "content": "// [ ] For each operation, determine if operands are compile-time constants\r\n// [ ] If not constant, verify bounds checking exists\r\n// [ ] For addition (a + b): verify require(a <= MAX - b) or equivalent\r\n// [ ] For multiplication (a * b): verify both a and b are bounded\r\n// [ ] For subtraction (a - b): verify require(a >= b) or equivalent\r\n// [ ] Verify bounds checking dominates arithmetic in all code paths\r\n// [ ] Check that bounds are appropriate for the use case\r\n// [ ] Verify post-condition checks exist (result > operand, result >= 0)\r\n// [ ] Test with boundary values near int64 limits\r\n// [ ] Document maximum safe values for all parameters\r\n// [ ] Run NexOps static analyzer to verify all operations are protected\r\n\r\n// EXAMPLE NEXOPS ERROR MESSAGE:\r\n// ❌ HIGH: Integer overflow risk detected\r\n// File: reward_contract.cash\r\n// Line: 67\r\n// Expression: stakedAmount * rewardRate * blockElapsed\r\n// Issue: Multiplication may overflow int64 bounds\r\n// Fix: Add bounds checking before multiplication:\r\n//   require(stakedAmount <= 100000000000);  // 1000 BCH max\r\n//   require(rewardRate <= 10000);           // 100% max rate\r\n//   require(blockElapsed <= maxBlocks);\r\n// Severity: High (silent miscalculation)\r\n// Max safe values:\r\n//   stakedAmount * rewardRate must be < 9223372036854775807 / blockElapsed",
    "source": "NexKB/common_mistakes/integer_overflow.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-0",
    "content": "pragma cashscript ^0.13.0;\r\n\r\n// COMMON MISTAKE: State Corruption via Invalid Transitions\r\n// SEVERITY: Critical (fund loss, logic bypass, protocol violation)\r\n// CATEGORY: Covenant Continuation Safety\r\n\r\n// MISTAKE DESCRIPTION:\r\n// Allowing state transitions that violate contract invariants by failing to validate\r\n// that covenant continuation outputs maintain required state properties. This includes\r\n// state length mismatches, invalid state values, unauthorized state mutations, and\r\n// missing state fields. In stateful covenants, the contract must cryptographically\r\n// enforce that its future self maintains all required properties.\r\n\r\n// WHY THIS IS CRITICAL:\r\n// - State corruption allows bypassing contract logic and security guarantees\r\n// - Attacker can craft continuation states that violate invariants\r\n// - Can lead to fund theft, unauthorized withdrawals, or protocol violations\r\n// - Breaks the fundamental covenant model (self-enforcing rules)\r\n// - Once corrupted state is committed, it cannot be reversed (immutable)\r\n// - Undermines trust in the entire covenant system\r\n\r\n// COMMON SCENARIOS:\r\n// 1. Not validating continuation contract lockingBytecode matches expected structure\r\n// 2. State length mismatches (e.g., 32-byte hash becomes 16 bytes)\r\n// 3. Missing required state fields in continuation\r\n// 4. Allowing state mutations that violate invariants\r\n// 5. Not validating serialized state format\r\n// 6. Trusting builder-provided continuation without verification\r\n// 7. Partial state validation (checking some fields but not all)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-1",
    "content": "// COVENANT STATE MODEL:\r\n// A stateful covenant recreates itself with updated state:\r\n// Input: Contract(state1) → Output: Contract(state2)\r\n// The contract MUST validate that state2 is a valid successor to state1\r\n// This is NOT enforced automatically - it requires explicit validation\r\n\r\n// ❌ VULNERABLE EXAMPLE: Counter without state validation\r\ncontract CounterVulnerable(\r\n    bytes32 stateHash  // Hash of current counter state\r\n) {\r\n    // Increment counter and continue with new state\r\n    function increment(\r\n        bytes currentState,     // Current counter value (serialized)\r\n        bytes32 newStateHash,   // Hash of new counter value (UNCHECKED)\r\n        bytes newContractOutput // Continuation contract output (UNCHECKED)\r\n    ) {\r\n        // VULNERABLE: No validation that currentState matches stateHash\r\n        // Attacker can provide arbitrary currentState\r\n        // 💥 STATE CORRUPTION: Can claim any current value\r\n        \r\n        // VULNERABLE: No validation of currentState format/length\r\n        // Attacker can provide malformed state\r\n        // 💥 STATE LENGTH MISMATCH: Can break state assumptions\r\n        \r\n        // Assume currentState is a 4-byte integer (no validation)\r\n        bytes4 counterBytes = bytes4(currentState);\r\n        int counter = int(counterBytes);\r\n        \r\n        // Increment counter\r\n        int newCounter = counter + 1;\r\n        bytes4 newCounterBytes = bytes4(newCounter);\r\n        \r\n        // VULNERABLE: No validation that newStateHash is correct",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-2",
    "content": "// Attacker can provide arbitrary newStateHash\r\n        // 💥 STATE CORRUPTION: Can commit invalid hash for future state\r\n        \r\n        // VULNERABLE: No validation of newContractOutput structure\r\n        // Attacker can redirect continuation to different contract\r\n        // 💥 COVENANT ESCAPE: Can break out of covenant constraints\r\n        \r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].lockingBytecode == newContractOutput);\r\n        require(tx.outputs[0].value >= tx.inputs[this.activeInputIndex].value);\r\n    }\r\n}\r\n\r\n// CONSEQUENCES OF THE VULNERABLE EXAMPLE:\r\n// Attack Scenario 1: State hash bypass\r\n// - Attacker provides currentState = 0x00000064 (counter = 100)\r\n// - But stateHash = hash(0x00000001) (should be counter = 1)\r\n// - Contract doesn't verify currentState matches stateHash\r\n// - Attacker skips 99 increments, breaking counter invariant\r\n//\r\n// Attack Scenario 2: State length mismatch\r\n// - Contract expects 4-byte counter\r\n// - Attacker provides currentState = 0xFFFFFFFFFFFFFFFF (8 bytes)\r\n// - bytes4(currentState) truncates to first 4 bytes\r\n// - State interpretation corrupted, undefined behavior\r\n//\r\n// Attack Scenario 3: Invalid continuation hash\r\n// - Attacker increments counter: 1 → 2\r\n// - Provides newStateHash = hash(0x00000005) instead of hash(0x00000002)\r\n// - Next increment starts from corrupted state (thinks counter = 5)\r\n// - Counter jumps forward, breaking monotonic increment invariant\r\n//\r\n// Attack Scenario 4: Covenant escape",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-3",
    "content": "// - Attacker provides newContractOutput = different contract bytecode\r\n// - Continuation output is not the same Counter contract\r\n// - Breaks out of covenant constraints\r\n// - Can redirect funds to arbitrary contract or address\r\n\r\n// ✅ SECURE EXAMPLE: Counter with comprehensive state validation\r\ncontract CounterSecure(\r\n    bytes32 stateHash  // Hash of current counter state\r\n) {\r\n    // Increment counter and continue with new state\r\n    function increment(\r\n        bytes currentState,     // Current counter value (serialized)\r\n        bytes newContractOutput // Continuation contract output\r\n    ) {\r\n        // ✅ CRITICAL VALIDATION: State format validation\r\n        // Ensure currentState is exactly 4 bytes (expected format)\r\n        // Prevents state length mismatch attacks\r\n        require(currentState.length == 4);\r\n        \r\n        // ✅ CRITICAL VALIDATION: State integrity validation\r\n        // Verify currentState matches the committed stateHash\r\n        // Prevents state hash bypass attacks\r\n        require(hash256(currentState) == stateHash);\r\n        \r\n        // Now safe: currentState is verified to be correct\r\n        bytes4 counterBytes = bytes4(currentState);\r\n        int counter = int(counterBytes);\r\n        \r\n        // Increment counter (state transition logic)\r\n        int newCounter = counter + 1;\r\n        bytes4 newCounterBytes = bytes4(newCounter);\r\n        \r\n        // ✅ CRITICAL VALIDATION: New state hash calculation\r\n        // Calculate the correct hash for the new state",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-4",
    "content": "// This is NOT provided by caller - we calculate it ourselves\r\n        bytes32 newStateHash = hash256(bytes(newCounterBytes));\r\n        \r\n        // ✅ CRITICAL VALIDATION: Covenant continuation validation\r\n        // The continuation output MUST be the same contract with new state\r\n        // We reconstruct the expected lockingBytecode and validate it matches\r\n        // This prevents covenant escape attacks\r\n        \r\n        // Expected continuation: Counter(newStateHash)\r\n        // In practice, this requires reconstructing the contract bytecode\r\n        // CashScript limitation: We cannot reconstruct lockingBytecode on-chain\r\n        // WORKAROUND: Validate the output matches our current structure\r\n        require(\r\n            tx.outputs[0].lockingBytecode == \r\n            tx.inputs[this.activeInputIndex].lockingBytecode\r\n        );\r\n        \r\n        // This validates structure but NOT state parameter update\r\n        // KNOWN LIMITATION: Cannot enforce newStateHash in continuation on-chain\r\n        // NexOps MUST validate state parameter updates at build-time\r\n        \r\n        require(tx.outputs.length == 1);\r\n        require(tx.outputs[0].value >= tx.inputs[this.activeInputIndex].value);\r\n        \r\n        // SECURITY NOTE: We validate:\r\n        // ✓ Current state format (length == 4)\r\n        // ✓ Current state integrity (hash matches stateHash)\r\n        // ✓ New state calculation (deterministic from current state)\r\n        // ✓ Continuation structure (same contract)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-5",
    "content": "// ⚠ New state commitment (validated by NexOps builder, not on-chain)\r\n    }\r\n}\r\n\r\n// WHY THE SECURE EXAMPLE WORKS:\r\n// - require(currentState.length == 4) enforces expected state format (CRITICAL)\r\n// - require(hash256(currentState) == stateHash) verifies state integrity (CRITICAL)\r\n// - newStateHash calculated on-chain (not trusted from caller) (CRITICAL)\r\n// - Continuation lockingBytecode validated (prevents covenant escape) (CRITICAL)\r\n// - State transition is deterministic and verifiable\r\n// - Attacker cannot provide arbitrary state values\r\n// - State invariants are preserved across transitions\r\n\r\n// SEVERITY CLASSIFICATION:\r\n// NexOps classifies state corruption issues by severity:\r\n//\r\n// SEVERITY: Critical (Fund Loss / Protocol Violation)\r\n// - Missing state integrity validation (hash check)\r\n// - Missing covenant continuation validation\r\n// - Consequence: Fund theft, logic bypass, covenant escape\r\n// - Detection: AST-level - state hash comparison, lockingBytecode validation\r\n// - Prevention: Mandatory state hash validation, continuation enforcement\r\n//\r\n// SEVERITY: High (State Invariant Violation)\r\n// - State length mismatch (wrong size)\r\n// - Invalid state values (out of range)\r\n// - Consequence: Protocol malfunction, unexpected behavior\r\n// - Detection: AST-level - state deserialization without length check\r\n// - Prevention: Explicit format validation before deserialization\r\n//\r\n// SEVERITY: Medium (Incomplete Validation)\r\n// - Partial state validation (some fields checked, others not)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "covenant"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-6",
    "content": "// - Trusting builder for state calculation\r\n// - Consequence: Subtle bugs, edge case failures\r\n// - Detection: Code review - state validation coverage analysis\r\n// - Prevention: Comprehensive validation of all state components\r\n\r\n// STRUCTURAL INVARIANT FOR NEXOPS:\r\n// AST-Level Rule: State Integrity Invariant\r\n// For stateful covenants (contracts with state parameters):\r\n// 1. State Commitment:\r\n//    - If contract has state parameter (e.g., stateHash, merkleRoot)\r\n//    - There must exist validation that input state matches commitment\r\n//    - Pattern: require(hash256(state) == stateCommitment)\r\n//\r\n// 2. State Format:\r\n//    - Before deserializing state (e.g., bytes4(state), int(state))\r\n//    - There must exist length validation\r\n//    - Pattern: require(state.length == EXPECTED_LENGTH)\r\n//\r\n// 3. Covenant Continuation:\r\n//    - If contract recreates itself (covenant continuation)\r\n//    - There must exist validation of continuation lockingBytecode\r\n//    - Pattern: require(output.lockingBytecode == expected)\r\n//    - Minimum: require(output.lockingBytecode == input.lockingBytecode)\r\n//\r\n// 4. State Transition:\r\n//    - New state must be calculated on-chain (not trusted from caller)\r\n//    - Pattern: newState = calculateState(currentState) [on-chain]\r\n//    - NOT: newState = userProvidedState [trusted]\r\n\r\n// DETECTION RULES (AST-BASED):\r\n// 1. Identify stateful covenants:\r\n//    - Contracts with hash/commitment parameters (e.g., bytes32 stateHash)\r\n//    - Contracts with state deserialization (bytes to int/bytes4)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-7",
    "content": "//    - Contracts with covenant continuation patterns\r\n//\r\n// 2. For each stateful covenant, verify:\r\n//    a. State integrity check exists: hash256(state) == commitment\r\n//    b. State format validation exists: state.length == expected\r\n//    c. Continuation validation exists: output.lockingBytecode checked\r\n//    d. State transition is deterministic: new state calculated on-chain\r\n//\r\n// 3. Flag violations:\r\n//    - CRITICAL: Missing state integrity check\r\n//    - CRITICAL: Missing continuation validation\r\n//    - HIGH: Missing state format validation\r\n//    - MEDIUM: State transition trusts caller input\r\n\r\n// COMMON STATE CORRUPTION PATTERNS TO AVOID:\r\n\r\n// Pattern 1: No state integrity validation\r\n// ❌ VULNERABLE:\r\n// function update(bytes state, bytes32 newHash) {\r\n//     int value = int(state);  // No validation that state is correct\r\n// }\r\n//\r\n// ✅ SECURE:\r\n// function update(bytes state, bytes32 newHash) {\r\n//     require(hash256(state) == this.stateHash);\r\n//     int value = int(state);\r\n// }\r\n\r\n// Pattern 2: No state length validation\r\n// ❌ VULNERABLE:\r\n// bytes4 counter = bytes4(state);  // Truncates if state.length > 4\r\n//\r\n// ✅ SECURE:\r\n// require(state.length == 4);\r\n// bytes4 counter = bytes4(state);\r\n\r\n// Pattern 3: Trusting caller for new state hash\r\n// ❌ VULNERABLE:\r\n// function update(bytes state, bytes32 userProvidedNewHash) {\r\n//     require(hash256(state) == this.stateHash);\r\n//     // Use userProvidedNewHash in continuation (WRONG)\r\n// }\r\n//\r\n// ✅ SECURE:",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "function",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-8",
    "content": "// function update(bytes state) {\r\n//     require(hash256(state) == this.stateHash);\r\n//     bytes newState = calculateNewState(state);\r\n//     bytes32 newHash = hash256(newState);  // Calculate on-chain\r\n// }\r\n\r\n// Pattern 4: No continuation validation\r\n// ❌ VULNERABLE:\r\n// require(tx.outputs[0].lockingBytecode == userProvidedBytecode);\r\n//\r\n// ✅ SECURE:\r\n// require(\r\n//     tx.outputs[0].lockingBytecode ==\r\n//     tx.inputs[this.activeInputIndex].lockingBytecode\r\n// );\r\n\r\n// COVENANT CONTINUATION BEST PRACTICES:\r\n\r\n// Option A: Exact Structure Validation (Secure but Limiting)\r\n// ✅ Validates structure is unchanged\r\n// ⚠️ Cannot update state parameters on-chain (CashScript limitation)\r\n// require(\r\n//     tx.outputs[0].lockingBytecode ==\r\n//     tx.inputs[this.activeInputIndex].lockingBytecode\r\n// );\r\n\r\n// Option B: Builder-Verified State Update (Secure with NexOps)\r\n// ✅ Allows state parameter updates\r\n// ✅ Builder validates new contract matches expected structure + new state\r\n// ⚠️ Requires NexOps build-time validation\r\n// // On-chain: Validate structure\r\n// require(structureMatches(tx.outputs[0].lockingBytecode));\r\n// // Off-chain (NexOps): Validate state parameter is newStateHash\r\n\r\n// Option C: State Commitment Only (Simplest)\r\n// ✅ Doesn't require covenant continuation\r\n// ✅ Next transaction validates state independently\r\n// ⚠️ Doesn't enforce covenant structure preservation\r\n// // Just validate state integrity each time\r\n// require(hash256(state) == stateHash);\r\n\r\n// STATE VALIDATION CHECKLIST:",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "function",
      "transaction",
      "covenant",
      "bytes"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-9",
    "content": "// For any contract with state:\r\n// [ ] Identify all state parameters (hashes, commitments, roots)\r\n// [ ] Identify all state deserialization points (bytes → int, bytes4, etc.)\r\n// [ ] Add length validation before every deserialization\r\n// [ ] Add integrity validation (hash check) before using state\r\n// [ ] Calculate new state on-chain (don't trust caller)\r\n// [ ] Validate continuation lockingBytecode (if covenant)\r\n// [ ] Document state format and invariants clearly\r\n// [ ] Test with malformed state (wrong length, invalid hash)\r\n// [ ] Test with corrupted continuation (wrong contract)\r\n\r\n// BEST PRACTICES:\r\n// 1. Always validate state length before deserialization\r\n// 2. Always validate state hash matches commitment\r\n// 3. Calculate new state on-chain (don't trust caller)\r\n// 4. Validate covenant continuation lockingBytecode\r\n// 5. Document expected state format in comments\r\n// 6. Use fixed-length state formats when possible (easier to validate)\r\n// 7. Consider state versioning for upgradeable covenants\r\n// 8. Test with corrupted state inputs (fuzzing)\r\n\r\n// DEPLOYMENT VALIDATION:\r\n// Before deploying stateful covenants:\r\n// - Verify initial state is well-formed\r\n// - Verify initial state hash matches commitment\r\n// - Document state format and transition rules\r\n// - Test all state transitions with edge cases\r\n// - Verify NexOps builder validates state updates correctly\r\n\r\n// RELATIONSHIP TO OTHER ANTI-PATTERNS:\r\n// - Related to unenforced_covenant_continuation (both about continuation safety)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant",
      "bytes",
      "int"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-10",
    "content": "// - Connected to implicit_output_ordering (state often in outputs)\r\n// - Part of general covenant safety discipline\r\n// - Often combined with array_bounds issues (accessing state fields)\r\n\r\n// NEXOPS ENFORCEMENT:\r\n// NexOps MUST:\r\n// 1. Identify stateful covenants (contracts with hash/commitment parameters)\r\n// 2. Verify state integrity validation exists (hash checks)\r\n// 3. Verify state format validation exists (length checks)\r\n// 4. Verify covenant continuation validation exists\r\n// 5. Verify new state is calculated on-chain (not trusted)\r\n// 6. At build-time, validate state parameter updates in continuations\r\n// 7. Flag violations by severity (CRITICAL for missing integrity checks)\r\n// 8. Provide clear error messages with suggested fixes\r\n\r\n// AUDIT CHECKLIST FOR STATE VALIDATION:\r\n// [ ] Identify all state parameters in contract\r\n// [ ] Identify all state deserialization operations\r\n// [ ] Verify length validation before each deserialization\r\n// [ ] Verify hash validation for each state parameter\r\n// [ ] Verify new state calculation is on-chain\r\n// [ ] Verify covenant continuation lockingBytecode validation\r\n// [ ] Check that all validations happen BEFORE state use\r\n// [ ] Test with wrong-length state (should fail)\r\n// [ ] Test with wrong-hash state (should fail)\r\n// [ ] Test with corrupted continuation (should fail)\r\n// [ ] Document state format and invariants\r\n// [ ] Run NexOps static analyzer to verify state safety\r\n\r\n// TESTING RECOMMENDATIONS:\r\n// - Test with currentState.length != expected (should fail)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-11",
    "content": "// - Test with hash256(currentState) != stateHash (should fail)\r\n// - Test with corrupted newStateHash (should fail in next transition)\r\n// - Test with wrong continuation contract (should fail)\r\n// - Test valid state transitions (should succeed)\r\n// - Use fuzzing to test random state values\r\n// - Test state boundary values (min, max, edge cases)\r\n\r\n// REAL-WORLD IMPACT:\r\n// - Fund loss: Attacker can drain covenant by corrupting state\r\n// - Protocol violation: State invariants broken, system trust lost\r\n// - User impact: Unexpected behavior, lost funds, broken guarantees\r\n// - Reputation damage: Severe for protocols with state corruption bugs\r\n// - Prevention cost: Minimal (a few validation checks)\r\n// - Fix cost: Impossible (contract is immutable)\r\n\r\n// KNOWN CASHSCRIPT LIMITATIONS:\r\n// - Cannot reconstruct lockingBytecode with updated parameters on-chain\r\n// - Cannot verify continuation state parameter matches calculated state\r\n// - Workaround: NexOps validates state updates at build-time\r\n// - Alternative: Use exact structure validation (no parameter updates)\r\n// - Future: Consider stateless designs or external state tracking\r\n\r\n// EXAMPLE NEXOPS ERROR MESSAGE:\r\n// ❌ CRITICAL: State corruption risk detected\r\n// File: counter_contract.cash\r\n// Line: 23\r\n// Issue: State 'currentState' is deserialized without integrity validation\r\n// Missing: require(hash256(currentState) == stateHash);\r\n// Consequence: Attacker can provide arbitrary state values\r\n// Fix: Add state integrity check before deserialization",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": [
      "contract",
      "covenant"
    ]
  },
  {
    "id": "NexKB/common_mistakes/state_corruption.cash-12",
    "content": "// Severity: Critical (fund loss, protocol violation)",
    "source": "NexKB/common_mistakes/state_corruption.cash",
    "tier": "tier_c_faq",
    "type": "text",
    "topics": []
  }
]